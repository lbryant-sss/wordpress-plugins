{
  "version": 3,
  "sources": ["wordpress-external:@wordpress/hooks", "../../packages/i18n/src/index.ts", "../../node_modules/@tannin/sprintf/src/index.js", "../../packages/i18n/src/sprintf.ts", "../../node_modules/@tannin/postfix/index.js", "../../node_modules/@tannin/evaluate/index.js", "../../node_modules/@tannin/compile/index.js", "../../node_modules/@tannin/plural-forms/index.js", "../../node_modules/tannin/index.js", "../../packages/i18n/src/create-i18n.ts", "../../packages/i18n/src/default-i18n.ts"],
  "sourcesContent": ["module.exports = window.wp.hooks;", "export { sprintf } from './sprintf';\nexport * from './create-i18n';\nexport type * from './types';\nexport {\n\tdefault as defaultI18n,\n\tsetLocaleData,\n\tresetLocaleData,\n\tgetLocaleData,\n\tsubscribe,\n\t__,\n\t_x,\n\t_n,\n\t_nx,\n\tisRTL,\n\thasTranslation,\n} from './default-i18n';\n", "/**\n * Regular expression matching format placeholder syntax.\n *\n * The pattern for matching named arguments is a naive and incomplete matcher\n * against valid JavaScript identifier names.\n *\n * via Mathias Bynens:\n *\n * >An identifier must start with $, _, or any character in the Unicode\n * >categories \u201CUppercase letter (Lu)\u201D, \u201CLowercase letter (Ll)\u201D, \u201CTitlecase\n * >letter (Lt)\u201D, \u201CModifier letter (Lm)\u201D, \u201COther letter (Lo)\u201D, or \u201CLetter\n * >number (Nl)\u201D.\n * >\n * >The rest of the string can contain the same characters, plus any U+200C zero\n * >width non-joiner characters, U+200D zero width joiner characters, and\n * >characters in the Unicode categories \u201CNon-spacing mark (Mn)\u201D, \u201CSpacing\n * >combining mark (Mc)\u201D, \u201CDecimal digit number (Nd)\u201D, or \u201CConnector\n * >punctuation (Pc)\u201D.\n *\n * If browser support is constrained to those supporting ES2015, this could be\n * made more accurate using the `u` flag:\n *\n * ```\n * /^[$_\\p{L}\\p{Nl}][$_\\p{L}\\p{Nl}\\u200C\\u200D\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/u;\n * ```\n *\n * @see http://www.pixelbeat.org/programming/gcc/format_specs.html\n * @see https://mathiasbynens.be/notes/javascript-identifiers#valid-identifier-names\n *\n * @type {RegExp}\n */\nvar PATTERN =\n\t/%(((\\d+)\\$)|(\\(([$_a-zA-Z][$_a-zA-Z0-9]*)\\)))?[ +0#-]*\\d*(\\.(\\d+|\\*))?(ll|[lhqL])?([cduxXefgsp%])/g;\n//               \u25B2         \u25B2                    \u25B2       \u25B2  \u25B2            \u25B2           \u25B2 type\n//               \u2502         \u2502                    \u2502       \u2502  \u2502            \u2514 Length (unsupported)\n//               \u2502         \u2502                    \u2502       \u2502  \u2514 Precision / max width\n//               \u2502         \u2502                    \u2502       \u2514 Min width (unsupported)\n//               \u2502         \u2502                    \u2514 Flags (unsupported)\n//               \u2514 Index   \u2514 Name (for named arguments)\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // \u21D2 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // \u21D2 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // \u21D2 'Hello world!'\n * ```\n * @template {string} T\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\nexport default function sprintf(string, ...args) {\n\tvar i = 0;\n\tif (Array.isArray(args[0])) {\n\t\targs = /** @type {import('../types').SprintfArgs<T>[]} */ (\n\t\t\t/** @type {unknown} */ args[0]\n\t\t);\n\t}\n\n\treturn string.replace(PATTERN, function () {\n\t\tvar index,\n\t\t\t// name needs to be documented as `string | undefined` else value will have tpye unknown.\n\t\t\t/**\n\t\t\t * Name of the argument to substitute, if any.\n\t\t\t *\n\t\t\t * @type {string | undefined}\n\t\t\t */\n\t\t\tname,\n\t\t\tprecision,\n\t\t\ttype,\n\t\t\tvalue;\n\n\t\tindex = arguments[3];\n\t\tname = arguments[5];\n\t\tprecision = arguments[7];\n\t\ttype = arguments[9];\n\n\t\t// There's no placeholder substitution in the explicit \"%\", meaning it\n\t\t// is not necessary to increment argument index.\n\t\tif (type === '%') {\n\t\t\treturn '%';\n\t\t}\n\n\t\t// Asterisk precision determined by peeking / shifting next argument.\n\t\tif (precision === '*') {\n\t\t\tprecision = args[i];\n\t\t\ti++;\n\t\t}\n\n\t\tif (name === undefined) {\n\t\t\t// If not a positional argument, use counter value.\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = i + 1;\n\t\t\t}\n\n\t\t\ti++;\n\n\t\t\t// Positional argument.\n\t\t\tvalue = args[index - 1];\n\t\t} else if (\n\t\t\targs[0] &&\n\t\t\ttypeof args[0] === 'object' &&\n\t\t\targs[0].hasOwnProperty(name)\n\t\t) {\n\t\t\t// If it's a named argument, use name.\n\t\t\tvalue = args[0][name];\n\t\t}\n\n\t\t// Parse as type.\n\t\tif (type === 'f') {\n\t\t\tvalue = parseFloat(value) || 0;\n\t\t} else if (type === 'd') {\n\t\t\tvalue = parseInt(value) || 0;\n\t\t}\n\n\t\t// Apply precision.\n\t\tif (precision !== undefined) {\n\t\t\tif (type === 'f') {\n\t\t\t\tvalue = value.toFixed(precision);\n\t\t\t} else if (type === 's') {\n\t\t\t\tvalue = value.substr(0, precision);\n\t\t\t}\n\t\t}\n\n\t\t// To avoid \"undefined\" concatenation, return empty string if no\n\t\t// placeholder substitution can be performed.\n\t\treturn value !== undefined && value !== null ? value : '';\n\t});\n}\n", "/**\n * External dependencies\n */\n// Disable reason: `eslint-plugin-import` doesn't support `exports` (https://github.com/import-js/eslint-plugin-import/issues/1810)\n// eslint-disable-next-line import/no-unresolved\nimport _sprintf from '@tannin/sprintf';\n\n/**\n * Internal dependencies\n */\nimport type { DistributeSprintfArgs, TranslatableText } from './types';\n\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\t...args: DistributeSprintfArgs< T >\n): string;\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\targs: DistributeSprintfArgs< T >\n): string;\n\n/**\n * Returns a formatted string.\n *\n * @param format The format of the string to generate.\n * @param args   Arguments to apply to the format.\n *\n * @see https://www.npmjs.com/package/@tannin/sprintf\n *\n * @return The formatted string.\n */\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\t...args: DistributeSprintfArgs< T >\n): string {\n\treturn _sprintf( format as T, ...( args as DistributeSprintfArgs< T > ) );\n}\n", "var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;\n\n/**\n * Operator precedence mapping.\n *\n * @type {Object}\n */\nPRECEDENCE = {\n\t'(': 9,\n\t'!': 8,\n\t'*': 7,\n\t'/': 7,\n\t'%': 7,\n\t'+': 6,\n\t'-': 6,\n\t'<': 5,\n\t'<=': 5,\n\t'>': 5,\n\t'>=': 5,\n\t'==': 4,\n\t'!=': 4,\n\t'&&': 3,\n\t'||': 2,\n\t'?': 1,\n\t'?:': 1,\n};\n\n/**\n * Characters which signal pair opening, to be terminated by terminators.\n *\n * @type {string[]}\n */\nOPENERS = [ '(', '?' ];\n\n/**\n * Characters which signal pair termination, the value an array with the\n * opener as its first member. The second member is an optional operator\n * replacement to push to the stack.\n *\n * @type {string[]}\n */\nTERMINATORS = {\n\t')': [ '(' ],\n\t':': [ '?', '?:' ],\n};\n\n/**\n * Pattern matching operators and openers.\n *\n * @type {RegExp}\n */\nPATTERN = /<=|>=|==|!=|&&|\\|\\||\\?:|\\(|!|\\*|\\/|%|\\+|-|<|>|\\?|\\)|:/;\n\n/**\n * Given a C expression, returns the equivalent postfix (Reverse Polish)\n * notation terms as an array.\n *\n * If a postfix string is desired, simply `.join( ' ' )` the result.\n *\n * @example\n *\n * ```js\n * import postfix from '@tannin/postfix';\n *\n * postfix( 'n > 1' );\n * // \u21D2 [ 'n', '1', '>' ]\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {string[]} Postfix terms.\n */\nexport default function postfix( expression ) {\n\tvar terms = [],\n\t\tstack = [],\n\t\tmatch, operator, term, element;\n\n\twhile ( ( match = expression.match( PATTERN ) ) ) {\n\t\toperator = match[ 0 ];\n\n\t\t// Term is the string preceding the operator match. It may contain\n\t\t// whitespace, and may be empty (if operator is at beginning).\n\t\tterm = expression.substr( 0, match.index ).trim();\n\t\tif ( term ) {\n\t\t\tterms.push( term );\n\t\t}\n\n\t\twhile ( ( element = stack.pop() ) ) {\n\t\t\tif ( TERMINATORS[ operator ] ) {\n\t\t\t\tif ( TERMINATORS[ operator ][ 0 ] === element ) {\n\t\t\t\t\t// Substitution works here under assumption that because\n\t\t\t\t\t// the assigned operator will no longer be a terminator, it\n\t\t\t\t\t// will be pushed to the stack during the condition below.\n\t\t\t\t\toperator = TERMINATORS[ operator ][ 1 ] || operator;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if ( OPENERS.indexOf( element ) >= 0 || PRECEDENCE[ element ] < PRECEDENCE[ operator ] ) {\n\t\t\t\t// Push to stack if either an opener or when pop reveals an\n\t\t\t\t// element of lower precedence.\n\t\t\t\tstack.push( element );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// For each popped from stack, push to terms.\n\t\t\tterms.push( element );\n\t\t}\n\n\t\tif ( ! TERMINATORS[ operator ] ) {\n\t\t\tstack.push( operator );\n\t\t}\n\n\t\t// Slice matched fragment from expression to continue match.\n\t\texpression = expression.substr( match.index + operator.length );\n\t}\n\n\t// Push remainder of operand, if exists, to terms.\n\texpression = expression.trim();\n\tif ( expression ) {\n\t\tterms.push( expression );\n\t}\n\n\t// Pop remaining items from stack into terms.\n\treturn terms.concat( stack.reverse() );\n}\n", "/**\n * Operator callback functions.\n *\n * @type {Object}\n */\nvar OPERATORS = {\n\t'!': function( a ) {\n\t\treturn ! a;\n\t},\n\t'*': function( a, b ) {\n\t\treturn a * b;\n\t},\n\t'/': function( a, b ) {\n\t\treturn a / b;\n\t},\n\t'%': function( a, b ) {\n\t\treturn a % b;\n\t},\n\t'+': function( a, b ) {\n\t\treturn a + b;\n\t},\n\t'-': function( a, b ) {\n\t\treturn a - b;\n\t},\n\t'<': function( a, b ) {\n\t\treturn a < b;\n\t},\n\t'<=': function( a, b ) {\n\t\treturn a <= b;\n\t},\n\t'>': function( a, b ) {\n\t\treturn a > b;\n\t},\n\t'>=': function( a, b ) {\n\t\treturn a >= b;\n\t},\n\t'==': function( a, b ) {\n\t\treturn a === b;\n\t},\n\t'!=': function( a, b ) {\n\t\treturn a !== b;\n\t},\n\t'&&': function( a, b ) {\n\t\treturn a && b;\n\t},\n\t'||': function( a, b ) {\n\t\treturn a || b;\n\t},\n\t'?:': function( a, b, c ) {\n\t\tif ( a ) {\n\t\t\tthrow b;\n\t\t}\n\n\t\treturn c;\n\t},\n};\n\n/**\n * Given an array of postfix terms and operand variables, returns the result of\n * the postfix evaluation.\n *\n * @example\n *\n * ```js\n * import evaluate from '@tannin/evaluate';\n *\n * // 3 + 4 * 5 / 6 \u21D2 '3 4 5 * 6 / +'\n * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];\n *\n * evaluate( terms, {} );\n * // \u21D2 6.333333333333334\n * ```\n *\n * @param {string[]} postfix   Postfix terms.\n * @param {Object}   variables Operand variables.\n *\n * @return {*} Result of evaluation.\n */\nexport default function evaluate( postfix, variables ) {\n\tvar stack = [],\n\t\ti, j, args, getOperatorResult, term, value;\n\n\tfor ( i = 0; i < postfix.length; i++ ) {\n\t\tterm = postfix[ i ];\n\n\t\tgetOperatorResult = OPERATORS[ term ];\n\t\tif ( getOperatorResult ) {\n\t\t\t// Pop from stack by number of function arguments.\n\t\t\tj = getOperatorResult.length;\n\t\t\targs = Array( j );\n\t\t\twhile ( j-- ) {\n\t\t\t\targs[ j ] = stack.pop();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalue = getOperatorResult.apply( null, args );\n\t\t\t} catch ( earlyReturn ) {\n\t\t\t\treturn earlyReturn;\n\t\t\t}\n\t\t} else if ( variables.hasOwnProperty( term ) ) {\n\t\t\tvalue = variables[ term ];\n\t\t} else {\n\t\t\tvalue = +term;\n\t\t}\n\n\t\tstack.push( value );\n\t}\n\n\treturn stack[ 0 ];\n}\n", "import postfix from '@tannin/postfix';\nimport evaluate from '@tannin/evaluate';\n\n/**\n * Given a C expression, returns a function which can be called to evaluate its\n * result.\n *\n * @example\n *\n * ```js\n * import compile from '@tannin/compile';\n *\n * const evaluate = compile( 'n > 1' );\n *\n * evaluate( { n: 2 } );\n * // \u21D2 true\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {(variables?:{[variable:string]:*})=>*} Compiled evaluator.\n */\nexport default function compile( expression ) {\n\tvar terms = postfix( expression );\n\n\treturn function( variables ) {\n\t\treturn evaluate( terms, variables );\n\t};\n}\n", "import compile from '@tannin/compile';\n\n/**\n * Given a C expression, returns a function which, when called with a value,\n * evaluates the result with the value assumed to be the \"n\" variable of the\n * expression. The result will be coerced to its numeric equivalent.\n *\n * @param {string} expression C expression.\n *\n * @return {Function} Evaluator function.\n */\nexport default function pluralForms( expression ) {\n\tvar evaluate = compile( expression );\n\n\treturn function( n ) {\n\t\treturn +evaluate( { n: n } );\n\t};\n}\n", "import pluralForms from '@tannin/plural-forms';\n\n/**\n * Tannin constructor options.\n *\n * @typedef {Object} TanninOptions\n *\n * @property {string}   [contextDelimiter] Joiner in string lookup with context.\n * @property {Function} [onMissingKey]     Callback to invoke when key missing.\n */\n\n/**\n * Domain metadata.\n *\n * @typedef {Object} TanninDomainMetadata\n *\n * @property {string}            [domain]       Domain name.\n * @property {string}            [lang]         Language code.\n * @property {(string|Function)} [plural_forms] Plural forms expression or\n *                                              function evaluator.\n */\n\n/**\n * Domain translation pair respectively representing the singular and plural\n * translation.\n *\n * @typedef {[string,string]} TanninTranslation\n */\n\n/**\n * Locale data domain. The key is used as reference for lookup, the value an\n * array of two string entries respectively representing the singular and plural\n * translation.\n *\n * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain\n */\n\n/**\n * Jed-formatted locale data.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData\n */\n\n/**\n * Default Tannin constructor options.\n *\n * @type {TanninOptions}\n */\nvar DEFAULT_OPTIONS = {\n\tcontextDelimiter: '\\u0004',\n\tonMissingKey: null,\n};\n\n/**\n * Given a specific locale data's config `plural_forms` value, returns the\n * expression.\n *\n * @example\n *\n * ```\n * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'\n * ```\n *\n * @param {string} pf Locale data plural forms.\n *\n * @return {string} Plural forms expression.\n */\nfunction getPluralExpression( pf ) {\n\tvar parts, i, part;\n\n\tparts = pf.split( ';' );\n\n\tfor ( i = 0; i < parts.length; i++ ) {\n\t\tpart = parts[ i ].trim();\n\t\tif ( part.indexOf( 'plural=' ) === 0 ) {\n\t\t\treturn part.substr( 7 );\n\t\t}\n\t}\n}\n\n/**\n * Tannin constructor.\n *\n * @class\n *\n * @param {TanninLocaleData} data      Jed-formatted locale data.\n * @param {TanninOptions}    [options] Tannin options.\n */\nexport default function Tannin( data, options ) {\n\tvar key;\n\n\t/**\n\t * Jed-formatted locale data.\n\t *\n\t * @name Tannin#data\n\t * @type {TanninLocaleData}\n\t */\n\tthis.data = data;\n\n\t/**\n\t * Plural forms function cache, keyed by plural forms string.\n\t *\n\t * @name Tannin#pluralForms\n\t * @type {Object<string,Function>}\n\t */\n\tthis.pluralForms = {};\n\n\t/**\n\t * Effective options for instance, including defaults.\n\t *\n\t * @name Tannin#options\n\t * @type {TanninOptions}\n\t */\n\tthis.options = {};\n\n\tfor ( key in DEFAULT_OPTIONS ) {\n\t\tthis.options[ key ] = options !== undefined && key in options\n\t\t\t? options[ key ]\n\t\t\t: DEFAULT_OPTIONS[ key ];\n\t}\n}\n\n/**\n * Returns the plural form index for the given domain and value.\n *\n * @param {string} domain Domain on which to calculate plural form.\n * @param {number} n      Value for which plural form is to be calculated.\n *\n * @return {number} Plural form index.\n */\nTannin.prototype.getPluralForm = function( domain, n ) {\n\tvar getPluralForm = this.pluralForms[ domain ],\n\t\tconfig, plural, pf;\n\n\tif ( ! getPluralForm ) {\n\t\tconfig = this.data[ domain ][ '' ];\n\n\t\tpf = (\n\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t// @ts-ignore\n\t\t\tconfig.plural_forms\n\t\t);\n\n\t\tif ( typeof pf !== 'function' ) {\n\t\t\tplural = getPluralExpression(\n\t\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t\t// @ts-ignore\n\t\t\t\tconfig.plural_forms\n\t\t\t);\n\n\t\t\tpf = pluralForms( plural );\n\t\t}\n\n\t\tgetPluralForm = this.pluralForms[ domain ] = pf;\n\t}\n\n\treturn getPluralForm( n );\n};\n\n/**\n * Translate a string.\n *\n * @param {string}      domain   Translation domain.\n * @param {string|void} context  Context distinguishing terms of the same name.\n * @param {string}      singular Primary key for translation lookup.\n * @param {string=}     plural   Fallback value used for non-zero plural\n *                               form index.\n * @param {number=}     n        Value to use in calculating plural form.\n *\n * @return {string} Translated string.\n */\nTannin.prototype.dcnpgettext = function( domain, context, singular, plural, n ) {\n\tvar index, key, entry;\n\n\tif ( n === undefined ) {\n\t\t// Default to singular.\n\t\tindex = 0;\n\t} else {\n\t\t// Find index by evaluating plural form for value.\n\t\tindex = this.getPluralForm( domain, n );\n\t}\n\n\tkey = singular;\n\n\t// If provided, context is prepended to key with delimiter.\n\tif ( context ) {\n\t\tkey = context + this.options.contextDelimiter + singular;\n\t}\n\n\tentry = this.data[ domain ][ key ];\n\n\t// Verify not only that entry exists, but that the intended index is within\n\t// range and non-empty.\n\tif ( entry && entry[ index ] ) {\n\t\treturn entry[ index ];\n\t}\n\n\tif ( this.options.onMissingKey ) {\n\t\tthis.options.onMissingKey( singular, domain );\n\t}\n\n\t// If entry not found, fall back to singular vs. plural with zero index\n\t// representing the singular value.\n\treturn index === 0 ? singular : plural;\n};\n", "/**\n * External dependencies\n */\nimport type { TanninLocaleDomain } from 'tannin';\nimport Tannin from 'tannin';\n/**\n * Internal dependencies\n */\nimport type {\n\tgetFilterDomain,\n\tI18n,\n\tLocaleData,\n\tSubscribeCallback,\n\tTranslatableText,\n\tUnsubscribeCallback,\n} from './types';\n/**\n * WordPress dependencies\n */\nimport type { Hooks } from '@wordpress/hooks';\n/**\n * Default locale data to use for Tannin domain when not otherwise provided.\n * Assumes an English plural forms expression.\n */\nconst DEFAULT_LOCALE_DATA: LocaleData = {\n\t'': {\n\t\tplural_forms( n: number ) {\n\t\t\treturn n === 1 ? 0 : 1;\n\t\t},\n\t},\n};\n\n/*\n * Regular expression that matches i18n hooks like `i18n.gettext`, `i18n.ngettext`,\n * `i18n.gettext_domain` or `i18n.ngettext_with_context` or `i18n.has_translation`.\n */\nconst I18N_HOOK_REGEXP = /^i18n\\.(n?gettext|has_translation)(_|$)/;\n\n/**\n * Create an i18n instance\n *\n * @param [initialData]   Locale data configuration.\n * @param [initialDomain] Domain for which configuration applies.\n * @param [hooks]         Hooks implementation.\n *\n * @return I18n instance.\n */\nexport const createI18n = < TextDomain extends string >(\n\tinitialData?: LocaleData< TextDomain >,\n\tinitialDomain?: TextDomain,\n\thooks?: Hooks\n): I18n< TextDomain > => {\n\t/**\n\t * The underlying instance of Tannin to which exported functions interface.\n\t */\n\tconst tannin = new Tannin( {} );\n\n\tconst listeners = new Set< () => void >();\n\n\tconst notifyListeners = () => {\n\t\tlisteners.forEach( ( listener ) => listener() );\n\t};\n\n\t/**\n\t * Subscribe to changes of locale data.\n\t *\n\t * @param callback Subscription callback.\n\t * @return Unsubscribe callback.\n\t */\n\tconst subscribe = ( callback: SubscribeCallback ): UnsubscribeCallback => {\n\t\tlisteners.add( callback );\n\t\treturn () => listeners.delete( callback );\n\t};\n\n\tconst getLocaleData: I18n< TextDomain >[ 'getLocaleData' ] = (\n\t\tdomain = 'default' as TextDomain\n\t) => tannin.data[ domain ] as LocaleData< TextDomain >;\n\n\t/**\n\t * @param [data]\n\t * @param [domain]\n\t */\n\tconst doSetLocaleData = (\n\t\tdata?: LocaleData,\n\t\tdomain: TextDomain = 'default' as TextDomain\n\t) => {\n\t\ttannin.data[ domain ] = {\n\t\t\t...tannin.data[ domain ],\n\t\t\t...data,\n\t\t} as TanninLocaleDomain;\n\n\t\t// Populate default domain configuration (supported locale date which omits\n\t\t// a plural forms expression).\n\t\ttannin.data[ domain ][ '' ] = {\n\t\t\t...DEFAULT_LOCALE_DATA[ '' ],\n\t\t\t...tannin.data[ domain ]?.[ '' ],\n\t\t};\n\n\t\t// Clean up cached plural forms functions cache as it might be updated.\n\t\tdelete tannin.pluralForms[ domain ];\n\t};\n\n\tconst setLocaleData: I18n< TextDomain >[ 'setLocaleData' ] = (\n\t\tdata,\n\t\tdomain\n\t) => {\n\t\tdoSetLocaleData( data, domain );\n\t\tnotifyListeners();\n\t};\n\n\tconst addLocaleData: I18n< TextDomain >[ 'addLocaleData' ] = (\n\t\tdata,\n\t\tdomain = 'default' as TextDomain\n\t) => {\n\t\ttannin.data[ domain ] = {\n\t\t\t...tannin.data[ domain ],\n\t\t\t...data,\n\t\t\t// Populate default domain configuration (supported locale date which omits\n\t\t\t// a plural forms expression).\n\t\t\t'': {\n\t\t\t\t...DEFAULT_LOCALE_DATA[ '' ],\n\t\t\t\t...tannin.data[ domain ]?.[ '' ],\n\t\t\t\t...data?.[ '' ],\n\t\t\t},\n\t\t} as TanninLocaleDomain;\n\n\t\t// Clean up cached plural forms functions cache as it might be updated.\n\t\tdelete tannin.pluralForms[ domain ];\n\n\t\tnotifyListeners();\n\t};\n\n\tconst resetLocaleData: I18n< TextDomain >[ 'resetLocaleData' ] = (\n\t\tdata,\n\t\tdomain\n\t) => {\n\t\t// Reset all current Tannin locale data.\n\t\ttannin.data = {};\n\n\t\t// Reset cached plural forms functions cache.\n\t\ttannin.pluralForms = {};\n\n\t\tsetLocaleData( data, domain );\n\t};\n\n\t/**\n\t * Wrapper for Tannin's `dcnpgettext`. Populates default locale data if not\n\t * otherwise previously assigned.\n\t *\n\t * @param domain   Domain to retrieve the translated text.\n\t * @param context  Context information for the translators.\n\t * @param single   Text to translate if non-plural. Used as\n\t *                 fallback return value on a caught error.\n\t * @param [plural] The text to be used if the number is\n\t *                 plural.\n\t * @param [number] The number to compare against to use\n\t *                 either the singular or plural form.\n\t *\n\t * @return The translated string.\n\t */\n\tconst dcnpgettext = (\n\t\tdomain = 'default' as TextDomain,\n\t\tcontext: string | void,\n\t\tsingle: string,\n\t\tplural?: string,\n\t\tnumber?: number\n\t): string => {\n\t\tif ( ! tannin.data[ domain ] ) {\n\t\t\t// Use `doSetLocaleData` to set silently, without notifying listeners.\n\t\t\tdoSetLocaleData( undefined, domain );\n\t\t}\n\n\t\treturn tannin.dcnpgettext( domain, context, single, plural, number );\n\t};\n\n\tconst getFilterDomain: getFilterDomain = ( domain ) => domain || 'default';\n\n\tconst __: I18n< TextDomain >[ '__' ] = ( text, domain ) => {\n\t\tlet translation = dcnpgettext( domain, undefined, text );\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText< typeof text >;\n\t\t}\n\n\t\t/**\n\t\t * Filters text with its translation.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param text        Text to translate.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.gettext',\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.gettext_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\t};\n\n\tconst _x: I18n< TextDomain >[ '_x' ] = ( text, context, domain ) => {\n\t\tlet translation = dcnpgettext( domain, context, text );\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText< typeof text >;\n\t\t}\n\n\t\t/**\n\t\t * Filters text with its translation based on context information.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param text        Text to translate.\n\t\t * @param context     Context information for the translators.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.gettext_with_context',\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.gettext_with_context_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\t};\n\n\tconst _n: I18n< TextDomain >[ '_n' ] = (\n\t\tsingle,\n\t\tplural,\n\t\tnumber,\n\t\tdomain\n\t) => {\n\t\tlet translation = dcnpgettext(\n\t\t\tdomain,\n\t\t\tundefined,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber\n\t\t);\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText<\n\t\t\t\ttypeof single | typeof plural\n\t\t\t>;\n\t\t}\n\n\t\t/**\n\t\t * Filters the singular or plural form of a string.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param single      The text to be used if the number is singular.\n\t\t * @param plural      The text to be used if the number is plural.\n\t\t * @param number      The number to compare against to use either the singular or plural form.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.ngettext',\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.ngettext_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\t};\n\n\tconst _nx: I18n< TextDomain >[ '_nx' ] = (\n\t\tsingle,\n\t\tplural,\n\t\tnumber,\n\t\tcontext,\n\t\tdomain\n\t) => {\n\t\tlet translation = dcnpgettext(\n\t\t\tdomain,\n\t\t\tcontext,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber\n\t\t);\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText<\n\t\t\t\ttypeof single | typeof plural\n\t\t\t>;\n\t\t}\n\n\t\t/**\n\t\t * Filters the singular or plural form of a string with gettext context.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param single      The text to be used if the number is singular.\n\t\t * @param plural      The text to be used if the number is plural.\n\t\t * @param number      The number to compare against to use either the singular or plural form.\n\t\t * @param context     Context information for the translators.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.ngettext_with_context',\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.ngettext_with_context_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\t};\n\n\tconst isRTL: I18n< TextDomain >[ 'isRTL' ] = () => {\n\t\treturn 'rtl' === _x( 'ltr', 'text direction' );\n\t};\n\n\tconst hasTranslation: I18n< TextDomain >[ 'hasTranslation' ] = (\n\t\tsingle,\n\t\tcontext,\n\t\tdomain\n\t) => {\n\t\tconst key = context ? context + '\\u0004' + single : single;\n\t\tlet result = !! tannin.data?.[ domain ?? 'default' ]?.[ key ];\n\t\tif ( hooks ) {\n\t\t\t/**\n\t\t\t * Filters the presence of a translation in the locale data.\n\t\t\t *\n\t\t\t * @param hasTranslation Whether the translation is present or not..\n\t\t\t * @param single         The singular form of the translated text (used as key in locale data)\n\t\t\t * @param context        Context information for the translators.\n\t\t\t * @param domain         Text domain. Unique identifier for retrieving translated strings.\n\t\t\t */\n\t\t\tresult = hooks.applyFilters(\n\t\t\t\t'i18n.has_translation',\n\t\t\t\tresult,\n\t\t\t\tsingle,\n\t\t\t\tcontext,\n\t\t\t\tdomain\n\t\t\t) as boolean;\n\n\t\t\tresult = hooks.applyFilters(\n\t\t\t\t'i18n.has_translation_' + getFilterDomain( domain ),\n\t\t\t\tresult,\n\t\t\t\tsingle,\n\t\t\t\tcontext,\n\t\t\t\tdomain\n\t\t\t) as boolean;\n\t\t}\n\t\treturn result;\n\t};\n\n\tif ( initialData ) {\n\t\tsetLocaleData( initialData, initialDomain );\n\t}\n\n\tif ( hooks ) {\n\t\t/**\n\t\t * @param hookName\n\t\t */\n\t\tconst onHookAddedOrRemoved = ( hookName: string ) => {\n\t\t\tif ( I18N_HOOK_REGEXP.test( hookName ) ) {\n\t\t\t\tnotifyListeners();\n\t\t\t}\n\t\t};\n\n\t\thooks.addAction( 'hookAdded', 'core/i18n', onHookAddedOrRemoved );\n\t\thooks.addAction( 'hookRemoved', 'core/i18n', onHookAddedOrRemoved );\n\t}\n\n\treturn {\n\t\tgetLocaleData,\n\t\tsetLocaleData,\n\t\taddLocaleData,\n\t\tresetLocaleData,\n\t\tsubscribe,\n\t\t__,\n\t\t_x,\n\t\t_n,\n\t\t_nx,\n\t\tisRTL,\n\t\thasTranslation,\n\t};\n};\n", "/**\n * Internal dependencies\n */\nimport { createI18n } from './create-i18n';\n\n/**\n * WordPress dependencies\n */\nimport { defaultHooks } from '@wordpress/hooks';\nimport {\n\tLocaleData,\n\tSubscribeCallback,\n\tTranslatableText,\n\tUnsubscribeCallback,\n} from './types';\n\nconst i18n = createI18n( undefined, undefined, defaultHooks );\n\n/**\n * Default, singleton instance of `I18n`.\n */\nexport default i18n;\n\n/*\n * Comments in this file are duplicated from ./i18n due to\n * https://github.com/WordPress/gutenberg/pull/20318#issuecomment-590837722\n */\n\n/**\n * Returns locale data by domain in a Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param { string | undefined } [domain] Domain for which to get the data.\n * @return { LocaleData } Locale data.\n */\nexport const getLocaleData = i18n.getLocaleData.bind( i18n );\n\n/**\n * Merges locale data into the Tannin instance by domain. Accepts data in a\n * Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param {LocaleData }        [data]   Locale data configuration.\n * @param {string | undefined} [domain] Domain for which configuration applies.\n */\nexport const setLocaleData = i18n.setLocaleData.bind( i18n );\n\n/**\n * Resets all current Tannin instance locale data and sets the specified\n * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param {LocaleData}         [data]   Locale data configuration.\n * @param {string | undefined} [domain] Domain for which configuration applies.\n */\nexport const resetLocaleData = i18n.resetLocaleData.bind( i18n );\n\n/**\n * Subscribes to changes of locale data\n *\n * @param {SubscribeCallback} callback Subscription callback\n * @return {UnsubscribeCallback} Unsubscribe callback\n */\nexport const subscribe = i18n.subscribe.bind( i18n );\n\n/**\n * Retrieve the translation of text.\n *\n * @see https://developer.wordpress.org/reference/functions/__/\n *\n * @template {string} Text\n *\n * @param {Text}               text   Text to translate.\n * @param {string | undefined} domain Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Text>} Translated text.\n */\nexport const __ = i18n.__.bind( i18n );\n\n/**\n * Retrieve translated string with gettext context.\n *\n * @see https://developer.wordpress.org/reference/functions/_x/\n *\n * @template {string} Text\n *\n * @param {Text}               text    Text to translate.\n * @param {string}             context Context information for the translators.\n * @param {string | undefined} domain  Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Text>} Translated context string without pipe.\n */\nexport const _x = i18n._x.bind( i18n );\n\n/**\n * Translates and retrieves the singular or plural form based on the supplied\n * number.\n *\n * @see https://developer.wordpress.org/reference/functions/_n/\n *\n * @template {string} Single\n * @template {string} Plural\n *\n * @param {Single}             single The text to be used if the number is singular.\n * @param {Plural}             plural The text to be used if the number is plural.\n * @param {number}             number The number to compare against to use either the\n *                                    singular or plural form.\n * @param {string | undefined} domain Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Single | Plural>} The translated singular or plural form.\n */\nexport const _n = i18n._n.bind( i18n );\n\n/**\n * Translates and retrieves the singular or plural form based on the supplied\n * number, with gettext context.\n *\n * @see https://developer.wordpress.org/reference/functions/_nx/\n *\n * @template {string} Single\n * @template {string} Plural\n * @param {Single}             single   The text to be used if the number is singular.\n *\n * @param {Single}             single   The text to be used if the number is singular.\n * @param {Plural}             plural   The text to be used if the number is plural.\n * @param {number}             number   The number to compare against to use either the\n *                                      singular or plural form.\n * @param {string}             context  Context information for the translators.\n * @param {string | undefined} [domain] Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Single | Plural>} The translated singular or plural form.\n */\nexport const _nx = i18n._nx.bind( i18n );\n\n/**\n * Check if current locale is RTL.\n *\n * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.\n * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common\n * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,\n * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).\n *\n * @return {boolean} Whether locale is RTL.\n */\nexport const isRTL = i18n.isRTL.bind( i18n );\n\n/**\n * Check if there is a translation for a given string (in singular form).\n *\n * @param {string} single  Singular form of the string to look up.\n * @param {string} context Context information for the translators.\n * @param {string} domain  Domain to retrieve the translated text.\n *\n * @return {boolean} Whether the translation exists or not.\n */\nexport const hasTranslation = i18n.hasTranslation.bind( i18n );\n"],
  "mappings": "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",
  "names": ["sprintf", "sprintf", "PATTERN", "postfix", "evaluate", "subscribe", "getLocaleData", "setLocaleData", "resetLocaleData", "__", "_x", "_n", "_nx", "isRTL", "hasTranslation"]
}
