{
  "version": 3,
  "sources": ["wordpress-external:@wordpress/hooks", "../../packages/i18n/src/index.ts", "../../node_modules/@tannin/sprintf/src/index.js", "../../packages/i18n/src/sprintf.ts", "../../node_modules/@tannin/postfix/index.js", "../../node_modules/@tannin/evaluate/index.js", "../../node_modules/@tannin/compile/index.js", "../../node_modules/@tannin/plural-forms/index.js", "../../node_modules/tannin/index.js", "../../packages/i18n/src/create-i18n.ts", "../../packages/i18n/src/default-i18n.ts"],
  "sourcesContent": ["module.exports = window.wp.hooks;", "export { sprintf } from './sprintf';\nexport * from './create-i18n';\nexport type * from './types';\nexport {\n\tdefault as defaultI18n,\n\tsetLocaleData,\n\tresetLocaleData,\n\tgetLocaleData,\n\tsubscribe,\n\t__,\n\t_x,\n\t_n,\n\t_nx,\n\tisRTL,\n\thasTranslation,\n} from './default-i18n';\n", "/**\n * Regular expression matching format placeholder syntax.\n *\n * The pattern for matching named arguments is a naive and incomplete matcher\n * against valid JavaScript identifier names.\n *\n * via Mathias Bynens:\n *\n * >An identifier must start with $, _, or any character in the Unicode\n * >categories \u201CUppercase letter (Lu)\u201D, \u201CLowercase letter (Ll)\u201D, \u201CTitlecase\n * >letter (Lt)\u201D, \u201CModifier letter (Lm)\u201D, \u201COther letter (Lo)\u201D, or \u201CLetter\n * >number (Nl)\u201D.\n * >\n * >The rest of the string can contain the same characters, plus any U+200C zero\n * >width non-joiner characters, U+200D zero width joiner characters, and\n * >characters in the Unicode categories \u201CNon-spacing mark (Mn)\u201D, \u201CSpacing\n * >combining mark (Mc)\u201D, \u201CDecimal digit number (Nd)\u201D, or \u201CConnector\n * >punctuation (Pc)\u201D.\n *\n * If browser support is constrained to those supporting ES2015, this could be\n * made more accurate using the `u` flag:\n *\n * ```\n * /^[$_\\p{L}\\p{Nl}][$_\\p{L}\\p{Nl}\\u200C\\u200D\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/u;\n * ```\n *\n * @see http://www.pixelbeat.org/programming/gcc/format_specs.html\n * @see https://mathiasbynens.be/notes/javascript-identifiers#valid-identifier-names\n *\n * @type {RegExp}\n */\nvar PATTERN =\n\t/%(((\\d+)\\$)|(\\(([$_a-zA-Z][$_a-zA-Z0-9]*)\\)))?[ +0#-]*\\d*(\\.(\\d+|\\*))?(ll|[lhqL])?([cduxXefgsp%])/g;\n//               \u25B2         \u25B2                    \u25B2       \u25B2  \u25B2            \u25B2           \u25B2 type\n//               \u2502         \u2502                    \u2502       \u2502  \u2502            \u2514 Length (unsupported)\n//               \u2502         \u2502                    \u2502       \u2502  \u2514 Precision / max width\n//               \u2502         \u2502                    \u2502       \u2514 Min width (unsupported)\n//               \u2502         \u2502                    \u2514 Flags (unsupported)\n//               \u2514 Index   \u2514 Name (for named arguments)\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // \u21D2 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // \u21D2 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // \u21D2 'Hello world!'\n * ```\n * @template {string} T\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\nexport default function sprintf(string, ...args) {\n\tvar i = 0;\n\tif (Array.isArray(args[0])) {\n\t\targs = /** @type {import('../types').SprintfArgs<T>[]} */ (\n\t\t\t/** @type {unknown} */ args[0]\n\t\t);\n\t}\n\n\treturn string.replace(PATTERN, function () {\n\t\tvar index,\n\t\t\t// name needs to be documented as `string | undefined` else value will have tpye unknown.\n\t\t\t/**\n\t\t\t * Name of the argument to substitute, if any.\n\t\t\t *\n\t\t\t * @type {string | undefined}\n\t\t\t */\n\t\t\tname,\n\t\t\tprecision,\n\t\t\ttype,\n\t\t\tvalue;\n\n\t\tindex = arguments[3];\n\t\tname = arguments[5];\n\t\tprecision = arguments[7];\n\t\ttype = arguments[9];\n\n\t\t// There's no placeholder substitution in the explicit \"%\", meaning it\n\t\t// is not necessary to increment argument index.\n\t\tif (type === '%') {\n\t\t\treturn '%';\n\t\t}\n\n\t\t// Asterisk precision determined by peeking / shifting next argument.\n\t\tif (precision === '*') {\n\t\t\tprecision = args[i];\n\t\t\ti++;\n\t\t}\n\n\t\tif (name === undefined) {\n\t\t\t// If not a positional argument, use counter value.\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = i + 1;\n\t\t\t}\n\n\t\t\ti++;\n\n\t\t\t// Positional argument.\n\t\t\tvalue = args[index - 1];\n\t\t} else if (\n\t\t\targs[0] &&\n\t\t\ttypeof args[0] === 'object' &&\n\t\t\targs[0].hasOwnProperty(name)\n\t\t) {\n\t\t\t// If it's a named argument, use name.\n\t\t\tvalue = args[0][name];\n\t\t}\n\n\t\t// Parse as type.\n\t\tif (type === 'f') {\n\t\t\tvalue = parseFloat(value) || 0;\n\t\t} else if (type === 'd') {\n\t\t\tvalue = parseInt(value) || 0;\n\t\t}\n\n\t\t// Apply precision.\n\t\tif (precision !== undefined) {\n\t\t\tif (type === 'f') {\n\t\t\t\tvalue = value.toFixed(precision);\n\t\t\t} else if (type === 's') {\n\t\t\t\tvalue = value.substr(0, precision);\n\t\t\t}\n\t\t}\n\n\t\t// To avoid \"undefined\" concatenation, return empty string if no\n\t\t// placeholder substitution can be performed.\n\t\treturn value !== undefined && value !== null ? value : '';\n\t});\n}\n", "/**\n * External dependencies\n */\n// Disable reason: `eslint-plugin-import` doesn't support `exports` (https://github.com/import-js/eslint-plugin-import/issues/1810)\n// eslint-disable-next-line import/no-unresolved\nimport _sprintf from '@tannin/sprintf';\n\n/**\n * Internal dependencies\n */\nimport type { DistributeSprintfArgs, TranslatableText } from './types';\n\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\t...args: DistributeSprintfArgs< T >\n): string;\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\targs: DistributeSprintfArgs< T >\n): string;\n\n/**\n * Returns a formatted string.\n *\n * @param format The format of the string to generate.\n * @param args   Arguments to apply to the format.\n *\n * @see https://www.npmjs.com/package/@tannin/sprintf\n *\n * @return The formatted string.\n */\nexport function sprintf< T extends string >(\n\tformat: T | TranslatableText< T >,\n\t...args: DistributeSprintfArgs< T >\n): string {\n\treturn _sprintf( format as T, ...( args as DistributeSprintfArgs< T > ) );\n}\n", "var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;\n\n/**\n * Operator precedence mapping.\n *\n * @type {Object}\n */\nPRECEDENCE = {\n\t'(': 9,\n\t'!': 8,\n\t'*': 7,\n\t'/': 7,\n\t'%': 7,\n\t'+': 6,\n\t'-': 6,\n\t'<': 5,\n\t'<=': 5,\n\t'>': 5,\n\t'>=': 5,\n\t'==': 4,\n\t'!=': 4,\n\t'&&': 3,\n\t'||': 2,\n\t'?': 1,\n\t'?:': 1,\n};\n\n/**\n * Characters which signal pair opening, to be terminated by terminators.\n *\n * @type {string[]}\n */\nOPENERS = [ '(', '?' ];\n\n/**\n * Characters which signal pair termination, the value an array with the\n * opener as its first member. The second member is an optional operator\n * replacement to push to the stack.\n *\n * @type {string[]}\n */\nTERMINATORS = {\n\t')': [ '(' ],\n\t':': [ '?', '?:' ],\n};\n\n/**\n * Pattern matching operators and openers.\n *\n * @type {RegExp}\n */\nPATTERN = /<=|>=|==|!=|&&|\\|\\||\\?:|\\(|!|\\*|\\/|%|\\+|-|<|>|\\?|\\)|:/;\n\n/**\n * Given a C expression, returns the equivalent postfix (Reverse Polish)\n * notation terms as an array.\n *\n * If a postfix string is desired, simply `.join( ' ' )` the result.\n *\n * @example\n *\n * ```js\n * import postfix from '@tannin/postfix';\n *\n * postfix( 'n > 1' );\n * // \u21D2 [ 'n', '1', '>' ]\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {string[]} Postfix terms.\n */\nexport default function postfix( expression ) {\n\tvar terms = [],\n\t\tstack = [],\n\t\tmatch, operator, term, element;\n\n\twhile ( ( match = expression.match( PATTERN ) ) ) {\n\t\toperator = match[ 0 ];\n\n\t\t// Term is the string preceding the operator match. It may contain\n\t\t// whitespace, and may be empty (if operator is at beginning).\n\t\tterm = expression.substr( 0, match.index ).trim();\n\t\tif ( term ) {\n\t\t\tterms.push( term );\n\t\t}\n\n\t\twhile ( ( element = stack.pop() ) ) {\n\t\t\tif ( TERMINATORS[ operator ] ) {\n\t\t\t\tif ( TERMINATORS[ operator ][ 0 ] === element ) {\n\t\t\t\t\t// Substitution works here under assumption that because\n\t\t\t\t\t// the assigned operator will no longer be a terminator, it\n\t\t\t\t\t// will be pushed to the stack during the condition below.\n\t\t\t\t\toperator = TERMINATORS[ operator ][ 1 ] || operator;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if ( OPENERS.indexOf( element ) >= 0 || PRECEDENCE[ element ] < PRECEDENCE[ operator ] ) {\n\t\t\t\t// Push to stack if either an opener or when pop reveals an\n\t\t\t\t// element of lower precedence.\n\t\t\t\tstack.push( element );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// For each popped from stack, push to terms.\n\t\t\tterms.push( element );\n\t\t}\n\n\t\tif ( ! TERMINATORS[ operator ] ) {\n\t\t\tstack.push( operator );\n\t\t}\n\n\t\t// Slice matched fragment from expression to continue match.\n\t\texpression = expression.substr( match.index + operator.length );\n\t}\n\n\t// Push remainder of operand, if exists, to terms.\n\texpression = expression.trim();\n\tif ( expression ) {\n\t\tterms.push( expression );\n\t}\n\n\t// Pop remaining items from stack into terms.\n\treturn terms.concat( stack.reverse() );\n}\n", "/**\n * Operator callback functions.\n *\n * @type {Object}\n */\nvar OPERATORS = {\n\t'!': function( a ) {\n\t\treturn ! a;\n\t},\n\t'*': function( a, b ) {\n\t\treturn a * b;\n\t},\n\t'/': function( a, b ) {\n\t\treturn a / b;\n\t},\n\t'%': function( a, b ) {\n\t\treturn a % b;\n\t},\n\t'+': function( a, b ) {\n\t\treturn a + b;\n\t},\n\t'-': function( a, b ) {\n\t\treturn a - b;\n\t},\n\t'<': function( a, b ) {\n\t\treturn a < b;\n\t},\n\t'<=': function( a, b ) {\n\t\treturn a <= b;\n\t},\n\t'>': function( a, b ) {\n\t\treturn a > b;\n\t},\n\t'>=': function( a, b ) {\n\t\treturn a >= b;\n\t},\n\t'==': function( a, b ) {\n\t\treturn a === b;\n\t},\n\t'!=': function( a, b ) {\n\t\treturn a !== b;\n\t},\n\t'&&': function( a, b ) {\n\t\treturn a && b;\n\t},\n\t'||': function( a, b ) {\n\t\treturn a || b;\n\t},\n\t'?:': function( a, b, c ) {\n\t\tif ( a ) {\n\t\t\tthrow b;\n\t\t}\n\n\t\treturn c;\n\t},\n};\n\n/**\n * Given an array of postfix terms and operand variables, returns the result of\n * the postfix evaluation.\n *\n * @example\n *\n * ```js\n * import evaluate from '@tannin/evaluate';\n *\n * // 3 + 4 * 5 / 6 \u21D2 '3 4 5 * 6 / +'\n * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];\n *\n * evaluate( terms, {} );\n * // \u21D2 6.333333333333334\n * ```\n *\n * @param {string[]} postfix   Postfix terms.\n * @param {Object}   variables Operand variables.\n *\n * @return {*} Result of evaluation.\n */\nexport default function evaluate( postfix, variables ) {\n\tvar stack = [],\n\t\ti, j, args, getOperatorResult, term, value;\n\n\tfor ( i = 0; i < postfix.length; i++ ) {\n\t\tterm = postfix[ i ];\n\n\t\tgetOperatorResult = OPERATORS[ term ];\n\t\tif ( getOperatorResult ) {\n\t\t\t// Pop from stack by number of function arguments.\n\t\t\tj = getOperatorResult.length;\n\t\t\targs = Array( j );\n\t\t\twhile ( j-- ) {\n\t\t\t\targs[ j ] = stack.pop();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalue = getOperatorResult.apply( null, args );\n\t\t\t} catch ( earlyReturn ) {\n\t\t\t\treturn earlyReturn;\n\t\t\t}\n\t\t} else if ( variables.hasOwnProperty( term ) ) {\n\t\t\tvalue = variables[ term ];\n\t\t} else {\n\t\t\tvalue = +term;\n\t\t}\n\n\t\tstack.push( value );\n\t}\n\n\treturn stack[ 0 ];\n}\n", "import postfix from '@tannin/postfix';\nimport evaluate from '@tannin/evaluate';\n\n/**\n * Given a C expression, returns a function which can be called to evaluate its\n * result.\n *\n * @example\n *\n * ```js\n * import compile from '@tannin/compile';\n *\n * const evaluate = compile( 'n > 1' );\n *\n * evaluate( { n: 2 } );\n * // \u21D2 true\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {(variables?:{[variable:string]:*})=>*} Compiled evaluator.\n */\nexport default function compile( expression ) {\n\tvar terms = postfix( expression );\n\n\treturn function( variables ) {\n\t\treturn evaluate( terms, variables );\n\t};\n}\n", "import compile from '@tannin/compile';\n\n/**\n * Given a C expression, returns a function which, when called with a value,\n * evaluates the result with the value assumed to be the \"n\" variable of the\n * expression. The result will be coerced to its numeric equivalent.\n *\n * @param {string} expression C expression.\n *\n * @return {Function} Evaluator function.\n */\nexport default function pluralForms( expression ) {\n\tvar evaluate = compile( expression );\n\n\treturn function( n ) {\n\t\treturn +evaluate( { n: n } );\n\t};\n}\n", "import pluralForms from '@tannin/plural-forms';\n\n/**\n * Tannin constructor options.\n *\n * @typedef {Object} TanninOptions\n *\n * @property {string}   [contextDelimiter] Joiner in string lookup with context.\n * @property {Function} [onMissingKey]     Callback to invoke when key missing.\n */\n\n/**\n * Domain metadata.\n *\n * @typedef {Object} TanninDomainMetadata\n *\n * @property {string}            [domain]       Domain name.\n * @property {string}            [lang]         Language code.\n * @property {(string|Function)} [plural_forms] Plural forms expression or\n *                                              function evaluator.\n */\n\n/**\n * Domain translation pair respectively representing the singular and plural\n * translation.\n *\n * @typedef {[string,string]} TanninTranslation\n */\n\n/**\n * Locale data domain. The key is used as reference for lookup, the value an\n * array of two string entries respectively representing the singular and plural\n * translation.\n *\n * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain\n */\n\n/**\n * Jed-formatted locale data.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData\n */\n\n/**\n * Default Tannin constructor options.\n *\n * @type {TanninOptions}\n */\nvar DEFAULT_OPTIONS = {\n\tcontextDelimiter: '\\u0004',\n\tonMissingKey: null,\n};\n\n/**\n * Given a specific locale data's config `plural_forms` value, returns the\n * expression.\n *\n * @example\n *\n * ```\n * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'\n * ```\n *\n * @param {string} pf Locale data plural forms.\n *\n * @return {string} Plural forms expression.\n */\nfunction getPluralExpression( pf ) {\n\tvar parts, i, part;\n\n\tparts = pf.split( ';' );\n\n\tfor ( i = 0; i < parts.length; i++ ) {\n\t\tpart = parts[ i ].trim();\n\t\tif ( part.indexOf( 'plural=' ) === 0 ) {\n\t\t\treturn part.substr( 7 );\n\t\t}\n\t}\n}\n\n/**\n * Tannin constructor.\n *\n * @class\n *\n * @param {TanninLocaleData} data      Jed-formatted locale data.\n * @param {TanninOptions}    [options] Tannin options.\n */\nexport default function Tannin( data, options ) {\n\tvar key;\n\n\t/**\n\t * Jed-formatted locale data.\n\t *\n\t * @name Tannin#data\n\t * @type {TanninLocaleData}\n\t */\n\tthis.data = data;\n\n\t/**\n\t * Plural forms function cache, keyed by plural forms string.\n\t *\n\t * @name Tannin#pluralForms\n\t * @type {Object<string,Function>}\n\t */\n\tthis.pluralForms = {};\n\n\t/**\n\t * Effective options for instance, including defaults.\n\t *\n\t * @name Tannin#options\n\t * @type {TanninOptions}\n\t */\n\tthis.options = {};\n\n\tfor ( key in DEFAULT_OPTIONS ) {\n\t\tthis.options[ key ] = options !== undefined && key in options\n\t\t\t? options[ key ]\n\t\t\t: DEFAULT_OPTIONS[ key ];\n\t}\n}\n\n/**\n * Returns the plural form index for the given domain and value.\n *\n * @param {string} domain Domain on which to calculate plural form.\n * @param {number} n      Value for which plural form is to be calculated.\n *\n * @return {number} Plural form index.\n */\nTannin.prototype.getPluralForm = function( domain, n ) {\n\tvar getPluralForm = this.pluralForms[ domain ],\n\t\tconfig, plural, pf;\n\n\tif ( ! getPluralForm ) {\n\t\tconfig = this.data[ domain ][ '' ];\n\n\t\tpf = (\n\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t// @ts-ignore\n\t\t\tconfig.plural_forms\n\t\t);\n\n\t\tif ( typeof pf !== 'function' ) {\n\t\t\tplural = getPluralExpression(\n\t\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t\t// @ts-ignore\n\t\t\t\tconfig.plural_forms\n\t\t\t);\n\n\t\t\tpf = pluralForms( plural );\n\t\t}\n\n\t\tgetPluralForm = this.pluralForms[ domain ] = pf;\n\t}\n\n\treturn getPluralForm( n );\n};\n\n/**\n * Translate a string.\n *\n * @param {string}      domain   Translation domain.\n * @param {string|void} context  Context distinguishing terms of the same name.\n * @param {string}      singular Primary key for translation lookup.\n * @param {string=}     plural   Fallback value used for non-zero plural\n *                               form index.\n * @param {number=}     n        Value to use in calculating plural form.\n *\n * @return {string} Translated string.\n */\nTannin.prototype.dcnpgettext = function( domain, context, singular, plural, n ) {\n\tvar index, key, entry;\n\n\tif ( n === undefined ) {\n\t\t// Default to singular.\n\t\tindex = 0;\n\t} else {\n\t\t// Find index by evaluating plural form for value.\n\t\tindex = this.getPluralForm( domain, n );\n\t}\n\n\tkey = singular;\n\n\t// If provided, context is prepended to key with delimiter.\n\tif ( context ) {\n\t\tkey = context + this.options.contextDelimiter + singular;\n\t}\n\n\tentry = this.data[ domain ][ key ];\n\n\t// Verify not only that entry exists, but that the intended index is within\n\t// range and non-empty.\n\tif ( entry && entry[ index ] ) {\n\t\treturn entry[ index ];\n\t}\n\n\tif ( this.options.onMissingKey ) {\n\t\tthis.options.onMissingKey( singular, domain );\n\t}\n\n\t// If entry not found, fall back to singular vs. plural with zero index\n\t// representing the singular value.\n\treturn index === 0 ? singular : plural;\n};\n", "/**\n * External dependencies\n */\nimport type { TanninLocaleDomain } from 'tannin';\nimport Tannin from 'tannin';\n/**\n * Internal dependencies\n */\nimport type {\n\tgetFilterDomain,\n\tI18n,\n\tLocaleData,\n\tSubscribeCallback,\n\tTranslatableText,\n\tUnsubscribeCallback,\n} from './types';\n/**\n * WordPress dependencies\n */\nimport type { Hooks } from '@wordpress/hooks';\n/**\n * Default locale data to use for Tannin domain when not otherwise provided.\n * Assumes an English plural forms expression.\n */\nconst DEFAULT_LOCALE_DATA: LocaleData = {\n\t'': {\n\t\tplural_forms( n: number ) {\n\t\t\treturn n === 1 ? 0 : 1;\n\t\t},\n\t},\n};\n\n/*\n * Regular expression that matches i18n hooks like `i18n.gettext`, `i18n.ngettext`,\n * `i18n.gettext_domain` or `i18n.ngettext_with_context` or `i18n.has_translation`.\n */\nconst I18N_HOOK_REGEXP = /^i18n\\.(n?gettext|has_translation)(_|$)/;\n\n/**\n * Create an i18n instance\n *\n * @param [initialData]   Locale data configuration.\n * @param [initialDomain] Domain for which configuration applies.\n * @param [hooks]         Hooks implementation.\n *\n * @return I18n instance.\n */\nexport const createI18n = < TextDomain extends string >(\n\tinitialData?: LocaleData< TextDomain >,\n\tinitialDomain?: TextDomain,\n\thooks?: Hooks\n): I18n< TextDomain > => {\n\t/**\n\t * The underlying instance of Tannin to which exported functions interface.\n\t */\n\tconst tannin = new Tannin( {} );\n\n\tconst listeners = new Set< () => void >();\n\n\tconst notifyListeners = () => {\n\t\tlisteners.forEach( ( listener ) => listener() );\n\t};\n\n\t/**\n\t * Subscribe to changes of locale data.\n\t *\n\t * @param callback Subscription callback.\n\t * @return Unsubscribe callback.\n\t */\n\tconst subscribe = ( callback: SubscribeCallback ): UnsubscribeCallback => {\n\t\tlisteners.add( callback );\n\t\treturn () => listeners.delete( callback );\n\t};\n\n\tconst getLocaleData: I18n< TextDomain >[ 'getLocaleData' ] = (\n\t\tdomain = 'default' as TextDomain\n\t) => tannin.data[ domain ] as LocaleData< TextDomain >;\n\n\t/**\n\t * @param [data]\n\t * @param [domain]\n\t */\n\tconst doSetLocaleData = (\n\t\tdata?: LocaleData,\n\t\tdomain: TextDomain = 'default' as TextDomain\n\t) => {\n\t\ttannin.data[ domain ] = {\n\t\t\t...tannin.data[ domain ],\n\t\t\t...data,\n\t\t} as TanninLocaleDomain;\n\n\t\t// Populate default domain configuration (supported locale date which omits\n\t\t// a plural forms expression).\n\t\ttannin.data[ domain ][ '' ] = {\n\t\t\t...DEFAULT_LOCALE_DATA[ '' ],\n\t\t\t...tannin.data[ domain ]?.[ '' ],\n\t\t};\n\n\t\t// Clean up cached plural forms functions cache as it might be updated.\n\t\tdelete tannin.pluralForms[ domain ];\n\t};\n\n\tconst setLocaleData: I18n< TextDomain >[ 'setLocaleData' ] = (\n\t\tdata,\n\t\tdomain\n\t) => {\n\t\tdoSetLocaleData( data, domain );\n\t\tnotifyListeners();\n\t};\n\n\tconst addLocaleData: I18n< TextDomain >[ 'addLocaleData' ] = (\n\t\tdata,\n\t\tdomain = 'default' as TextDomain\n\t) => {\n\t\ttannin.data[ domain ] = {\n\t\t\t...tannin.data[ domain ],\n\t\t\t...data,\n\t\t\t// Populate default domain configuration (supported locale date which omits\n\t\t\t// a plural forms expression).\n\t\t\t'': {\n\t\t\t\t...DEFAULT_LOCALE_DATA[ '' ],\n\t\t\t\t...tannin.data[ domain ]?.[ '' ],\n\t\t\t\t...data?.[ '' ],\n\t\t\t},\n\t\t} as TanninLocaleDomain;\n\n\t\t// Clean up cached plural forms functions cache as it might be updated.\n\t\tdelete tannin.pluralForms[ domain ];\n\n\t\tnotifyListeners();\n\t};\n\n\tconst resetLocaleData: I18n< TextDomain >[ 'resetLocaleData' ] = (\n\t\tdata,\n\t\tdomain\n\t) => {\n\t\t// Reset all current Tannin locale data.\n\t\ttannin.data = {};\n\n\t\t// Reset cached plural forms functions cache.\n\t\ttannin.pluralForms = {};\n\n\t\tsetLocaleData( data, domain );\n\t};\n\n\t/**\n\t * Wrapper for Tannin's `dcnpgettext`. Populates default locale data if not\n\t * otherwise previously assigned.\n\t *\n\t * @param domain   Domain to retrieve the translated text.\n\t * @param context  Context information for the translators.\n\t * @param single   Text to translate if non-plural. Used as\n\t *                 fallback return value on a caught error.\n\t * @param [plural] The text to be used if the number is\n\t *                 plural.\n\t * @param [number] The number to compare against to use\n\t *                 either the singular or plural form.\n\t *\n\t * @return The translated string.\n\t */\n\tconst dcnpgettext = (\n\t\tdomain = 'default' as TextDomain,\n\t\tcontext: string | void,\n\t\tsingle: string,\n\t\tplural?: string,\n\t\tnumber?: number\n\t): string => {\n\t\tif ( ! tannin.data[ domain ] ) {\n\t\t\t// Use `doSetLocaleData` to set silently, without notifying listeners.\n\t\t\tdoSetLocaleData( undefined, domain );\n\t\t}\n\n\t\treturn tannin.dcnpgettext( domain, context, single, plural, number );\n\t};\n\n\tconst getFilterDomain: getFilterDomain = ( domain ) => domain || 'default';\n\n\tconst __: I18n< TextDomain >[ '__' ] = ( text, domain ) => {\n\t\tlet translation = dcnpgettext( domain, undefined, text );\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText< typeof text >;\n\t\t}\n\n\t\t/**\n\t\t * Filters text with its translation.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param text        Text to translate.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.gettext',\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.gettext_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\t};\n\n\tconst _x: I18n< TextDomain >[ '_x' ] = ( text, context, domain ) => {\n\t\tlet translation = dcnpgettext( domain, context, text );\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText< typeof text >;\n\t\t}\n\n\t\t/**\n\t\t * Filters text with its translation based on context information.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param text        Text to translate.\n\t\t * @param context     Context information for the translators.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.gettext_with_context',\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.gettext_with_context_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\ttext,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof text >;\n\t};\n\n\tconst _n: I18n< TextDomain >[ '_n' ] = (\n\t\tsingle,\n\t\tplural,\n\t\tnumber,\n\t\tdomain\n\t) => {\n\t\tlet translation = dcnpgettext(\n\t\t\tdomain,\n\t\t\tundefined,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber\n\t\t);\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText<\n\t\t\t\ttypeof single | typeof plural\n\t\t\t>;\n\t\t}\n\n\t\t/**\n\t\t * Filters the singular or plural form of a string.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param single      The text to be used if the number is singular.\n\t\t * @param plural      The text to be used if the number is plural.\n\t\t * @param number      The number to compare against to use either the singular or plural form.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.ngettext',\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.ngettext_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\t};\n\n\tconst _nx: I18n< TextDomain >[ '_nx' ] = (\n\t\tsingle,\n\t\tplural,\n\t\tnumber,\n\t\tcontext,\n\t\tdomain\n\t) => {\n\t\tlet translation = dcnpgettext(\n\t\t\tdomain,\n\t\t\tcontext,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber\n\t\t);\n\t\tif ( ! hooks ) {\n\t\t\treturn translation as TranslatableText<\n\t\t\t\ttypeof single | typeof plural\n\t\t\t>;\n\t\t}\n\n\t\t/**\n\t\t * Filters the singular or plural form of a string with gettext context.\n\t\t *\n\t\t * @param translation Translated text.\n\t\t * @param single      The text to be used if the number is singular.\n\t\t * @param plural      The text to be used if the number is plural.\n\t\t * @param number      The number to compare against to use either the singular or plural form.\n\t\t * @param context     Context information for the translators.\n\t\t * @param domain      Text domain. Unique identifier for retrieving translated strings.\n\t\t */\n\t\ttranslation = hooks.applyFilters(\n\t\t\t'i18n.ngettext_with_context',\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\n\t\treturn hooks.applyFilters(\n\t\t\t'i18n.ngettext_with_context_' + getFilterDomain( domain ),\n\t\t\ttranslation,\n\t\t\tsingle,\n\t\t\tplural,\n\t\t\tnumber,\n\t\t\tcontext,\n\t\t\tdomain\n\t\t) as TranslatableText< typeof single | typeof plural >;\n\t};\n\n\tconst isRTL: I18n< TextDomain >[ 'isRTL' ] = () => {\n\t\treturn 'rtl' === _x( 'ltr', 'text direction' );\n\t};\n\n\tconst hasTranslation: I18n< TextDomain >[ 'hasTranslation' ] = (\n\t\tsingle,\n\t\tcontext,\n\t\tdomain\n\t) => {\n\t\tconst key = context ? context + '\\u0004' + single : single;\n\t\tlet result = !! tannin.data?.[ domain ?? 'default' ]?.[ key ];\n\t\tif ( hooks ) {\n\t\t\t/**\n\t\t\t * Filters the presence of a translation in the locale data.\n\t\t\t *\n\t\t\t * @param hasTranslation Whether the translation is present or not..\n\t\t\t * @param single         The singular form of the translated text (used as key in locale data)\n\t\t\t * @param context        Context information for the translators.\n\t\t\t * @param domain         Text domain. Unique identifier for retrieving translated strings.\n\t\t\t */\n\t\t\tresult = hooks.applyFilters(\n\t\t\t\t'i18n.has_translation',\n\t\t\t\tresult,\n\t\t\t\tsingle,\n\t\t\t\tcontext,\n\t\t\t\tdomain\n\t\t\t) as boolean;\n\n\t\t\tresult = hooks.applyFilters(\n\t\t\t\t'i18n.has_translation_' + getFilterDomain( domain ),\n\t\t\t\tresult,\n\t\t\t\tsingle,\n\t\t\t\tcontext,\n\t\t\t\tdomain\n\t\t\t) as boolean;\n\t\t}\n\t\treturn result;\n\t};\n\n\tif ( initialData ) {\n\t\tsetLocaleData( initialData, initialDomain );\n\t}\n\n\tif ( hooks ) {\n\t\t/**\n\t\t * @param hookName\n\t\t */\n\t\tconst onHookAddedOrRemoved = ( hookName: string ) => {\n\t\t\tif ( I18N_HOOK_REGEXP.test( hookName ) ) {\n\t\t\t\tnotifyListeners();\n\t\t\t}\n\t\t};\n\n\t\thooks.addAction( 'hookAdded', 'core/i18n', onHookAddedOrRemoved );\n\t\thooks.addAction( 'hookRemoved', 'core/i18n', onHookAddedOrRemoved );\n\t}\n\n\treturn {\n\t\tgetLocaleData,\n\t\tsetLocaleData,\n\t\taddLocaleData,\n\t\tresetLocaleData,\n\t\tsubscribe,\n\t\t__,\n\t\t_x,\n\t\t_n,\n\t\t_nx,\n\t\tisRTL,\n\t\thasTranslation,\n\t};\n};\n", "/**\n * Internal dependencies\n */\nimport { createI18n } from './create-i18n';\n\n/**\n * WordPress dependencies\n */\nimport { defaultHooks } from '@wordpress/hooks';\nimport {\n\tLocaleData,\n\tSubscribeCallback,\n\tTranslatableText,\n\tUnsubscribeCallback,\n} from './types';\n\nconst i18n = createI18n( undefined, undefined, defaultHooks );\n\n/**\n * Default, singleton instance of `I18n`.\n */\nexport default i18n;\n\n/*\n * Comments in this file are duplicated from ./i18n due to\n * https://github.com/WordPress/gutenberg/pull/20318#issuecomment-590837722\n */\n\n/**\n * Returns locale data by domain in a Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param { string | undefined } [domain] Domain for which to get the data.\n * @return { LocaleData } Locale data.\n */\nexport const getLocaleData = i18n.getLocaleData.bind( i18n );\n\n/**\n * Merges locale data into the Tannin instance by domain. Accepts data in a\n * Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param {LocaleData }        [data]   Locale data configuration.\n * @param {string | undefined} [domain] Domain for which configuration applies.\n */\nexport const setLocaleData = i18n.setLocaleData.bind( i18n );\n\n/**\n * Resets all current Tannin instance locale data and sets the specified\n * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @param {LocaleData}         [data]   Locale data configuration.\n * @param {string | undefined} [domain] Domain for which configuration applies.\n */\nexport const resetLocaleData = i18n.resetLocaleData.bind( i18n );\n\n/**\n * Subscribes to changes of locale data\n *\n * @param {SubscribeCallback} callback Subscription callback\n * @return {UnsubscribeCallback} Unsubscribe callback\n */\nexport const subscribe = i18n.subscribe.bind( i18n );\n\n/**\n * Retrieve the translation of text.\n *\n * @see https://developer.wordpress.org/reference/functions/__/\n *\n * @template {string} Text\n *\n * @param {Text}               text   Text to translate.\n * @param {string | undefined} domain Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Text>} Translated text.\n */\nexport const __ = i18n.__.bind( i18n );\n\n/**\n * Retrieve translated string with gettext context.\n *\n * @see https://developer.wordpress.org/reference/functions/_x/\n *\n * @template {string} Text\n *\n * @param {Text}               text    Text to translate.\n * @param {string}             context Context information for the translators.\n * @param {string | undefined} domain  Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Text>} Translated context string without pipe.\n */\nexport const _x = i18n._x.bind( i18n );\n\n/**\n * Translates and retrieves the singular or plural form based on the supplied\n * number.\n *\n * @see https://developer.wordpress.org/reference/functions/_n/\n *\n * @template {string} Single\n * @template {string} Plural\n *\n * @param {Single}             single The text to be used if the number is singular.\n * @param {Plural}             plural The text to be used if the number is plural.\n * @param {number}             number The number to compare against to use either the\n *                                    singular or plural form.\n * @param {string | undefined} domain Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Single | Plural>} The translated singular or plural form.\n */\nexport const _n = i18n._n.bind( i18n );\n\n/**\n * Translates and retrieves the singular or plural form based on the supplied\n * number, with gettext context.\n *\n * @see https://developer.wordpress.org/reference/functions/_nx/\n *\n * @template {string} Single\n * @template {string} Plural\n * @param {Single}             single   The text to be used if the number is singular.\n *\n * @param {Single}             single   The text to be used if the number is singular.\n * @param {Plural}             plural   The text to be used if the number is plural.\n * @param {number}             number   The number to compare against to use either the\n *                                      singular or plural form.\n * @param {string}             context  Context information for the translators.\n * @param {string | undefined} [domain] Domain to retrieve the translated text.\n *\n * @return {TranslatableText<Single | Plural>} The translated singular or plural form.\n */\nexport const _nx = i18n._nx.bind( i18n );\n\n/**\n * Check if current locale is RTL.\n *\n * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.\n * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common\n * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,\n * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).\n *\n * @return {boolean} Whether locale is RTL.\n */\nexport const isRTL = i18n.isRTL.bind( i18n );\n\n/**\n * Check if there is a translation for a given string (in singular form).\n *\n * @param {string} single  Singular form of the string to look up.\n * @param {string} context Context information for the translators.\n * @param {string} domain  Domain to retrieve the translated text.\n *\n * @return {boolean} Whether the translation exists or not.\n */\nexport const hasTranslation = i18n.hasTranslation.bind( i18n );\n"],
  "mappings": "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",
  "names": ["require_hooks", "__commonJSMin", "exports", "module", "index_exports", "__export", "__", "_n", "_nx", "_x", "createI18n", "default_i18n_default", "getLocaleData", "hasTranslation", "isRTL", "resetLocaleData", "setLocaleData", "sprintf", "subscribe", "PATTERN", "sprintf", "string", "args", "i", "index", "name", "precision", "type", "value", "sprintf", "format", "args", "PRECEDENCE", "OPENERS", "TERMINATORS", "PATTERN", "postfix", "expression", "terms", "stack", "match", "operator", "term", "element", "OPERATORS", "a", "b", "c", "evaluate", "postfix", "variables", "stack", "i", "j", "args", "getOperatorResult", "term", "value", "earlyReturn", "compile", "expression", "terms", "postfix", "variables", "evaluate", "pluralForms", "expression", "evaluate", "compile", "n", "DEFAULT_OPTIONS", "getPluralExpression", "pf", "parts", "i", "part", "Tannin", "data", "options", "key", "domain", "n", "getPluralForm", "config", "plural", "pluralForms", "context", "singular", "index", "entry", "DEFAULT_LOCALE_DATA", "n", "I18N_HOOK_REGEXP", "createI18n", "initialData", "initialDomain", "hooks", "tannin", "Tannin", "listeners", "notifyListeners", "listener", "subscribe", "callback", "getLocaleData", "domain", "doSetLocaleData", "data", "setLocaleData", "addLocaleData", "resetLocaleData", "dcnpgettext", "context", "single", "plural", "number", "getFilterDomain", "__", "text", "translation", "_x", "_n", "_nx", "isRTL", "hasTranslation", "key", "result", "onHookAddedOrRemoved", "hookName", "import_hooks", "i18n", "createI18n", "default_i18n_default", "getLocaleData", "setLocaleData", "resetLocaleData", "subscribe", "__", "_x", "_n", "_nx", "isRTL", "hasTranslation"]
}
