{
  "version": 3,
  "sources": ["../../node_modules/requestidlecallback/index.js", "../../packages/priority-queue/src/index.ts", "../../packages/priority-queue/src/request-idle-callback.ts"],
  "sourcesContent": ["(function (factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine([], factory);\n\t} else if (typeof module === 'object' && module.exports) {\n\t\tmodule.exports = factory();\n\t} else {\n\t\twindow.idleCallbackShim = factory();\n\t}\n}(function(){\n\t'use strict';\n\tvar scheduleStart, throttleDelay, lazytimer, lazyraf;\n\tvar root = typeof window != 'undefined' ?\n\t\twindow :\n\t\ttypeof global != undefined ?\n\t\t\tglobal :\n\t\t\tthis || {};\n\tvar requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;\n\tvar cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;\n\tvar tasks = [];\n\tvar runAttempts = 0;\n\tvar isRunning = false;\n\tvar remainingTime = 7;\n\tvar minThrottle = 35;\n\tvar throttle = 125;\n\tvar index = 0;\n\tvar taskStart = 0;\n\tvar tasklength = 0;\n\tvar IdleDeadline = {\n\t\tget didTimeout(){\n\t\t\treturn false;\n\t\t},\n\t\ttimeRemaining: function(){\n\t\t\tvar timeRemaining = remainingTime - (Date.now() - taskStart);\n\t\t\treturn timeRemaining < 0 ? 0 : timeRemaining;\n\t\t},\n\t};\n\tvar setInactive = debounce(function(){\n\t\tremainingTime = 22;\n\t\tthrottle = 66;\n\t\tminThrottle = 0;\n\t});\n\n\tfunction debounce(fn){\n\t\tvar id, timestamp;\n\t\tvar wait = 99;\n\t\tvar check = function(){\n\t\t\tvar last = (Date.now()) - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tid = setTimeout(check, wait - last);\n\t\t\t} else {\n\t\t\t\tid = null;\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\t\treturn function(){\n\t\t\ttimestamp = Date.now();\n\t\t\tif(!id){\n\t\t\t\tid = setTimeout(check, wait);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction abortRunning(){\n\t\tif(isRunning){\n\t\t\tif(lazyraf){\n\t\t\t\tcancelRequestAnimationFrame(lazyraf);\n\t\t\t}\n\t\t\tif(lazytimer){\n\t\t\t\tclearTimeout(lazytimer);\n\t\t\t}\n\t\t\tisRunning = false;\n\t\t}\n\t}\n\n\tfunction onInputorMutation(){\n\t\tif(throttle != 125){\n\t\t\tremainingTime = 7;\n\t\t\tthrottle = 125;\n\t\t\tminThrottle = 35;\n\n\t\t\tif(isRunning) {\n\t\t\t\tabortRunning();\n\t\t\t\tscheduleLazy();\n\t\t\t}\n\t\t}\n\t\tsetInactive();\n\t}\n\n\tfunction scheduleAfterRaf() {\n\t\tlazyraf = null;\n\t\tlazytimer = setTimeout(runTasks, 0);\n\t}\n\n\tfunction scheduleRaf(){\n\t\tlazytimer = null;\n\t\trequestAnimationFrame(scheduleAfterRaf);\n\t}\n\n\tfunction scheduleLazy(){\n\n\t\tif(isRunning){return;}\n\t\tthrottleDelay = throttle - (Date.now() - taskStart);\n\n\t\tscheduleStart = Date.now();\n\n\t\tisRunning = true;\n\n\t\tif(minThrottle && throttleDelay < minThrottle){\n\t\t\tthrottleDelay = minThrottle;\n\t\t}\n\n\t\tif(throttleDelay > 9){\n\t\t\tlazytimer = setTimeout(scheduleRaf, throttleDelay);\n\t\t} else {\n\t\t\tthrottleDelay = 0;\n\t\t\tscheduleRaf();\n\t\t}\n\t}\n\n\tfunction runTasks(){\n\t\tvar task, i, len;\n\t\tvar timeThreshold = remainingTime > 9 ?\n\t\t\t9 :\n\t\t\t1\n\t\t;\n\n\t\ttaskStart = Date.now();\n\t\tisRunning = false;\n\n\t\tlazytimer = null;\n\n\t\tif(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){\n\t\t\tfor(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){\n\t\t\t\ttask = tasks.shift();\n\t\t\t\ttasklength++;\n\t\t\t\tif(task){\n\t\t\t\t\ttask(IdleDeadline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tasks.length){\n\t\t\tscheduleLazy();\n\t\t} else {\n\t\t\trunAttempts = 0;\n\t\t}\n\t}\n\n\tfunction requestIdleCallbackShim(task){\n\t\tindex++;\n\t\ttasks.push(task);\n\t\tscheduleLazy();\n\t\treturn index;\n\t}\n\n\tfunction cancelIdleCallbackShim(id){\n\t\tvar index = id - 1 - tasklength;\n\t\tif(tasks[index]){\n\t\t\ttasks[index] = null;\n\t\t}\n\t}\n\n\tif(!root.requestIdleCallback || !root.cancelIdleCallback){\n\t\troot.requestIdleCallback = requestIdleCallbackShim;\n\t\troot.cancelIdleCallback = cancelIdleCallbackShim;\n\n\t\tif(root.document && document.addEventListener){\n\t\t\troot.addEventListener('scroll', onInputorMutation, true);\n\t\t\troot.addEventListener('resize', onInputorMutation);\n\n\t\t\tdocument.addEventListener('focus', onInputorMutation, true);\n\t\t\tdocument.addEventListener('mouseover', onInputorMutation, true);\n\t\t\t['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){\n\t\t\t\tdocument.addEventListener(name, onInputorMutation, {capture: true, passive: true});\n\t\t\t});\n\n\t\t\tif(root.MutationObserver){\n\t\t\t\tnew MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttry{\n\t\t\troot.requestIdleCallback(function(){}, {timeout: 0});\n\t\t} catch(e){\n\t\t\t(function(rIC){\n\t\t\t\tvar timeRemainingProto, timeRemaining;\n\t\t\t\troot.requestIdleCallback = function(fn, timeout){\n\t\t\t\t\tif(timeout && typeof timeout.timeout == 'number'){\n\t\t\t\t\t\treturn rIC(fn, timeout.timeout);\n\t\t\t\t\t}\n\t\t\t\t\treturn rIC(fn);\n\t\t\t\t};\n\t\t\t\tif(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){\n\t\t\t\t\ttimeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');\n\t\t\t\t\tif(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}\n\t\t\t\t\tObject.defineProperty(timeRemainingProto, 'timeRemaining', {\n\t\t\t\t\t\tvalue:  function(){\n\t\t\t\t\t\t\treturn timeRemaining.get.call(this);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})(root.requestIdleCallback)\n\t\t}\n\t}\n\n\treturn {\n\t\trequest: requestIdleCallbackShim,\n\t\tcancel: cancelIdleCallbackShim,\n\t};\n}));\n", "/**\n * Internal dependencies\n */\nimport requestIdleCallback from './request-idle-callback';\n\n/**\n * Enqueued callback to invoke once idle time permits.\n */\nexport type WPPriorityQueueCallback = VoidFunction;\n\n/**\n * An object used to associate callbacks in a particular context grouping.\n */\nexport type WPPriorityQueueContext = object;\n\n/**\n * Interface for the priority queue instance.\n */\nexport interface WPPriorityQueue {\n\t/**\n\t * Add a callback to the queue for a given context.\n\t */\n\tadd: (\n\t\telement: WPPriorityQueueContext,\n\t\titem: WPPriorityQueueCallback\n\t) => void;\n\n\t/**\n\t * Flush and run the callback for a given context immediately.\n\t * @return true if a callback was run, false otherwise.\n\t */\n\tflush: ( element: WPPriorityQueueContext ) => boolean;\n\n\t/**\n\t * Cancel (remove) the callback for a given context without running it.\n\t * @return true if a callback was cancelled, false otherwise.\n\t */\n\tcancel: ( element: WPPriorityQueueContext ) => boolean;\n\n\t/**\n\t * Reset the entire queue, clearing pending callbacks.\n\t */\n\treset: VoidFunction;\n}\n\n/**\n * Creates a context-aware queue that only executes\n * the last task of a given context.\n *\n * @example\n *```js\n * import { createQueue } from '@wordpress/priority-queue';\n *\n * const queue = createQueue();\n *\n * // Context objects.\n * const ctx1 = {};\n * const ctx2 = {};\n *\n * // For a given context in the queue, only the last callback is executed.\n * queue.add( ctx1, () => console.log( 'This will be printed first' ) );\n * queue.add( ctx2, () => console.log( 'This won\\'t be printed' ) );\n * queue.add( ctx2, () => console.log( 'This will be printed second' ) );\n *```\n *\n * @return {WPPriorityQueue} Queue object with `add`, `flush` and `reset` methods.\n */\nexport const createQueue = (): WPPriorityQueue => {\n\tconst waitingList = new Map<\n\t\tWPPriorityQueueContext,\n\t\tWPPriorityQueueCallback\n\t>();\n\tlet isRunning = false;\n\n\t/**\n\t * Callback to process as much queue as time permits.\n\t *\n\t * Map Iteration follows the original insertion order. This means that here\n\t * we can iterate the queue and know that the first contexts which were\n\t * added will be run first. On the other hand, if anyone adds a new callback\n\t * for an existing context it will supplant the previously-set callback for\n\t * that context because we reassigned that map key's value.\n\t *\n\t * In the case that a callback adds a new callback to its own context then\n\t * the callback it adds will appear at the end of the iteration and will be\n\t * run only after all other existing contexts have finished executing.\n\t *\n\t * @param {IdleDeadline|number} deadline Idle callback deadline object, or\n\t *                                       animation frame timestamp.\n\t */\n\tconst runWaitingList = ( deadline: IdleDeadline | number ): void => {\n\t\tfor ( const [ nextElement, callback ] of waitingList ) {\n\t\t\twaitingList.delete( nextElement );\n\t\t\tcallback();\n\n\t\t\tif (\n\t\t\t\t'number' === typeof deadline ||\n\t\t\t\tdeadline.timeRemaining() <= 0\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( waitingList.size === 0 ) {\n\t\t\tisRunning = false;\n\t\t\treturn;\n\t\t}\n\n\t\trequestIdleCallback( runWaitingList );\n\t};\n\n\t/**\n\t * Add a callback to the queue for a given context.\n\t *\n\t * If errors with undefined callbacks are encountered double check that\n\t * all of your useSelect calls have the right dependencies set correctly\n\t * in their second parameter. Missing dependencies can cause unexpected\n\t * loops and race conditions in the queue.\n\t *\n\t * @param {WPPriorityQueueContext}  element Context object.\n\t * @param {WPPriorityQueueCallback} item    Callback function.\n\t */\n\tconst add: WPPriorityQueue[ 'add' ] = (\n\t\telement: WPPriorityQueueContext,\n\t\titem: WPPriorityQueueCallback\n\t) => {\n\t\twaitingList.set( element, item );\n\t\tif ( ! isRunning ) {\n\t\t\tisRunning = true;\n\t\t\trequestIdleCallback( runWaitingList );\n\t\t}\n\t};\n\n\t/**\n\t * Flushes queue for a given context, returning true if the flush was\n\t * performed, or false if there is no queue for the given context.\n\t *\n\t * @param {WPPriorityQueueContext} element Context object.\n\t *\n\t * @return {boolean} Whether flush was performed.\n\t */\n\tconst flush: WPPriorityQueue[ 'flush' ] = (\n\t\telement: WPPriorityQueueContext\n\t) => {\n\t\tconst callback = waitingList.get( element );\n\t\tif ( undefined === callback ) {\n\t\t\treturn false;\n\t\t}\n\n\t\twaitingList.delete( element );\n\t\tcallback();\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Clears the queue for a given context, cancelling the callbacks without\n\t * executing them. Returns `true` if there were scheduled callbacks to cancel,\n\t * or `false` if there was is no queue for the given context.\n\t *\n\t * @param {WPPriorityQueueContext} element Context object.\n\t *\n\t * @return {boolean} Whether any callbacks got cancelled.\n\t */\n\tconst cancel: WPPriorityQueue[ 'cancel' ] = (\n\t\telement: WPPriorityQueueContext\n\t) => {\n\t\treturn waitingList.delete( element );\n\t};\n\n\t/**\n\t * Reset the queue without running the pending callbacks.\n\t */\n\tconst reset: WPPriorityQueue[ 'reset' ] = () => {\n\t\twaitingList.clear();\n\t\tisRunning = false;\n\t};\n\n\treturn {\n\t\tadd,\n\t\tflush,\n\t\tcancel,\n\t\treset,\n\t};\n};\n", "/**\n * External dependencies\n */\nimport 'requestidlecallback';\n\n/**\n * Internal dependencies\n */\nimport type { RequestIdleCallbackCallback } from './types';\n\n/**\n * @return A function that schedules a callback when the browser is idle or via setTimeout on the server.\n */\nexport function createRequestIdleCallback() {\n\tif ( typeof window === 'undefined' ) {\n\t\treturn ( callback: RequestIdleCallbackCallback ) => {\n\t\t\tsetTimeout( () => callback( Date.now() ), 0 );\n\t\t};\n\t}\n\n\treturn window.requestIdleCallback;\n}\n\nexport default createRequestIdleCallback();\n"],
  "mappings": "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",
  "names": ["require_requestidlecallback", "__commonJSMin", "exports", "module", "factory", "scheduleStart", "throttleDelay", "lazytimer", "lazyraf", "root", "requestAnimationFrame", "cancelRequestAnimationFrame", "tasks", "runAttempts", "isRunning", "remainingTime", "minThrottle", "throttle", "index", "taskStart", "tasklength", "IdleDeadline", "timeRemaining", "setInactive", "debounce", "fn", "id", "timestamp", "wait", "check", "last", "abortRunning", "onInputorMutation", "scheduleLazy", "scheduleAfterRaf", "runTasks", "scheduleRaf", "task", "i", "len", "timeThreshold", "requestIdleCallbackShim", "cancelIdleCallbackShim", "name", "rIC", "timeRemainingProto", "timeout", "index_exports", "__export", "createQueue", "import_requestidlecallback", "createRequestIdleCallback", "callback", "request_idle_callback_default", "createQueue", "waitingList", "isRunning", "runWaitingList", "deadline", "nextElement", "callback", "request_idle_callback_default", "element", "item"]
}
