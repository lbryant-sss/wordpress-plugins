"use strict";
var wp;
(wp ||= {}).blockEditor = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // vendor-external:react/jsx-runtime
  var require_jsx_runtime = __commonJS({
    "vendor-external:react/jsx-runtime"(exports, module) {
      module.exports = window.ReactJSXRuntime;
    }
  });

  // wordpress-external:@wordpress/blocks
  var require_blocks = __commonJS({
    "wordpress-external:@wordpress/blocks"(exports, module) {
      module.exports = window.wp.blocks;
    }
  });

  // wordpress-external:@wordpress/element
  var require_element = __commonJS({
    "wordpress-external:@wordpress/element"(exports, module) {
      module.exports = window.wp.element;
    }
  });

  // wordpress-external:@wordpress/data
  var require_data = __commonJS({
    "wordpress-external:@wordpress/data"(exports, module) {
      module.exports = window.wp.data;
    }
  });

  // wordpress-external:@wordpress/compose
  var require_compose = __commonJS({
    "wordpress-external:@wordpress/compose"(exports, module) {
      module.exports = window.wp.compose;
    }
  });

  // wordpress-external:@wordpress/hooks
  var require_hooks = __commonJS({
    "wordpress-external:@wordpress/hooks"(exports, module) {
      module.exports = window.wp.hooks;
    }
  });

  // wordpress-external:@wordpress/components
  var require_components = __commonJS({
    "wordpress-external:@wordpress/components"(exports, module) {
      module.exports = window.wp.components;
    }
  });

  // wordpress-external:@wordpress/private-apis
  var require_private_apis = __commonJS({
    "wordpress-external:@wordpress/private-apis"(exports, module) {
      module.exports = window.wp.privateApis;
    }
  });

  // wordpress-external:@wordpress/deprecated
  var require_deprecated = __commonJS({
    "wordpress-external:@wordpress/deprecated"(exports, module) {
      module.exports = window.wp.deprecated;
    }
  });

  // wordpress-external:@wordpress/url
  var require_url = __commonJS({
    "wordpress-external:@wordpress/url"(exports, module) {
      module.exports = window.wp.url;
    }
  });

  // node_modules/fast-deep-equal/es6/index.js
  var require_es6 = __commonJS({
    "node_modules/fast-deep-equal/es6/index.js"(exports, module) {
      "use strict";
      module.exports = function equal(a2, b2) {
        if (a2 === b2) return true;
        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
          if (a2.constructor !== b2.constructor) return false;
          var length2, i2, keys;
          if (Array.isArray(a2)) {
            length2 = a2.length;
            if (length2 != b2.length) return false;
            for (i2 = length2; i2-- !== 0; )
              if (!equal(a2[i2], b2[i2])) return false;
            return true;
          }
          if (a2 instanceof Map && b2 instanceof Map) {
            if (a2.size !== b2.size) return false;
            for (i2 of a2.entries())
              if (!b2.has(i2[0])) return false;
            for (i2 of a2.entries())
              if (!equal(i2[1], b2.get(i2[0]))) return false;
            return true;
          }
          if (a2 instanceof Set && b2 instanceof Set) {
            if (a2.size !== b2.size) return false;
            for (i2 of a2.entries())
              if (!b2.has(i2[0])) return false;
            return true;
          }
          if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
            length2 = a2.length;
            if (length2 != b2.length) return false;
            for (i2 = length2; i2-- !== 0; )
              if (a2[i2] !== b2[i2]) return false;
            return true;
          }
          if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
          if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
          if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
          keys = Object.keys(a2);
          length2 = keys.length;
          if (length2 !== Object.keys(b2).length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
          for (i2 = length2; i2-- !== 0; ) {
            var key = keys[i2];
            if (!equal(a2[key], b2[key])) return false;
          }
          return true;
        }
        return a2 !== a2 && b2 !== b2;
      };
    }
  });

  // wordpress-external:@wordpress/i18n
  var require_i18n = __commonJS({
    "wordpress-external:@wordpress/i18n"(exports, module) {
      module.exports = window.wp.i18n;
    }
  });

  // wordpress-external:@wordpress/primitives
  var require_primitives = __commonJS({
    "wordpress-external:@wordpress/primitives"(exports, module) {
      module.exports = window.wp.primitives;
    }
  });

  // wordpress-external:@wordpress/rich-text
  var require_rich_text = __commonJS({
    "wordpress-external:@wordpress/rich-text"(exports, module) {
      module.exports = window.wp.richText;
    }
  });

  // wordpress-external:@wordpress/block-serialization-default-parser
  var require_block_serialization_default_parser = __commonJS({
    "wordpress-external:@wordpress/block-serialization-default-parser"(exports, module) {
      module.exports = window.wp.blockSerializationDefaultParser;
    }
  });

  // wordpress-external:@wordpress/a11y
  var require_a11y = __commonJS({
    "wordpress-external:@wordpress/a11y"(exports, module) {
      module.exports = window.wp.a11y;
    }
  });

  // wordpress-external:@wordpress/notices
  var require_notices = __commonJS({
    "wordpress-external:@wordpress/notices"(exports, module) {
      module.exports = window.wp.notices;
    }
  });

  // wordpress-external:@wordpress/preferences
  var require_preferences = __commonJS({
    "wordpress-external:@wordpress/preferences"(exports, module) {
      module.exports = window.wp.preferences;
    }
  });

  // node_modules/remove-accents/index.js
  var require_remove_accents = __commonJS({
    "node_modules/remove-accents/index.js"(exports, module) {
      var characterMap = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\u1EA4": "A",
        "\u1EAE": "A",
        "\u1EB2": "A",
        "\u1EB4": "A",
        "\u1EB6": "A",
        "\xC6": "AE",
        "\u1EA6": "A",
        "\u1EB0": "A",
        "\u0202": "A",
        "\u1EA2": "A",
        "\u1EA0": "A",
        "\u1EA8": "A",
        "\u1EAA": "A",
        "\u1EAC": "A",
        "\xC7": "C",
        "\u1E08": "C",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\u1EBE": "E",
        "\u1E16": "E",
        "\u1EC0": "E",
        "\u1E14": "E",
        "\u1E1C": "E",
        "\u0206": "E",
        "\u1EBA": "E",
        "\u1EBC": "E",
        "\u1EB8": "E",
        "\u1EC2": "E",
        "\u1EC4": "E",
        "\u1EC6": "E",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\u1E2E": "I",
        "\u020A": "I",
        "\u1EC8": "I",
        "\u1ECA": "I",
        "\xD0": "D",
        "\xD1": "N",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\u1ED0": "O",
        "\u1E4C": "O",
        "\u1E52": "O",
        "\u020E": "O",
        "\u1ECE": "O",
        "\u1ECC": "O",
        "\u1ED4": "O",
        "\u1ED6": "O",
        "\u1ED8": "O",
        "\u1EDC": "O",
        "\u1EDE": "O",
        "\u1EE0": "O",
        "\u1EDA": "O",
        "\u1EE2": "O",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\u1EE6": "U",
        "\u1EE4": "U",
        "\u1EEC": "U",
        "\u1EEE": "U",
        "\u1EF0": "U",
        "\xDD": "Y",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\u1EA5": "a",
        "\u1EAF": "a",
        "\u1EB3": "a",
        "\u1EB5": "a",
        "\u1EB7": "a",
        "\xE6": "ae",
        "\u1EA7": "a",
        "\u1EB1": "a",
        "\u0203": "a",
        "\u1EA3": "a",
        "\u1EA1": "a",
        "\u1EA9": "a",
        "\u1EAB": "a",
        "\u1EAD": "a",
        "\xE7": "c",
        "\u1E09": "c",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\u1EBF": "e",
        "\u1E17": "e",
        "\u1EC1": "e",
        "\u1E15": "e",
        "\u1E1D": "e",
        "\u0207": "e",
        "\u1EBB": "e",
        "\u1EBD": "e",
        "\u1EB9": "e",
        "\u1EC3": "e",
        "\u1EC5": "e",
        "\u1EC7": "e",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\u1E2F": "i",
        "\u020B": "i",
        "\u1EC9": "i",
        "\u1ECB": "i",
        "\xF0": "d",
        "\xF1": "n",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\u1ED1": "o",
        "\u1E4D": "o",
        "\u1E53": "o",
        "\u020F": "o",
        "\u1ECF": "o",
        "\u1ECD": "o",
        "\u1ED5": "o",
        "\u1ED7": "o",
        "\u1ED9": "o",
        "\u1EDD": "o",
        "\u1EDF": "o",
        "\u1EE1": "o",
        "\u1EDB": "o",
        "\u1EE3": "o",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\u1EE7": "u",
        "\u1EE5": "u",
        "\u1EED": "u",
        "\u1EEF": "u",
        "\u1EF1": "u",
        "\xFD": "y",
        "\xFF": "y",
        "\u0100": "A",
        "\u0101": "a",
        "\u0102": "A",
        "\u0103": "a",
        "\u0104": "A",
        "\u0105": "a",
        "\u0106": "C",
        "\u0107": "c",
        "\u0108": "C",
        "\u0109": "c",
        "\u010A": "C",
        "\u010B": "c",
        "\u010C": "C",
        "\u010D": "c",
        "C\u0306": "C",
        "c\u0306": "c",
        "\u010E": "D",
        "\u010F": "d",
        "\u0110": "D",
        "\u0111": "d",
        "\u0112": "E",
        "\u0113": "e",
        "\u0114": "E",
        "\u0115": "e",
        "\u0116": "E",
        "\u0117": "e",
        "\u0118": "E",
        "\u0119": "e",
        "\u011A": "E",
        "\u011B": "e",
        "\u011C": "G",
        "\u01F4": "G",
        "\u011D": "g",
        "\u01F5": "g",
        "\u011E": "G",
        "\u011F": "g",
        "\u0120": "G",
        "\u0121": "g",
        "\u0122": "G",
        "\u0123": "g",
        "\u0124": "H",
        "\u0125": "h",
        "\u0126": "H",
        "\u0127": "h",
        "\u1E2A": "H",
        "\u1E2B": "h",
        "\u0128": "I",
        "\u0129": "i",
        "\u012A": "I",
        "\u012B": "i",
        "\u012C": "I",
        "\u012D": "i",
        "\u012E": "I",
        "\u012F": "i",
        "\u0130": "I",
        "\u0131": "i",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u1E30": "K",
        "\u1E31": "k",
        "K\u0306": "K",
        "k\u0306": "k",
        "\u0139": "L",
        "\u013A": "l",
        "\u013B": "L",
        "\u013C": "l",
        "\u013D": "L",
        "\u013E": "l",
        "\u013F": "L",
        "\u0140": "l",
        "\u0141": "l",
        "\u0142": "l",
        "\u1E3E": "M",
        "\u1E3F": "m",
        "M\u0306": "M",
        "m\u0306": "m",
        "\u0143": "N",
        "\u0144": "n",
        "\u0145": "N",
        "\u0146": "n",
        "\u0147": "N",
        "\u0148": "n",
        "\u0149": "n",
        "N\u0306": "N",
        "n\u0306": "n",
        "\u014C": "O",
        "\u014D": "o",
        "\u014E": "O",
        "\u014F": "o",
        "\u0150": "O",
        "\u0151": "o",
        "\u0152": "OE",
        "\u0153": "oe",
        "P\u0306": "P",
        "p\u0306": "p",
        "\u0154": "R",
        "\u0155": "r",
        "\u0156": "R",
        "\u0157": "r",
        "\u0158": "R",
        "\u0159": "r",
        "R\u0306": "R",
        "r\u0306": "r",
        "\u0212": "R",
        "\u0213": "r",
        "\u015A": "S",
        "\u015B": "s",
        "\u015C": "S",
        "\u015D": "s",
        "\u015E": "S",
        "\u0218": "S",
        "\u0219": "s",
        "\u015F": "s",
        "\u0160": "S",
        "\u0161": "s",
        "\u0162": "T",
        "\u0163": "t",
        "\u021B": "t",
        "\u021A": "T",
        "\u0164": "T",
        "\u0165": "t",
        "\u0166": "T",
        "\u0167": "t",
        "T\u0306": "T",
        "t\u0306": "t",
        "\u0168": "U",
        "\u0169": "u",
        "\u016A": "U",
        "\u016B": "u",
        "\u016C": "U",
        "\u016D": "u",
        "\u016E": "U",
        "\u016F": "u",
        "\u0170": "U",
        "\u0171": "u",
        "\u0172": "U",
        "\u0173": "u",
        "\u0216": "U",
        "\u0217": "u",
        "V\u0306": "V",
        "v\u0306": "v",
        "\u0174": "W",
        "\u0175": "w",
        "\u1E82": "W",
        "\u1E83": "w",
        "X\u0306": "X",
        "x\u0306": "x",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "Y\u0306": "Y",
        "y\u0306": "y",
        "\u0179": "Z",
        "\u017A": "z",
        "\u017B": "Z",
        "\u017C": "z",
        "\u017D": "Z",
        "\u017E": "z",
        "\u017F": "s",
        "\u0192": "f",
        "\u01A0": "O",
        "\u01A1": "o",
        "\u01AF": "U",
        "\u01B0": "u",
        "\u01CD": "A",
        "\u01CE": "a",
        "\u01CF": "I",
        "\u01D0": "i",
        "\u01D1": "O",
        "\u01D2": "o",
        "\u01D3": "U",
        "\u01D4": "u",
        "\u01D5": "U",
        "\u01D6": "u",
        "\u01D7": "U",
        "\u01D8": "u",
        "\u01D9": "U",
        "\u01DA": "u",
        "\u01DB": "U",
        "\u01DC": "u",
        "\u1EE8": "U",
        "\u1EE9": "u",
        "\u1E78": "U",
        "\u1E79": "u",
        "\u01FA": "A",
        "\u01FB": "a",
        "\u01FC": "AE",
        "\u01FD": "ae",
        "\u01FE": "O",
        "\u01FF": "o",
        "\xDE": "TH",
        "\xFE": "th",
        "\u1E54": "P",
        "\u1E55": "p",
        "\u1E64": "S",
        "\u1E65": "s",
        "X\u0301": "X",
        "x\u0301": "x",
        "\u0403": "\u0413",
        "\u0453": "\u0433",
        "\u040C": "\u041A",
        "\u045C": "\u043A",
        "A\u030B": "A",
        "a\u030B": "a",
        "E\u030B": "E",
        "e\u030B": "e",
        "I\u030B": "I",
        "i\u030B": "i",
        "\u01F8": "N",
        "\u01F9": "n",
        "\u1ED2": "O",
        "\u1ED3": "o",
        "\u1E50": "O",
        "\u1E51": "o",
        "\u1EEA": "U",
        "\u1EEB": "u",
        "\u1E80": "W",
        "\u1E81": "w",
        "\u1EF2": "Y",
        "\u1EF3": "y",
        "\u0200": "A",
        "\u0201": "a",
        "\u0204": "E",
        "\u0205": "e",
        "\u0208": "I",
        "\u0209": "i",
        "\u020C": "O",
        "\u020D": "o",
        "\u0210": "R",
        "\u0211": "r",
        "\u0214": "U",
        "\u0215": "u",
        "B\u030C": "B",
        "b\u030C": "b",
        "\u010C\u0323": "C",
        "\u010D\u0323": "c",
        "\xCA\u030C": "E",
        "\xEA\u030C": "e",
        "F\u030C": "F",
        "f\u030C": "f",
        "\u01E6": "G",
        "\u01E7": "g",
        "\u021E": "H",
        "\u021F": "h",
        "J\u030C": "J",
        "\u01F0": "j",
        "\u01E8": "K",
        "\u01E9": "k",
        "M\u030C": "M",
        "m\u030C": "m",
        "P\u030C": "P",
        "p\u030C": "p",
        "Q\u030C": "Q",
        "q\u030C": "q",
        "\u0158\u0329": "R",
        "\u0159\u0329": "r",
        "\u1E66": "S",
        "\u1E67": "s",
        "V\u030C": "V",
        "v\u030C": "v",
        "W\u030C": "W",
        "w\u030C": "w",
        "X\u030C": "X",
        "x\u030C": "x",
        "Y\u030C": "Y",
        "y\u030C": "y",
        "A\u0327": "A",
        "a\u0327": "a",
        "B\u0327": "B",
        "b\u0327": "b",
        "\u1E10": "D",
        "\u1E11": "d",
        "\u0228": "E",
        "\u0229": "e",
        "\u0190\u0327": "E",
        "\u025B\u0327": "e",
        "\u1E28": "H",
        "\u1E29": "h",
        "I\u0327": "I",
        "i\u0327": "i",
        "\u0197\u0327": "I",
        "\u0268\u0327": "i",
        "M\u0327": "M",
        "m\u0327": "m",
        "O\u0327": "O",
        "o\u0327": "o",
        "Q\u0327": "Q",
        "q\u0327": "q",
        "U\u0327": "U",
        "u\u0327": "u",
        "X\u0327": "X",
        "x\u0327": "x",
        "Z\u0327": "Z",
        "z\u0327": "z",
        "\u0439": "\u0438",
        "\u0419": "\u0418",
        "\u0451": "\u0435",
        "\u0401": "\u0415"
      };
      var chars = Object.keys(characterMap).join("|");
      var allAccents = new RegExp(chars, "g");
      var firstAccent = new RegExp(chars, "");
      function matcher(match2) {
        return characterMap[match2];
      }
      var removeAccents2 = function(string) {
        return string.replace(allAccents, matcher);
      };
      var hasAccents = function(string) {
        return !!string.match(firstAccent);
      };
      module.exports = removeAccents2;
      module.exports.has = hasAccents;
      module.exports.remove = removeAccents2;
    }
  });

  // wordpress-external:@wordpress/api-fetch
  var require_api_fetch = __commonJS({
    "wordpress-external:@wordpress/api-fetch"(exports, module) {
      module.exports = window.wp.apiFetch;
    }
  });

  // wordpress-external:@wordpress/html-entities
  var require_html_entities = __commonJS({
    "wordpress-external:@wordpress/html-entities"(exports, module) {
      module.exports = window.wp.htmlEntities;
    }
  });

  // wordpress-external:@wordpress/style-engine
  var require_style_engine = __commonJS({
    "wordpress-external:@wordpress/style-engine"(exports, module) {
      module.exports = window.wp.styleEngine;
    }
  });

  // wordpress-external:@wordpress/keycodes
  var require_keycodes = __commonJS({
    "wordpress-external:@wordpress/keycodes"(exports, module) {
      module.exports = window.wp.keycodes;
    }
  });

  // wordpress-external:@wordpress/dom
  var require_dom = __commonJS({
    "wordpress-external:@wordpress/dom"(exports, module) {
      module.exports = window.wp.dom;
    }
  });

  // node_modules/diff/lib/diff/base.js
  var require_base = __commonJS({
    "node_modules/diff/lib/diff/base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = Diff;
      function Diff() {
      }
      Diff.prototype = {
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        diff: function diff(oldString, newString) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var callback = options.callback;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          this.options = options;
          var self = this;
          function done(value) {
            if (callback) {
              setTimeout(function() {
                callback(void 0, value);
              }, 0);
              return true;
            } else {
              return value;
            }
          }
          oldString = this.castInput(oldString);
          newString = this.castInput(newString);
          oldString = this.removeEmpty(this.tokenize(oldString));
          newString = this.removeEmpty(this.tokenize(newString));
          var newLen = newString.length, oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{
            newPos: -1,
            components: []
          }];
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            return done([{
              value: this.join(newString),
              count: newString.length
            }]);
          }
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = (
                /*istanbul ignore start*/
                void 0
              );
              var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath) {
                bestPath[diagonalPath - 1] = void 0;
              }
              var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = void 0;
                continue;
              }
              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self.pushComponent(basePath.components, void 0, true);
              } else {
                basePath = addPath;
                basePath.newPos++;
                self.pushComponent(basePath.components, true, void 0);
              }
              _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
              if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
                return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
              } else {
                bestPath[diagonalPath] = basePath;
              }
            }
            editLength++;
          }
          if (callback) {
            (function exec() {
              setTimeout(function() {
                if (editLength > maxEditLength) {
                  return callback();
                }
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            })();
          } else {
            while (editLength <= maxEditLength) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        },
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        pushComponent: function pushComponent(components, added, removed) {
          var last3 = components[components.length - 1];
          if (last3 && last3.added === added && last3.removed === removed) {
            components[components.length - 1] = {
              count: last3.count + 1,
              added,
              removed
            };
          } else {
            components.push({
              count: 1,
              added,
              removed
            });
          }
        },
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
          if (commonCount) {
            basePath.components.push({
              count: commonCount
            });
          }
          basePath.newPos = newPos;
          return oldPos;
        },
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        equals: function equals(left, right) {
          if (this.options.comparator) {
            return this.options.comparator(left, right);
          } else {
            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
          }
        },
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        removeEmpty: function removeEmpty(array) {
          var ret = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            if (array[i2]) {
              ret.push(array[i2]);
            }
          }
          return ret;
        },
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        castInput: function castInput(value) {
          return value;
        },
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        tokenize: function tokenize3(value) {
          return value.split("");
        },
        /*istanbul ignore start*/
        /*istanbul ignore end*/
        join: function join(chars) {
          return chars.join("");
        }
      };
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value = newString.slice(newPos, newPos + component.count);
              value = value.map(function(value2, i2) {
                var oldValue = oldString[oldPos + i2];
                return oldValue.length > value2.length ? oldValue : value2;
              });
              component.value = diff.join(value);
            } else {
              component.value = diff.join(newString.slice(newPos, newPos + component.count));
            }
            newPos += component.count;
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
        var lastComponent = components[componentLen - 1];
        if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
          components[componentLen - 2].value += lastComponent.value;
          components.pop();
        }
        return components;
      }
      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }
    }
  });

  // node_modules/diff/lib/diff/character.js
  var require_character = __commonJS({
    "node_modules/diff/lib/diff/character.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.diffChars = diffChars2;
      exports.characterDiff = void 0;
      var _base = _interopRequireDefault(require_base());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var characterDiff = new /*istanbul ignore start*/
      _base.default();
      exports.characterDiff = characterDiff;
      function diffChars2(oldStr, newStr, options) {
        return characterDiff.diff(oldStr, newStr, options);
      }
    }
  });

  // vendor-external:react
  var require_react = __commonJS({
    "vendor-external:react"(exports, module) {
      module.exports = window.React;
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment88 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode2 = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment88;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode2;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i2 = 0; i2 < 10; i2++) {
            test2["_" + String.fromCharCode(i2)] = i2;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
            return test2[n2];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from2;
        var to2 = toObject(target);
        var symbols;
        for (var s2 = 1; s2 < arguments.length; s2++) {
          from2 = Object(arguments[s2]);
          for (var key in from2) {
            if (hasOwnProperty2.call(from2, key)) {
              to2[key] = from2[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              if (propIsEnumerable.call(from2, symbols[i2])) {
                to2[symbols[i2]] = from2[symbols[i2]];
              }
            }
          }
        }
        return to2;
      };
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module) {
      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x2) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                loggedTypeFailures[error.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is();
      var assign3 = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x2) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is2(x2, y2) {
          if (x2 === y2) {
            return x2 !== 0 || 1 / x2 === 1 / y2;
          } else {
            return x2 !== x2 && y2 !== y2;
          }
        }
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey2 = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey2] && // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey2] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i2 = 0; i2 < propValue.length; i2++) {
              var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i2 = 0; i2 < expectedValues.length; i2++) {
              if (is2(propValue, expectedValues[i2])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker = arrayOfTypeCheckers[i2];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
              var checker2 = arrayOfTypeCheckers[i3];
              var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function invalidValidatorError(componentName, location, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign3({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/autosize/dist/autosize.js
  var require_autosize = __commonJS({
    "node_modules/autosize/dist/autosize.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define(["module", "exports"], factory);
        } else if (typeof exports !== "undefined") {
          factory(module, exports);
        } else {
          var mod = {
            exports: {}
          };
          factory(mod, mod.exports);
          global2.autosize = mod.exports;
        }
      })(exports, function(module2, exports2) {
        "use strict";
        var map = typeof Map === "function" ? /* @__PURE__ */ new Map() : /* @__PURE__ */ (function() {
          var keys = [];
          var values = [];
          return {
            has: function has(key) {
              return keys.indexOf(key) > -1;
            },
            get: function get(key) {
              return values[keys.indexOf(key)];
            },
            set: function set(key, value) {
              if (keys.indexOf(key) === -1) {
                keys.push(key);
                values.push(value);
              }
            },
            delete: function _delete(key) {
              var index = keys.indexOf(key);
              if (index > -1) {
                keys.splice(index, 1);
                values.splice(index, 1);
              }
            }
          };
        })();
        var createEvent = function createEvent2(name) {
          return new Event(name, { bubbles: true });
        };
        try {
          new Event("test");
        } catch (e2) {
          createEvent = function createEvent2(name) {
            var evt = document.createEvent("Event");
            evt.initEvent(name, true, false);
            return evt;
          };
        }
        function assign3(ta) {
          if (!ta || !ta.nodeName || ta.nodeName !== "TEXTAREA" || map.has(ta)) return;
          var heightOffset = null;
          var clientWidth = null;
          var cachedHeight = null;
          function init() {
            var style = window.getComputedStyle(ta, null);
            if (style.resize === "vertical") {
              ta.style.resize = "none";
            } else if (style.resize === "both") {
              ta.style.resize = "horizontal";
            }
            if (style.boxSizing === "content-box") {
              heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
            } else {
              heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
            }
            if (isNaN(heightOffset)) {
              heightOffset = 0;
            }
            update4();
          }
          function changeOverflow(value) {
            {
              var width = ta.style.width;
              ta.style.width = "0px";
              ta.offsetWidth;
              ta.style.width = width;
            }
            ta.style.overflowY = value;
          }
          function getParentOverflows(el) {
            var arr = [];
            while (el && el.parentNode && el.parentNode instanceof Element) {
              if (el.parentNode.scrollTop) {
                arr.push({
                  node: el.parentNode,
                  scrollTop: el.parentNode.scrollTop
                });
              }
              el = el.parentNode;
            }
            return arr;
          }
          function resize() {
            if (ta.scrollHeight === 0) {
              return;
            }
            var overflows = getParentOverflows(ta);
            var docTop = document.documentElement && document.documentElement.scrollTop;
            ta.style.height = "";
            ta.style.height = ta.scrollHeight + heightOffset + "px";
            clientWidth = ta.clientWidth;
            overflows.forEach(function(el) {
              el.node.scrollTop = el.scrollTop;
            });
            if (docTop) {
              document.documentElement.scrollTop = docTop;
            }
          }
          function update4() {
            resize();
            var styleHeight = Math.round(parseFloat(ta.style.height));
            var computed = window.getComputedStyle(ta, null);
            var actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;
            if (actualHeight < styleHeight) {
              if (computed.overflowY === "hidden") {
                changeOverflow("scroll");
                resize();
                actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
              }
            } else {
              if (computed.overflowY !== "hidden") {
                changeOverflow("hidden");
                resize();
                actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
              }
            }
            if (cachedHeight !== actualHeight) {
              cachedHeight = actualHeight;
              var evt = createEvent("autosize:resized");
              try {
                ta.dispatchEvent(evt);
              } catch (err) {
              }
            }
          }
          var pageResize = function pageResize2() {
            if (ta.clientWidth !== clientWidth) {
              update4();
            }
          };
          var destroy2 = function(style) {
            window.removeEventListener("resize", pageResize, false);
            ta.removeEventListener("input", update4, false);
            ta.removeEventListener("keyup", update4, false);
            ta.removeEventListener("autosize:destroy", destroy2, false);
            ta.removeEventListener("autosize:update", update4, false);
            Object.keys(style).forEach(function(key) {
              ta.style[key] = style[key];
            });
            map.delete(ta);
          }.bind(ta, {
            height: ta.style.height,
            resize: ta.style.resize,
            overflowY: ta.style.overflowY,
            overflowX: ta.style.overflowX,
            wordWrap: ta.style.wordWrap
          });
          ta.addEventListener("autosize:destroy", destroy2, false);
          if ("onpropertychange" in ta && "oninput" in ta) {
            ta.addEventListener("keyup", update4, false);
          }
          window.addEventListener("resize", pageResize, false);
          ta.addEventListener("input", update4, false);
          ta.addEventListener("autosize:update", update4, false);
          ta.style.overflowX = "hidden";
          ta.style.wordWrap = "break-word";
          map.set(ta, {
            destroy: destroy2,
            update: update4
          });
          init();
        }
        function destroy(ta) {
          var methods = map.get(ta);
          if (methods) {
            methods.destroy();
          }
        }
        function update3(ta) {
          var methods = map.get(ta);
          if (methods) {
            methods.update();
          }
        }
        var autosize = null;
        if (typeof window === "undefined" || typeof window.getComputedStyle !== "function") {
          autosize = function autosize2(el) {
            return el;
          };
          autosize.destroy = function(el) {
            return el;
          };
          autosize.update = function(el) {
            return el;
          };
        } else {
          autosize = function autosize2(el, options) {
            if (el) {
              Array.prototype.forEach.call(el.length ? el : [el], function(x2) {
                return assign3(x2, options);
              });
            }
            return el;
          };
          autosize.destroy = function(el) {
            if (el) {
              Array.prototype.forEach.call(el.length ? el : [el], destroy);
            }
            return el;
          };
          autosize.update = function(el) {
            if (el) {
              Array.prototype.forEach.call(el.length ? el : [el], update3);
            }
            return el;
          };
        }
        exports2.default = autosize;
        module2.exports = exports2["default"];
      });
    }
  });

  // node_modules/computed-style/dist/computedStyle.commonjs.js
  var require_computedStyle_commonjs = __commonJS({
    "node_modules/computed-style/dist/computedStyle.commonjs.js"(exports, module) {
      var computedStyle = function(el, prop, getComputedStyle) {
        getComputedStyle = window.getComputedStyle;
        return (
          // If we have getComputedStyle
          (getComputedStyle ? (
            // Query it
            // TODO: From CSS-Query notes, we might need (node, null) for FF
            getComputedStyle(el)
          ) : (
            // Otherwise, we are in IE and use currentStyle
            el.currentStyle
          ))[
            // Switch to camelCase for CSSOM
            // DEV: Grabbed from jQuery
            // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
            // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
            prop.replace(/-(\w)/gi, function(word, letter) {
              return letter.toUpperCase();
            })
          ]
        );
      };
      module.exports = computedStyle;
    }
  });

  // node_modules/line-height/lib/line-height.js
  var require_line_height = __commonJS({
    "node_modules/line-height/lib/line-height.js"(exports, module) {
      var computedStyle = require_computedStyle_commonjs();
      function lineHeight(node2) {
        var lnHeightStr = computedStyle(node2, "line-height");
        var lnHeight = parseFloat(lnHeightStr, 10);
        if (lnHeightStr === lnHeight + "") {
          var _lnHeightStyle = node2.style.lineHeight;
          node2.style.lineHeight = lnHeightStr + "em";
          lnHeightStr = computedStyle(node2, "line-height");
          lnHeight = parseFloat(lnHeightStr, 10);
          if (_lnHeightStyle) {
            node2.style.lineHeight = _lnHeightStyle;
          } else {
            delete node2.style.lineHeight;
          }
        }
        if (lnHeightStr.indexOf("pt") !== -1) {
          lnHeight *= 4;
          lnHeight /= 3;
        } else if (lnHeightStr.indexOf("mm") !== -1) {
          lnHeight *= 96;
          lnHeight /= 25.4;
        } else if (lnHeightStr.indexOf("cm") !== -1) {
          lnHeight *= 96;
          lnHeight /= 2.54;
        } else if (lnHeightStr.indexOf("in") !== -1) {
          lnHeight *= 96;
        } else if (lnHeightStr.indexOf("pc") !== -1) {
          lnHeight *= 16;
        }
        lnHeight = Math.round(lnHeight);
        if (lnHeightStr === "normal") {
          var nodeName = node2.nodeName;
          var _node = document.createElement(nodeName);
          _node.innerHTML = "&nbsp;";
          if (nodeName.toUpperCase() === "TEXTAREA") {
            _node.setAttribute("rows", "1");
          }
          var fontSizeStr = computedStyle(node2, "font-size");
          _node.style.fontSize = fontSizeStr;
          _node.style.padding = "0px";
          _node.style.border = "0px";
          var body = document.body;
          body.appendChild(_node);
          var height = _node.offsetHeight;
          lnHeight = height;
          body.removeChild(_node);
        }
        return lnHeight;
      }
      module.exports = lineHeight;
    }
  });

  // node_modules/react-autosize-textarea/lib/TextareaAutosize.js
  var require_TextareaAutosize = __commonJS({
    "node_modules/react-autosize-textarea/lib/TextareaAutosize.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || (function() {
        var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p2 in b2) if (b2.hasOwnProperty(p2)) d2[p2] = b2[p2];
        };
        return function(d2, b2) {
          extendStatics2(d2, b2);
          function __189() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__189.prototype = b2.prototype, new __189());
        };
      })();
      var __assign2 = exports && exports.__assign || Object.assign || function(t3) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
            t3[p2] = s2[p2];
        }
        return t3;
      };
      var __rest = exports && exports.__rest || function(s2, e2) {
        var t3 = {};
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
          t3[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function") {
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) if (e2.indexOf(p2[i2]) < 0)
            t3[p2[i2]] = s2[p2[i2]];
        }
        return t3;
      };
      exports.__esModule = true;
      var React4 = require_react();
      var PropTypes = require_prop_types();
      var autosize = require_autosize();
      var _getLineHeight = require_line_height();
      var getLineHeight = _getLineHeight;
      var RESIZED = "autosize:resized";
      var TextareaAutosizeClass = (
        /** @class */
        (function(_super) {
          __extends2(TextareaAutosizeClass2, _super);
          function TextareaAutosizeClass2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
              lineHeight: null
            };
            _this.textarea = null;
            _this.onResize = function(e2) {
              if (_this.props.onResize) {
                _this.props.onResize(e2);
              }
            };
            _this.updateLineHeight = function() {
              if (_this.textarea) {
                _this.setState({
                  lineHeight: getLineHeight(_this.textarea)
                });
              }
            };
            _this.onChange = function(e2) {
              var onChange = _this.props.onChange;
              _this.currentValue = e2.currentTarget.value;
              onChange && onChange(e2);
            };
            return _this;
          }
          TextareaAutosizeClass2.prototype.componentDidMount = function() {
            var _this = this;
            var _a = this.props, maxRows = _a.maxRows, async = _a.async;
            if (typeof maxRows === "number") {
              this.updateLineHeight();
            }
            if (typeof maxRows === "number" || async) {
              setTimeout(function() {
                return _this.textarea && autosize(_this.textarea);
              });
            } else {
              this.textarea && autosize(this.textarea);
            }
            if (this.textarea) {
              this.textarea.addEventListener(RESIZED, this.onResize);
            }
          };
          TextareaAutosizeClass2.prototype.componentWillUnmount = function() {
            if (this.textarea) {
              this.textarea.removeEventListener(RESIZED, this.onResize);
              autosize.destroy(this.textarea);
            }
          };
          TextareaAutosizeClass2.prototype.render = function() {
            var _this = this;
            var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
            var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
            return React4.createElement("textarea", __assign2({}, props, { onChange: this.onChange, style: maxHeight ? __assign2({}, style, { maxHeight }) : style, ref: function(element) {
              _this.textarea = element;
              if (typeof _this.props.innerRef === "function") {
                _this.props.innerRef(element);
              } else if (_this.props.innerRef) {
                _this.props.innerRef.current = element;
              }
            } }), children);
          };
          TextareaAutosizeClass2.prototype.componentDidUpdate = function() {
            this.textarea && autosize.update(this.textarea);
          };
          TextareaAutosizeClass2.defaultProps = {
            rows: 1,
            async: false
          };
          TextareaAutosizeClass2.propTypes = {
            rows: PropTypes.number,
            maxRows: PropTypes.number,
            onResize: PropTypes.func,
            innerRef: PropTypes.any,
            async: PropTypes.bool
          };
          return TextareaAutosizeClass2;
        })(React4.Component)
      );
      exports.TextareaAutosize = React4.forwardRef(function(props, ref) {
        return React4.createElement(TextareaAutosizeClass, __assign2({}, props, { innerRef: ref }));
      });
    }
  });

  // node_modules/react-autosize-textarea/lib/index.js
  var require_lib = __commonJS({
    "node_modules/react-autosize-textarea/lib/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var TextareaAutosize_1 = require_TextareaAutosize();
      exports["default"] = TextareaAutosize_1.TextareaAutosize;
    }
  });

  // wordpress-external:@wordpress/warning
  var require_warning = __commonJS({
    "wordpress-external:@wordpress/warning"(exports, module) {
      module.exports = window.wp.warning;
    }
  });

  // vendor-external:react-dom
  var require_react_dom = __commonJS({
    "vendor-external:react-dom"(exports, module) {
      module.exports = window.ReactDOM;
    }
  });

  // wordpress-external:@wordpress/blob
  var require_blob = __commonJS({
    "wordpress-external:@wordpress/blob"(exports, module) {
      module.exports = window.wp.blob;
    }
  });

  // wordpress-external:@wordpress/keyboard-shortcuts
  var require_keyboard_shortcuts = __commonJS({
    "wordpress-external:@wordpress/keyboard-shortcuts"(exports, module) {
      module.exports = window.wp.keyboardShortcuts;
    }
  });

  // (disabled):node_modules/postcss/node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "(disabled):node_modules/postcss/node_modules/source-map-js/source-map.js"() {
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // (disabled):node_modules/url/url.js
  var require_url2 = __commonJS({
    "(disabled):node_modules/url/url.js"() {
    }
  });

  // node_modules/nanoid/non-secure/index.cjs
  var require_non_secure = __commonJS({
    "node_modules/nanoid/non-secure/index.cjs"(exports, module) {
      var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      var customAlphabet = (alphabet, defaultSize = 21) => {
        return (size = defaultSize) => {
          let id = "";
          let i2 = size | 0;
          while (i2--) {
            id += alphabet[Math.random() * alphabet.length | 0];
          }
          return id;
        };
      };
      var nanoid = (size = 21) => {
        let id = "";
        let i2 = size | 0;
        while (i2--) {
          id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
      };
      module.exports = { nanoid, customAlphabet };
    }
  });

  // (disabled):node_modules/postcss/lib/terminal-highlight
  var require_terminal_highlight = __commonJS({
    "(disabled):node_modules/postcss/lib/terminal-highlight"() {
    }
  });

  // node_modules/picocolors/picocolors.browser.js
  var require_picocolors_browser = __commonJS({
    "node_modules/picocolors/picocolors.browser.js"(exports, module) {
      var x2 = String;
      var create6 = function() {
        return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2, blackBright: x2, redBright: x2, greenBright: x2, yellowBright: x2, blueBright: x2, magentaBright: x2, cyanBright: x2, whiteBright: x2, bgBlackBright: x2, bgRedBright: x2, bgGreenBright: x2, bgYellowBright: x2, bgBlueBright: x2, bgMagentaBright: x2, bgCyanBright: x2, bgWhiteBright: x2 };
      };
      module.exports = create6();
      module.exports.createColors = create6;
    }
  });

  // node_modules/postcss/lib/css-syntax-error.js
  var require_css_syntax_error = __commonJS({
    "node_modules/postcss/lib/css-syntax-error.js"(exports, module) {
      "use strict";
      var pico = require_picocolors_browser();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError2 = class _CssSyntaxError extends Error {
        constructor(message, line2, column2, source, file, plugin) {
          super(message);
          this.name = "CssSyntaxError";
          this.reason = message;
          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin) {
            this.plugin = plugin;
          }
          if (typeof line2 !== "undefined" && typeof column2 !== "undefined") {
            if (typeof line2 === "number") {
              this.line = line2;
              this.column = column2;
            } else {
              this.line = line2.line;
              this.column = line2.column;
              this.endLine = column2.line;
              this.endColumn = column2.column;
            }
          }
          this.setMessage();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _CssSyntaxError);
          }
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "";
          this.message += this.file ? this.file : "<css input>";
          if (typeof this.line !== "undefined") {
            this.message += ":" + this.line + ":" + this.column;
          }
          this.message += ": " + this.reason;
        }
        showSourceCode(color) {
          if (!this.source) return "";
          let css = this.source;
          if (color == null) color = pico.isColorSupported;
          if (terminalHighlight) {
            if (color) css = terminalHighlight(css);
          }
          let lines = css.split(/\r?\n/);
          let start2 = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);
          let maxWidth = String(end).length;
          let mark, aside;
          if (color) {
            let { bold, gray, red } = pico.createColors(true);
            mark = (text) => bold(red(text));
            aside = (text) => gray(text);
          } else {
            mark = aside = (str) => str;
          }
          return lines.slice(start2, end).map((line2, index) => {
            let number = start2 + 1 + index;
            let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
            if (number === this.line) {
              let spacing = aside(gutter.replace(/\d/g, " ")) + line2.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + line2 + "\n " + spacing + mark("^");
            }
            return " " + aside(gutter) + line2;
          }).join("\n");
        }
        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = "\n\n" + code + "\n";
          }
          return this.name + ": " + this.message + code;
        }
      };
      module.exports = CssSyntaxError2;
      CssSyntaxError2.default = CssSyntaxError2;
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/postcss/lib/previous-map.js
  var require_previous_map = __commonJS({
    "node_modules/postcss/lib/previous-map.js"(exports, module) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { existsSync, readFileSync } = require_fs();
      var { dirname, join } = require_path();
      function fromBase64(str) {
        if (Buffer) {
          return Buffer.from(str, "base64").toString();
        } else {
          return window.atob(str);
        }
      }
      var PreviousMap = class {
        constructor(css, opts) {
          if (opts.map === false) return;
          this.loadAnnotation(css);
          this.inline = this.startWith(this.annotation, "data:");
          let prev2 = opts.map ? opts.map.prev : void 0;
          let text = this.loadMap(opts.from, prev2);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile) this.root = dirname(this.mapFile);
          if (text) this.text = text;
        }
        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }
        decodeInline(text) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;
          if (charsetUri.test(text) || uri.test(text)) {
            return decodeURIComponent(text.substr(RegExp.lastMatch.length));
          }
          if (baseCharsetUri.test(text) || baseUri.test(text)) {
            return fromBase64(text.substr(RegExp.lastMatch.length));
          }
          let encoding = text.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + encoding);
        }
        getAnnotationURL(sourceMapString) {
          return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        isMap(map) {
          if (typeof map !== "object") return false;
          return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
        }
        loadAnnotation(css) {
          let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
          if (!comments) return;
          let start2 = css.lastIndexOf(comments.pop());
          let end = css.indexOf("*/", start2);
          if (start2 > -1 && end > -1) {
            this.annotation = this.getAnnotationURL(css.substring(start2, end));
          }
        }
        loadFile(path) {
          this.root = dirname(path);
          if (existsSync(path)) {
            this.mapFile = path;
            return readFileSync(path, "utf-8").toString().trim();
          }
        }
        loadMap(file, prev2) {
          if (prev2 === false) return false;
          if (prev2) {
            if (typeof prev2 === "string") {
              return prev2;
            } else if (typeof prev2 === "function") {
              let prevPath = prev2(file);
              if (prevPath) {
                let map = this.loadFile(prevPath);
                if (!map) {
                  throw new Error(
                    "Unable to load previous source map: " + prevPath.toString()
                  );
                }
                return map;
              }
            } else if (prev2 instanceof SourceMapConsumer) {
              return SourceMapGenerator.fromSourceMap(prev2).toString();
            } else if (prev2 instanceof SourceMapGenerator) {
              return prev2.toString();
            } else if (this.isMap(prev2)) {
              return JSON.stringify(prev2);
            } else {
              throw new Error(
                "Unsupported previous source map format: " + prev2.toString()
              );
            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map = this.annotation;
            if (file) map = join(dirname(file), map);
            return this.loadFile(map);
          }
        }
        startWith(string, start2) {
          if (!string) return false;
          return string.substr(0, start2.length) === start2;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
      };
      module.exports = PreviousMap;
      PreviousMap.default = PreviousMap;
    }
  });

  // node_modules/postcss/lib/input.js
  var require_input = __commonJS({
    "node_modules/postcss/lib/input.js"(exports, module) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { fileURLToPath, pathToFileURL } = require_url2();
      var { isAbsolute, resolve } = require_path();
      var { nanoid } = require_non_secure();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError2 = require_css_syntax_error();
      var PreviousMap = require_previous_map();
      var fromOffsetCache = Symbol("fromOffsetCache");
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(resolve && isAbsolute);
      var Input = class {
        constructor(css, opts = {}) {
          if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }
          this.css = css.toString();
          if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }
          if (opts.from) {
            if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
              this.file = opts.from;
            } else {
              this.file = resolve(opts.from);
            }
          }
          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file) this.file = this.mapResolve(file);
            }
          }
          if (!this.file) {
            this.id = "<input css " + nanoid(6) + ">";
          }
          if (this.map) this.map.file = this.from;
        }
        error(message, line2, column2, opts = {}) {
          let result, endLine, endColumn;
          if (line2 && typeof line2 === "object") {
            let start2 = line2;
            let end = column2;
            if (typeof start2.offset === "number") {
              let pos = this.fromOffset(start2.offset);
              line2 = pos.line;
              column2 = pos.col;
            } else {
              line2 = start2.line;
              column2 = start2.column;
            }
            if (typeof end.offset === "number") {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column2) {
            let pos = this.fromOffset(line2);
            line2 = pos.line;
            column2 = pos.col;
          }
          let origin = this.origin(line2, column2, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError2(
              message,
              origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
              origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
              origin.source,
              origin.file,
              opts.plugin
            );
          } else {
            result = new CssSyntaxError2(
              message,
              endLine === void 0 ? line2 : { column: column2, line: line2 },
              endLine === void 0 ? column2 : { column: endColumn, line: endLine },
              this.css,
              this.file,
              opts.plugin
            );
          }
          result.input = { column: column2, endColumn, endLine, line: line2, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }
          return result;
        }
        fromOffset(offset) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split("\n");
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;
            for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
              lineToIndex[i2] = prevIndex;
              prevIndex += lines[i2].length + 1;
            }
            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];
          let min = 0;
          if (offset >= lastLine) {
            min = lineToIndex.length - 1;
          } else {
            let max = lineToIndex.length - 2;
            let mid;
            while (min < max) {
              mid = min + (max - min >> 1);
              if (offset < lineToIndex[mid]) {
                max = mid - 1;
              } else if (offset >= lineToIndex[mid + 1]) {
                min = mid + 1;
              } else {
                min = mid;
                break;
              }
            }
          }
          return {
            col: offset - lineToIndex[min] + 1,
            line: min + 1
          };
        }
        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
        }
        origin(line2, column2, endLine, endColumn) {
          if (!this.map) return false;
          let consumer = this.map.consumer();
          let from2 = consumer.originalPositionFor({ column: column2, line: line2 });
          if (!from2.source) return false;
          let to2;
          if (typeof endLine === "number") {
            to2 = consumer.originalPositionFor({ column: endColumn, line: endLine });
          }
          let fromUrl;
          if (isAbsolute(from2.source)) {
            fromUrl = pathToFileURL(from2.source);
          } else {
            fromUrl = new URL(
              from2.source,
              this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
            );
          }
          let result = {
            column: from2.column,
            endColumn: to2 && to2.column,
            endLine: to2 && to2.line,
            line: from2.line,
            url: fromUrl.toString()
          };
          if (fromUrl.protocol === "file:") {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }
          let source = consumer.sourceContentFor(from2.source);
          if (source) result.source = source;
          return result;
        }
        toJSON() {
          let json = {};
          for (let name of ["hasBOM", "css", "file", "id"]) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = { ...this.map };
            if (json.map.consumerCache) {
              json.map.consumerCache = void 0;
            }
          }
          return json;
        }
        get from() {
          return this.file || this.id;
        }
      };
      module.exports = Input;
      Input.default = Input;
      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input);
      }
    }
  });

  // node_modules/postcss/lib/map-generator.js
  var require_map_generator = __commonJS({
    "node_modules/postcss/lib/map-generator.js"(exports, module) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { dirname, relative, resolve, sep } = require_path();
      var { pathToFileURL } = require_url2();
      var Input = require_input();
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(dirname && resolve && relative && sep);
      var MapGenerator = class {
        constructor(stringify3, root, opts, cssString) {
          this.stringify = stringify3;
          this.mapOpts = opts.map || {};
          this.root = root;
          this.opts = opts;
          this.css = cssString;
          this.originalCSS = cssString;
          this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
          this.memoizedFileURLs = /* @__PURE__ */ new Map();
          this.memoizedPaths = /* @__PURE__ */ new Map();
          this.memoizedURLs = /* @__PURE__ */ new Map();
        }
        addAnnotation() {
          let content;
          if (this.isInline()) {
            content = "data:application/json;base64," + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === "string") {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === "function") {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + ".map";
          }
          let eol = "\n";
          if (this.css.includes("\r\n")) eol = "\r\n";
          this.css += eol + "/*# sourceMappingURL=" + content + " */";
        }
        applyPrevMaps() {
          for (let prev2 of this.previous()) {
            let from2 = this.toUrl(this.path(prev2.file));
            let root = prev2.root || dirname(prev2.file);
            let map;
            if (this.mapOpts.sourcesContent === false) {
              map = new SourceMapConsumer(prev2.text);
              if (map.sourcesContent) {
                map.sourcesContent = null;
              }
            } else {
              map = prev2.consumer();
            }
            this.map.applySourceMap(map, from2, this.toUrl(this.path(root)));
          }
        }
        clearAnnotation() {
          if (this.mapOpts.annotation === false) return;
          if (this.root) {
            let node2;
            for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
              node2 = this.root.nodes[i2];
              if (node2.type !== "comment") continue;
              if (node2.text.indexOf("# sourceMappingURL=") === 0) {
                this.root.removeChild(i2);
              }
            }
          } else if (this.css) {
            this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
          }
        }
        generate() {
          this.clearAnnotation();
          if (pathAvailable && sourceMapAvailable && this.isMap()) {
            return this.generateMap();
          } else {
            let result = "";
            this.stringify(this.root, (i2) => {
              result += i2;
            });
            return [result];
          }
        }
        generateMap() {
          if (this.root) {
            this.generateString();
          } else if (this.previous().length === 1) {
            let prev2 = this.previous()[0].consumer();
            prev2.file = this.outputFile();
            this.map = SourceMapGenerator.fromSourceMap(prev2, {
              ignoreInvalidMapping: true
            });
          } else {
            this.map = new SourceMapGenerator({
              file: this.outputFile(),
              ignoreInvalidMapping: true
            });
            this.map.addMapping({
              generated: { column: 0, line: 1 },
              original: { column: 0, line: 1 },
              source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
            });
          }
          if (this.isSourcesContent()) this.setSourcesContent();
          if (this.root && this.previous().length > 0) this.applyPrevMaps();
          if (this.isAnnotation()) this.addAnnotation();
          if (this.isInline()) {
            return [this.css];
          } else {
            return [this.css, this.map];
          }
        }
        generateString() {
          this.css = "";
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          let line2 = 1;
          let column2 = 1;
          let noSource = "<no source>";
          let mapping = {
            generated: { column: 0, line: 0 },
            original: { column: 0, line: 0 },
            source: ""
          };
          let lines, last3;
          this.stringify(this.root, (str, node2, type) => {
            this.css += str;
            if (node2 && type !== "end") {
              mapping.generated.line = line2;
              mapping.generated.column = column2 - 1;
              if (node2.source && node2.source.start) {
                mapping.source = this.sourcePath(node2);
                mapping.original.line = node2.source.start.line;
                mapping.original.column = node2.source.start.column - 1;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                this.map.addMapping(mapping);
              }
            }
            lines = str.match(/\n/g);
            if (lines) {
              line2 += lines.length;
              last3 = str.lastIndexOf("\n");
              column2 = str.length - last3;
            } else {
              column2 += str.length;
            }
            if (node2 && type !== "start") {
              let p2 = node2.parent || { raws: {} };
              let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
              if (!childless || node2 !== p2.last || p2.raws.semicolon) {
                if (node2.source && node2.source.end) {
                  mapping.source = this.sourcePath(node2);
                  mapping.original.line = node2.source.end.line;
                  mapping.original.column = node2.source.end.column - 1;
                  mapping.generated.line = line2;
                  mapping.generated.column = column2 - 2;
                  this.map.addMapping(mapping);
                } else {
                  mapping.source = noSource;
                  mapping.original.line = 1;
                  mapping.original.column = 0;
                  mapping.generated.line = line2;
                  mapping.generated.column = column2 - 1;
                  this.map.addMapping(mapping);
                }
              }
            }
          });
        }
        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== "undefined") {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.annotation);
          }
          return true;
        }
        isInline() {
          if (typeof this.mapOpts.inline !== "undefined") {
            return this.mapOpts.inline;
          }
          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== "undefined" && annotation !== true) {
            return false;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.inline);
          }
          return true;
        }
        isMap() {
          if (typeof this.opts.map !== "undefined") {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }
        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== "undefined") {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.withContent());
          }
          return true;
        }
        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          } else if (this.opts.from) {
            return this.path(this.opts.from);
          } else {
            return "to.css";
          }
        }
        path(file) {
          if (this.mapOpts.absolute) return file;
          if (file.charCodeAt(0) === 60) return file;
          if (/^\w+:\/\//.test(file)) return file;
          let cached = this.memoizedPaths.get(file);
          if (cached) return cached;
          let from2 = this.opts.to ? dirname(this.opts.to) : ".";
          if (typeof this.mapOpts.annotation === "string") {
            from2 = dirname(resolve(from2, this.mapOpts.annotation));
          }
          let path = relative(from2, file);
          this.memoizedPaths.set(file, path);
          return path;
        }
        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            if (this.root) {
              this.root.walk((node2) => {
                if (node2.source && node2.source.input.map) {
                  let map = node2.source.input.map;
                  if (!this.previousMaps.includes(map)) {
                    this.previousMaps.push(map);
                  }
                }
              });
            } else {
              let input = new Input(this.originalCSS, this.opts);
              if (input.map) this.previousMaps.push(input.map);
            }
          }
          return this.previousMaps;
        }
        setSourcesContent() {
          let already = {};
          if (this.root) {
            this.root.walk((node2) => {
              if (node2.source) {
                let from2 = node2.source.input.from;
                if (from2 && !already[from2]) {
                  already[from2] = true;
                  let fromUrl = this.usesFileUrls ? this.toFileUrl(from2) : this.toUrl(this.path(from2));
                  this.map.setSourceContent(fromUrl, node2.source.input.css);
                }
              }
            });
          } else if (this.css) {
            let from2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(from2, this.css);
          }
        }
        sourcePath(node2) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.usesFileUrls) {
            return this.toFileUrl(node2.source.input.from);
          } else {
            return this.toUrl(this.path(node2.source.input.from));
          }
        }
        toBase64(str) {
          if (Buffer) {
            return Buffer.from(str).toString("base64");
          } else {
            return window.btoa(unescape(encodeURIComponent(str)));
          }
        }
        toFileUrl(path) {
          let cached = this.memoizedFileURLs.get(path);
          if (cached) return cached;
          if (pathToFileURL) {
            let fileURL = pathToFileURL(path).toString();
            this.memoizedFileURLs.set(path, fileURL);
            return fileURL;
          } else {
            throw new Error(
              "`map.absolute` option is not available in this PostCSS build"
            );
          }
        }
        toUrl(path) {
          let cached = this.memoizedURLs.get(path);
          if (cached) return cached;
          if (sep === "\\") {
            path = path.replace(/\\/g, "/");
          }
          let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
          this.memoizedURLs.set(path, url);
          return url;
        }
      };
      module.exports = MapGenerator;
    }
  });

  // node_modules/postcss/lib/stringifier.js
  var require_stringifier = __commonJS({
    "node_modules/postcss/lib/stringifier.js"(exports, module) {
      "use strict";
      var DEFAULT_RAW = {
        after: "\n",
        beforeClose: "\n",
        beforeComment: "\n",
        beforeDecl: "\n",
        beforeOpen: " ",
        beforeRule: "\n",
        colon: ": ",
        commentLeft: " ",
        commentRight: " ",
        emptyBody: "",
        indent: "    ",
        semicolon: false
      };
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      var Stringifier = class {
        constructor(builder) {
          this.builder = builder;
        }
        atrule(node2, semicolon) {
          let name = "@" + node2.name;
          let params = node2.params ? this.rawValue(node2, "params") : "";
          if (typeof node2.raws.afterName !== "undefined") {
            name += node2.raws.afterName;
          } else if (params) {
            name += " ";
          }
          if (node2.nodes) {
            this.block(node2, name + params);
          } else {
            let end = (node2.raws.between || "") + (semicolon ? ";" : "");
            this.builder(name + params + end, node2);
          }
        }
        beforeAfter(node2, detect) {
          let value;
          if (node2.type === "decl") {
            value = this.raw(node2, null, "beforeDecl");
          } else if (node2.type === "comment") {
            value = this.raw(node2, null, "beforeComment");
          } else if (detect === "before") {
            value = this.raw(node2, null, "beforeRule");
          } else {
            value = this.raw(node2, null, "beforeClose");
          }
          let buf = node2.parent;
          let depth = 0;
          while (buf && buf.type !== "root") {
            depth += 1;
            buf = buf.parent;
          }
          if (value.includes("\n")) {
            let indent = this.raw(node2, null, "indent");
            if (indent.length) {
              for (let step = 0; step < depth; step++) value += indent;
            }
          }
          return value;
        }
        block(node2, start2) {
          let between = this.raw(node2, "between", "beforeOpen");
          this.builder(start2 + between + "{", node2, "start");
          let after;
          if (node2.nodes && node2.nodes.length) {
            this.body(node2);
            after = this.raw(node2, "after");
          } else {
            after = this.raw(node2, "after", "emptyBody");
          }
          if (after) this.builder(after);
          this.builder("}", node2, "end");
        }
        body(node2) {
          let last3 = node2.nodes.length - 1;
          while (last3 > 0) {
            if (node2.nodes[last3].type !== "comment") break;
            last3 -= 1;
          }
          let semicolon = this.raw(node2, "semicolon");
          for (let i2 = 0; i2 < node2.nodes.length; i2++) {
            let child = node2.nodes[i2];
            let before = this.raw(child, "before");
            if (before) this.builder(before);
            this.stringify(child, last3 !== i2 || semicolon);
          }
        }
        comment(node2) {
          let left = this.raw(node2, "left", "commentLeft");
          let right = this.raw(node2, "right", "commentRight");
          this.builder("/*" + left + node2.text + right + "*/", node2);
        }
        decl(node2, semicolon) {
          let between = this.raw(node2, "between", "colon");
          let string = node2.prop + between + this.rawValue(node2, "value");
          if (node2.important) {
            string += node2.raws.important || " !important";
          }
          if (semicolon) string += ";";
          this.builder(string, node2);
        }
        document(node2) {
          this.body(node2);
        }
        raw(node2, own, detect) {
          let value;
          if (!detect) detect = own;
          if (own) {
            value = node2.raws[own];
            if (typeof value !== "undefined") return value;
          }
          let parent = node2.parent;
          if (detect === "before") {
            if (!parent || parent.type === "root" && parent.first === node2) {
              return "";
            }
            if (parent && parent.type === "document") {
              return "";
            }
          }
          if (!parent) return DEFAULT_RAW[detect];
          let root = node2.root();
          if (!root.rawCache) root.rawCache = {};
          if (typeof root.rawCache[detect] !== "undefined") {
            return root.rawCache[detect];
          }
          if (detect === "before" || detect === "after") {
            return this.beforeAfter(node2, detect);
          } else {
            let method = "raw" + capitalize(detect);
            if (this[method]) {
              value = this[method](root, node2);
            } else {
              root.walk((i2) => {
                value = i2.raws[own];
                if (typeof value !== "undefined") return false;
              });
            }
          }
          if (typeof value === "undefined") value = DEFAULT_RAW[detect];
          root.rawCache[detect] = value;
          return value;
        }
        rawBeforeClose(root) {
          let value;
          root.walk((i2) => {
            if (i2.nodes && i2.nodes.length > 0) {
              if (typeof i2.raws.after !== "undefined") {
                value = i2.raws.after;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value) value = value.replace(/\S/g, "");
          return value;
        }
        rawBeforeComment(root, node2) {
          let value;
          root.walkComments((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node2, null, "beforeDecl");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeDecl(root, node2) {
          let value;
          root.walkDecls((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node2, null, "beforeRule");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeOpen(root) {
          let value;
          root.walk((i2) => {
            if (i2.type !== "decl") {
              value = i2.raws.between;
              if (typeof value !== "undefined") return false;
            }
          });
          return value;
        }
        rawBeforeRule(root) {
          let value;
          root.walk((i2) => {
            if (i2.nodes && (i2.parent !== root || root.first !== i2)) {
              if (typeof i2.raws.before !== "undefined") {
                value = i2.raws.before;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value) value = value.replace(/\S/g, "");
          return value;
        }
        rawColon(root) {
          let value;
          root.walkDecls((i2) => {
            if (typeof i2.raws.between !== "undefined") {
              value = i2.raws.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
          return value;
        }
        rawEmptyBody(root) {
          let value;
          root.walk((i2) => {
            if (i2.nodes && i2.nodes.length === 0) {
              value = i2.raws.after;
              if (typeof value !== "undefined") return false;
            }
          });
          return value;
        }
        rawIndent(root) {
          if (root.raws.indent) return root.raws.indent;
          let value;
          root.walk((i2) => {
            let p2 = i2.parent;
            if (p2 && p2 !== root && p2.parent && p2.parent === root) {
              if (typeof i2.raws.before !== "undefined") {
                let parts = i2.raws.before.split("\n");
                value = parts[parts.length - 1];
                value = value.replace(/\S/g, "");
                return false;
              }
            }
          });
          return value;
        }
        rawSemicolon(root) {
          let value;
          root.walk((i2) => {
            if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
              value = i2.raws.semicolon;
              if (typeof value !== "undefined") return false;
            }
          });
          return value;
        }
        rawValue(node2, prop) {
          let value = node2[prop];
          let raw = node2.raws[prop];
          if (raw && raw.value === value) {
            return raw.raw;
          }
          return value;
        }
        root(node2) {
          this.body(node2);
          if (node2.raws.after) this.builder(node2.raws.after);
        }
        rule(node2) {
          this.block(node2, this.rawValue(node2, "selector"));
          if (node2.raws.ownSemicolon) {
            this.builder(node2.raws.ownSemicolon, node2, "end");
          }
        }
        stringify(node2, semicolon) {
          if (!this[node2.type]) {
            throw new Error(
              "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
            );
          }
          this[node2.type](node2, semicolon);
        }
      };
      module.exports = Stringifier;
      Stringifier.default = Stringifier;
    }
  });

  // node_modules/postcss/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/postcss/lib/stringify.js"(exports, module) {
      "use strict";
      var Stringifier = require_stringifier();
      function stringify3(node2, builder) {
        let str = new Stringifier(builder);
        str.stringify(node2);
      }
      module.exports = stringify3;
      stringify3.default = stringify3;
    }
  });

  // node_modules/postcss/lib/warn-once.js
  var require_warn_once = __commonJS({
    "node_modules/postcss/lib/warn-once.js"(exports, module) {
      "use strict";
      var printed = {};
      module.exports = function warnOnce(message) {
        if (printed[message]) return;
        printed[message] = true;
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
      };
    }
  });

  // node_modules/postcss/lib/symbols.js
  var require_symbols = __commonJS({
    "node_modules/postcss/lib/symbols.js"(exports, module) {
      "use strict";
      module.exports.isClean = Symbol("isClean");
      module.exports.my = Symbol("my");
    }
  });

  // node_modules/postcss/lib/node.js
  var require_node = __commonJS({
    "node_modules/postcss/lib/node.js"(exports, module) {
      "use strict";
      var { isClean, my } = require_symbols();
      var CssSyntaxError2 = require_css_syntax_error();
      var Stringifier = require_stringifier();
      var stringify3 = require_stringify();
      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();
        for (let i2 in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
            continue;
          }
          if (i2 === "proxyCache") continue;
          let value = obj[i2];
          let type = typeof value;
          if (i2 === "parent" && type === "object") {
            if (parent) cloned[i2] = parent;
          } else if (i2 === "source") {
            cloned[i2] = value;
          } else if (Array.isArray(value)) {
            cloned[i2] = value.map((j2) => cloneNode(j2, cloned));
          } else {
            if (type === "object" && value !== null) value = cloneNode(value);
            cloned[i2] = value;
          }
        }
        return cloned;
      }
      var Node = class {
        constructor(defaults2 = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;
          for (let name in defaults2) {
            if (name === "nodes") {
              this.nodes = [];
              for (let node2 of defaults2[name]) {
                if (typeof node2.clone === "function") {
                  this.append(node2.clone());
                } else {
                  this.append(node2);
                }
              }
            } else {
              this[name] = defaults2[name];
            }
          }
        }
        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s2 = this.source;
            error.stack = error.stack.replace(
              /\n\s{4}at /,
              `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
            );
          }
          return error;
        }
        after(add2) {
          this.parent.insertAfter(this, add2);
          return this;
        }
        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }
        before(add2) {
          this.parent.insertBefore(this, add2);
          return this;
        }
        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween) delete this.raws.between;
        }
        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }
        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }
        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }
        error(message, opts = {}) {
          if (this.source) {
            let { end, start: start2 } = this.rangeBy(opts);
            return this.source.input.error(
              message,
              { column: start2.column, line: start2.line },
              { column: end.column, line: end.line },
              opts
            );
          }
          return new CssSyntaxError2(message);
        }
        getProxyProcessor() {
          return {
            get(node2, prop) {
              if (prop === "proxyOf") {
                return node2;
              } else if (prop === "root") {
                return () => node2.root().toProxy();
              } else {
                return node2[prop];
              }
            },
            set(node2, prop, value) {
              if (node2[prop] === value) return true;
              node2[prop] = value;
              if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
              prop === "text") {
                node2.markDirty();
              }
              return true;
            }
          };
        }
        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next2 = this;
            while (next2 = next2.parent) {
              next2[isClean] = false;
            }
          }
        }
        next() {
          if (!this.parent) return void 0;
          let index = this.parent.index(this);
          return this.parent.nodes[index + 1];
        }
        positionBy(opts, stringRepresentation) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index, stringRepresentation);
          } else if (opts.word) {
            stringRepresentation = this.toString();
            let index = stringRepresentation.indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index, stringRepresentation);
          }
          return pos;
        }
        positionInside(index, stringRepresentation) {
          let string = stringRepresentation || this.toString();
          let column2 = this.source.start.column;
          let line2 = this.source.start.line;
          for (let i2 = 0; i2 < index; i2++) {
            if (string[i2] === "\n") {
              column2 = 1;
              line2 += 1;
            } else {
              column2 += 1;
            }
          }
          return { column: column2, line: line2 };
        }
        prev() {
          if (!this.parent) return void 0;
          let index = this.parent.index(this);
          return this.parent.nodes[index - 1];
        }
        rangeBy(opts) {
          let start2 = {
            column: this.source.start.column,
            line: this.source.start.line
          };
          let end = this.source.end ? {
            column: this.source.end.column + 1,
            line: this.source.end.line
          } : {
            column: start2.column + 1,
            line: start2.line
          };
          if (opts.word) {
            let stringRepresentation = this.toString();
            let index = stringRepresentation.indexOf(opts.word);
            if (index !== -1) {
              start2 = this.positionInside(index, stringRepresentation);
              end = this.positionInside(index + opts.word.length, stringRepresentation);
            }
          } else {
            if (opts.start) {
              start2 = {
                column: opts.start.column,
                line: opts.start.line
              };
            } else if (opts.index) {
              start2 = this.positionInside(opts.index);
            }
            if (opts.end) {
              end = {
                column: opts.end.column,
                line: opts.end.line
              };
            } else if (typeof opts.endIndex === "number") {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }
          if (end.line < start2.line || end.line === start2.line && end.column <= start2.column) {
            end = { column: start2.column + 1, line: start2.line };
          }
          return { end, start: start2 };
        }
        raw(prop, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop, defaultType);
        }
        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        }
        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node2 of nodes) {
              if (node2 === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node2);
                bookmark = node2;
              } else {
                this.parent.insertBefore(bookmark, node2);
              }
            }
            if (!foundSelf) {
              this.remove();
            }
          }
          return this;
        }
        root() {
          let result = this;
          while (result.parent && result.parent.type !== "document") {
            result = result.parent;
          }
          return result;
        }
        toJSON(_, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || /* @__PURE__ */ new Map();
          let inputsNextIndex = 0;
          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              continue;
            }
            if (name === "parent" || name === "proxyCache") continue;
            let value = this[name];
            if (Array.isArray(value)) {
              fixed[name] = value.map((i2) => {
                if (typeof i2 === "object" && i2.toJSON) {
                  return i2.toJSON(null, inputs);
                } else {
                  return i2;
                }
              });
            } else if (typeof value === "object" && value.toJSON) {
              fixed[name] = value.toJSON(null, inputs);
            } else if (name === "source") {
              let inputId = inputs.get(value.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                end: value.end,
                inputId,
                start: value.start
              };
            } else {
              fixed[name] = value;
            }
          }
          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
          }
          return fixed;
        }
        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }
        toString(stringifier = stringify3) {
          if (stringifier.stringify) stringifier = stringifier.stringify;
          let result = "";
          stringifier(this, (i2) => {
            result += i2;
          });
          return result;
        }
        warn(result, text, opts) {
          let data = { node: this };
          for (let i2 in opts) data[i2] = opts[i2];
          return result.warn(text, data);
        }
        get proxyOf() {
          return this;
        }
      };
      module.exports = Node;
      Node.default = Node;
    }
  });

  // node_modules/postcss/lib/declaration.js
  var require_declaration = __commonJS({
    "node_modules/postcss/lib/declaration.js"(exports, module) {
      "use strict";
      var Node = require_node();
      var Declaration = class extends Node {
        constructor(defaults2) {
          if (defaults2 && typeof defaults2.value !== "undefined" && typeof defaults2.value !== "string") {
            defaults2 = { ...defaults2, value: String(defaults2.value) };
          }
          super(defaults2);
          this.type = "decl";
        }
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
      };
      module.exports = Declaration;
      Declaration.default = Declaration;
    }
  });

  // node_modules/postcss/lib/comment.js
  var require_comment = __commonJS({
    "node_modules/postcss/lib/comment.js"(exports, module) {
      "use strict";
      var Node = require_node();
      var Comment = class extends Node {
        constructor(defaults2) {
          super(defaults2);
          this.type = "comment";
        }
      };
      module.exports = Comment;
      Comment.default = Comment;
    }
  });

  // node_modules/postcss/lib/container.js
  var require_container = __commonJS({
    "node_modules/postcss/lib/container.js"(exports, module) {
      "use strict";
      var { isClean, my } = require_symbols();
      var Declaration = require_declaration();
      var Comment = require_comment();
      var Node = require_node();
      var parse5;
      var Rule;
      var AtRule;
      var Root2;
      function cleanSource(nodes) {
        return nodes.map((i2) => {
          if (i2.nodes) i2.nodes = cleanSource(i2.nodes);
          delete i2.source;
          return i2;
        });
      }
      function markDirtyUp(node2) {
        node2[isClean] = false;
        if (node2.proxyOf.nodes) {
          for (let i2 of node2.proxyOf.nodes) {
            markDirtyUp(i2);
          }
        }
      }
      var Container = class _Container extends Node {
        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node2 of nodes) this.proxyOf.nodes.push(node2);
          }
          this.markDirty();
          return this;
        }
        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
          }
        }
        each(callback) {
          if (!this.proxyOf.nodes) return void 0;
          let iterator = this.getIterator();
          let index, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index], index);
            if (result === false) break;
            this.indexes[iterator] += 1;
          }
          delete this.indexes[iterator];
          return result;
        }
        every(condition) {
          return this.nodes.every(condition);
        }
        getIterator() {
          if (!this.lastEach) this.lastEach = 0;
          if (!this.indexes) this.indexes = {};
          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;
          return iterator;
        }
        getProxyProcessor() {
          return {
            get(node2, prop) {
              if (prop === "proxyOf") {
                return node2;
              } else if (!node2[prop]) {
                return node2[prop];
              } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
                return (...args) => {
                  return node2[prop](
                    ...args.map((i2) => {
                      if (typeof i2 === "function") {
                        return (child, index) => i2(child.toProxy(), index);
                      } else {
                        return i2;
                      }
                    })
                  );
                };
              } else if (prop === "every" || prop === "some") {
                return (cb) => {
                  return node2[prop](
                    (child, ...other) => cb(child.toProxy(), ...other)
                  );
                };
              } else if (prop === "root") {
                return () => node2.root().toProxy();
              } else if (prop === "nodes") {
                return node2.nodes.map((i2) => i2.toProxy());
              } else if (prop === "first" || prop === "last") {
                return node2[prop].toProxy();
              } else {
                return node2[prop];
              }
            },
            set(node2, prop, value) {
              if (node2[prop] === value) return true;
              node2[prop] = value;
              if (prop === "name" || prop === "params" || prop === "selector") {
                node2.markDirty();
              }
              return true;
            }
          };
        }
        index(child) {
          if (typeof child === "number") return child;
          if (child.proxyOf) child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }
        insertAfter(exist, add2) {
          let existIndex = this.index(exist);
          let nodes = this.normalize(add2, this.proxyOf.nodes[existIndex]).reverse();
          existIndex = this.index(exist);
          for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (existIndex < index) {
              this.indexes[id] = index + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        insertBefore(exist, add2) {
          let existIndex = this.index(exist);
          let type = existIndex === 0 ? "prepend" : false;
          let nodes = this.normalize(add2, this.proxyOf.nodes[existIndex], type).reverse();
          existIndex = this.index(exist);
          for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (existIndex <= index) {
              this.indexes[id] = index + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        normalize(nodes, sample) {
          if (typeof nodes === "string") {
            nodes = cleanSource(parse5(nodes).nodes);
          } else if (typeof nodes === "undefined") {
            nodes = [];
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent) i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type === "root" && this.type !== "document") {
            nodes = nodes.nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent) i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === "undefined") {
              throw new Error("Value field is missed in node creation");
            } else if (typeof nodes.value !== "string") {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration(nodes)];
          } else if (nodes.selector) {
            nodes = [new Rule(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment(nodes)];
          } else {
            throw new Error("Unknown node type in node creation");
          }
          let processed = nodes.map((i2) => {
            if (!i2[my]) _Container.rebuild(i2);
            i2 = i2.proxyOf;
            if (i2.parent) i2.parent.removeChild(i2);
            if (i2[isClean]) markDirtyUp(i2);
            if (typeof i2.raws.before === "undefined") {
              if (sample && typeof sample.raws.before !== "undefined") {
                i2.raws.before = sample.raws.before.replace(/\S/g, "");
              }
            }
            i2.parent = this.proxyOf;
            return i2;
          });
          return processed;
        }
        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, "prepend").reverse();
            for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
            for (let id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }
        removeAll() {
          for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
          this.proxyOf.nodes = [];
          this.markDirty();
          return this;
        }
        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = void 0;
          this.proxyOf.nodes.splice(child, 1);
          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (index >= child) {
              this.indexes[id] = index - 1;
            }
          }
          this.markDirty();
          return this;
        }
        replaceValues(pattern, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }
          this.walkDecls((decl) => {
            if (opts.props && !opts.props.includes(decl.prop)) return;
            if (opts.fast && !decl.value.includes(opts.fast)) return;
            decl.value = decl.value.replace(pattern, callback);
          });
          this.markDirty();
          return this;
        }
        some(condition) {
          return this.nodes.some(condition);
        }
        walk(callback) {
          return this.each((child, i2) => {
            let result;
            try {
              result = callback(child, i2);
            } catch (e2) {
              throw child.addToError(e2);
            }
            if (result !== false && child.walk) {
              result = child.walk(callback);
            }
            return result;
          });
        }
        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child, i2) => {
              if (child.type === "atrule") {
                return callback(child, i2);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "atrule" && name.test(child.name)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "atrule" && child.name === name) {
              return callback(child, i2);
            }
          });
        }
        walkComments(callback) {
          return this.walk((child, i2) => {
            if (child.type === "comment") {
              return callback(child, i2);
            }
          });
        }
        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i2) => {
              if (child.type === "decl") {
                return callback(child, i2);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "decl" && prop.test(child.prop)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "decl" && child.prop === prop) {
              return callback(child, i2);
            }
          });
        }
        walkRules(selector3, callback) {
          if (!callback) {
            callback = selector3;
            return this.walk((child, i2) => {
              if (child.type === "rule") {
                return callback(child, i2);
              }
            });
          }
          if (selector3 instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "rule" && selector3.test(child.selector)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "rule" && child.selector === selector3) {
              return callback(child, i2);
            }
          });
        }
        get first() {
          if (!this.proxyOf.nodes) return void 0;
          return this.proxyOf.nodes[0];
        }
        get last() {
          if (!this.proxyOf.nodes) return void 0;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
      };
      Container.registerParse = (dependant) => {
        parse5 = dependant;
      };
      Container.registerRule = (dependant) => {
        Rule = dependant;
      };
      Container.registerAtRule = (dependant) => {
        AtRule = dependant;
      };
      Container.registerRoot = (dependant) => {
        Root2 = dependant;
      };
      module.exports = Container;
      Container.default = Container;
      Container.rebuild = (node2) => {
        if (node2.type === "atrule") {
          Object.setPrototypeOf(node2, AtRule.prototype);
        } else if (node2.type === "rule") {
          Object.setPrototypeOf(node2, Rule.prototype);
        } else if (node2.type === "decl") {
          Object.setPrototypeOf(node2, Declaration.prototype);
        } else if (node2.type === "comment") {
          Object.setPrototypeOf(node2, Comment.prototype);
        } else if (node2.type === "root") {
          Object.setPrototypeOf(node2, Root2.prototype);
        }
        node2[my] = true;
        if (node2.nodes) {
          node2.nodes.forEach((child) => {
            Container.rebuild(child);
          });
        }
      };
    }
  });

  // node_modules/postcss/lib/tokenize.js
  var require_tokenize = __commonJS({
    "node_modules/postcss/lib/tokenize.js"(exports, module) {
      "use strict";
      var SINGLE_QUOTE = "'".charCodeAt(0);
      var DOUBLE_QUOTE = '"'.charCodeAt(0);
      var BACKSLASH = "\\".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var SPACE3 = " ".charCodeAt(0);
      var FEED = "\f".charCodeAt(0);
      var TAB4 = "	".charCodeAt(0);
      var CR = "\r".charCodeAt(0);
      var OPEN_SQUARE = "[".charCodeAt(0);
      var CLOSE_SQUARE = "]".charCodeAt(0);
      var OPEN_PARENTHESES = "(".charCodeAt(0);
      var CLOSE_PARENTHESES = ")".charCodeAt(0);
      var OPEN_CURLY = "{".charCodeAt(0);
      var CLOSE_CURLY = "}".charCodeAt(0);
      var SEMICOLON = ";".charCodeAt(0);
      var ASTERISK = "*".charCodeAt(0);
      var COLON = ":".charCodeAt(0);
      var AT = "@".charCodeAt(0);
      var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
      var RE_HEX_ESCAPE = /[\da-f]/i;
      module.exports = function tokenizer(input, options = {}) {
        let css = input.css.valueOf();
        let ignore = options.ignoreErrors;
        let code, next2, quote, content, escape;
        let escaped, escapePos, prev2, n2, currentToken;
        let length2 = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];
        function position2() {
          return pos;
        }
        function unclosed(what) {
          throw input.error("Unclosed " + what, pos);
        }
        function endOfFile() {
          return returned.length === 0 && pos >= length2;
        }
        function nextToken(opts) {
          if (returned.length) return returned.pop();
          if (pos >= length2) return;
          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code = css.charCodeAt(pos);
          switch (code) {
            case NEWLINE:
            case SPACE3:
            case TAB4:
            case CR:
            case FEED: {
              next2 = pos;
              do {
                next2 += 1;
                code = css.charCodeAt(next2);
              } while (code === SPACE3 || code === NEWLINE || code === TAB4 || code === CR || code === FEED);
              currentToken = ["space", css.slice(pos, next2)];
              pos = next2 - 1;
              break;
            }
            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES: {
              let controlChar = String.fromCharCode(code);
              currentToken = [controlChar, controlChar, pos];
              break;
            }
            case OPEN_PARENTHESES: {
              prev2 = buffer.length ? buffer.pop()[1] : "";
              n2 = css.charCodeAt(pos + 1);
              if (prev2 === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE3 && n2 !== NEWLINE && n2 !== TAB4 && n2 !== FEED && n2 !== CR) {
                next2 = pos;
                do {
                  escaped = false;
                  next2 = css.indexOf(")", next2 + 1);
                  if (next2 === -1) {
                    if (ignore || ignoreUnclosed) {
                      next2 = pos;
                      break;
                    } else {
                      unclosed("bracket");
                    }
                  }
                  escapePos = next2;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                currentToken = ["brackets", css.slice(pos, next2 + 1), pos, next2];
                pos = next2;
              } else {
                next2 = css.indexOf(")", pos + 1);
                content = css.slice(pos, next2 + 1);
                if (next2 === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ["(", "(", pos];
                } else {
                  currentToken = ["brackets", content, pos, next2];
                  pos = next2;
                }
              }
              break;
            }
            case SINGLE_QUOTE:
            case DOUBLE_QUOTE: {
              quote = code === SINGLE_QUOTE ? "'" : '"';
              next2 = pos;
              do {
                escaped = false;
                next2 = css.indexOf(quote, next2 + 1);
                if (next2 === -1) {
                  if (ignore || ignoreUnclosed) {
                    next2 = pos + 1;
                    break;
                  } else {
                    unclosed("string");
                  }
                }
                escapePos = next2;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["string", css.slice(pos, next2 + 1), pos, next2];
              pos = next2;
              break;
            }
            case AT: {
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next2 = css.length - 1;
              } else {
                next2 = RE_AT_END.lastIndex - 2;
              }
              currentToken = ["at-word", css.slice(pos, next2 + 1), pos, next2];
              pos = next2;
              break;
            }
            case BACKSLASH: {
              next2 = pos;
              escape = true;
              while (css.charCodeAt(next2 + 1) === BACKSLASH) {
                next2 += 1;
                escape = !escape;
              }
              code = css.charCodeAt(next2 + 1);
              if (escape && code !== SLASH && code !== SPACE3 && code !== NEWLINE && code !== TAB4 && code !== CR && code !== FEED) {
                next2 += 1;
                if (RE_HEX_ESCAPE.test(css.charAt(next2))) {
                  while (RE_HEX_ESCAPE.test(css.charAt(next2 + 1))) {
                    next2 += 1;
                  }
                  if (css.charCodeAt(next2 + 1) === SPACE3) {
                    next2 += 1;
                  }
                }
              }
              currentToken = ["word", css.slice(pos, next2 + 1), pos, next2];
              pos = next2;
              break;
            }
            default: {
              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                next2 = css.indexOf("*/", pos + 2) + 1;
                if (next2 === 0) {
                  if (ignore || ignoreUnclosed) {
                    next2 = css.length;
                  } else {
                    unclosed("comment");
                  }
                }
                currentToken = ["comment", css.slice(pos, next2 + 1), pos, next2];
                pos = next2;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next2 = css.length - 1;
                } else {
                  next2 = RE_WORD_END.lastIndex - 2;
                }
                currentToken = ["word", css.slice(pos, next2 + 1), pos, next2];
                buffer.push(currentToken);
                pos = next2;
              }
              break;
            }
          }
          pos++;
          return currentToken;
        }
        function back(token2) {
          returned.push(token2);
        }
        return {
          back,
          endOfFile,
          nextToken,
          position: position2
        };
      };
    }
  });

  // node_modules/postcss/lib/at-rule.js
  var require_at_rule = __commonJS({
    "node_modules/postcss/lib/at-rule.js"(exports, module) {
      "use strict";
      var Container = require_container();
      var AtRule = class extends Container {
        constructor(defaults2) {
          super(defaults2);
          this.type = "atrule";
        }
        append(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.append(...children);
        }
        prepend(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.prepend(...children);
        }
      };
      module.exports = AtRule;
      AtRule.default = AtRule;
      Container.registerAtRule(AtRule);
    }
  });

  // node_modules/postcss/lib/root.js
  var require_root = __commonJS({
    "node_modules/postcss/lib/root.js"(exports, module) {
      "use strict";
      var Container = require_container();
      var LazyResult;
      var Processor2;
      var Root2 = class extends Container {
        constructor(defaults2) {
          super(defaults2);
          this.type = "root";
          if (!this.nodes) this.nodes = [];
        }
        normalize(child, sample, type) {
          let nodes = super.normalize(child);
          if (sample) {
            if (type === "prepend") {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node2 of nodes) {
                node2.raws.before = sample.raws.before;
              }
            }
          }
          return nodes;
        }
        removeChild(child, ignore) {
          let index = this.index(child);
          if (!ignore && index === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index].raws.before;
          }
          return super.removeChild(child);
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor2(), this, opts);
          return lazy.stringify();
        }
      };
      Root2.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Root2.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Root2;
      Root2.default = Root2;
      Container.registerRoot(Root2);
    }
  });

  // node_modules/postcss/lib/list.js
  var require_list = __commonJS({
    "node_modules/postcss/lib/list.js"(exports, module) {
      "use strict";
      var list = {
        comma(string) {
          return list.split(string, [","], true);
        },
        space(string) {
          let spaces = [" ", "\n", "	"];
          return list.split(string, spaces);
        },
        split(string, separators, last3) {
          let array = [];
          let current = "";
          let split2 = false;
          let func = 0;
          let inQuote = false;
          let prevQuote = "";
          let escape = false;
          for (let letter of string) {
            if (escape) {
              escape = false;
            } else if (letter === "\\") {
              escape = true;
            } else if (inQuote) {
              if (letter === prevQuote) {
                inQuote = false;
              }
            } else if (letter === '"' || letter === "'") {
              inQuote = true;
              prevQuote = letter;
            } else if (letter === "(") {
              func += 1;
            } else if (letter === ")") {
              if (func > 0) func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter)) split2 = true;
            }
            if (split2) {
              if (current !== "") array.push(current.trim());
              current = "";
              split2 = false;
            } else {
              current += letter;
            }
          }
          if (last3 || current !== "") array.push(current.trim());
          return array;
        }
      };
      module.exports = list;
      list.default = list;
    }
  });

  // node_modules/postcss/lib/rule.js
  var require_rule = __commonJS({
    "node_modules/postcss/lib/rule.js"(exports, module) {
      "use strict";
      var Container = require_container();
      var list = require_list();
      var Rule = class extends Container {
        constructor(defaults2) {
          super(defaults2);
          this.type = "rule";
          if (!this.nodes) this.nodes = [];
        }
        get selectors() {
          return list.comma(this.selector);
        }
        set selectors(values) {
          let match2 = this.selector ? this.selector.match(/,\s*/) : null;
          let sep = match2 ? match2[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep);
        }
      };
      module.exports = Rule;
      Rule.default = Rule;
      Container.registerRule(Rule);
    }
  });

  // node_modules/postcss/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/postcss/lib/parser.js"(exports, module) {
      "use strict";
      var Declaration = require_declaration();
      var tokenizer = require_tokenize();
      var Comment = require_comment();
      var AtRule = require_at_rule();
      var Root2 = require_root();
      var Rule = require_rule();
      var SAFE_COMMENT_NEIGHBOR = {
        empty: true,
        space: true
      };
      function findLastWithPosition(tokens) {
        for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
          let token2 = tokens[i2];
          let pos = token2[3] || token2[2];
          if (pos) return pos;
        }
      }
      var Parser = class {
        constructor(input) {
          this.input = input;
          this.root = new Root2();
          this.current = this.root;
          this.spaces = "";
          this.semicolon = false;
          this.createTokenizer();
          this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
        }
        atrule(token2) {
          let node2 = new AtRule();
          node2.name = token2[1].slice(1);
          if (node2.name === "") {
            this.unnamedAtrule(node2, token2);
          }
          this.init(node2, token2[2]);
          let type;
          let prev2;
          let shift;
          let last3 = false;
          let open = false;
          let params = [];
          let brackets = [];
          while (!this.tokenizer.endOfFile()) {
            token2 = this.tokenizer.nextToken();
            type = token2[0];
            if (type === "(" || type === "[") {
              brackets.push(type === "(" ? ")" : "]");
            } else if (type === "{" && brackets.length > 0) {
              brackets.push("}");
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }
            if (brackets.length === 0) {
              if (type === ";") {
                node2.source.end = this.getPosition(token2[2]);
                node2.source.end.offset++;
                this.semicolon = true;
                break;
              } else if (type === "{") {
                open = true;
                break;
              } else if (type === "}") {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev2 = params[shift];
                  while (prev2 && prev2[0] === "space") {
                    prev2 = params[--shift];
                  }
                  if (prev2) {
                    node2.source.end = this.getPosition(prev2[3] || prev2[2]);
                    node2.source.end.offset++;
                  }
                }
                this.end(token2);
                break;
              } else {
                params.push(token2);
              }
            } else {
              params.push(token2);
            }
            if (this.tokenizer.endOfFile()) {
              last3 = true;
              break;
            }
          }
          node2.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node2.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node2, "params", params);
            if (last3) {
              token2 = params[params.length - 1];
              node2.source.end = this.getPosition(token2[3] || token2[2]);
              node2.source.end.offset++;
              this.spaces = node2.raws.between;
              node2.raws.between = "";
            }
          } else {
            node2.raws.afterName = "";
            node2.params = "";
          }
          if (open) {
            node2.nodes = [];
            this.current = node2;
          }
        }
        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false) return;
          let founded = 0;
          let token2;
          for (let j2 = colon - 1; j2 >= 0; j2--) {
            token2 = tokens[j2];
            if (token2[0] !== "space") {
              founded += 1;
              if (founded === 2) break;
            }
          }
          throw this.input.error(
            "Missed semicolon",
            token2[0] === "word" ? token2[3] + 1 : token2[2]
          );
        }
        colon(tokens) {
          let brackets = 0;
          let token2, type, prev2;
          for (let [i2, element] of tokens.entries()) {
            token2 = element;
            type = token2[0];
            if (type === "(") {
              brackets += 1;
            }
            if (type === ")") {
              brackets -= 1;
            }
            if (brackets === 0 && type === ":") {
              if (!prev2) {
                this.doubleColon(token2);
              } else if (prev2[0] === "word" && prev2[1] === "progid") {
                continue;
              } else {
                return i2;
              }
            }
            prev2 = token2;
          }
          return false;
        }
        comment(token2) {
          let node2 = new Comment();
          this.init(node2, token2[2]);
          node2.source.end = this.getPosition(token2[3] || token2[2]);
          node2.source.end.offset++;
          let text = token2[1].slice(2, -2);
          if (/^\s*$/.test(text)) {
            node2.text = "";
            node2.raws.left = text;
            node2.raws.right = "";
          } else {
            let match2 = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node2.text = match2[2];
            node2.raws.left = match2[1];
            node2.raws.right = match2[3];
          }
        }
        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }
        decl(tokens, customProperty) {
          let node2 = new Declaration();
          this.init(node2, tokens[0][2]);
          let last3 = tokens[tokens.length - 1];
          if (last3[0] === ";") {
            this.semicolon = true;
            tokens.pop();
          }
          node2.source.end = this.getPosition(
            last3[3] || last3[2] || findLastWithPosition(tokens)
          );
          node2.source.end.offset++;
          while (tokens[0][0] !== "word") {
            if (tokens.length === 1) this.unknownWord(tokens);
            node2.raws.before += tokens.shift()[1];
          }
          node2.source.start = this.getPosition(tokens[0][2]);
          node2.prop = "";
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ":" || type === "space" || type === "comment") {
              break;
            }
            node2.prop += tokens.shift()[1];
          }
          node2.raws.between = "";
          let token2;
          while (tokens.length) {
            token2 = tokens.shift();
            if (token2[0] === ":") {
              node2.raws.between += token2[1];
              break;
            } else {
              if (token2[0] === "word" && /\w/.test(token2[1])) {
                this.unknownWord([token2]);
              }
              node2.raws.between += token2[1];
            }
          }
          if (node2.prop[0] === "_" || node2.prop[0] === "*") {
            node2.raws.before += node2.prop[0];
            node2.prop = node2.prop.slice(1);
          }
          let firstSpaces = [];
          let next2;
          while (tokens.length) {
            next2 = tokens[0][0];
            if (next2 !== "space" && next2 !== "comment") break;
            firstSpaces.push(tokens.shift());
          }
          this.precheckMissedSemicolon(tokens);
          for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
            token2 = tokens[i2];
            if (token2[1].toLowerCase() === "!important") {
              node2.important = true;
              let string = this.stringFrom(tokens, i2);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== " !important") node2.raws.important = string;
              break;
            } else if (token2[1].toLowerCase() === "important") {
              let cache = tokens.slice(0);
              let str = "";
              for (let j2 = i2; j2 > 0; j2--) {
                let type = cache[j2][0];
                if (str.trim().indexOf("!") === 0 && type !== "space") {
                  break;
                }
                str = cache.pop()[1] + str;
              }
              if (str.trim().indexOf("!") === 0) {
                node2.important = true;
                node2.raws.important = str;
                tokens = cache;
              }
            }
            if (token2[0] !== "space" && token2[0] !== "comment") {
              break;
            }
          }
          let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
          if (hasWord) {
            node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
            firstSpaces = [];
          }
          this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
          if (node2.value.includes(":") && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }
        doubleColon(token2) {
          throw this.input.error(
            "Double colon",
            { offset: token2[2] },
            { offset: token2[2] + token2[1].length }
          );
        }
        emptyRule(token2) {
          let node2 = new Rule();
          this.init(node2, token2[2]);
          node2.selector = "";
          node2.raws.between = "";
          this.current = node2;
        }
        end(token2) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.spaces = "";
          if (this.current.parent) {
            this.current.source.end = this.getPosition(token2[2]);
            this.current.source.end.offset++;
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token2);
          }
        }
        endFile() {
          if (this.current.parent) this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.root.source.end = this.getPosition(this.tokenizer.position());
        }
        freeSemicolon(token2) {
          this.spaces += token2[1];
          if (this.current.nodes) {
            let prev2 = this.current.nodes[this.current.nodes.length - 1];
            if (prev2 && prev2.type === "rule" && !prev2.raws.ownSemicolon) {
              prev2.raws.ownSemicolon = this.spaces;
              this.spaces = "";
            }
          }
        }
        // Helpers
        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            column: pos.col,
            line: pos.line,
            offset
          };
        }
        init(node2, offset) {
          this.current.push(node2);
          node2.source = {
            input: this.input,
            start: this.getPosition(offset)
          };
          node2.raws.before = this.spaces;
          this.spaces = "";
          if (node2.type !== "comment") this.semicolon = false;
        }
        other(start2) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start2[1].startsWith("--");
          let tokens = [];
          let token2 = start2;
          while (token2) {
            type = token2[0];
            tokens.push(token2);
            if (type === "(" || type === "[") {
              if (!bracket) bracket = token2;
              brackets.push(type === "(" ? ")" : "]");
            } else if (customProperty && colon && type === "{") {
              if (!bracket) bracket = token2;
              brackets.push("}");
            } else if (brackets.length === 0) {
              if (type === ";") {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === "{") {
                this.rule(tokens);
                return;
              } else if (type === "}") {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ":") {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0) bracket = null;
            }
            token2 = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile()) end = true;
          if (brackets.length > 0) this.unclosedBracket(bracket);
          if (end && colon) {
            if (!customProperty) {
              while (tokens.length) {
                token2 = tokens[tokens.length - 1][0];
                if (token2 !== "space" && token2 !== "comment") break;
                this.tokenizer.back(tokens.pop());
              }
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }
        parse() {
          let token2;
          while (!this.tokenizer.endOfFile()) {
            token2 = this.tokenizer.nextToken();
            switch (token2[0]) {
              case "space":
                this.spaces += token2[1];
                break;
              case ";":
                this.freeSemicolon(token2);
                break;
              case "}":
                this.end(token2);
                break;
              case "comment":
                this.comment(token2);
                break;
              case "at-word":
                this.atrule(token2);
                break;
              case "{":
                this.emptyRule(token2);
                break;
              default:
                this.other(token2);
                break;
            }
          }
          this.endFile();
        }
        precheckMissedSemicolon() {
        }
        raw(node2, prop, tokens, customProperty) {
          let token2, type;
          let length2 = tokens.length;
          let value = "";
          let clean = true;
          let next2, prev2;
          for (let i2 = 0; i2 < length2; i2 += 1) {
            token2 = tokens[i2];
            type = token2[0];
            if (type === "space" && i2 === length2 - 1 && !customProperty) {
              clean = false;
            } else if (type === "comment") {
              prev2 = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
              next2 = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
              if (!SAFE_COMMENT_NEIGHBOR[prev2] && !SAFE_COMMENT_NEIGHBOR[next2]) {
                if (value.slice(-1) === ",") {
                  clean = false;
                } else {
                  value += token2[1];
                }
              } else {
                clean = false;
              }
            } else {
              value += token2[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i2) => all + i2[1], "");
            node2.raws[prop] = { raw, value };
          }
          node2[prop] = value;
        }
        rule(tokens) {
          tokens.pop();
          let node2 = new Rule();
          this.init(node2, tokens[0][2]);
          node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node2, "selector", tokens);
          this.current = node2;
        }
        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space" && lastTokenType !== "comment") break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        // Errors
        spacesAndCommentsFromStart(tokens) {
          let next2;
          let spaces = "";
          while (tokens.length) {
            next2 = tokens[0][0];
            if (next2 !== "space" && next2 !== "comment") break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }
        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space") break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        stringFrom(tokens, from2) {
          let result = "";
          for (let i2 = from2; i2 < tokens.length; i2++) {
            result += tokens[i2][1];
          }
          tokens.splice(from2, tokens.length - from2);
          return result;
        }
        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error("Unclosed block", pos.line, pos.column);
        }
        unclosedBracket(bracket) {
          throw this.input.error(
            "Unclosed bracket",
            { offset: bracket[2] },
            { offset: bracket[2] + 1 }
          );
        }
        unexpectedClose(token2) {
          throw this.input.error(
            "Unexpected }",
            { offset: token2[2] },
            { offset: token2[2] + 1 }
          );
        }
        unknownWord(tokens) {
          throw this.input.error(
            "Unknown word",
            { offset: tokens[0][2] },
            { offset: tokens[0][2] + tokens[0][1].length }
          );
        }
        unnamedAtrule(node2, token2) {
          throw this.input.error(
            "At-rule without name",
            { offset: token2[2] },
            { offset: token2[2] + token2[1].length }
          );
        }
      };
      module.exports = Parser;
    }
  });

  // node_modules/postcss/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/postcss/lib/parse.js"(exports, module) {
      "use strict";
      var Container = require_container();
      var Parser = require_parser();
      var Input = require_input();
      function parse5(css, opts) {
        let input = new Input(css, opts);
        let parser = new Parser(input);
        try {
          parser.parse();
        } catch (e2) {
          if (true) {
            if (e2.name === "CssSyntaxError" && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
              } else if (/\.sass/i.test(opts.from)) {
                e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
              } else if (/\.less$/i.test(opts.from)) {
                e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
              }
            }
          }
          throw e2;
        }
        return parser.root;
      }
      module.exports = parse5;
      parse5.default = parse5;
      Container.registerParse(parse5);
    }
  });

  // node_modules/postcss/lib/warning.js
  var require_warning2 = __commonJS({
    "node_modules/postcss/lib/warning.js"(exports, module) {
      "use strict";
      var Warning2 = class {
        constructor(text, opts = {}) {
          this.type = "warning";
          this.text = text;
          if (opts.node && opts.node.source) {
            let range2 = opts.node.rangeBy(opts);
            this.line = range2.start.line;
            this.column = range2.start.column;
            this.endLine = range2.end.line;
            this.endColumn = range2.end.column;
          }
          for (let opt in opts) this[opt] = opts[opt];
        }
        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              index: this.index,
              plugin: this.plugin,
              word: this.word
            }).message;
          }
          if (this.plugin) {
            return this.plugin + ": " + this.text;
          }
          return this.text;
        }
      };
      module.exports = Warning2;
      Warning2.default = Warning2;
    }
  });

  // node_modules/postcss/lib/result.js
  var require_result = __commonJS({
    "node_modules/postcss/lib/result.js"(exports, module) {
      "use strict";
      var Warning2 = require_warning2();
      var Result = class {
        constructor(processor, root, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root;
          this.opts = opts;
          this.css = void 0;
          this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(text, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }
          let warning6 = new Warning2(text, opts);
          this.messages.push(warning6);
          return warning6;
        }
        warnings() {
          return this.messages.filter((i2) => i2.type === "warning");
        }
        get content() {
          return this.css;
        }
      };
      module.exports = Result;
      Result.default = Result;
    }
  });

  // node_modules/postcss/lib/no-work-result.js
  var require_no_work_result = __commonJS({
    "node_modules/postcss/lib/no-work-result.js"(exports, module) {
      "use strict";
      var MapGenerator = require_map_generator();
      var stringify3 = require_stringify();
      var warnOnce = require_warn_once();
      var parse5 = require_parse();
      var Result = require_result();
      var NoWorkResult = class {
        constructor(processor, css, opts) {
          css = css.toString();
          this.stringified = false;
          this._processor = processor;
          this._css = css;
          this._opts = opts;
          this._map = void 0;
          let root;
          let str = stringify3;
          this.result = new Result(this._processor, root, this._opts);
          this.result.css = css;
          let self = this;
          Object.defineProperty(this.result, "root", {
            get() {
              return self.root;
            }
          });
          let map = new MapGenerator(str, root, this._opts, css);
          if (map.isMap()) {
            let [generatedCSS, generatedMap] = map.generate();
            if (generatedCSS) {
              this.result.css = generatedCSS;
            }
            if (generatedMap) {
              this.result.map = generatedMap;
            }
          } else {
            map.clearAnnotation();
            this.result.css = map.css;
          }
        }
        async() {
          if (this.error) return Promise.reject(this.error);
          return Promise.resolve(this.result);
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        sync() {
          if (this.error) throw this.error;
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this._opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this._css;
        }
        warnings() {
          return [];
        }
        get content() {
          return this.result.css;
        }
        get css() {
          return this.result.css;
        }
        get map() {
          return this.result.map;
        }
        get messages() {
          return [];
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          if (this._root) {
            return this._root;
          }
          let root;
          let parser = parse5;
          try {
            root = parser(this._css, this._opts);
          } catch (error) {
            this.error = error;
          }
          if (this.error) {
            throw this.error;
          } else {
            this._root = root;
            return root;
          }
        }
        get [Symbol.toStringTag]() {
          return "NoWorkResult";
        }
      };
      module.exports = NoWorkResult;
      NoWorkResult.default = NoWorkResult;
    }
  });

  // node_modules/postcss/lib/document.js
  var require_document = __commonJS({
    "node_modules/postcss/lib/document.js"(exports, module) {
      "use strict";
      var Container = require_container();
      var LazyResult;
      var Processor2;
      var Document = class extends Container {
        constructor(defaults2) {
          super({ type: "document", ...defaults2 });
          if (!this.nodes) {
            this.nodes = [];
          }
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor2(), this, opts);
          return lazy.stringify();
        }
      };
      Document.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Document.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Document;
      Document.default = Document;
    }
  });

  // node_modules/postcss/lib/lazy-result.js
  var require_lazy_result = __commonJS({
    "node_modules/postcss/lib/lazy-result.js"(exports, module) {
      "use strict";
      var { isClean, my } = require_symbols();
      var MapGenerator = require_map_generator();
      var stringify3 = require_stringify();
      var Container = require_container();
      var Document = require_document();
      var warnOnce = require_warn_once();
      var Result = require_result();
      var parse5 = require_parse();
      var Root2 = require_root();
      var TYPE_TO_CLASS_NAME = {
        atrule: "AtRule",
        comment: "Comment",
        decl: "Declaration",
        document: "Document",
        root: "Root",
        rule: "Rule"
      };
      var PLUGIN_PROPS = {
        AtRule: true,
        AtRuleExit: true,
        Comment: true,
        CommentExit: true,
        Declaration: true,
        DeclarationExit: true,
        Document: true,
        DocumentExit: true,
        Once: true,
        OnceExit: true,
        postcssPlugin: true,
        prepare: true,
        Root: true,
        RootExit: true,
        Rule: true,
        RuleExit: true
      };
      var NOT_VISITORS = {
        Once: true,
        postcssPlugin: true,
        prepare: true
      };
      var CHILDREN = 0;
      function isPromise(obj) {
        return typeof obj === "object" && typeof obj.then === "function";
      }
      function getEvents(node2) {
        let key = false;
        let type = TYPE_TO_CLASS_NAME[node2.type];
        if (node2.type === "decl") {
          key = node2.prop.toLowerCase();
        } else if (node2.type === "atrule") {
          key = node2.name.toLowerCase();
        }
        if (key && node2.append) {
          return [
            type,
            type + "-" + key,
            CHILDREN,
            type + "Exit",
            type + "Exit-" + key
          ];
        } else if (key) {
          return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
        } else if (node2.append) {
          return [type, CHILDREN, type + "Exit"];
        } else {
          return [type, type + "Exit"];
        }
      }
      function toStack(node2) {
        let events;
        if (node2.type === "document") {
          events = ["Document", CHILDREN, "DocumentExit"];
        } else if (node2.type === "root") {
          events = ["Root", CHILDREN, "RootExit"];
        } else {
          events = getEvents(node2);
        }
        return {
          eventIndex: 0,
          events,
          iterator: 0,
          node: node2,
          visitorIndex: 0,
          visitors: []
        };
      }
      function cleanMarks(node2) {
        node2[isClean] = false;
        if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks(i2));
        return node2;
      }
      var postcss = {};
      var LazyResult = class _LazyResult {
        constructor(processor, css, opts) {
          this.stringified = false;
          this.processed = false;
          let root;
          if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
            root = cleanMarks(css);
          } else if (css instanceof _LazyResult || css instanceof Result) {
            root = cleanMarks(css.root);
            if (css.map) {
              if (typeof opts.map === "undefined") opts.map = {};
              if (!opts.map.inline) opts.map.inline = false;
              opts.map.prev = css.map;
            }
          } else {
            let parser = parse5;
            if (opts.syntax) parser = opts.syntax.parse;
            if (opts.parser) parser = opts.parser;
            if (parser.parse) parser = parser.parse;
            try {
              root = parser(css, opts);
            } catch (error) {
              this.processed = true;
              this.error = error;
            }
            if (root && !root[my]) {
              Container.rebuild(root);
            }
          }
          this.result = new Result(processor, root, opts);
          this.helpers = { ...postcss, postcss, result: this.result };
          this.plugins = this.processor.plugins.map((plugin) => {
            if (typeof plugin === "object" && plugin.prepare) {
              return { ...plugin, ...plugin.prepare(this.result) };
            } else {
              return plugin;
            }
          });
        }
        async() {
          if (this.error) return Promise.reject(this.error);
          if (this.processed) return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(error, node2) {
          let plugin = this.result.lastPlugin;
          try {
            if (node2) node2.addToError(error);
            this.error = error;
            if (error.name === "CssSyntaxError" && !error.plugin) {
              error.plugin = plugin.postcssPlugin;
              error.setMessage();
            } else if (plugin.postcssVersion) {
              if (true) {
                let pluginName = plugin.postcssPlugin;
                let pluginVer = plugin.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a2 = pluginVer.split(".");
                let b2 = runtimeVer.split(".");
                if (a2[0] !== b2[0] || parseInt(a2[1]) > parseInt(b2[1])) {
                  console.error(
                    "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                  );
                }
              }
            }
          } catch (err) {
            if (console && console.error) console.error(err);
          }
          return error;
        }
        prepareVisitors() {
          this.listeners = {};
          let add2 = (plugin, type, cb) => {
            if (!this.listeners[type]) this.listeners[type] = [];
            this.listeners[type].push([plugin, cb]);
          };
          for (let plugin of this.plugins) {
            if (typeof plugin === "object") {
              for (let event in plugin) {
                if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                  throw new Error(
                    `Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                  );
                }
                if (!NOT_VISITORS[event]) {
                  if (typeof plugin[event] === "object") {
                    for (let filter in plugin[event]) {
                      if (filter === "*") {
                        add2(plugin, event, plugin[event][filter]);
                      } else {
                        add2(
                          plugin,
                          event + "-" + filter.toLowerCase(),
                          plugin[event][filter]
                        );
                      }
                    }
                  } else if (typeof plugin[event] === "function") {
                    add2(plugin, event, plugin[event]);
                  }
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        async runAsync() {
          this.plugin = 0;
          for (let i2 = 0; i2 < this.plugins.length; i2++) {
            let plugin = this.plugins[i2];
            let promise = this.runOnRoot(plugin);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (error) {
                throw this.handleError(error);
              }
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root = this.result.root;
            while (!root[isClean]) {
              root[isClean] = true;
              let stack = [toStack(root)];
              while (stack.length > 0) {
                let promise = this.visitTick(stack);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (e2) {
                    let node2 = stack[stack.length - 1].node;
                    throw this.handleError(e2, node2);
                  }
                }
              }
            }
            if (this.listeners.OnceExit) {
              for (let [plugin, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin;
                try {
                  if (root.type === "document") {
                    let roots = root.nodes.map(
                      (subRoot) => visitor(subRoot, this.helpers)
                    );
                    await Promise.all(roots);
                  } else {
                    await visitor(root, this.helpers);
                  }
                } catch (e2) {
                  throw this.handleError(e2);
                }
              }
            }
          }
          this.processed = true;
          return this.stringify();
        }
        runOnRoot(plugin) {
          this.result.lastPlugin = plugin;
          try {
            if (typeof plugin === "object" && plugin.Once) {
              if (this.result.root.type === "document") {
                let roots = this.result.root.nodes.map(
                  (root) => plugin.Once(root, this.helpers)
                );
                if (isPromise(roots[0])) {
                  return Promise.all(roots);
                }
                return roots;
              }
              return plugin.Once(this.result.root, this.helpers);
            } else if (typeof plugin === "function") {
              return plugin(this.result.root, this.result);
            }
          } catch (error) {
            throw this.handleError(error);
          }
        }
        stringify() {
          if (this.error) throw this.error;
          if (this.stringified) return this.result;
          this.stringified = true;
          this.sync();
          let opts = this.result.opts;
          let str = stringify3;
          if (opts.syntax) str = opts.syntax.stringify;
          if (opts.stringifier) str = opts.stringifier;
          if (str.stringify) str = str.stringify;
          let map = new MapGenerator(str, this.result.root, this.result.opts);
          let data = map.generate();
          this.result.css = data[0];
          this.result.map = data[1];
          return this.result;
        }
        sync() {
          if (this.error) throw this.error;
          if (this.processed) return this.result;
          this.processed = true;
          if (this.processing) {
            throw this.getAsyncError();
          }
          for (let plugin of this.plugins) {
            let promise = this.runOnRoot(plugin);
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root = this.result.root;
            while (!root[isClean]) {
              root[isClean] = true;
              this.walkSync(root);
            }
            if (this.listeners.OnceExit) {
              if (root.type === "document") {
                for (let subRoot of root.nodes) {
                  this.visitSync(this.listeners.OnceExit, subRoot);
                }
              } else {
                this.visitSync(this.listeners.OnceExit, root);
              }
            }
          }
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this.opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this.css;
        }
        visitSync(visitors, node2) {
          for (let [plugin, visitor] of visitors) {
            this.result.lastPlugin = plugin;
            let promise;
            try {
              promise = visitor(node2, this.helpers);
            } catch (e2) {
              throw this.handleError(e2, node2.proxyOf);
            }
            if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
              return true;
            }
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
        }
        visitTick(stack) {
          let visit = stack[stack.length - 1];
          let { node: node2, visitors } = visit;
          if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
            stack.pop();
            return;
          }
          if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
            let [plugin, visitor] = visitors[visit.visitorIndex];
            visit.visitorIndex += 1;
            if (visit.visitorIndex === visitors.length) {
              visit.visitors = [];
              visit.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin;
            try {
              return visitor(node2.toProxy(), this.helpers);
            } catch (e2) {
              throw this.handleError(e2, node2);
            }
          }
          if (visit.iterator !== 0) {
            let iterator = visit.iterator;
            let child;
            while (child = node2.nodes[node2.indexes[iterator]]) {
              node2.indexes[iterator] += 1;
              if (!child[isClean]) {
                child[isClean] = true;
                stack.push(toStack(child));
                return;
              }
            }
            visit.iterator = 0;
            delete node2.indexes[iterator];
          }
          let events = visit.events;
          while (visit.eventIndex < events.length) {
            let event = events[visit.eventIndex];
            visit.eventIndex += 1;
            if (event === CHILDREN) {
              if (node2.nodes && node2.nodes.length) {
                node2[isClean] = true;
                visit.iterator = node2.getIterator();
              }
              return;
            } else if (this.listeners[event]) {
              visit.visitors = this.listeners[event];
              return;
            }
          }
          stack.pop();
        }
        walkSync(node2) {
          node2[isClean] = true;
          let events = getEvents(node2);
          for (let event of events) {
            if (event === CHILDREN) {
              if (node2.nodes) {
                node2.each((child) => {
                  if (!child[isClean]) this.walkSync(child);
                });
              }
            } else {
              let visitors = this.listeners[event];
              if (visitors) {
                if (this.visitSync(visitors, node2.toProxy())) return;
              }
            }
          }
        }
        warnings() {
          return this.sync().warnings();
        }
        get content() {
          return this.stringify().content;
        }
        get css() {
          return this.stringify().css;
        }
        get map() {
          return this.stringify().map;
        }
        get messages() {
          return this.sync().messages;
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          return this.sync().root;
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
      };
      LazyResult.registerPostcss = (dependant) => {
        postcss = dependant;
      };
      module.exports = LazyResult;
      LazyResult.default = LazyResult;
      Root2.registerLazyResult(LazyResult);
      Document.registerLazyResult(LazyResult);
    }
  });

  // node_modules/postcss/lib/processor.js
  var require_processor = __commonJS({
    "node_modules/postcss/lib/processor.js"(exports, module) {
      "use strict";
      var NoWorkResult = require_no_work_result();
      var LazyResult = require_lazy_result();
      var Document = require_document();
      var Root2 = require_root();
      var Processor2 = class {
        constructor(plugins = []) {
          this.version = "8.4.38";
          this.plugins = this.normalize(plugins);
        }
        normalize(plugins) {
          let normalized = [];
          for (let i2 of plugins) {
            if (i2.postcss === true) {
              i2 = i2();
            } else if (i2.postcss) {
              i2 = i2.postcss;
            }
            if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
              normalized = normalized.concat(i2.plugins);
            } else if (typeof i2 === "object" && i2.postcssPlugin) {
              normalized.push(i2);
            } else if (typeof i2 === "function") {
              normalized.push(i2);
            } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
              if (true) {
                throw new Error(
                  "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
                );
              }
            } else {
              throw new Error(i2 + " is not a PostCSS plugin");
            }
          }
          return normalized;
        }
        process(css, opts = {}) {
          if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
            return new NoWorkResult(this, css, opts);
          } else {
            return new LazyResult(this, css, opts);
          }
        }
        use(plugin) {
          this.plugins = this.plugins.concat(this.normalize([plugin]));
          return this;
        }
      };
      module.exports = Processor2;
      Processor2.default = Processor2;
      Root2.registerProcessor(Processor2);
      Document.registerProcessor(Processor2);
    }
  });

  // node_modules/postcss-prefix-selector/index.js
  var require_postcss_prefix_selector = __commonJS({
    "node_modules/postcss-prefix-selector/index.js"(exports, module) {
      module.exports = function postcssPrefixSelector(options) {
        const prefix3 = options.prefix;
        const prefixWithSpace = /\s+$/.test(prefix3) ? prefix3 : `${prefix3} `;
        const ignoreFiles = options.ignoreFiles ? [].concat(options.ignoreFiles) : [];
        const includeFiles = options.includeFiles ? [].concat(options.includeFiles) : [];
        return function(root) {
          if (ignoreFiles.length && root.source.input.file && isFileInArray(root.source.input.file, ignoreFiles)) {
            return;
          }
          if (includeFiles.length && root.source.input.file && !isFileInArray(root.source.input.file, includeFiles)) {
            return;
          }
          root.walkRules((rule) => {
            const keyframeRules = [
              "keyframes",
              "-webkit-keyframes",
              "-moz-keyframes",
              "-o-keyframes",
              "-ms-keyframes"
            ];
            if (rule.parent && keyframeRules.includes(rule.parent.name)) {
              return;
            }
            rule.selectors = rule.selectors.map((selector3) => {
              if (options.exclude && excludeSelector(selector3, options.exclude)) {
                return selector3;
              }
              if (options.transform) {
                return options.transform(
                  prefix3,
                  selector3,
                  prefixWithSpace + selector3,
                  root.source.input.file,
                  rule
                );
              }
              return prefixWithSpace + selector3;
            });
          });
        };
      };
      function isFileInArray(file, arr) {
        return arr.some((ruleOrString) => {
          if (ruleOrString instanceof RegExp) {
            return ruleOrString.test(file);
          }
          return file.includes(ruleOrString);
        });
      }
      function excludeSelector(selector3, excludeArr) {
        return excludeArr.some((excludeRule) => {
          if (excludeRule instanceof RegExp) {
            return excludeRule.test(selector3);
          }
          return selector3 === excludeRule;
        });
      }
    }
  });

  // packages/block-editor/node_modules/postcss-value-parser/lib/parse.js
  var require_parse2 = __commonJS({
    "packages/block-editor/node_modules/postcss-value-parser/lib/parse.js"(exports, module) {
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;
      module.exports = function(input) {
        var tokens = [];
        var value = input;
        var next2, quote, prev2, token2, escape, escapePos, whitespacePos, parenthesesOpenPos;
        var pos = 0;
        var code = value.charCodeAt(pos);
        var max = value.length;
        var stack = [{ nodes: tokens }];
        var balanced = 0;
        var parent;
        var name = "";
        var before = "";
        var after = "";
        while (pos < max) {
          if (code <= 32) {
            next2 = pos;
            do {
              next2 += 1;
              code = value.charCodeAt(next2);
            } while (code <= 32);
            token2 = value.slice(pos, next2);
            prev2 = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
              after = token2;
            } else if (prev2 && prev2.type === "div") {
              prev2.after = token2;
              prev2.sourceEndIndex += token2.length;
            } else if (code === comma || code === colon || code === slash && value.charCodeAt(next2 + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
              before = token2;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                sourceEndIndex: next2,
                value: token2
              });
            }
            pos = next2;
          } else if (code === singleQuote || code === doubleQuote) {
            next2 = pos;
            quote = code === singleQuote ? "'" : '"';
            token2 = {
              type: "string",
              sourceIndex: pos,
              quote
            };
            do {
              escape = false;
              next2 = value.indexOf(quote, next2 + 1);
              if (~next2) {
                escapePos = next2;
                while (value.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape = !escape;
                }
              } else {
                value += quote;
                next2 = value.length - 1;
                token2.unclosed = true;
              }
            } while (escape);
            token2.value = value.slice(pos + 1, next2);
            token2.sourceEndIndex = token2.unclosed ? next2 : next2 + 1;
            tokens.push(token2);
            pos = next2 + 1;
            code = value.charCodeAt(pos);
          } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next2 = value.indexOf("*/", pos);
            token2 = {
              type: "comment",
              sourceIndex: pos,
              sourceEndIndex: next2 + 2
            };
            if (next2 === -1) {
              token2.unclosed = true;
              next2 = value.length;
              token2.sourceEndIndex = next2;
            }
            token2.value = value.slice(pos + 2, next2);
            tokens.push(token2);
            pos = next2 + 2;
            code = value.charCodeAt(pos);
          } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
            token2 = value[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token2.length,
              value: token2
            });
            pos += 1;
            code = value.charCodeAt(pos);
          } else if (code === slash || code === comma || code === colon) {
            token2 = value[pos];
            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token2.length,
              value: token2,
              before,
              after: ""
            });
            before = "";
            pos += 1;
            code = value.charCodeAt(pos);
          } else if (openParentheses === code) {
            next2 = pos;
            do {
              next2 += 1;
              code = value.charCodeAt(next2);
            } while (code <= 32);
            parenthesesOpenPos = pos;
            token2 = {
              type: "function",
              sourceIndex: pos - name.length,
              value: name,
              before: value.slice(parenthesesOpenPos + 1, next2)
            };
            pos = next2;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
              next2 -= 1;
              do {
                escape = false;
                next2 = value.indexOf(")", next2 + 1);
                if (~next2) {
                  escapePos = next2;
                  while (value.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape = !escape;
                  }
                } else {
                  value += ")";
                  next2 = value.length - 1;
                  token2.unclosed = true;
                }
              } while (escape);
              whitespacePos = next2;
              do {
                whitespacePos -= 1;
                code = value.charCodeAt(whitespacePos);
              } while (code <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token2.nodes = [
                    {
                      type: "word",
                      sourceIndex: pos,
                      sourceEndIndex: whitespacePos + 1,
                      value: value.slice(pos, whitespacePos + 1)
                    }
                  ];
                } else {
                  token2.nodes = [];
                }
                if (token2.unclosed && whitespacePos + 1 !== next2) {
                  token2.after = "";
                  token2.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    sourceEndIndex: next2,
                    value: value.slice(whitespacePos + 1, next2)
                  });
                } else {
                  token2.after = value.slice(whitespacePos + 1, next2);
                  token2.sourceEndIndex = next2;
                }
              } else {
                token2.after = "";
                token2.nodes = [];
              }
              pos = next2 + 1;
              token2.sourceEndIndex = token2.unclosed ? next2 : pos;
              code = value.charCodeAt(pos);
              tokens.push(token2);
            } else {
              balanced += 1;
              token2.after = "";
              token2.sourceEndIndex = pos + 1;
              tokens.push(token2);
              stack.push(token2);
              tokens = token2.nodes = [];
              parent = token2;
            }
            name = "";
          } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
          } else {
            next2 = pos;
            do {
              if (code === backslash) {
                next2 += 1;
              }
              next2 += 1;
              code = value.charCodeAt(next2);
            } while (next2 < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
            token2 = value.slice(pos, next2);
            if (openParentheses === code) {
              name = token2;
            } else if ((uLower === token2.charCodeAt(0) || uUpper === token2.charCodeAt(0)) && plus === token2.charCodeAt(1) && isUnicodeRange.test(token2.slice(2))) {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                sourceEndIndex: next2,
                value: token2
              });
            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: next2,
                value: token2
              });
            }
            pos = next2;
          }
        }
        for (pos = stack.length - 1; pos; pos -= 1) {
          stack[pos].unclosed = true;
          stack[pos].sourceEndIndex = value.length;
        }
        return stack[0].nodes;
      };
    }
  });

  // packages/block-editor/node_modules/postcss-value-parser/lib/walk.js
  var require_walk = __commonJS({
    "packages/block-editor/node_modules/postcss-value-parser/lib/walk.js"(exports, module) {
      module.exports = function walk(nodes, cb, bubble) {
        var i2, max, node2, result;
        for (i2 = 0, max = nodes.length; i2 < max; i2 += 1) {
          node2 = nodes[i2];
          if (!bubble) {
            result = cb(node2, i2, nodes);
          }
          if (result !== false && node2.type === "function" && Array.isArray(node2.nodes)) {
            walk(node2.nodes, cb, bubble);
          }
          if (bubble) {
            cb(node2, i2, nodes);
          }
        }
      };
    }
  });

  // packages/block-editor/node_modules/postcss-value-parser/lib/stringify.js
  var require_stringify2 = __commonJS({
    "packages/block-editor/node_modules/postcss-value-parser/lib/stringify.js"(exports, module) {
      function stringifyNode(node2, custom) {
        var type = node2.type;
        var value = node2.value;
        var buf;
        var customResult;
        if (custom && (customResult = custom(node2)) !== void 0) {
          return customResult;
        } else if (type === "word" || type === "space") {
          return value;
        } else if (type === "string") {
          buf = node2.quote || "";
          return buf + value + (node2.unclosed ? "" : buf);
        } else if (type === "comment") {
          return "/*" + value + (node2.unclosed ? "" : "*/");
        } else if (type === "div") {
          return (node2.before || "") + value + (node2.after || "");
        } else if (Array.isArray(node2.nodes)) {
          buf = stringify3(node2.nodes, custom);
          if (type !== "function") {
            return buf;
          }
          return value + "(" + (node2.before || "") + buf + (node2.after || "") + (node2.unclosed ? "" : ")");
        }
        return value;
      }
      function stringify3(nodes, custom) {
        var result, i2;
        if (Array.isArray(nodes)) {
          result = "";
          for (i2 = nodes.length - 1; ~i2; i2 -= 1) {
            result = stringifyNode(nodes[i2], custom) + result;
          }
          return result;
        }
        return stringifyNode(nodes, custom);
      }
      module.exports = stringify3;
    }
  });

  // packages/block-editor/node_modules/postcss-value-parser/lib/unit.js
  var require_unit = __commonJS({
    "packages/block-editor/node_modules/postcss-value-parser/lib/unit.js"(exports, module) {
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);
      function likeNumber(value) {
        var code = value.charCodeAt(0);
        var nextCode;
        if (code === plus || code === minus) {
          nextCode = value.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          var nextNextCode = value.charCodeAt(2);
          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code === dot) {
          nextCode = value.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code >= 48 && code <= 57) {
          return true;
        }
        return false;
      }
      module.exports = function(value) {
        var pos = 0;
        var length2 = value.length;
        var code;
        var nextCode;
        var nextNextCode;
        if (length2 === 0 || !likeNumber(value)) {
          return false;
        }
        code = value.charCodeAt(pos);
        if (code === plus || code === minus) {
          pos++;
        }
        while (pos < length2) {
          code = value.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);
        if (code === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;
          while (pos < length2) {
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);
        nextNextCode = value.charCodeAt(pos + 2);
        if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;
          while (pos < length2) {
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        return {
          number: value.slice(0, pos),
          unit: value.slice(pos)
        };
      };
    }
  });

  // packages/block-editor/node_modules/postcss-value-parser/lib/index.js
  var require_lib2 = __commonJS({
    "packages/block-editor/node_modules/postcss-value-parser/lib/index.js"(exports, module) {
      var parse5 = require_parse2();
      var walk = require_walk();
      var stringify3 = require_stringify2();
      function ValueParser(value) {
        if (this instanceof ValueParser) {
          this.nodes = parse5(value);
          return this;
        }
        return new ValueParser(value);
      }
      ValueParser.prototype.toString = function() {
        return Array.isArray(this.nodes) ? stringify3(this.nodes) : "";
      };
      ValueParser.prototype.walk = function(cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };
      ValueParser.unit = require_unit();
      ValueParser.walk = walk;
      ValueParser.stringify = stringify3;
      module.exports = ValueParser;
    }
  });

  // packages/block-editor/node_modules/postcss-urlrebase/index.js
  var require_postcss_urlrebase = __commonJS({
    "packages/block-editor/node_modules/postcss-urlrebase/index.js"(exports, module) {
      var CSSValueParser = require_lib2();
      module.exports = (opts) => {
        const DEFAULTS = {
          skipHostRelativeUrls: true
        };
        const config2 = Object.assign(DEFAULTS, opts);
        return {
          postcssPlugin: "rebaseUrl",
          Declaration(decl) {
            const parsedValue = CSSValueParser(decl.value);
            let valueChanged = false;
            parsedValue.walk((node2) => {
              if (node2.type !== "function" || node2.value !== "url") {
                return;
              }
              const urlVal = node2.nodes[0].value;
              const basedUrl = new URL(urlVal, opts.rootUrl);
              if (basedUrl.pathname === urlVal && config2.skipHostRelativeUrls) {
                return false;
              }
              node2.nodes[0].value = basedUrl.toString();
              valueChanged = true;
              return false;
            });
            if (valueChanged) {
              decl.value = CSSValueParser.stringify(parsedValue);
            }
          }
        };
      };
      module.exports.postcss = true;
    }
  });

  // wordpress-external:@wordpress/priority-queue
  var require_priority_queue = __commonJS({
    "wordpress-external:@wordpress/priority-queue"(exports, module) {
      module.exports = window.wp.priorityQueue;
    }
  });

  // wordpress-external:@wordpress/is-shallow-equal
  var require_is_shallow_equal = __commonJS({
    "wordpress-external:@wordpress/is-shallow-equal"(exports, module) {
      module.exports = window.wp.isShallowEqual;
    }
  });

  // wordpress-external:@wordpress/token-list
  var require_token_list = __commonJS({
    "wordpress-external:@wordpress/token-list"(exports, module) {
      module.exports = window.wp.tokenList;
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      module.exports = function equal(a2, b2) {
        if (a2 === b2) return true;
        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
          if (a2.constructor !== b2.constructor) return false;
          var length2, i2, keys;
          if (Array.isArray(a2)) {
            length2 = a2.length;
            if (length2 != b2.length) return false;
            for (i2 = length2; i2-- !== 0; )
              if (!equal(a2[i2], b2[i2])) return false;
            return true;
          }
          if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
          if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
          if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
          keys = Object.keys(a2);
          length2 = keys.length;
          if (length2 !== Object.keys(b2).length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
          for (i2 = length2; i2-- !== 0; ) {
            var key = keys[i2];
            if (!equal(a2[key], b2[key])) return false;
          }
          return true;
        }
        return a2 !== a2 && b2 !== b2;
      };
    }
  });

  // wordpress-external:@wordpress/commands
  var require_commands = __commonJS({
    "wordpress-external:@wordpress/commands"(exports, module) {
      module.exports = window.wp.commands;
    }
  });

  // wordpress-external:@wordpress/date
  var require_date = __commonJS({
    "wordpress-external:@wordpress/date"(exports, module) {
      module.exports = window.wp.date;
    }
  });

  // node_modules/normalize-wheel/src/UserAgent_DEPRECATED.js
  var require_UserAgent_DEPRECATED = __commonJS({
    "node_modules/normalize-wheel/src/UserAgent_DEPRECATED.js"(exports, module) {
      var _populated = false;
      var _ie;
      var _firefox;
      var _opera;
      var _webkit;
      var _chrome;
      var _ie_real_version;
      var _osx;
      var _windows;
      var _linux;
      var _android;
      var _win64;
      var _iphone;
      var _ipad;
      var _native;
      var _mobile;
      function _populate() {
        if (_populated) {
          return;
        }
        _populated = true;
        var uas = navigator.userAgent;
        var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
        var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
        _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
        _ipad = /\b(iP[ao]d)/.exec(uas);
        _android = /Android/i.exec(uas);
        _native = /FBAN\/\w+;/i.exec(uas);
        _mobile = /Mobile/i.exec(uas);
        _win64 = !!/Win64/.exec(uas);
        if (agent) {
          _ie = agent[1] ? parseFloat(agent[1]) : agent[5] ? parseFloat(agent[5]) : NaN;
          if (_ie && document && document.documentMode) {
            _ie = document.documentMode;
          }
          var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
          _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
          _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
          _opera = agent[3] ? parseFloat(agent[3]) : NaN;
          _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
          if (_webkit) {
            agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
            _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
          } else {
            _chrome = NaN;
          }
        } else {
          _ie = _firefox = _opera = _chrome = _webkit = NaN;
        }
        if (os) {
          if (os[1]) {
            var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
            _osx = ver ? parseFloat(ver[1].replace("_", ".")) : true;
          } else {
            _osx = false;
          }
          _windows = !!os[2];
          _linux = !!os[3];
        } else {
          _osx = _windows = _linux = false;
        }
      }
      var UserAgent_DEPRECATED = {
        /**
         *  Check if the UA is Internet Explorer.
         *
         *
         *  @return float|NaN Version number (if match) or NaN.
         */
        ie: function() {
          return _populate() || _ie;
        },
        /**
         * Check if we're in Internet Explorer compatibility mode.
         *
         * @return bool true if in compatibility mode, false if
         * not compatibility mode or not ie
         */
        ieCompatibilityMode: function() {
          return _populate() || _ie_real_version > _ie;
        },
        /**
         * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
         * only need this because Skype can't handle 64-bit IE yet.  We need to remove
         * this when we don't need it -- tracked by #601957.
         */
        ie64: function() {
          return UserAgent_DEPRECATED.ie() && _win64;
        },
        /**
         *  Check if the UA is Firefox.
         *
         *
         *  @return float|NaN Version number (if match) or NaN.
         */
        firefox: function() {
          return _populate() || _firefox;
        },
        /**
         *  Check if the UA is Opera.
         *
         *
         *  @return float|NaN Version number (if match) or NaN.
         */
        opera: function() {
          return _populate() || _opera;
        },
        /**
         *  Check if the UA is WebKit.
         *
         *
         *  @return float|NaN Version number (if match) or NaN.
         */
        webkit: function() {
          return _populate() || _webkit;
        },
        /**
         *  For Push
         *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
         */
        safari: function() {
          return UserAgent_DEPRECATED.webkit();
        },
        /**
         *  Check if the UA is a Chrome browser.
         *
         *
         *  @return float|NaN Version number (if match) or NaN.
         */
        chrome: function() {
          return _populate() || _chrome;
        },
        /**
         *  Check if the user is running Windows.
         *
         *  @return bool `true' if the user's OS is Windows.
         */
        windows: function() {
          return _populate() || _windows;
        },
        /**
         *  Check if the user is running Mac OS X.
         *
         *  @return float|bool   Returns a float if a version number is detected,
         *                       otherwise true/false.
         */
        osx: function() {
          return _populate() || _osx;
        },
        /**
         * Check if the user is running Linux.
         *
         * @return bool `true' if the user's OS is some flavor of Linux.
         */
        linux: function() {
          return _populate() || _linux;
        },
        /**
         * Check if the user is running on an iPhone or iPod platform.
         *
         * @return bool `true' if the user is running some flavor of the
         *    iPhone OS.
         */
        iphone: function() {
          return _populate() || _iphone;
        },
        mobile: function() {
          return _populate() || (_iphone || _ipad || _android || _mobile);
        },
        nativeApp: function() {
          return _populate() || _native;
        },
        android: function() {
          return _populate() || _android;
        },
        ipad: function() {
          return _populate() || _ipad;
        }
      };
      module.exports = UserAgent_DEPRECATED;
    }
  });

  // node_modules/normalize-wheel/src/ExecutionEnvironment.js
  var require_ExecutionEnvironment = __commonJS({
    "node_modules/normalize-wheel/src/ExecutionEnvironment.js"(exports, module) {
      "use strict";
      var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      var ExecutionEnvironment = {
        canUseDOM,
        canUseWorkers: typeof Worker !== "undefined",
        canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
        canUseViewport: canUseDOM && !!window.screen,
        isInWorker: !canUseDOM
        // For now, this is true - might change in the future.
      };
      module.exports = ExecutionEnvironment;
    }
  });

  // node_modules/normalize-wheel/src/isEventSupported.js
  var require_isEventSupported = __commonJS({
    "node_modules/normalize-wheel/src/isEventSupported.js"(exports, module) {
      "use strict";
      var ExecutionEnvironment = require_ExecutionEnvironment();
      var useHasFeature;
      if (ExecutionEnvironment.canUseDOM) {
        useHasFeature = document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
        // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
        document.implementation.hasFeature("", "") !== true;
      }
      function isEventSupported(eventNameSuffix, capture) {
        if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener" in document)) {
          return false;
        }
        var eventName = "on" + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;");
          isSupported = typeof element[eventName] === "function";
        }
        if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
          isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
        }
        return isSupported;
      }
      module.exports = isEventSupported;
    }
  });

  // node_modules/normalize-wheel/src/normalizeWheel.js
  var require_normalizeWheel = __commonJS({
    "node_modules/normalize-wheel/src/normalizeWheel.js"(exports, module) {
      "use strict";
      var UserAgent_DEPRECATED = require_UserAgent_DEPRECATED();
      var isEventSupported = require_isEventSupported();
      var PIXEL_STEP = 10;
      var LINE_HEIGHT = 40;
      var PAGE_HEIGHT = 800;
      function normalizeWheel2(event) {
        var sX = 0, sY = 0, pX = 0, pY = 0;
        if ("detail" in event) {
          sY = event.detail;
        }
        if ("wheelDelta" in event) {
          sY = -event.wheelDelta / 120;
        }
        if ("wheelDeltaY" in event) {
          sY = -event.wheelDeltaY / 120;
        }
        if ("wheelDeltaX" in event) {
          sX = -event.wheelDeltaX / 120;
        }
        if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
        if ("deltaY" in event) {
          pY = event.deltaY;
        }
        if ("deltaX" in event) {
          pX = event.deltaX;
        }
        if ((pX || pY) && event.deltaMode) {
          if (event.deltaMode == 1) {
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        }
        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }
        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY
        };
      }
      normalizeWheel2.getEventType = function() {
        return UserAgent_DEPRECATED.firefox() ? "DOMMouseScroll" : isEventSupported("wheel") ? "wheel" : "mousewheel";
      };
      module.exports = normalizeWheel2;
    }
  });

  // node_modules/normalize-wheel/index.js
  var require_normalize_wheel = __commonJS({
    "node_modules/normalize-wheel/index.js"(exports, module) {
      module.exports = require_normalizeWheel();
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i2 = 0; i2 < keys.length; ++i2) {
            var key = keys[i2];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e2) {
              }
            }
          }
        }
        return targetComponent;
      }
      module.exports = hoistNonReactStatics;
    }
  });

  // packages/block-editor/build-module/index.js
  var index_exports = {};
  __export(index_exports, {
    AlignmentControl: () => AlignmentControl,
    AlignmentToolbar: () => AlignmentToolbar,
    Autocomplete: () => autocomplete_default,
    BlockAlignmentControl: () => BlockAlignmentControl,
    BlockAlignmentToolbar: () => BlockAlignmentToolbar,
    BlockBreadcrumb: () => block_breadcrumb_default,
    BlockCanvas: () => block_canvas_default,
    BlockColorsStyleSelector: () => color_style_selector_default,
    BlockContextProvider: () => BlockContextProvider,
    BlockControls: () => block_controls_default,
    BlockEdit: () => BlockEdit,
    BlockEditorKeyboardShortcuts: () => keyboard_shortcuts_default,
    BlockEditorProvider: () => provider_default2,
    BlockFormatControls: () => BlockFormatControls,
    BlockIcon: () => block_icon_default,
    BlockInspector: () => block_inspector_default,
    BlockList: () => BlockList,
    BlockMover: () => block_mover_default,
    BlockNavigationDropdown: () => dropdown_default,
    BlockPopover: () => block_popover_default,
    BlockPreview: () => block_preview_default,
    BlockSelectionClearer: () => BlockSelectionClearer,
    BlockSettingsMenu: () => block_settings_menu_default,
    BlockSettingsMenuControls: () => block_settings_menu_controls_default,
    BlockStyles: () => block_styles_default,
    BlockTitle: () => BlockTitle,
    BlockToolbar: () => BlockToolbar,
    BlockTools: () => BlockTools,
    BlockVerticalAlignmentControl: () => BlockVerticalAlignmentControl,
    BlockVerticalAlignmentToolbar: () => BlockVerticalAlignmentToolbar,
    ButtonBlockAppender: () => button_block_appender_default,
    ButtonBlockerAppender: () => ButtonBlockerAppender,
    ColorPalette: () => color_palette_default,
    ColorPaletteControl: () => ColorPaletteControl,
    ContrastChecker: () => contrast_checker_default,
    CopyHandler: () => CopyHandler,
    DefaultBlockAppender: () => DefaultBlockAppender,
    FontSizePicker: () => font_size_picker_default,
    HeadingLevelDropdown: () => HeadingLevelDropdown,
    HeightControl: () => HeightControl,
    InnerBlocks: () => inner_blocks_default,
    Inserter: () => inserter_default,
    InspectorAdvancedControls: () => InspectorAdvancedControls,
    InspectorControls: () => inspector_controls_default,
    JustifyContentControl: () => JustifyContentControl,
    JustifyToolbar: () => JustifyToolbar,
    LineHeightControl: () => line_height_control_default,
    LinkControl: () => link_control_default,
    MediaPlaceholder: () => media_placeholder_default,
    MediaReplaceFlow: () => media_replace_flow_default,
    MediaUpload: () => media_upload_default,
    MediaUploadCheck: () => check_default2,
    MultiSelectScrollIntoView: () => MultiSelectScrollIntoView,
    NavigableToolbar: () => NavigableToolbar,
    ObserveTyping: () => observe_typing_default,
    PanelColorSettings: () => panel_color_settings_default,
    PlainText: () => plain_text_default,
    RecursionProvider: () => RecursionProvider,
    RichText: () => rich_text_default,
    RichTextShortcut: () => RichTextShortcut,
    RichTextToolbarButton: () => RichTextToolbarButton,
    SETTINGS_DEFAULTS: () => SETTINGS_DEFAULTS,
    SkipToSelectedBlock: () => SkipToSelectedBlock,
    Typewriter: () => typewriter_default,
    URLInput: () => url_input_default,
    URLInputButton: () => button_default,
    URLPopover: () => url_popover_default,
    Warning: () => warning_default,
    WritingFlow: () => writing_flow_default,
    __experimentalBlockAlignmentMatrixControl: () => block_alignment_matrix_control_default,
    __experimentalBlockFullHeightAligmentControl: () => block_full_height_alignment_control_default,
    __experimentalBlockPatternSetup: () => block_pattern_setup_default,
    __experimentalBlockPatternsList: () => block_patterns_list_default,
    __experimentalBlockVariationPicker: () => block_variation_picker_default,
    __experimentalBlockVariationTransforms: () => block_variation_transforms_default,
    __experimentalBorderRadiusControl: () => BorderRadiusControl,
    __experimentalColorGradientControl: () => control_default,
    __experimentalColorGradientSettingsDropdown: () => ColorGradientSettingsDropdown,
    __experimentalDateFormatPicker: () => DateFormatPicker,
    __experimentalDuotoneControl: () => duotone_control_default,
    __experimentalFontAppearanceControl: () => FontAppearanceControl,
    __experimentalFontFamilyControl: () => FontFamilyControl,
    __experimentalGetBorderClassesAndStyles: () => getBorderClassesAndStyles,
    __experimentalGetColorClassesAndStyles: () => getColorClassesAndStyles,
    __experimentalGetElementClassName: () => __experimentalGetElementClassName,
    __experimentalGetGapCSSValue: () => getGapCSSValue,
    __experimentalGetGradientClass: () => __experimentalGetGradientClass,
    __experimentalGetGradientObjectByGradientValue: () => __experimentalGetGradientObjectByGradientValue,
    __experimentalGetShadowClassesAndStyles: () => getShadowClassesAndStyles,
    __experimentalGetSpacingClassesAndStyles: () => getSpacingClassesAndStyles,
    __experimentalImageEditor: () => ImageEditor,
    __experimentalImageSizeControl: () => ImageSizeControl,
    __experimentalImageURLInputUI: () => ImageURLInputUI,
    __experimentalInspectorPopoverHeader: () => InspectorPopoverHeader,
    __experimentalLetterSpacingControl: () => LetterSpacingControl,
    __experimentalLibrary: () => library_default,
    __experimentalLinkControl: () => DeprecatedExperimentalLinkControl,
    __experimentalLinkControlSearchInput: () => __experimentalLinkControlSearchInput,
    __experimentalLinkControlSearchItem: () => __experimentalLinkControlSearchItem,
    __experimentalLinkControlSearchResults: () => __experimentalLinkControlSearchResults,
    __experimentalListView: () => list_view_default2,
    __experimentalPanelColorGradientSettings: () => panel_color_gradient_settings_default,
    __experimentalPreviewOptions: () => PreviewOptions,
    __experimentalPublishDateTimePicker: () => publish_date_time_picker_default,
    __experimentalRecursionProvider: () => DeprecatedExperimentalRecursionProvider,
    __experimentalResponsiveBlockControl: () => responsive_block_control_default,
    __experimentalSpacingSizesControl: () => SpacingSizesControl,
    __experimentalTextDecorationControl: () => TextDecorationControl,
    __experimentalTextTransformControl: () => TextTransformControl,
    __experimentalUnitControl: () => UnitControl10,
    __experimentalUseBlockOverlayActive: () => useBlockOverlayActive,
    __experimentalUseBlockPreview: () => useBlockPreview,
    __experimentalUseBorderProps: () => useBorderProps,
    __experimentalUseColorProps: () => useColorProps,
    __experimentalUseCustomSides: () => useCustomSides,
    __experimentalUseGradient: () => __experimentalUseGradient,
    __experimentalUseHasRecursion: () => DeprecatedExperimentalUseHasRecursion,
    __experimentalUseMultipleOriginColorsAndGradients: () => useMultipleOriginColorsAndGradients,
    __experimentalUseResizeCanvas: () => useResizeCanvas,
    __experimentalWritingModeControl: () => WritingModeControl,
    __unstableBlockNameContext: () => block_name_context_default,
    __unstableBlockSettingsMenuFirstItem: () => block_settings_menu_first_item_default,
    __unstableBlockToolbarLastItem: () => block_toolbar_last_item_default,
    __unstableEditorStyles: () => editor_styles_default,
    __unstableIframe: () => iframe_default,
    __unstableInserterMenuExtension: () => inserter_menu_extension_default,
    __unstableRichTextInputEvent: () => __unstableRichTextInputEvent,
    __unstableUseBlockSelectionClearer: () => useBlockSelectionClearer,
    __unstableUseClipboardHandler: () => __unstableUseClipboardHandler,
    __unstableUseMouseMoveTypingReset: () => useMouseMoveTypingReset,
    __unstableUseTypewriter: () => useTypewriter,
    __unstableUseTypingObserver: () => useTypingObserver,
    createCustomColorsHOC: () => createCustomColorsHOC,
    getColorClassName: () => getColorClassName,
    getColorObjectByAttributeValues: () => getColorObjectByAttributeValues,
    getColorObjectByColorValue: () => getColorObjectByColorValue,
    getComputedFluidTypographyValue: () => getComputedFluidTypographyValue,
    getCustomValueFromPreset: () => getCustomValueFromPreset,
    getFontSize: () => getFontSize,
    getFontSizeClass: () => getFontSizeClass,
    getFontSizeObjectByValue: () => getFontSizeObjectByValue,
    getGradientSlugByValue: () => getGradientSlugByValue,
    getGradientValueBySlug: () => getGradientValueBySlug,
    getPxFromCssUnit: () => get_px_from_css_unit_default,
    getSpacingPresetCssVar: () => getSpacingPresetCssVar,
    getTypographyClassesAndStyles: () => getTypographyClassesAndStyles,
    isValueSpacingPreset: () => isValueSpacingPreset,
    privateApis: () => privateApis2,
    store: () => store,
    storeConfig: () => storeConfig,
    transformStyles: () => transform_styles_default,
    useBlockBindingsUtils: () => useBlockBindingsUtils,
    useBlockCommands: () => useBlockCommands,
    useBlockDisplayInformation: () => useBlockDisplayInformation,
    useBlockEditContext: () => useBlockEditContext,
    useBlockEditingMode: () => useBlockEditingMode,
    useBlockProps: () => useBlockProps,
    useCachedTruthy: () => useCachedTruthy,
    useHasRecursion: () => useHasRecursion,
    useInnerBlocksProps: () => useInnerBlocksProps,
    useSetting: () => useSetting,
    useSettings: () => useSettings,
    useStyleOverride: () => useStyleOverride,
    withColorContext: () => with_color_context_default,
    withColors: () => withColors,
    withFontSizes: () => with_font_sizes_default
  });

  // packages/block-editor/build-module/hooks/utils.js
  var import_jsx_runtime368 = __toESM(require_jsx_runtime());
  var import_blocks89 = __toESM(require_blocks());
  var import_element210 = __toESM(require_element());
  var import_data165 = __toESM(require_data());
  var import_compose88 = __toESM(require_compose());
  var import_hooks13 = __toESM(require_hooks());

  // packages/block-editor/build-module/components/block-edit/context.js
  var import_element = __toESM(require_element());
  var mayDisplayControlsKey = Symbol("mayDisplayControls");
  var mayDisplayParentControlsKey = Symbol("mayDisplayParentControls");
  var blockEditingModeKey = Symbol("blockEditingMode");
  var blockBindingsKey = Symbol("blockBindings");
  var isPreviewModeKey = Symbol("isPreviewMode");
  var DEFAULT_BLOCK_EDIT_CONTEXT = {
    name: "",
    isSelected: false
  };
  var Context = (0, import_element.createContext)(DEFAULT_BLOCK_EDIT_CONTEXT);
  Context.displayName = "BlockEditContext";
  var { Provider } = Context;
  function useBlockEditContext() {
    return (0, import_element.useContext)(Context);
  }

  // node_modules/colord/index.mjs
  var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var t = function(r3) {
    return "string" == typeof r3 ? r3.length > 0 : "number" == typeof r3;
  };
  var n = function(r3, t3, n2) {
    return void 0 === t3 && (t3 = 0), void 0 === n2 && (n2 = Math.pow(10, t3)), Math.round(n2 * r3) / n2 + 0;
  };
  var e = function(r3, t3, n2) {
    return void 0 === t3 && (t3 = 0), void 0 === n2 && (n2 = 1), r3 > n2 ? n2 : r3 > t3 ? r3 : t3;
  };
  var u = function(r3) {
    return (r3 = isFinite(r3) ? r3 % 360 : 0) > 0 ? r3 : r3 + 360;
  };
  var a = function(r3) {
    return { r: e(r3.r, 0, 255), g: e(r3.g, 0, 255), b: e(r3.b, 0, 255), a: e(r3.a) };
  };
  var o = function(r3) {
    return { r: n(r3.r), g: n(r3.g), b: n(r3.b), a: n(r3.a, 3) };
  };
  var i = /^#([0-9a-f]{3,8})$/i;
  var s = function(r3) {
    var t3 = r3.toString(16);
    return t3.length < 2 ? "0" + t3 : t3;
  };
  var h = function(r3) {
    var t3 = r3.r, n2 = r3.g, e2 = r3.b, u2 = r3.a, a2 = Math.max(t3, n2, e2), o3 = a2 - Math.min(t3, n2, e2), i2 = o3 ? a2 === t3 ? (n2 - e2) / o3 : a2 === n2 ? 2 + (e2 - t3) / o3 : 4 + (t3 - n2) / o3 : 0;
    return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o3 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
  };
  var b = function(r3) {
    var t3 = r3.h, n2 = r3.s, e2 = r3.v, u2 = r3.a;
    t3 = t3 / 360 * 6, n2 /= 100, e2 /= 100;
    var a2 = Math.floor(t3), o3 = e2 * (1 - n2), i2 = e2 * (1 - (t3 - a2) * n2), s2 = e2 * (1 - (1 - t3 + a2) * n2), h2 = a2 % 6;
    return { r: 255 * [e2, i2, o3, o3, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o3, o3][h2], b: 255 * [o3, o3, s2, e2, e2, i2][h2], a: u2 };
  };
  var g = function(r3) {
    return { h: u(r3.h), s: e(r3.s, 0, 100), l: e(r3.l, 0, 100), a: e(r3.a) };
  };
  var d = function(r3) {
    return { h: n(r3.h), s: n(r3.s), l: n(r3.l), a: n(r3.a, 3) };
  };
  var f = function(r3) {
    return b((n2 = (t3 = r3).s, { h: t3.h, s: (n2 *= ((e2 = t3.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t3.a }));
    var t3, n2, e2;
  };
  var c = function(r3) {
    return { h: (t3 = h(r3)).h, s: (u2 = (200 - (n2 = t3.s)) * (e2 = t3.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t3.a };
    var t3, n2, e2, u2;
  };
  var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var y = { string: [[function(r3) {
    var t3 = i.exec(r3);
    return t3 ? (r3 = t3[1]).length <= 4 ? { r: parseInt(r3[0] + r3[0], 16), g: parseInt(r3[1] + r3[1], 16), b: parseInt(r3[2] + r3[2], 16), a: 4 === r3.length ? n(parseInt(r3[3] + r3[3], 16) / 255, 2) : 1 } : 6 === r3.length || 8 === r3.length ? { r: parseInt(r3.substr(0, 2), 16), g: parseInt(r3.substr(2, 2), 16), b: parseInt(r3.substr(4, 2), 16), a: 8 === r3.length ? n(parseInt(r3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
  }, "hex"], [function(r3) {
    var t3 = v.exec(r3) || m.exec(r3);
    return t3 ? t3[2] !== t3[4] || t3[4] !== t3[6] ? null : a({ r: Number(t3[1]) / (t3[2] ? 100 / 255 : 1), g: Number(t3[3]) / (t3[4] ? 100 / 255 : 1), b: Number(t3[5]) / (t3[6] ? 100 / 255 : 1), a: void 0 === t3[7] ? 1 : Number(t3[7]) / (t3[8] ? 100 : 1) }) : null;
  }, "rgb"], [function(t3) {
    var n2 = l.exec(t3) || p.exec(t3);
    if (!n2) return null;
    var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
    return f(a2);
  }, "hsl"]], object: [[function(r3) {
    var n2 = r3.r, e2 = r3.g, u2 = r3.b, o3 = r3.a, i2 = void 0 === o3 ? 1 : o3;
    return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
  }, "rgb"], [function(r3) {
    var n2 = r3.h, e2 = r3.s, u2 = r3.l, a2 = r3.a, o3 = void 0 === a2 ? 1 : a2;
    if (!t(n2) || !t(e2) || !t(u2)) return null;
    var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o3) });
    return f(i2);
  }, "hsl"], [function(r3) {
    var n2 = r3.h, a2 = r3.s, o3 = r3.v, i2 = r3.a, s2 = void 0 === i2 ? 1 : i2;
    if (!t(n2) || !t(a2) || !t(o3)) return null;
    var h2 = (function(r4) {
      return { h: u(r4.h), s: e(r4.s, 0, 100), v: e(r4.v, 0, 100), a: e(r4.a) };
    })({ h: Number(n2), s: Number(a2), v: Number(o3), a: Number(s2) });
    return b(h2);
  }, "hsv"]] };
  var N = function(r3, t3) {
    for (var n2 = 0; n2 < t3.length; n2++) {
      var e2 = t3[n2][0](r3);
      if (e2) return [e2, t3[n2][1]];
    }
    return [null, void 0];
  };
  var x = function(r3) {
    return "string" == typeof r3 ? N(r3.trim(), y.string) : "object" == typeof r3 && null !== r3 ? N(r3, y.object) : [null, void 0];
  };
  var M = function(r3, t3) {
    var n2 = c(r3);
    return { h: n2.h, s: e(n2.s + 100 * t3, 0, 100), l: n2.l, a: n2.a };
  };
  var H = function(r3) {
    return (299 * r3.r + 587 * r3.g + 114 * r3.b) / 1e3 / 255;
  };
  var $ = function(r3, t3) {
    var n2 = c(r3);
    return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t3, 0, 100), a: n2.a };
  };
  var j = (function() {
    function r3(r4) {
      this.parsed = x(r4)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
    }
    return r3.prototype.isValid = function() {
      return null !== this.parsed;
    }, r3.prototype.brightness = function() {
      return n(H(this.rgba), 2);
    }, r3.prototype.isDark = function() {
      return H(this.rgba) < 0.5;
    }, r3.prototype.isLight = function() {
      return H(this.rgba) >= 0.5;
    }, r3.prototype.toHex = function() {
      return r4 = o(this.rgba), t3 = r4.r, e2 = r4.g, u2 = r4.b, i2 = (a2 = r4.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t3) + s(e2) + s(u2) + i2;
      var r4, t3, e2, u2, a2, i2;
    }, r3.prototype.toRgb = function() {
      return o(this.rgba);
    }, r3.prototype.toRgbString = function() {
      return r4 = o(this.rgba), t3 = r4.r, n2 = r4.g, e2 = r4.b, (u2 = r4.a) < 1 ? "rgba(" + t3 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t3 + ", " + n2 + ", " + e2 + ")";
      var r4, t3, n2, e2, u2;
    }, r3.prototype.toHsl = function() {
      return d(c(this.rgba));
    }, r3.prototype.toHslString = function() {
      return r4 = d(c(this.rgba)), t3 = r4.h, n2 = r4.s, e2 = r4.l, (u2 = r4.a) < 1 ? "hsla(" + t3 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t3 + ", " + n2 + "%, " + e2 + "%)";
      var r4, t3, n2, e2, u2;
    }, r3.prototype.toHsv = function() {
      return r4 = h(this.rgba), { h: n(r4.h), s: n(r4.s), v: n(r4.v), a: n(r4.a, 3) };
      var r4;
    }, r3.prototype.invert = function() {
      return w({ r: 255 - (r4 = this.rgba).r, g: 255 - r4.g, b: 255 - r4.b, a: r4.a });
      var r4;
    }, r3.prototype.saturate = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, r4));
    }, r3.prototype.desaturate = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, -r4));
    }, r3.prototype.grayscale = function() {
      return w(M(this.rgba, -1));
    }, r3.prototype.lighten = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w($(this.rgba, r4));
    }, r3.prototype.darken = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w($(this.rgba, -r4));
    }, r3.prototype.rotate = function(r4) {
      return void 0 === r4 && (r4 = 15), this.hue(this.hue() + r4);
    }, r3.prototype.alpha = function(r4) {
      return "number" == typeof r4 ? w({ r: (t3 = this.rgba).r, g: t3.g, b: t3.b, a: r4 }) : n(this.rgba.a, 3);
      var t3;
    }, r3.prototype.hue = function(r4) {
      var t3 = c(this.rgba);
      return "number" == typeof r4 ? w({ h: r4, s: t3.s, l: t3.l, a: t3.a }) : n(t3.h);
    }, r3.prototype.isEqual = function(r4) {
      return this.toHex() === w(r4).toHex();
    }, r3;
  })();
  var w = function(r3) {
    return r3 instanceof j ? r3 : new j(r3);
  };
  var S = [];
  var k = function(r3) {
    r3.forEach(function(r4) {
      S.indexOf(r4) < 0 && (r4(j, y), S.push(r4));
    });
  };

  // node_modules/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r3 = {};
    for (var d2 in a2) r3[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var d3, i2, n2 = r3[this.toHex()];
      if (n2) return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o3 = this.toRgb(), t3 = 1 / 0, b2 = "black";
        if (!l2.length) for (var c6 in a2) l2[c6] = new e2(a2[c6]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o3, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
          u2 < t3 && (t3 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r4 = f3.toLowerCase(), d3 = "transparent" === r4 ? "#0000" : a2[r4];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }

  // node_modules/colord/plugins/a11y.mjs
  var o2 = function(o3) {
    var t3 = o3 / 255;
    return t3 < 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
  };
  var t2 = function(t3) {
    return 0.2126 * o2(t3.r) + 0.7152 * o2(t3.g) + 0.0722 * o2(t3.b);
  };
  function a11y_default(o3) {
    o3.prototype.luminance = function() {
      return o4 = t2(this.rgba), void 0 === (r3 = 2) && (r3 = 0), void 0 === n2 && (n2 = Math.pow(10, r3)), Math.round(n2 * o4) / n2 + 0;
      var o4, r3, n2;
    }, o3.prototype.contrast = function(r3) {
      void 0 === r3 && (r3 = "#FFF");
      var n2, a2, i2, e2, v2, u2, d2, c6 = r3 instanceof o3 ? r3 : new o3(r3);
      return e2 = this.rgba, v2 = c6.toRgb(), u2 = t2(e2), d2 = t2(v2), n2 = u2 > d2 ? (u2 + 0.05) / (d2 + 0.05) : (d2 + 0.05) / (u2 + 0.05), void 0 === (a2 = 2) && (a2 = 0), void 0 === i2 && (i2 = Math.pow(10, a2)), Math.floor(i2 * n2) / i2 + 0;
    }, o3.prototype.isReadable = function(o4, t3) {
      return void 0 === o4 && (o4 = "#FFF"), void 0 === t3 && (t3 = {}), this.contrast(o4) >= (e2 = void 0 === (i2 = (r3 = t3).size) ? "normal" : i2, "AAA" === (a2 = void 0 === (n2 = r3.level) ? "AA" : n2) && "normal" === e2 ? 7 : "AA" === a2 && "large" === e2 ? 3 : 4.5);
      var r3, n2, a2, i2, e2;
    };
  }

  // packages/block-editor/build-module/components/colors/utils.js
  var import_components = __toESM(require_components());

  // packages/block-editor/build-module/lock-unlock.js
  var import_private_apis = __toESM(require_private_apis());
  var { lock, unlock } = (0, import_private_apis.__dangerousOptInToUnstableAPIsOnlyForCoreModules)(
    "I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.",
    "@wordpress/block-editor"
  );

  // packages/block-editor/build-module/components/colors/utils.js
  k([names_default, a11y_default]);
  var { kebabCase } = unlock(import_components.privateApis);
  var getColorObjectByAttributeValues = (colors2, definedColor, customColor) => {
    if (definedColor) {
      const colorObj = colors2?.find(
        (color) => color.slug === definedColor
      );
      if (colorObj) {
        return colorObj;
      }
    }
    return {
      color: customColor
    };
  };
  var getColorObjectByColorValue = (colors2, colorValue) => {
    return colors2?.find((color) => color.color === colorValue);
  };
  function getColorClassName(colorContextName, colorSlug) {
    if (!colorContextName || !colorSlug) {
      return void 0;
    }
    return `has-${kebabCase(colorSlug)}-${colorContextName}`;
  }
  function getMostReadableColor(colors2, colorValue) {
    const colordColor = w(colorValue);
    const getColorContrast = ({ color }) => colordColor.contrast(color);
    const maxContrast = Math.max(...colors2.map(getColorContrast));
    return colors2.find((color) => getColorContrast(color) === maxContrast).color;
  }

  // packages/block-editor/build-module/components/colors/with-colors.js
  var import_jsx_runtime114 = __toESM(require_jsx_runtime());
  var import_element9 = __toESM(require_element());
  var import_compose2 = __toESM(require_compose());
  var import_components5 = __toESM(require_components());

  // packages/block-editor/build-module/components/use-settings/index.js
  var import_data8 = __toESM(require_data());
  var import_deprecated5 = __toESM(require_deprecated());

  // packages/block-editor/build-module/components/block-edit/index.js
  var import_jsx_runtime113 = __toESM(require_jsx_runtime());
  var import_element8 = __toESM(require_element());
  var import_blocks9 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/block-edit/edit.js
  var import_jsx_runtime110 = __toESM(require_jsx_runtime());

  // node_modules/clsx/dist/clsx.mjs
  function r2(e2) {
    var t3, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2) if (Array.isArray(e2)) {
      var o3 = e2.length;
      for (t3 = 0; t3 < o3; t3++) e2[t3] && (f2 = r2(e2[t3])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx() {
    for (var e2, t3, f2 = 0, n2 = "", o3 = arguments.length; f2 < o3; f2++) (e2 = arguments[f2]) && (t3 = r2(e2)) && (n2 && (n2 += " "), n2 += t3);
    return n2;
  }
  var clsx_default = clsx;

  // packages/block-editor/build-module/components/block-edit/edit.js
  var import_blocks7 = __toESM(require_blocks());
  var import_components2 = __toESM(require_components());
  var import_data6 = __toESM(require_data());
  var import_element7 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-context/index.js
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var import_element2 = __toESM(require_element());
  var Context2 = (0, import_element2.createContext)({});
  Context2.displayName = "BlockContext";
  function BlockContextProvider({ value, children }) {
    const context = (0, import_element2.useContext)(Context2);
    const nextValue = (0, import_element2.useMemo)(
      () => ({ ...context, ...value }),
      [context, value]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context2.Provider, { value: nextValue, children });
  }
  var block_context_default = Context2;

  // packages/block-editor/build-module/components/link-control/is-url-like.js
  var import_url = __toESM(require_url());
  function isURLLike(val) {
    const hasSpaces = val.includes(" ");
    if (hasSpaces) {
      return false;
    }
    const protocol = (0, import_url.getProtocol)(val);
    const protocolIsValid = (0, import_url.isValidProtocol)(protocol);
    const mayBeTLD = hasPossibleTLD(val);
    const isWWW = val?.startsWith("www.");
    const isInternal = val?.startsWith("#") && (0, import_url.isValidFragment)(val);
    return protocolIsValid || isWWW || isInternal || mayBeTLD;
  }
  function hasPossibleTLD(url, maxLength = 6) {
    const cleanedURL = url.split(/[?#]/)[0];
    const regex = new RegExp(
      `(?<=\\S)\\.(?:[a-zA-Z_]{2,${maxLength}})(?:\\/|$)`
    );
    return regex.test(cleanedURL);
  }

  // packages/block-editor/build-module/utils/block-bindings.js
  var import_data5 = __toESM(require_data());

  // packages/block-editor/build-module/store/index.js
  var import_data4 = __toESM(require_data());

  // packages/block-editor/build-module/store/reducer.js
  var import_es6 = __toESM(require_es6());
  var import_compose = __toESM(require_compose());
  var import_data = __toESM(require_data());
  var import_deprecated = __toESM(require_deprecated());
  var import_blocks = __toESM(require_blocks());

  // packages/block-editor/build-module/store/defaults.js
  var import_i18n = __toESM(require_i18n());
  var PREFERENCES_DEFAULTS = {
    insertUsage: {}
  };
  var SETTINGS_DEFAULTS = {
    alignWide: false,
    supportsLayout: true,
    // colors setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
    // The setting is only kept for backward compatibility purposes.
    colors: [
      {
        name: (0, import_i18n.__)("Black"),
        slug: "black",
        color: "#000000"
      },
      {
        name: (0, import_i18n.__)("Cyan bluish gray"),
        slug: "cyan-bluish-gray",
        color: "#abb8c3"
      },
      {
        name: (0, import_i18n.__)("White"),
        slug: "white",
        color: "#ffffff"
      },
      {
        name: (0, import_i18n.__)("Pale pink"),
        slug: "pale-pink",
        color: "#f78da7"
      },
      { name: (0, import_i18n.__)("Vivid red"), slug: "vivid-red", color: "#cf2e2e" },
      {
        name: (0, import_i18n.__)("Luminous vivid orange"),
        slug: "luminous-vivid-orange",
        color: "#ff6900"
      },
      {
        name: (0, import_i18n.__)("Luminous vivid amber"),
        slug: "luminous-vivid-amber",
        color: "#fcb900"
      },
      {
        name: (0, import_i18n.__)("Light green cyan"),
        slug: "light-green-cyan",
        color: "#7bdcb5"
      },
      {
        name: (0, import_i18n.__)("Vivid green cyan"),
        slug: "vivid-green-cyan",
        color: "#00d084"
      },
      {
        name: (0, import_i18n.__)("Pale cyan blue"),
        slug: "pale-cyan-blue",
        color: "#8ed1fc"
      },
      {
        name: (0, import_i18n.__)("Vivid cyan blue"),
        slug: "vivid-cyan-blue",
        color: "#0693e3"
      },
      {
        name: (0, import_i18n.__)("Vivid purple"),
        slug: "vivid-purple",
        color: "#9b51e0"
      }
    ],
    // fontSizes setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
    // The setting is only kept for backward compatibility purposes.
    fontSizes: [
      {
        name: (0, import_i18n._x)("Small", "font size name"),
        size: 13,
        slug: "small"
      },
      {
        name: (0, import_i18n._x)("Normal", "font size name"),
        size: 16,
        slug: "normal"
      },
      {
        name: (0, import_i18n._x)("Medium", "font size name"),
        size: 20,
        slug: "medium"
      },
      {
        name: (0, import_i18n._x)("Large", "font size name"),
        size: 36,
        slug: "large"
      },
      {
        name: (0, import_i18n._x)("Huge", "font size name"),
        size: 42,
        slug: "huge"
      }
    ],
    // Image default size slug.
    imageDefaultSize: "large",
    imageSizes: [
      { slug: "thumbnail", name: (0, import_i18n.__)("Thumbnail") },
      { slug: "medium", name: (0, import_i18n.__)("Medium") },
      { slug: "large", name: (0, import_i18n.__)("Large") },
      { slug: "full", name: (0, import_i18n.__)("Full Size") }
    ],
    // Allow plugin to disable Image Editor if need be.
    imageEditing: true,
    // This is current max width of the block inner area
    // It's used to constraint image resizing and this value could be overridden later by themes
    maxWidth: 580,
    // Allowed block types for the editor, defaulting to true (all supported).
    allowedBlockTypes: true,
    // Maximum upload size in bytes allowed for the site.
    maxUploadFileSize: 0,
    // List of allowed mime types and file extensions.
    allowedMimeTypes: null,
    // Allows to disable block locking interface.
    canLockBlocks: true,
    // Allows to disable Openverse media category in the inserter.
    enableOpenverseMediaCategory: true,
    clearBlockSelection: true,
    __experimentalCanUserUseUnfilteredHTML: false,
    __experimentalBlockDirectory: false,
    __mobileEnablePageTemplates: false,
    __experimentalBlockPatterns: [],
    __experimentalBlockPatternCategories: [],
    isPreviewMode: false,
    // These settings will be completely revamped in the future.
    // The goal is to evolve this into an API which will instruct
    // the block inspector to animate transitions between what it
    // displays based on the relationship between the selected block
    // and its parent, and only enable it if the parent is controlling
    // its children blocks.
    blockInspectorAnimation: {
      animationParent: "core/navigation",
      "core/navigation": { enterDirection: "leftToRight" },
      "core/navigation-submenu": { enterDirection: "rightToLeft" },
      "core/navigation-link": { enterDirection: "rightToLeft" },
      "core/search": { enterDirection: "rightToLeft" },
      "core/social-links": { enterDirection: "rightToLeft" },
      "core/page-list": { enterDirection: "rightToLeft" },
      "core/spacer": { enterDirection: "rightToLeft" },
      "core/home-link": { enterDirection: "rightToLeft" },
      "core/site-title": { enterDirection: "rightToLeft" },
      "core/site-logo": { enterDirection: "rightToLeft" }
    },
    generateAnchors: false,
    // gradients setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
    // The setting is only kept for backward compatibility purposes.
    gradients: [
      {
        name: (0, import_i18n.__)("Vivid cyan blue to vivid purple"),
        gradient: "linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)",
        slug: "vivid-cyan-blue-to-vivid-purple"
      },
      {
        name: (0, import_i18n.__)("Light green cyan to vivid green cyan"),
        gradient: "linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)",
        slug: "light-green-cyan-to-vivid-green-cyan"
      },
      {
        name: (0, import_i18n.__)("Luminous vivid amber to luminous vivid orange"),
        gradient: "linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)",
        slug: "luminous-vivid-amber-to-luminous-vivid-orange"
      },
      {
        name: (0, import_i18n.__)("Luminous vivid orange to vivid red"),
        gradient: "linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)",
        slug: "luminous-vivid-orange-to-vivid-red"
      },
      {
        name: (0, import_i18n.__)("Very light gray to cyan bluish gray"),
        gradient: "linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)",
        slug: "very-light-gray-to-cyan-bluish-gray"
      },
      {
        name: (0, import_i18n.__)("Cool to warm spectrum"),
        gradient: "linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)",
        slug: "cool-to-warm-spectrum"
      },
      {
        name: (0, import_i18n.__)("Blush light purple"),
        gradient: "linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)",
        slug: "blush-light-purple"
      },
      {
        name: (0, import_i18n.__)("Blush bordeaux"),
        gradient: "linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)",
        slug: "blush-bordeaux"
      },
      {
        name: (0, import_i18n.__)("Luminous dusk"),
        gradient: "linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)",
        slug: "luminous-dusk"
      },
      {
        name: (0, import_i18n.__)("Pale ocean"),
        gradient: "linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)",
        slug: "pale-ocean"
      },
      {
        name: (0, import_i18n.__)("Electric grass"),
        gradient: "linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)",
        slug: "electric-grass"
      },
      {
        name: (0, import_i18n.__)("Midnight"),
        gradient: "linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)",
        slug: "midnight"
      }
    ],
    __unstableResolvedAssets: { styles: [], scripts: [] }
  };

  // packages/block-editor/build-module/store/array.js
  function insertAt(array, elements, index) {
    return [
      ...array.slice(0, index),
      ...Array.isArray(elements) ? elements : [elements],
      ...array.slice(index)
    ];
  }
  function moveTo(array, from2, to2, count = 1) {
    const withoutMovedElements = [...array];
    withoutMovedElements.splice(from2, count);
    return insertAt(
      withoutMovedElements,
      array.slice(from2, from2 + count),
      to2
    );
  }

  // packages/block-editor/build-module/store/private-keys.js
  var globalStylesDataKey = Symbol("globalStylesDataKey");
  var globalStylesLinksDataKey = Symbol("globalStylesLinks");
  var selectBlockPatternsKey = Symbol("selectBlockPatternsKey");
  var reusableBlocksSelectKey = Symbol("reusableBlocksSelect");
  var sectionRootClientIdKey = Symbol("sectionRootClientIdKey");
  var mediaEditKey = Symbol("mediaEditKey");
  var essentialFormatKey = Symbol("essentialFormat");

  // packages/block-editor/build-module/store/reducer.js
  var { isContentBlock } = unlock(import_blocks.privateApis);
  var identity = (x2) => x2;
  function mapBlockOrder(blocks2, rootClientId = "") {
    const result = /* @__PURE__ */ new Map();
    const current = [];
    result.set(rootClientId, current);
    blocks2.forEach((block) => {
      const { clientId, innerBlocks } = block;
      current.push(clientId);
      mapBlockOrder(innerBlocks, clientId).forEach(
        (order, subClientId) => {
          result.set(subClientId, order);
        }
      );
    });
    return result;
  }
  function mapBlockParents(blocks2, rootClientId = "") {
    const result = [];
    const stack = [[rootClientId, blocks2]];
    while (stack.length) {
      const [parent, currentBlocks] = stack.shift();
      currentBlocks.forEach(({ innerBlocks, ...block }) => {
        result.push([block.clientId, parent]);
        if (innerBlocks?.length) {
          stack.push([block.clientId, innerBlocks]);
        }
      });
    }
    return result;
  }
  function flattenBlocks(blocks2, transform = identity) {
    const result = [];
    const stack = [...blocks2];
    while (stack.length) {
      const { innerBlocks, ...block } = stack.shift();
      stack.push(...innerBlocks);
      result.push([block.clientId, transform(block)]);
    }
    return result;
  }
  function getFlattenedClientIds(blocks2) {
    const result = {};
    const stack = [...blocks2];
    while (stack.length) {
      const { innerBlocks, ...block } = stack.shift();
      stack.push(...innerBlocks);
      result[block.clientId] = true;
    }
    return result;
  }
  function getFlattenedBlocksWithoutAttributes(blocks2) {
    return flattenBlocks(blocks2, (block) => {
      const { attributes, ...restBlock } = block;
      return restBlock;
    });
  }
  function getFlattenedBlockAttributes(blocks2) {
    return flattenBlocks(blocks2, (block) => block.attributes);
  }
  function hasSameKeys(a2, b2) {
    return (0, import_es6.default)(Object.keys(a2), Object.keys(b2));
  }
  function isUpdatingSameBlockAttribute(action, lastAction) {
    return action.type === "UPDATE_BLOCK_ATTRIBUTES" && lastAction !== void 0 && lastAction.type === "UPDATE_BLOCK_ATTRIBUTES" && (0, import_es6.default)(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
  }
  function updateBlockTreeForBlocks(state, blocks2) {
    const treeToUpdate = state.tree;
    const stack = [...blocks2];
    const flattenedBlocks = [...blocks2];
    while (stack.length) {
      const block = stack.shift();
      stack.push(...block.innerBlocks);
      flattenedBlocks.push(...block.innerBlocks);
    }
    for (const block of flattenedBlocks) {
      treeToUpdate.set(block.clientId, {});
    }
    for (const block of flattenedBlocks) {
      treeToUpdate.set(
        block.clientId,
        Object.assign(treeToUpdate.get(block.clientId), {
          ...state.byClientId.get(block.clientId),
          attributes: state.attributes.get(block.clientId),
          innerBlocks: block.innerBlocks.map(
            (subBlock) => treeToUpdate.get(subBlock.clientId)
          )
        })
      );
    }
  }
  function updateParentInnerBlocksInTree(state, updatedClientIds, updateChildrenOfUpdatedClientIds = false) {
    const treeToUpdate = state.tree;
    const uncontrolledParents = /* @__PURE__ */ new Set([]);
    const controlledParents = /* @__PURE__ */ new Set();
    for (const clientId of updatedClientIds) {
      let current = updateChildrenOfUpdatedClientIds ? clientId : state.parents.get(clientId);
      do {
        if (state.controlledInnerBlocks[current]) {
          controlledParents.add(current);
          break;
        } else {
          uncontrolledParents.add(current);
          current = state.parents.get(current);
        }
      } while (current !== void 0);
    }
    for (const clientId of uncontrolledParents) {
      treeToUpdate.set(clientId, { ...treeToUpdate.get(clientId) });
    }
    for (const clientId of uncontrolledParents) {
      treeToUpdate.get(clientId).innerBlocks = (state.order.get(clientId) || []).map((subClientId) => treeToUpdate.get(subClientId));
    }
    for (const clientId of controlledParents) {
      treeToUpdate.set("controlled||" + clientId, {
        innerBlocks: (state.order.get(clientId) || []).map(
          (subClientId) => treeToUpdate.get(subClientId)
        )
      });
    }
  }
  var withBlockTree = (reducer4) => (state = {}, action) => {
    const newState = reducer4(state, action);
    if (newState === state) {
      return state;
    }
    newState.tree = state.tree ? state.tree : /* @__PURE__ */ new Map();
    switch (action.type) {
      case "RECEIVE_BLOCKS":
      case "INSERT_BLOCKS": {
        newState.tree = new Map(newState.tree);
        updateBlockTreeForBlocks(newState, action.blocks);
        updateParentInnerBlocksInTree(
          newState,
          action.rootClientId ? [action.rootClientId] : [""],
          true
        );
        break;
      }
      case "UPDATE_BLOCK":
        newState.tree = new Map(newState.tree);
        newState.tree.set(action.clientId, {
          ...newState.tree.get(action.clientId),
          ...newState.byClientId.get(action.clientId),
          attributes: newState.attributes.get(action.clientId)
        });
        updateParentInnerBlocksInTree(
          newState,
          [action.clientId],
          false
        );
        break;
      case "SYNC_DERIVED_BLOCK_ATTRIBUTES":
      case "UPDATE_BLOCK_ATTRIBUTES": {
        newState.tree = new Map(newState.tree);
        action.clientIds.forEach((clientId) => {
          newState.tree.set(clientId, {
            ...newState.tree.get(clientId),
            attributes: newState.attributes.get(clientId)
          });
        });
        updateParentInnerBlocksInTree(
          newState,
          action.clientIds,
          false
        );
        break;
      }
      case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const inserterClientIds = getFlattenedClientIds(
          action.blocks
        );
        newState.tree = new Map(newState.tree);
        action.replacedClientIds.forEach((clientId) => {
          newState.tree.delete(clientId);
          if (!inserterClientIds[clientId]) {
            newState.tree.delete("controlled||" + clientId);
          }
        });
        updateBlockTreeForBlocks(newState, action.blocks);
        updateParentInnerBlocksInTree(
          newState,
          action.blocks.map((b2) => b2.clientId),
          false
        );
        const parentsOfRemovedBlocks2 = [];
        for (const clientId of action.clientIds) {
          const parentId = state.parents.get(clientId);
          if (parentId !== void 0 && (parentId === "" || newState.byClientId.get(parentId))) {
            parentsOfRemovedBlocks2.push(parentId);
          }
        }
        updateParentInnerBlocksInTree(
          newState,
          parentsOfRemovedBlocks2,
          true
        );
        break;
      }
      case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN":
        const parentsOfRemovedBlocks = [];
        for (const clientId of action.clientIds) {
          const parentId = state.parents.get(clientId);
          if (parentId !== void 0 && (parentId === "" || newState.byClientId.get(parentId))) {
            parentsOfRemovedBlocks.push(parentId);
          }
        }
        newState.tree = new Map(newState.tree);
        action.removedClientIds.forEach((clientId) => {
          newState.tree.delete(clientId);
          newState.tree.delete("controlled||" + clientId);
        });
        updateParentInnerBlocksInTree(
          newState,
          parentsOfRemovedBlocks,
          true
        );
        break;
      case "MOVE_BLOCKS_TO_POSITION": {
        const updatedBlockUids = [];
        if (action.fromRootClientId) {
          updatedBlockUids.push(action.fromRootClientId);
        } else {
          updatedBlockUids.push("");
        }
        if (action.toRootClientId) {
          updatedBlockUids.push(action.toRootClientId);
        }
        newState.tree = new Map(newState.tree);
        updateParentInnerBlocksInTree(
          newState,
          updatedBlockUids,
          true
        );
        break;
      }
      case "MOVE_BLOCKS_UP":
      case "MOVE_BLOCKS_DOWN": {
        const updatedBlockUids = [
          action.rootClientId ? action.rootClientId : ""
        ];
        newState.tree = new Map(newState.tree);
        updateParentInnerBlocksInTree(
          newState,
          updatedBlockUids,
          true
        );
        break;
      }
      case "SAVE_REUSABLE_BLOCK_SUCCESS": {
        const updatedBlockUids = [];
        newState.attributes.forEach((attributes, clientId) => {
          if (newState.byClientId.get(clientId).name === "core/block" && attributes.ref === action.updatedId) {
            updatedBlockUids.push(clientId);
          }
        });
        newState.tree = new Map(newState.tree);
        updatedBlockUids.forEach((clientId) => {
          newState.tree.set(clientId, {
            ...newState.byClientId.get(clientId),
            attributes: newState.attributes.get(clientId),
            innerBlocks: newState.tree.get(clientId).innerBlocks
          });
        });
        updateParentInnerBlocksInTree(
          newState,
          updatedBlockUids,
          false
        );
      }
    }
    return newState;
  };
  function withPersistentBlockChange(reducer4) {
    let lastAction;
    let markNextChangeAsNotPersistent = false;
    let explicitPersistent;
    return (state, action) => {
      let nextState = reducer4(state, action);
      let nextIsPersistentChange;
      if (action.type === "SET_EXPLICIT_PERSISTENT") {
        explicitPersistent = action.isPersistentChange;
        nextIsPersistentChange = state.isPersistentChange ?? true;
      }
      if (explicitPersistent !== void 0) {
        nextIsPersistentChange = explicitPersistent;
        return nextIsPersistentChange === nextState.isPersistentChange ? nextState : {
          ...nextState,
          isPersistentChange: nextIsPersistentChange
        };
      }
      const isExplicitPersistentChange = action.type === "MARK_LAST_CHANGE_AS_PERSISTENT" || markNextChangeAsNotPersistent;
      if (state === nextState && !isExplicitPersistentChange) {
        markNextChangeAsNotPersistent = action.type === "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT";
        nextIsPersistentChange = state?.isPersistentChange ?? true;
        if (state.isPersistentChange === nextIsPersistentChange) {
          return state;
        }
        return {
          ...nextState,
          isPersistentChange: nextIsPersistentChange
        };
      }
      nextState = {
        ...nextState,
        isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
      };
      lastAction = action;
      markNextChangeAsNotPersistent = action.type === "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT";
      return nextState;
    };
  }
  function withIgnoredBlockChange(reducer4) {
    const IGNORED_ACTION_TYPES = /* @__PURE__ */ new Set(["RECEIVE_BLOCKS"]);
    return (state, action) => {
      const nextState = reducer4(state, action);
      if (nextState !== state) {
        nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
      }
      return nextState;
    };
  }
  var withInnerBlocksRemoveCascade = (reducer4) => (state, action) => {
    const getAllChildren = (clientIds) => {
      let result = clientIds;
      for (let i2 = 0; i2 < result.length; i2++) {
        if (!state.order.get(result[i2]) || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i2]]) {
          continue;
        }
        if (result === clientIds) {
          result = [...result];
        }
        result.push(...state.order.get(result[i2]));
      }
      return result;
    };
    if (state) {
      switch (action.type) {
        case "REMOVE_BLOCKS":
          action = {
            ...action,
            type: "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN",
            removedClientIds: getAllChildren(action.clientIds)
          };
          break;
        case "REPLACE_BLOCKS":
          action = {
            ...action,
            type: "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN",
            replacedClientIds: getAllChildren(action.clientIds)
          };
          break;
      }
    }
    return reducer4(state, action);
  };
  var withBlockReset = (reducer4) => (state, action) => {
    if (action.type === "RESET_BLOCKS") {
      const newState = {
        ...state,
        byClientId: new Map(
          getFlattenedBlocksWithoutAttributes(action.blocks)
        ),
        attributes: new Map(getFlattenedBlockAttributes(action.blocks)),
        order: mapBlockOrder(action.blocks),
        parents: new Map(mapBlockParents(action.blocks)),
        controlledInnerBlocks: {}
      };
      newState.tree = new Map(state?.tree);
      updateBlockTreeForBlocks(newState, action.blocks);
      newState.tree.set("", {
        innerBlocks: action.blocks.map(
          (subBlock) => newState.tree.get(subBlock.clientId)
        )
      });
      return newState;
    }
    return reducer4(state, action);
  };
  var withReplaceInnerBlocks = (reducer4) => (state, action) => {
    if (action.type !== "REPLACE_INNER_BLOCKS") {
      return reducer4(state, action);
    }
    const nestedControllers = {};
    if (Object.keys(state.controlledInnerBlocks).length) {
      const stack = [...action.blocks];
      while (stack.length) {
        const { innerBlocks, ...block } = stack.shift();
        stack.push(...innerBlocks);
        if (!!state.controlledInnerBlocks[block.clientId]) {
          nestedControllers[block.clientId] = true;
        }
      }
    }
    let stateAfterBlocksRemoval = state;
    if (state.order.get(action.rootClientId)) {
      stateAfterBlocksRemoval = reducer4(stateAfterBlocksRemoval, {
        type: "REMOVE_BLOCKS",
        keepControlledInnerBlocks: nestedControllers,
        clientIds: state.order.get(action.rootClientId)
      });
    }
    let stateAfterInsert = stateAfterBlocksRemoval;
    if (action.blocks.length) {
      stateAfterInsert = reducer4(stateAfterInsert, {
        ...action,
        type: "INSERT_BLOCKS",
        index: 0
      });
      const stateAfterInsertOrder = new Map(stateAfterInsert.order);
      Object.keys(nestedControllers).forEach((key) => {
        if (state.order.get(key)) {
          stateAfterInsertOrder.set(key, state.order.get(key));
        }
      });
      stateAfterInsert.order = stateAfterInsertOrder;
      stateAfterInsert.tree = new Map(stateAfterInsert.tree);
      Object.keys(nestedControllers).forEach((_key) => {
        const key = `controlled||${_key}`;
        if (state.tree.has(key)) {
          stateAfterInsert.tree.set(key, state.tree.get(key));
        }
      });
    }
    return stateAfterInsert;
  };
  var withSaveReusableBlock = (reducer4) => (state, action) => {
    if (state && action.type === "SAVE_REUSABLE_BLOCK_SUCCESS") {
      const { id, updatedId } = action;
      if (id === updatedId) {
        return state;
      }
      state = { ...state };
      state.attributes = new Map(state.attributes);
      state.attributes.forEach((attributes, clientId) => {
        const { name } = state.byClientId.get(clientId);
        if (name === "core/block" && attributes.ref === id) {
          state.attributes.set(clientId, {
            ...attributes,
            ref: updatedId
          });
        }
      });
    }
    return reducer4(state, action);
  };
  var withResetControlledBlocks = (reducer4) => (state, action) => {
    if (action.type === "SET_HAS_CONTROLLED_INNER_BLOCKS") {
      const tempState = reducer4(state, {
        type: "REPLACE_INNER_BLOCKS",
        rootClientId: action.clientId,
        blocks: []
      });
      return reducer4(tempState, action);
    }
    return reducer4(state, action);
  };
  var blocks = (0, import_compose.pipe)(
    import_data.combineReducers,
    withSaveReusableBlock,
    // Needs to be before withBlockCache.
    withBlockTree,
    // Needs to be before withInnerBlocksRemoveCascade.
    withInnerBlocksRemoveCascade,
    withReplaceInnerBlocks,
    // Needs to be after withInnerBlocksRemoveCascade.
    withBlockReset,
    withPersistentBlockChange,
    withIgnoredBlockChange,
    withResetControlledBlocks
  )({
    // The state is using a Map instead of a plain object for performance reasons.
    // You can run the "./test/performance.js" unit test to check the impact
    // code changes can have on this reducer.
    byClientId(state = /* @__PURE__ */ new Map(), action) {
      switch (action.type) {
        case "RECEIVE_BLOCKS":
        case "INSERT_BLOCKS": {
          const newState = new Map(state);
          getFlattenedBlocksWithoutAttributes(action.blocks).forEach(
            ([key, value]) => {
              newState.set(key, value);
            }
          );
          return newState;
        }
        case "UPDATE_BLOCK": {
          if (!state.has(action.clientId)) {
            return state;
          }
          const { attributes, ...changes } = action.updates;
          if (Object.values(changes).length === 0) {
            return state;
          }
          const newState = new Map(state);
          newState.set(action.clientId, {
            ...state.get(action.clientId),
            ...changes
          });
          return newState;
        }
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          if (!action.blocks) {
            return state;
          }
          const newState = new Map(state);
          action.replacedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          getFlattenedBlocksWithoutAttributes(action.blocks).forEach(
            ([key, value]) => {
              newState.set(key, value);
            }
          );
          return newState;
        }
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          const newState = new Map(state);
          action.removedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          return newState;
        }
      }
      return state;
    },
    // The state is using a Map instead of a plain object for performance reasons.
    // You can run the "./test/performance.js" unit test to check the impact
    // code changes can have on this reducer.
    attributes(state = /* @__PURE__ */ new Map(), action) {
      switch (action.type) {
        case "RECEIVE_BLOCKS":
        case "INSERT_BLOCKS": {
          const newState = new Map(state);
          getFlattenedBlockAttributes(action.blocks).forEach(
            ([key, value]) => {
              newState.set(key, value);
            }
          );
          return newState;
        }
        case "UPDATE_BLOCK": {
          if (!state.get(action.clientId) || !action.updates.attributes) {
            return state;
          }
          const newState = new Map(state);
          newState.set(action.clientId, {
            ...state.get(action.clientId),
            ...action.updates.attributes
          });
          return newState;
        }
        case "SYNC_DERIVED_BLOCK_ATTRIBUTES":
        case "UPDATE_BLOCK_ATTRIBUTES": {
          if (action.clientIds.every((id) => !state.get(id))) {
            return state;
          }
          let hasChange = false;
          const newState = new Map(state);
          for (const clientId of action.clientIds) {
            const updatedAttributeEntries = Object.entries(
              !!action.options?.uniqueByBlock ? action.attributes[clientId] : action.attributes ?? {}
            );
            if (updatedAttributeEntries.length === 0) {
              continue;
            }
            let hasUpdatedAttributes = false;
            const existingAttributes = state.get(clientId);
            const newAttributes = {};
            updatedAttributeEntries.forEach(([key, value]) => {
              if (existingAttributes[key] !== value) {
                hasUpdatedAttributes = true;
                newAttributes[key] = value;
              }
            });
            hasChange = hasChange || hasUpdatedAttributes;
            if (hasUpdatedAttributes) {
              newState.set(clientId, {
                ...existingAttributes,
                ...newAttributes
              });
            }
          }
          return hasChange ? newState : state;
        }
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          if (!action.blocks) {
            return state;
          }
          const newState = new Map(state);
          action.replacedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          getFlattenedBlockAttributes(action.blocks).forEach(
            ([key, value]) => {
              newState.set(key, value);
            }
          );
          return newState;
        }
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          const newState = new Map(state);
          action.removedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          return newState;
        }
      }
      return state;
    },
    // The state is using a Map instead of a plain object for performance reasons.
    // You can run the "./test/performance.js" unit test to check the impact
    // code changes can have on this reducer.
    order(state = /* @__PURE__ */ new Map(), action) {
      switch (action.type) {
        case "RECEIVE_BLOCKS": {
          const blockOrder = mapBlockOrder(action.blocks);
          const newState = new Map(state);
          blockOrder.forEach((order, clientId) => {
            if (clientId !== "") {
              newState.set(clientId, order);
            }
          });
          newState.set(
            "",
            (state.get("") ?? []).concat(blockOrder[""])
          );
          return newState;
        }
        case "INSERT_BLOCKS": {
          const { rootClientId = "" } = action;
          const subState = state.get(rootClientId) || [];
          const mappedBlocks = mapBlockOrder(
            action.blocks,
            rootClientId
          );
          const { index = subState.length } = action;
          const newState = new Map(state);
          mappedBlocks.forEach((order, clientId) => {
            newState.set(clientId, order);
          });
          newState.set(
            rootClientId,
            insertAt(
              subState,
              mappedBlocks.get(rootClientId),
              index
            )
          );
          return newState;
        }
        case "MOVE_BLOCKS_TO_POSITION": {
          const {
            fromRootClientId = "",
            toRootClientId = "",
            clientIds
          } = action;
          const { index = state.get(toRootClientId).length } = action;
          if (fromRootClientId === toRootClientId) {
            const subState = state.get(toRootClientId);
            const fromIndex = subState.indexOf(clientIds[0]);
            const newState2 = new Map(state);
            newState2.set(
              toRootClientId,
              moveTo(
                state.get(toRootClientId),
                fromIndex,
                index,
                clientIds.length
              )
            );
            return newState2;
          }
          const newState = new Map(state);
          newState.set(
            fromRootClientId,
            state.get(fromRootClientId)?.filter((id) => !clientIds.includes(id)) ?? []
          );
          newState.set(
            toRootClientId,
            insertAt(state.get(toRootClientId), clientIds, index)
          );
          return newState;
        }
        case "MOVE_BLOCKS_UP": {
          const { clientIds, rootClientId = "" } = action;
          const firstClientId = clientIds[0];
          const subState = state.get(rootClientId);
          if (!subState.length || firstClientId === subState[0]) {
            return state;
          }
          const firstIndex = subState.indexOf(firstClientId);
          const newState = new Map(state);
          newState.set(
            rootClientId,
            moveTo(
              subState,
              firstIndex,
              firstIndex - 1,
              clientIds.length
            )
          );
          return newState;
        }
        case "MOVE_BLOCKS_DOWN": {
          const { clientIds, rootClientId = "" } = action;
          const firstClientId = clientIds[0];
          const lastClientId = clientIds[clientIds.length - 1];
          const subState = state.get(rootClientId);
          if (!subState.length || lastClientId === subState[subState.length - 1]) {
            return state;
          }
          const firstIndex = subState.indexOf(firstClientId);
          const newState = new Map(state);
          newState.set(
            rootClientId,
            moveTo(
              subState,
              firstIndex,
              firstIndex + 1,
              clientIds.length
            )
          );
          return newState;
        }
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          const { clientIds } = action;
          if (!action.blocks) {
            return state;
          }
          const mappedBlocks = mapBlockOrder(action.blocks);
          const newState = new Map(state);
          action.replacedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          mappedBlocks.forEach((order, clientId) => {
            if (clientId !== "") {
              newState.set(clientId, order);
            }
          });
          newState.forEach((order, clientId) => {
            const newSubOrder = Object.values(order).reduce(
              (result, subClientId) => {
                if (subClientId === clientIds[0]) {
                  return [...result, ...mappedBlocks.get("")];
                }
                if (clientIds.indexOf(subClientId) === -1) {
                  result.push(subClientId);
                }
                return result;
              },
              []
            );
            newState.set(clientId, newSubOrder);
          });
          return newState;
        }
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          const newState = new Map(state);
          action.removedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          newState.forEach((order, clientId) => {
            const newSubOrder = order?.filter(
              (id) => !action.removedClientIds.includes(id)
            ) ?? [];
            if (newSubOrder.length !== order.length) {
              newState.set(clientId, newSubOrder);
            }
          });
          return newState;
        }
      }
      return state;
    },
    // While technically redundant data as the inverse of `order`, it serves as
    // an optimization for the selectors which derive the ancestry of a block.
    parents(state = /* @__PURE__ */ new Map(), action) {
      switch (action.type) {
        case "RECEIVE_BLOCKS": {
          const newState = new Map(state);
          mapBlockParents(action.blocks).forEach(
            ([key, value]) => {
              newState.set(key, value);
            }
          );
          return newState;
        }
        case "INSERT_BLOCKS": {
          const newState = new Map(state);
          mapBlockParents(
            action.blocks,
            action.rootClientId || ""
          ).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
        case "MOVE_BLOCKS_TO_POSITION": {
          const newState = new Map(state);
          action.clientIds.forEach((id) => {
            newState.set(id, action.toRootClientId || "");
          });
          return newState;
        }
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          const newState = new Map(state);
          action.replacedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          mapBlockParents(
            action.blocks,
            state.get(action.clientIds[0])
          ).forEach(([key, value]) => {
            newState.set(key, value);
          });
          return newState;
        }
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          const newState = new Map(state);
          action.removedClientIds.forEach((clientId) => {
            newState.delete(clientId);
          });
          return newState;
        }
      }
      return state;
    },
    controlledInnerBlocks(state = {}, { type, clientId, hasControlledInnerBlocks }) {
      if (type === "SET_HAS_CONTROLLED_INNER_BLOCKS") {
        return {
          ...state,
          [clientId]: hasControlledInnerBlocks
        };
      }
      return state;
    }
  });
  function isBlockInterfaceHidden(state = false, action) {
    switch (action.type) {
      case "HIDE_BLOCK_INTERFACE":
        return true;
      case "SHOW_BLOCK_INTERFACE":
        return false;
    }
    return state;
  }
  function isTyping(state = false, action) {
    switch (action.type) {
      case "START_TYPING":
        return true;
      case "STOP_TYPING":
        return false;
    }
    return state;
  }
  function isDragging(state = false, action) {
    switch (action.type) {
      case "START_DRAGGING":
        return true;
      case "STOP_DRAGGING":
        return false;
    }
    return state;
  }
  function draggedBlocks(state = [], action) {
    switch (action.type) {
      case "START_DRAGGING_BLOCKS":
        return action.clientIds;
      case "STOP_DRAGGING_BLOCKS":
        return [];
    }
    return state;
  }
  function blockVisibility(state = {}, action) {
    if (action.type === "SET_BLOCK_VISIBILITY") {
      return {
        ...state,
        ...action.updates
      };
    }
    return state;
  }
  function selectionHelper(state = {}, action) {
    switch (action.type) {
      case "CLEAR_SELECTED_BLOCK": {
        if (state.clientId) {
          return {};
        }
        return state;
      }
      case "SELECT_BLOCK":
        if (action.clientId === state.clientId) {
          return state;
        }
        return { clientId: action.clientId };
      case "REPLACE_INNER_BLOCKS":
      case "INSERT_BLOCKS": {
        if (!action.updateSelection || !action.blocks.length) {
          return state;
        }
        return { clientId: action.blocks[0].clientId };
      }
      case "REMOVE_BLOCKS":
        if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }
        return {};
      case "REPLACE_BLOCKS": {
        if (action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }
        const blockToSelect = action.blocks[action.indexToSelect] || action.blocks[action.blocks.length - 1];
        if (!blockToSelect) {
          return {};
        }
        if (blockToSelect.clientId === state.clientId) {
          return state;
        }
        return { clientId: blockToSelect.clientId };
      }
    }
    return state;
  }
  function selection(state = {}, action) {
    switch (action.type) {
      case "SELECTION_CHANGE":
        if (action.clientId) {
          return {
            selectionStart: {
              clientId: action.clientId,
              attributeKey: action.attributeKey,
              offset: action.startOffset
            },
            selectionEnd: {
              clientId: action.clientId,
              attributeKey: action.attributeKey,
              offset: action.endOffset
            }
          };
        }
        return {
          selectionStart: action.start || state.selectionStart,
          selectionEnd: action.end || state.selectionEnd
        };
      case "RESET_SELECTION":
        const { selectionStart: selectionStart2, selectionEnd: selectionEnd2 } = action;
        return {
          selectionStart: selectionStart2,
          selectionEnd: selectionEnd2
        };
      case "MULTI_SELECT":
        const { start: start2, end } = action;
        if (start2 === state.selectionStart?.clientId && end === state.selectionEnd?.clientId) {
          return state;
        }
        return {
          selectionStart: { clientId: start2 },
          selectionEnd: { clientId: end }
        };
      case "RESET_BLOCKS":
        const startClientId = state?.selectionStart?.clientId;
        const endClientId = state?.selectionEnd?.clientId;
        if (!startClientId && !endClientId) {
          return state;
        }
        if (!action.blocks.some(
          (block) => block.clientId === startClientId
        )) {
          return {
            selectionStart: {},
            selectionEnd: {}
          };
        }
        if (!action.blocks.some(
          (block) => block.clientId === endClientId
        )) {
          return {
            ...state,
            selectionEnd: state.selectionStart
          };
        }
    }
    const selectionStart = selectionHelper(state.selectionStart, action);
    const selectionEnd = selectionHelper(state.selectionEnd, action);
    if (selectionStart === state.selectionStart && selectionEnd === state.selectionEnd) {
      return state;
    }
    return {
      selectionStart,
      selectionEnd
    };
  }
  function isMultiSelecting(state = false, action) {
    switch (action.type) {
      case "START_MULTI_SELECT":
        return true;
      case "STOP_MULTI_SELECT":
        return false;
    }
    return state;
  }
  function isSelectionEnabled(state = true, action) {
    switch (action.type) {
      case "TOGGLE_SELECTION":
        return action.isSelectionEnabled;
    }
    return state;
  }
  function removalPromptData(state = false, action) {
    switch (action.type) {
      case "DISPLAY_BLOCK_REMOVAL_PROMPT":
        const { clientIds, selectPrevious, message } = action;
        return {
          clientIds,
          selectPrevious,
          message
        };
      case "CLEAR_BLOCK_REMOVAL_PROMPT":
        return false;
    }
    return state;
  }
  function blockRemovalRules(state = false, action) {
    switch (action.type) {
      case "SET_BLOCK_REMOVAL_RULES":
        return action.rules;
    }
    return state;
  }
  function initialPosition(state = null, action) {
    if (action.type === "REPLACE_BLOCKS" && action.initialPosition !== void 0) {
      return action.initialPosition;
    } else if ([
      "MULTI_SELECT",
      "SELECT_BLOCK",
      "RESET_SELECTION",
      "INSERT_BLOCKS",
      "REPLACE_INNER_BLOCKS"
    ].includes(action.type)) {
      return action.initialPosition;
    }
    return state;
  }
  function blocksMode(state = {}, action) {
    if (action.type === "TOGGLE_BLOCK_MODE") {
      const { clientId } = action;
      return {
        ...state,
        [clientId]: state[clientId] && state[clientId] === "html" ? "visual" : "html"
      };
    }
    return state;
  }
  function insertionCue(state = null, action) {
    switch (action.type) {
      case "SHOW_INSERTION_POINT": {
        const {
          rootClientId,
          index,
          __unstableWithInserter,
          operation,
          nearestSide
        } = action;
        const nextState = {
          rootClientId,
          index,
          __unstableWithInserter,
          operation,
          nearestSide
        };
        return (0, import_es6.default)(state, nextState) ? state : nextState;
      }
      case "HIDE_INSERTION_POINT":
        return null;
    }
    return state;
  }
  function template(state = { isValid: true }, action) {
    switch (action.type) {
      case "SET_TEMPLATE_VALIDITY":
        return {
          ...state,
          isValid: action.isValid
        };
    }
    return state;
  }
  function settings(state = SETTINGS_DEFAULTS, action) {
    switch (action.type) {
      case "UPDATE_SETTINGS": {
        const updatedSettings = action.reset ? {
          ...SETTINGS_DEFAULTS,
          ...action.settings
        } : {
          ...state,
          ...action.settings
        };
        Object.defineProperty(updatedSettings, "__unstableIsPreviewMode", {
          get() {
            (0, import_deprecated.default)("__unstableIsPreviewMode", {
              since: "6.8",
              alternative: "isPreviewMode"
            });
            return this.isPreviewMode;
          }
        });
        return updatedSettings;
      }
    }
    return state;
  }
  function preferences(state = PREFERENCES_DEFAULTS, action) {
    switch (action.type) {
      case "INSERT_BLOCKS":
      case "REPLACE_BLOCKS": {
        const nextInsertUsage = action.blocks.reduce(
          (prevUsage, block) => {
            const { attributes, name: blockName } = block;
            let id = blockName;
            const match2 = (0, import_data.select)(import_blocks.store).getActiveBlockVariation(
              blockName,
              attributes
            );
            if (match2?.name) {
              id += "/" + match2.name;
            }
            if (blockName === "core/block") {
              id += "/" + attributes.ref;
            }
            return {
              ...prevUsage,
              [id]: {
                time: action.time,
                count: prevUsage[id] ? prevUsage[id].count + 1 : 1
              }
            };
          },
          state.insertUsage
        );
        return {
          ...state,
          insertUsage: nextInsertUsage
        };
      }
    }
    return state;
  }
  var blockListSettings = (state = {}, action) => {
    switch (action.type) {
      // Even if the replaced blocks have the same client ID, our logic
      // should correct the state.
      case "REPLACE_BLOCKS":
      case "REMOVE_BLOCKS": {
        return Object.fromEntries(
          Object.entries(state).filter(
            ([id]) => !action.clientIds.includes(id)
          )
        );
      }
      case "UPDATE_BLOCK_LIST_SETTINGS": {
        const updates = typeof action.clientId === "string" ? { [action.clientId]: action.settings } : action.clientId;
        for (const clientId in updates) {
          if (!updates[clientId]) {
            if (!state[clientId]) {
              delete updates[clientId];
            }
          } else if ((0, import_es6.default)(state[clientId], updates[clientId])) {
            delete updates[clientId];
          }
        }
        if (Object.keys(updates).length === 0) {
          return state;
        }
        const merged = { ...state, ...updates };
        for (const clientId in updates) {
          if (!updates[clientId]) {
            delete merged[clientId];
          }
        }
        return merged;
      }
    }
    return state;
  };
  function lastBlockAttributesChange(state = null, action) {
    switch (action.type) {
      case "UPDATE_BLOCK":
        if (!action.updates.attributes) {
          break;
        }
        return { [action.clientId]: action.updates.attributes };
      case "UPDATE_BLOCK_ATTRIBUTES":
        return action.clientIds.reduce(
          (accumulator, id) => ({
            ...accumulator,
            [id]: !!action.options?.uniqueByBlock ? action.attributes[id] : action.attributes
          }),
          {}
        );
    }
    return state;
  }
  function highlightedBlock(state, action) {
    switch (action.type) {
      case "TOGGLE_BLOCK_HIGHLIGHT":
        const { clientId, isHighlighted } = action;
        if (isHighlighted) {
          return clientId;
        } else if (state === clientId) {
          return null;
        }
        return state;
      case "SELECT_BLOCK":
        if (action.clientId !== state) {
          return null;
        }
    }
    return state;
  }
  function hasBlockSpotlight(state, action) {
    switch (action.type) {
      case "TOGGLE_BLOCK_SPOTLIGHT":
        const { clientId, hasBlockSpotlight: _hasBlockSpotlight } = action;
        if (_hasBlockSpotlight) {
          return clientId;
        } else if (state === clientId) {
          return null;
        }
        return state;
      case "SELECT_BLOCK":
        if (action.clientId !== state) {
          return null;
        }
        return state;
      case "SELECTION_CHANGE":
        if (action.start?.clientId !== state || action.end?.clientId !== state) {
          return null;
        }
        return state;
      case "CLEAR_SELECTED_BLOCK":
        return null;
    }
    return state;
  }
  function expandedBlock(state = null, action) {
    switch (action.type) {
      case "SET_BLOCK_EXPANDED_IN_LIST_VIEW":
        return action.clientId;
      case "SELECT_BLOCK":
        if (action.clientId !== state) {
          return null;
        }
    }
    return state;
  }
  function lastBlockInserted(state = {}, action) {
    switch (action.type) {
      case "INSERT_BLOCKS":
      case "REPLACE_BLOCKS":
        if (!action.blocks.length) {
          return state;
        }
        const clientIds = action.blocks.map((block) => {
          return block.clientId;
        });
        const source = action.meta?.source;
        return { clientIds, source };
      case "RESET_BLOCKS":
        return {};
    }
    return state;
  }
  function temporarilyEditingAsBlocks(state = "", action) {
    if (action.type === "SET_TEMPORARILY_EDITING_AS_BLOCKS") {
      return action.temporarilyEditingAsBlocks;
    }
    return state;
  }
  function temporarilyEditingFocusModeRevert(state = "", action) {
    if (action.type === "SET_TEMPORARILY_EDITING_AS_BLOCKS") {
      return action.focusModeToRevert;
    }
    return state;
  }
  function blockEditingModes(state = /* @__PURE__ */ new Map(), action) {
    switch (action.type) {
      case "SET_BLOCK_EDITING_MODE":
        if (state.get(action.clientId) === action.mode) {
          return state;
        }
        return new Map(state).set(action.clientId, action.mode);
      case "UNSET_BLOCK_EDITING_MODE": {
        if (!state.has(action.clientId)) {
          return state;
        }
        const newState = new Map(state);
        newState.delete(action.clientId);
        return newState;
      }
      case "RESET_BLOCKS": {
        return state.has("") ? (/* @__PURE__ */ new Map()).set("", state.get("")) : state;
      }
    }
    return state;
  }
  function openedBlockSettingsMenu(state = null, action) {
    if ("SET_OPENED_BLOCK_SETTINGS_MENU" === action.type) {
      return action?.clientId ?? null;
    }
    return state;
  }
  function styleOverrides(state = /* @__PURE__ */ new Map(), action) {
    switch (action.type) {
      case "SET_STYLE_OVERRIDE":
        return new Map(state).set(action.id, action.style);
      case "DELETE_STYLE_OVERRIDE": {
        const newState = new Map(state);
        newState.delete(action.id);
        return newState;
      }
    }
    return state;
  }
  function registeredInserterMediaCategories(state = [], action) {
    switch (action.type) {
      case "REGISTER_INSERTER_MEDIA_CATEGORY":
        return [...state, action.category];
    }
    return state;
  }
  function lastFocus(state = false, action) {
    switch (action.type) {
      case "LAST_FOCUS":
        return action.lastFocus;
    }
    return state;
  }
  function zoomLevel(state = 100, action) {
    switch (action.type) {
      case "SET_ZOOM_LEVEL":
        return action.zoom;
      case "RESET_ZOOM_LEVEL":
        return 100;
    }
    return state;
  }
  function insertionPoint(state = null, action) {
    switch (action.type) {
      case "SET_INSERTION_POINT":
        return action.value;
      case "SELECT_BLOCK":
        return null;
    }
    return state;
  }
  var combinedReducers = (0, import_data.combineReducers)({
    blocks,
    isDragging,
    isTyping,
    isBlockInterfaceHidden,
    draggedBlocks,
    selection,
    isMultiSelecting,
    isSelectionEnabled,
    initialPosition,
    blocksMode,
    blockListSettings,
    insertionPoint,
    insertionCue,
    template,
    settings,
    preferences,
    lastBlockAttributesChange,
    lastFocus,
    expandedBlock,
    highlightedBlock,
    lastBlockInserted,
    temporarilyEditingAsBlocks,
    temporarilyEditingFocusModeRevert,
    blockVisibility,
    blockEditingModes,
    styleOverrides,
    removalPromptData,
    blockRemovalRules,
    openedBlockSettingsMenu,
    registeredInserterMediaCategories,
    zoomLevel,
    hasBlockSpotlight
  });
  function getBlockTreeBlock(state, clientId) {
    if (clientId === "") {
      const rootBlock = state.blocks.tree.get(clientId);
      if (!rootBlock) {
        return;
      }
      return {
        clientId: "",
        ...rootBlock
      };
    }
    if (!state.blocks.controlledInnerBlocks[clientId]) {
      return state.blocks.tree.get(clientId);
    }
    const controlledTree = state.blocks.tree.get(`controlled||${clientId}`);
    const regularTree = state.blocks.tree.get(clientId);
    return {
      ...regularTree,
      innerBlocks: controlledTree?.innerBlocks
    };
  }
  function traverseBlockTree(state, clientId, callback) {
    const tree = getBlockTreeBlock(state, clientId);
    if (!tree) {
      return;
    }
    callback(tree);
    if (!tree?.innerBlocks?.length) {
      return;
    }
    for (const innerBlock of tree?.innerBlocks) {
      traverseBlockTree(state, innerBlock.clientId, callback);
    }
  }
  function findParentInClientIdsList(state, clientId, clientIds) {
    if (!clientIds.length) {
      return;
    }
    let parent = state.blocks.parents.get(clientId);
    while (parent !== void 0) {
      if (clientIds.includes(parent)) {
        return parent;
      }
      parent = state.blocks.parents.get(parent);
    }
  }
  function hasBindings(block) {
    return block?.attributes?.metadata?.bindings && Object.keys(block?.attributes?.metadata?.bindings).length;
  }
  function getDerivedBlockEditingModesForTree(state, treeClientId = "") {
    const isZoomedOut = state?.zoomLevel < 100 || state?.zoomLevel === "auto-scaled";
    const derivedBlockEditingModes = /* @__PURE__ */ new Map();
    const sectionRootClientId = state.settings?.[sectionRootClientIdKey];
    const sectionClientIds = state.blocks.order.get(sectionRootClientId);
    const hasDisabledBlocks = Array.from(state.blockEditingModes).some(
      ([, mode2]) => mode2 === "disabled"
    );
    const templatePartClientIds = [];
    const syncedPatternClientIds = [];
    Object.keys(state.blocks.controlledInnerBlocks).forEach((clientId) => {
      const block = state.blocks.byClientId?.get(clientId);
      if (block?.name === "core/template-part") {
        templatePartClientIds.push(clientId);
      }
      if (block?.name === "core/block") {
        syncedPatternClientIds.push(clientId);
      }
    });
    const contentOnlyTemplateLockedClientIds = Object.keys(
      state.blockListSettings
    ).filter(
      (clientId) => state.blockListSettings[clientId]?.templateLock === "contentOnly"
    );
    const unsyncedPatternClientIds = !!window?.__experimentalContentOnlyPatternInsertion ? Array.from(state.blocks.attributes.keys()).filter(
      (clientId) => state.blocks.attributes.get(clientId)?.metadata?.patternName
    ) : [];
    const contentOnlyParents = [
      ...contentOnlyTemplateLockedClientIds,
      ...unsyncedPatternClientIds,
      ...window?.__experimentalContentOnlyPatternInsertion ? templatePartClientIds : []
    ];
    traverseBlockTree(state, treeClientId, (block) => {
      const { clientId, name: blockName } = block;
      if (state.blockEditingModes.has(clientId)) {
        return;
      }
      if (hasDisabledBlocks) {
        let ancestorBlockEditingMode;
        let parent = state.blocks.parents.get(clientId);
        while (parent !== void 0) {
          if (state.blockEditingModes.has(parent)) {
            ancestorBlockEditingMode = state.blockEditingModes.get(parent);
          }
          if (ancestorBlockEditingMode) {
            break;
          }
          parent = state.blocks.parents.get(parent);
        }
        if (ancestorBlockEditingMode === "disabled") {
          derivedBlockEditingModes.set(clientId, "disabled");
          return;
        }
      }
      if (isZoomedOut) {
        if (clientId === sectionRootClientId) {
          derivedBlockEditingModes.set(clientId, "contentOnly");
          return;
        }
        if (!sectionClientIds?.length) {
          derivedBlockEditingModes.set(clientId, "disabled");
          return;
        }
        if (sectionClientIds.includes(clientId)) {
          derivedBlockEditingModes.set(clientId, "contentOnly");
          return;
        }
        derivedBlockEditingModes.set(clientId, "disabled");
        return;
      }
      if (syncedPatternClientIds.length) {
        if (syncedPatternClientIds.includes(clientId)) {
          if (findParentInClientIdsList(
            state,
            clientId,
            syncedPatternClientIds
          )) {
            derivedBlockEditingModes.set(clientId, "disabled");
            return;
          }
          return;
        }
        const parentPatternClientId = findParentInClientIdsList(
          state,
          clientId,
          syncedPatternClientIds
        );
        if (parentPatternClientId) {
          if (findParentInClientIdsList(
            state,
            parentPatternClientId,
            syncedPatternClientIds
          )) {
            derivedBlockEditingModes.set(clientId, "disabled");
            return;
          }
          if (hasBindings(block)) {
            derivedBlockEditingModes.set(clientId, "contentOnly");
            return;
          }
          derivedBlockEditingModes.set(clientId, "disabled");
        }
      }
      if (contentOnlyParents.length) {
        const hasContentOnlyParent = !!findParentInClientIdsList(
          state,
          clientId,
          contentOnlyParents
        );
        if (hasContentOnlyParent) {
          if (isContentBlock(blockName)) {
            derivedBlockEditingModes.set(clientId, "contentOnly");
          } else {
            derivedBlockEditingModes.set(clientId, "disabled");
          }
        }
      }
    });
    return derivedBlockEditingModes;
  }
  function getDerivedBlockEditingModesUpdates({
    prevState,
    nextState,
    addedBlocks,
    removedClientIds
  }) {
    const prevDerivedBlockEditingModes = prevState.derivedBlockEditingModes;
    let nextDerivedBlockEditingModes;
    removedClientIds?.forEach((clientId) => {
      traverseBlockTree(prevState, clientId, (block) => {
        if (prevDerivedBlockEditingModes.has(block.clientId)) {
          if (!nextDerivedBlockEditingModes) {
            nextDerivedBlockEditingModes = new Map(
              prevDerivedBlockEditingModes
            );
          }
          nextDerivedBlockEditingModes.delete(block.clientId);
        }
      });
    });
    addedBlocks?.forEach((addedBlock) => {
      const updates = getDerivedBlockEditingModesForTree(
        nextState,
        addedBlock.clientId
      );
      if (updates.size) {
        if (!nextDerivedBlockEditingModes) {
          nextDerivedBlockEditingModes = new Map([
            ...prevDerivedBlockEditingModes?.size ? prevDerivedBlockEditingModes : [],
            ...updates
          ]);
        } else {
          nextDerivedBlockEditingModes = new Map([
            ...nextDerivedBlockEditingModes?.size ? nextDerivedBlockEditingModes : [],
            ...updates
          ]);
        }
      }
    });
    return nextDerivedBlockEditingModes;
  }
  function withDerivedBlockEditingModes(reducer4) {
    return (state, action) => {
      const nextState = reducer4(state, action);
      if (action.type !== "SET_EDITOR_MODE" && nextState === state) {
        return state;
      }
      switch (action.type) {
        case "REMOVE_BLOCKS": {
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            removedClientIds: action.clientIds
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "RECEIVE_BLOCKS":
        case "INSERT_BLOCKS": {
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            addedBlocks: action.blocks
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "UPDATE_BLOCK_ATTRIBUTES": {
          const addedBlocks = [];
          const removedClientIds = [];
          for (const clientId of action?.clientIds) {
            const attributes = action.options?.uniqueByBlock ? action.attributes[clientId] : action.attributes;
            if (!attributes) {
              break;
            }
            if (
              // patternName is switching from falsy to truthy, indicating
              // this block is becoming an unsynced pattern.
              attributes.metadata?.patternName && !state.blocks.attributes.get(clientId)?.metadata?.patternName
            ) {
              addedBlocks.push(
                nextState.blocks.tree.get(clientId)
              );
            } else if (
              // patternName is switching from truthy to falsy, this block is becoming
              // a regular block but was an unsynced pattern.
              // Check that `metadata` is part of the included attributes, as
              // `updateBlockAttributes` merges attributes, if it isn't present
              // the previous `metadata` would be retained.
              attributes.metadata && !attributes.metadata?.patternName && state.blocks.attributes.get(clientId)?.metadata?.patternName
            ) {
              removedClientIds.push(clientId);
            }
          }
          if (!addedBlocks?.length && !removedClientIds?.length) {
            break;
          }
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            addedBlocks,
            removedClientIds
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "UPDATE_BLOCK_LIST_SETTINGS": {
          const addedBlocks = [];
          const removedClientIds = [];
          const updates = typeof action.clientId === "string" ? { [action.clientId]: action.settings } : action.clientId;
          for (const clientId in updates) {
            const isNewContentOnlyBlock = state.blockListSettings[clientId]?.templateLock !== "contentOnly" && nextState.blockListSettings[clientId]?.templateLock === "contentOnly";
            const wasContentOnlyBlock = state.blockListSettings[clientId]?.templateLock === "contentOnly" && nextState.blockListSettings[clientId]?.templateLock !== "contentOnly";
            if (isNewContentOnlyBlock) {
              addedBlocks.push(
                nextState.blocks.tree.get(clientId)
              );
            } else if (wasContentOnlyBlock) {
              removedClientIds.push(clientId);
            }
          }
          if (!addedBlocks.length && !removedClientIds.length) {
            break;
          }
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            addedBlocks,
            removedClientIds
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "SET_BLOCK_EDITING_MODE":
        case "UNSET_BLOCK_EDITING_MODE":
        case "SET_HAS_CONTROLLED_INNER_BLOCKS": {
          const updatedBlock = getBlockTreeBlock(
            nextState,
            action.clientId
          );
          if (!updatedBlock) {
            break;
          }
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            removedClientIds: [action.clientId],
            addedBlocks: [updatedBlock]
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "REPLACE_BLOCKS": {
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            addedBlocks: action.blocks,
            removedClientIds: action.clientIds
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "REPLACE_INNER_BLOCKS": {
          const removedClientIds = state.blocks.order.get(
            action.rootClientId
          );
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            addedBlocks: action.blocks,
            removedClientIds
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "MOVE_BLOCKS_TO_POSITION": {
          const addedBlocks = action.clientIds.map((clientId) => {
            return nextState.blocks.byClientId.get(clientId);
          });
          const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
            prevState: state,
            nextState,
            addedBlocks,
            removedClientIds: action.clientIds
          });
          if (nextDerivedBlockEditingModes) {
            return {
              ...nextState,
              derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
            };
          }
          break;
        }
        case "UPDATE_SETTINGS": {
          if (state?.settings?.[sectionRootClientIdKey] !== nextState?.settings?.[sectionRootClientIdKey]) {
            return {
              ...nextState,
              derivedBlockEditingModes: getDerivedBlockEditingModesForTree(nextState)
            };
          }
          break;
        }
        case "RESET_BLOCKS":
        case "SET_EDITOR_MODE":
        case "RESET_ZOOM_LEVEL":
        case "SET_ZOOM_LEVEL": {
          return {
            ...nextState,
            derivedBlockEditingModes: getDerivedBlockEditingModesForTree(nextState)
          };
        }
      }
      nextState.derivedBlockEditingModes = state?.derivedBlockEditingModes ?? /* @__PURE__ */ new Map();
      return nextState;
    };
  }
  function withAutomaticChangeReset(reducer4) {
    return (state, action) => {
      const nextState = reducer4(state, action);
      if (!state) {
        return nextState;
      }
      nextState.automaticChangeStatus = state.automaticChangeStatus;
      if (action.type === "MARK_AUTOMATIC_CHANGE") {
        return {
          ...nextState,
          automaticChangeStatus: "pending"
        };
      }
      if (action.type === "MARK_AUTOMATIC_CHANGE_FINAL" && state.automaticChangeStatus === "pending") {
        return {
          ...nextState,
          automaticChangeStatus: "final"
        };
      }
      if (nextState.blocks === state.blocks && nextState.selection === state.selection) {
        return nextState;
      }
      if (nextState.automaticChangeStatus !== "final" && nextState.selection !== state.selection) {
        return nextState;
      }
      return {
        ...nextState,
        automaticChangeStatus: void 0
      };
    };
  }
  var reducer_default = (0, import_compose.pipe)(
    withDerivedBlockEditingModes,
    withAutomaticChangeReset
  )(combinedReducers);

  // packages/block-editor/build-module/store/selectors.js
  var selectors_exports = {};
  __export(selectors_exports, {
    __experimentalGetActiveBlockIdByBlockNames: () => __experimentalGetActiveBlockIdByBlockNames,
    __experimentalGetAllowedBlocks: () => __experimentalGetAllowedBlocks,
    __experimentalGetAllowedPatterns: () => __experimentalGetAllowedPatterns,
    __experimentalGetBlockListSettingsForBlocks: () => __experimentalGetBlockListSettingsForBlocks,
    __experimentalGetDirectInsertBlock: () => __experimentalGetDirectInsertBlock,
    __experimentalGetGlobalBlocksByName: () => __experimentalGetGlobalBlocksByName,
    __experimentalGetLastBlockAttributeChanges: () => __experimentalGetLastBlockAttributeChanges,
    __experimentalGetParsedPattern: () => __experimentalGetParsedPattern,
    __experimentalGetPatternTransformItems: () => __experimentalGetPatternTransformItems,
    __experimentalGetPatternsByBlockTypes: () => __experimentalGetPatternsByBlockTypes,
    __experimentalGetReusableBlockTitle: () => __experimentalGetReusableBlockTitle,
    __unstableGetBlockWithoutInnerBlocks: () => __unstableGetBlockWithoutInnerBlocks,
    __unstableGetClientIdWithClientIdsTree: () => __unstableGetClientIdWithClientIdsTree,
    __unstableGetClientIdsTree: () => __unstableGetClientIdsTree,
    __unstableGetContentLockingParent: () => __unstableGetContentLockingParent,
    __unstableGetSelectedBlocksWithPartialSelection: () => __unstableGetSelectedBlocksWithPartialSelection,
    __unstableGetTemporarilyEditingAsBlocks: () => __unstableGetTemporarilyEditingAsBlocks,
    __unstableGetTemporarilyEditingFocusModeToRevert: () => __unstableGetTemporarilyEditingFocusModeToRevert,
    __unstableGetVisibleBlocks: () => __unstableGetVisibleBlocks,
    __unstableHasActiveBlockOverlayActive: () => __unstableHasActiveBlockOverlayActive,
    __unstableIsFullySelected: () => __unstableIsFullySelected,
    __unstableIsLastBlockChangeIgnored: () => __unstableIsLastBlockChangeIgnored,
    __unstableIsSelectionCollapsed: () => __unstableIsSelectionCollapsed,
    __unstableIsSelectionMergeable: () => __unstableIsSelectionMergeable,
    __unstableIsWithinBlockOverlay: () => __unstableIsWithinBlockOverlay,
    __unstableSelectionHasUnmergeableBlock: () => __unstableSelectionHasUnmergeableBlock,
    areInnerBlocksControlled: () => areInnerBlocksControlled,
    canEditBlock: () => canEditBlock,
    canInsertBlockType: () => canInsertBlockType,
    canInsertBlocks: () => canInsertBlocks,
    canLockBlockType: () => canLockBlockType,
    canMoveBlock: () => canMoveBlock,
    canMoveBlocks: () => canMoveBlocks,
    canRemoveBlock: () => canRemoveBlock,
    canRemoveBlocks: () => canRemoveBlocks,
    didAutomaticChange: () => didAutomaticChange,
    getAdjacentBlockClientId: () => getAdjacentBlockClientId,
    getAllowedBlocks: () => getAllowedBlocks,
    getBlock: () => getBlock,
    getBlockAttributes: () => getBlockAttributes,
    getBlockCount: () => getBlockCount,
    getBlockEditingMode: () => getBlockEditingMode,
    getBlockHierarchyRootClientId: () => getBlockHierarchyRootClientId,
    getBlockIndex: () => getBlockIndex,
    getBlockInsertionPoint: () => getBlockInsertionPoint,
    getBlockListSettings: () => getBlockListSettings,
    getBlockMode: () => getBlockMode,
    getBlockName: () => getBlockName,
    getBlockNamesByClientId: () => getBlockNamesByClientId,
    getBlockOrder: () => getBlockOrder,
    getBlockParents: () => getBlockParents,
    getBlockParentsByBlockName: () => getBlockParentsByBlockName,
    getBlockRootClientId: () => getBlockRootClientId,
    getBlockSelectionEnd: () => getBlockSelectionEnd,
    getBlockSelectionStart: () => getBlockSelectionStart,
    getBlockTransformItems: () => getBlockTransformItems,
    getBlocks: () => getBlocks,
    getBlocksByClientId: () => getBlocksByClientId,
    getBlocksByName: () => getBlocksByName,
    getClientIdsOfDescendants: () => getClientIdsOfDescendants,
    getClientIdsWithDescendants: () => getClientIdsWithDescendants,
    getDirectInsertBlock: () => getDirectInsertBlock,
    getDraggedBlockClientIds: () => getDraggedBlockClientIds,
    getFirstMultiSelectedBlockClientId: () => getFirstMultiSelectedBlockClientId,
    getGlobalBlockCount: () => getGlobalBlockCount,
    getHoveredBlockClientId: () => getHoveredBlockClientId,
    getInserterItems: () => getInserterItems,
    getLastMultiSelectedBlockClientId: () => getLastMultiSelectedBlockClientId,
    getLowestCommonAncestorWithSelectedBlock: () => getLowestCommonAncestorWithSelectedBlock,
    getMultiSelectedBlockClientIds: () => getMultiSelectedBlockClientIds,
    getMultiSelectedBlocks: () => getMultiSelectedBlocks,
    getMultiSelectedBlocksEndClientId: () => getMultiSelectedBlocksEndClientId,
    getMultiSelectedBlocksStartClientId: () => getMultiSelectedBlocksStartClientId,
    getNextBlockClientId: () => getNextBlockClientId,
    getPatternsByBlockTypes: () => getPatternsByBlockTypes,
    getPreviousBlockClientId: () => getPreviousBlockClientId,
    getSelectedBlock: () => getSelectedBlock,
    getSelectedBlockClientId: () => getSelectedBlockClientId,
    getSelectedBlockClientIds: () => getSelectedBlockClientIds,
    getSelectedBlockCount: () => getSelectedBlockCount,
    getSelectedBlocksInitialCaretPosition: () => getSelectedBlocksInitialCaretPosition,
    getSelectionEnd: () => getSelectionEnd,
    getSelectionStart: () => getSelectionStart,
    getSettings: () => getSettings,
    getTemplate: () => getTemplate,
    getTemplateLock: () => getTemplateLock,
    hasBlockMovingClientId: () => hasBlockMovingClientId,
    hasDraggedInnerBlock: () => hasDraggedInnerBlock,
    hasInserterItems: () => hasInserterItems,
    hasMultiSelection: () => hasMultiSelection,
    hasSelectedBlock: () => hasSelectedBlock,
    hasSelectedInnerBlock: () => hasSelectedInnerBlock,
    isAncestorBeingDragged: () => isAncestorBeingDragged,
    isAncestorMultiSelected: () => isAncestorMultiSelected,
    isBlockBeingDragged: () => isBlockBeingDragged,
    isBlockHighlighted: () => isBlockHighlighted,
    isBlockInsertionPointVisible: () => isBlockInsertionPointVisible,
    isBlockMultiSelected: () => isBlockMultiSelected,
    isBlockSelected: () => isBlockSelected,
    isBlockValid: () => isBlockValid,
    isBlockVisible: () => isBlockVisible,
    isBlockWithinSelection: () => isBlockWithinSelection,
    isCaretWithinFormattedText: () => isCaretWithinFormattedText,
    isDraggingBlocks: () => isDraggingBlocks,
    isFirstMultiSelectedBlock: () => isFirstMultiSelectedBlock,
    isGroupable: () => isGroupable,
    isLastBlockChangePersistent: () => isLastBlockChangePersistent,
    isMultiSelecting: () => isMultiSelecting2,
    isSelectionEnabled: () => isSelectionEnabled2,
    isTyping: () => isTyping2,
    isUngroupable: () => isUngroupable,
    isValidTemplate: () => isValidTemplate,
    wasBlockJustInserted: () => wasBlockJustInserted
  });
  var import_blocks5 = __toESM(require_blocks());
  var import_element4 = __toESM(require_element());
  var import_hooks2 = __toESM(require_hooks());

  // packages/icons/build-module/icon/index.js
  var import_element3 = __toESM(require_element());
  var icon_default = (0, import_element3.forwardRef)(
    ({ icon, size = 24, ...props }, ref) => {
      return (0, import_element3.cloneElement)(icon, {
        width: size,
        height: size,
        ...props,
        ref
      });
    }
  );

  // packages/icons/build-module/library/align-center.js
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var import_primitives = __toESM(require_primitives());
  var align_center_default = /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_primitives.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_primitives.Path, { d: "M7.5 5.5h9V4h-9v1.5Zm-3.5 7h16V11H4v1.5Zm3.5 7h9V18h-9v1.5Z" }) });

  // packages/icons/build-module/library/align-justify.js
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  var import_primitives2 = __toESM(require_primitives());
  var align_justify_default = /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_primitives2.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_primitives2.Path, { d: "M4 12.8h16v-1.5H4v1.5zm0 7h12.4v-1.5H4v1.5zM4 4.3v1.5h16V4.3H4z" }) });

  // packages/icons/build-module/library/align-left.js
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  var import_primitives3 = __toESM(require_primitives());
  var align_left_default = /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_primitives3.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_primitives3.Path, { d: "M13 5.5H4V4h9v1.5Zm7 7H4V11h16v1.5Zm-7 7H4V18h9v1.5Z" }) });

  // packages/icons/build-module/library/align-none.js
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var import_primitives4 = __toESM(require_primitives());
  var align_none_default = /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_primitives4.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_primitives4.Path, { d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM5 9h14v6H5V9Z" }) });

  // packages/icons/build-module/library/align-right.js
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var import_primitives5 = __toESM(require_primitives());
  var align_right_default = /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_primitives5.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_primitives5.Path, { d: "M11.111 5.5H20V4h-8.889v1.5ZM4 12.5h16V11H4v1.5Zm7.111 7H20V18h-8.889v1.5Z" }) });

  // packages/icons/build-module/library/arrow-down.js
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var import_primitives6 = __toESM(require_primitives());
  var arrow_down_default = /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_primitives6.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_primitives6.Path, { d: "m16.5 13.5-3.7 3.7V4h-1.5v13.2l-3.8-3.7-1 1 5.5 5.6 5.5-5.6z" }) });

  // packages/icons/build-module/library/arrow-left.js
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var import_primitives7 = __toESM(require_primitives());
  var arrow_left_default = /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_primitives7.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_primitives7.Path, { d: "M20 11.2H6.8l3.7-3.7-1-1L3.9 12l5.6 5.5 1-1-3.7-3.7H20z" }) });

  // packages/icons/build-module/library/arrow-right.js
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var import_primitives8 = __toESM(require_primitives());
  var arrow_right_default = /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_primitives8.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_primitives8.Path, { d: "m14.5 6.5-1 1 3.7 3.7H4v1.6h13.2l-3.7 3.7 1 1 5.6-5.5z" }) });

  // packages/icons/build-module/library/aspect-ratio.js
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var import_primitives9 = __toESM(require_primitives());
  var aspect_ratio_default = /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_primitives9.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_primitives9.Path, { d: "M18.5 5.5h-13c-1.1 0-2 .9-2 2v9c0 1.1.9 2 2 2h13c1.1 0 2-.9 2-2v-9c0-1.1-.9-2-2-2zm.5 11c0 .3-.2.5-.5.5h-13c-.3 0-.5-.2-.5-.5v-9c0-.3.2-.5.5-.5h13c.3 0 .5.2.5.5v9zM6.5 12H8v-2h2V8.5H6.5V12zm9.5 2h-2v1.5h3.5V12H16v2z" }) });

  // packages/icons/build-module/library/block-default.js
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var import_primitives10 = __toESM(require_primitives());
  var block_default_default = /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(import_primitives10.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(import_primitives10.Path, { d: "M19 8h-1V6h-5v2h-2V6H6v2H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2zm.5 10c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5v-8c0-.3.2-.5.5-.5h14c.3 0 .5.2.5.5v8z" }) });

  // packages/icons/build-module/library/category.js
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  var import_primitives11 = __toESM(require_primitives());
  var category_default = /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(import_primitives11.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
    import_primitives11.Path,
    {
      d: "M6 5.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM4 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2V6zm11-.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5h-3a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM13 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2h-3a2 2 0 01-2-2V6zm5 8.5h-3a.5.5 0 00-.5.5v3a.5.5 0 00.5.5h3a.5.5 0 00.5-.5v-3a.5.5 0 00-.5-.5zM15 13a2 2 0 00-2 2v3a2 2 0 002 2h3a2 2 0 002-2v-3a2 2 0 00-2-2h-3zm-9 1.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5v-3a.5.5 0 01.5-.5zM4 15a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2v-3z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  ) });

  // packages/icons/build-module/library/check.js
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var import_primitives12 = __toESM(require_primitives());
  var check_default = /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(import_primitives12.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(import_primitives12.Path, { d: "M16.5 7.5 10 13.9l-2.5-2.4-1 1 3.5 3.6 7.5-7.6z" }) });

  // packages/icons/build-module/library/chevron-down.js
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var import_primitives13 = __toESM(require_primitives());
  var chevron_down_default = /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(import_primitives13.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(import_primitives13.Path, { d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z" }) });

  // packages/icons/build-module/library/chevron-left-small.js
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var import_primitives14 = __toESM(require_primitives());
  var chevron_left_small_default = /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(import_primitives14.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(import_primitives14.Path, { d: "m13.1 16-3.4-4 3.4-4 1.1 1-2.6 3 2.6 3-1.1 1z" }) });

  // packages/icons/build-module/library/chevron-left.js
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  var import_primitives15 = __toESM(require_primitives());
  var chevron_left_default = /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(import_primitives15.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(import_primitives15.Path, { d: "M14.6 7l-1.2-1L8 12l5.4 6 1.2-1-4.6-5z" }) });

  // packages/icons/build-module/library/chevron-right-small.js
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var import_primitives16 = __toESM(require_primitives());
  var chevron_right_small_default = /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(import_primitives16.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(import_primitives16.Path, { d: "M10.8622 8.04053L14.2805 12.0286L10.8622 16.0167L9.72327 15.0405L12.3049 12.0286L9.72327 9.01672L10.8622 8.04053Z" }) });

  // packages/icons/build-module/library/chevron-right.js
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  var import_primitives17 = __toESM(require_primitives());
  var chevron_right_default = /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(import_primitives17.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(import_primitives17.Path, { d: "M10.6 6L9.4 7l4.6 5-4.6 5 1.2 1 5.4-6z" }) });

  // packages/icons/build-module/library/chevron-up.js
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  var import_primitives18 = __toESM(require_primitives());
  var chevron_up_default = /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(import_primitives18.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(import_primitives18.Path, { d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z" }) });

  // packages/icons/build-module/library/close-small.js
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  var import_primitives19 = __toESM(require_primitives());
  var close_small_default = /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(import_primitives19.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(import_primitives19.Path, { d: "M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z" }) });

  // packages/icons/build-module/library/cog.js
  var import_jsx_runtime21 = __toESM(require_jsx_runtime());
  var import_primitives20 = __toESM(require_primitives());
  var cog_default = /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(import_primitives20.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    import_primitives20.Path,
    {
      fillRule: "evenodd",
      d: "M10.289 4.836A1 1 0 0111.275 4h1.306a1 1 0 01.987.836l.244 1.466c.787.26 1.503.679 2.108 1.218l1.393-.522a1 1 0 011.216.437l.653 1.13a1 1 0 01-.23 1.273l-1.148.944a6.025 6.025 0 010 2.435l1.149.946a1 1 0 01.23 1.272l-.653 1.13a1 1 0 01-1.216.437l-1.394-.522c-.605.54-1.32.958-2.108 1.218l-.244 1.466a1 1 0 01-.987.836h-1.306a1 1 0 01-.986-.836l-.244-1.466a5.995 5.995 0 01-2.108-1.218l-1.394.522a1 1 0 01-1.217-.436l-.653-1.131a1 1 0 01.23-1.272l1.149-.946a6.026 6.026 0 010-2.435l-1.148-.944a1 1 0 01-.23-1.272l.653-1.131a1 1 0 011.217-.437l1.393.522a5.994 5.994 0 012.108-1.218l.244-1.466zM14.929 12a3 3 0 11-6 0 3 3 0 016 0z",
      clipRule: "evenodd"
    }
  ) });

  // packages/icons/build-module/library/copy-small.js
  var import_jsx_runtime22 = __toESM(require_jsx_runtime());
  var import_primitives21 = __toESM(require_primitives());
  var copy_small_default = /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(import_primitives21.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
    import_primitives21.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.625 5.5h9.75c.069 0 .125.056.125.125v9.75a.125.125 0 0 1-.125.125h-9.75a.125.125 0 0 1-.125-.125v-9.75c0-.069.056-.125.125-.125ZM4 5.625C4 4.728 4.728 4 5.625 4h9.75C16.273 4 17 4.728 17 5.625v9.75c0 .898-.727 1.625-1.625 1.625h-9.75A1.625 1.625 0 0 1 4 15.375v-9.75Zm14.5 11.656v-9H20v9C20 18.8 18.77 20 17.251 20H6.25v-1.5h11.001c.69 0 1.249-.528 1.249-1.219Z"
    }
  ) });

  // packages/icons/build-module/library/copy.js
  var import_jsx_runtime23 = __toESM(require_jsx_runtime());
  var import_primitives22 = __toESM(require_primitives());
  var copy_default = /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(import_primitives22.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
    import_primitives22.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5 4.5h11a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5H5a.5.5 0 0 1-.5-.5V5a.5.5 0 0 1 .5-.5ZM3 5a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5Zm17 3v10.75c0 .69-.56 1.25-1.25 1.25H6v1.5h12.75a2.75 2.75 0 0 0 2.75-2.75V8H20Z"
    }
  ) });

  // packages/icons/build-module/library/corner-all.js
  var import_jsx_runtime24 = __toESM(require_jsx_runtime());
  var import_primitives23 = __toESM(require_primitives());
  var corner_all_default = /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(import_primitives23.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    import_primitives23.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5Zm-12.5 9v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z"
    }
  ) });

  // packages/icons/build-module/library/corner-bottom-left.js
  var import_jsx_runtime25 = __toESM(require_jsx_runtime());
  var import_primitives24 = __toESM(require_primitives());
  var corner_bottom_left_default = /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(import_primitives24.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(import_primitives24.G, { opacity: ".25", children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(import_primitives24.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
      import_primitives24.Path,
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.75 15v3c0 .138.112.25.25.25h3v1.5H6A1.75 1.75 0 0 1 4.25 18v-3h1.5Z"
      }
    )
  ] });

  // packages/icons/build-module/library/corner-bottom-right.js
  var import_jsx_runtime26 = __toESM(require_jsx_runtime());
  var import_primitives25 = __toESM(require_primitives());
  var corner_bottom_right_default = /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)(import_primitives25.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(import_primitives25.G, { opacity: ".25", children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(import_primitives25.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      import_primitives25.Path,
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M15 18.25h3a.25.25 0 0 0 .25-.25v-3h1.5v3A1.75 1.75 0 0 1 18 19.75h-3v-1.5Z"
      }
    )
  ] });

  // packages/icons/build-module/library/corner-top-left.js
  var import_jsx_runtime27 = __toESM(require_jsx_runtime());
  var import_primitives26 = __toESM(require_primitives());
  var corner_top_left_default = /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(import_primitives26.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(import_primitives26.G, { opacity: ".25", children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(import_primitives26.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
      import_primitives26.Path,
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6 5.75a.25.25 0 0 0-.25.25v3h-1.5V6c0-.966.784-1.75 1.75-1.75h3v1.5H6Z"
      }
    )
  ] });

  // packages/icons/build-module/library/corner-top-right.js
  var import_jsx_runtime28 = __toESM(require_jsx_runtime());
  var import_primitives27 = __toESM(require_primitives());
  var corner_top_right_default = /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_primitives27.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(import_primitives27.G, { opacity: ".25", children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(import_primitives27.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
      import_primitives27.Path,
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5Z"
      }
    )
  ] });

  // packages/icons/build-module/library/drag-handle.js
  var import_jsx_runtime29 = __toESM(require_jsx_runtime());
  var import_primitives28 = __toESM(require_primitives());
  var drag_handle_default = /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(import_primitives28.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(import_primitives28.Path, { d: "M8 7h2V5H8v2zm0 6h2v-2H8v2zm0 6h2v-2H8v2zm6-14v2h2V5h-2zm0 8h2v-2h-2v2zm0 6h2v-2h-2v2z" }) });

  // packages/icons/build-module/library/external.js
  var import_jsx_runtime30 = __toESM(require_jsx_runtime());
  var import_primitives29 = __toESM(require_primitives());
  var external_default = /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(import_primitives29.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(import_primitives29.Path, { d: "M19.5 4.5h-7V6h4.44l-5.97 5.97 1.06 1.06L18 7.06v4.44h1.5v-7Zm-13 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3H17v3a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h3V5.5h-3Z" }) });

  // packages/icons/build-module/library/file.js
  var import_jsx_runtime31 = __toESM(require_jsx_runtime());
  var import_primitives30 = __toESM(require_primitives());
  var file_default = /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(import_primitives30.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    import_primitives30.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12.848 8a1 1 0 0 1-.914-.594l-.723-1.63a.5.5 0 0 0-.447-.276H5a.5.5 0 0 0-.5.5v11.5a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5v-9A.5.5 0 0 0 19 8h-6.152Zm.612-1.5a.5.5 0 0 1-.462-.31l-.445-1.084A2 2 0 0 0 10.763 4H5a2 2 0 0 0-2 2v11.5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-9a2 2 0 0 0-2-2h-5.54Z"
    }
  ) });

  // packages/icons/build-module/library/filter.js
  var import_jsx_runtime32 = __toESM(require_jsx_runtime());
  var import_primitives31 = __toESM(require_primitives());
  var filter_default = /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(import_primitives31.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(import_primitives31.Path, { d: "M12 4 4 19h16L12 4zm0 3.2 5.5 10.3H12V7.2z" }) });

  // packages/icons/build-module/library/format-capitalize.js
  var import_jsx_runtime33 = __toESM(require_jsx_runtime());
  var import_primitives32 = __toESM(require_primitives());
  var format_capitalize_default = /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(import_primitives32.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(import_primitives32.Path, { d: "M7.1 6.8L3.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H7.1zm-.8 6.8L8 8.9l1.7 4.7H6.3zm14.5-1.5c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2 .1.8-.2 1.4-.6 2z" }) });

  // packages/icons/build-module/library/format-lowercase.js
  var import_jsx_runtime34 = __toESM(require_jsx_runtime());
  var import_primitives33 = __toESM(require_primitives());
  var format_lowercase_default = /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(import_primitives33.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(import_primitives33.Path, { d: "M11 16.8c-.1-.1-.2-.3-.3-.5v-2.6c0-.9-.1-1.7-.3-2.2-.2-.5-.5-.9-.9-1.2-.4-.2-.9-.3-1.6-.3-.5 0-1 .1-1.5.2s-.9.3-1.2.6l.2 1.2c.4-.3.7-.4 1.1-.5.3-.1.7-.2 1-.2.6 0 1 .1 1.3.4.3.2.4.7.4 1.4-1.2 0-2.3.2-3.3.7s-1.4 1.1-1.4 2.1c0 .7.2 1.2.7 1.6.4.4 1 .6 1.8.6.9 0 1.7-.4 2.4-1.2.1.3.2.5.4.7.1.2.3.3.6.4.3.1.6.1 1.1.1h.1l.2-1.2h-.1c-.4.1-.6 0-.7-.1zM9.2 16c-.2.3-.5.6-.9.8-.3.1-.7.2-1.1.2-.4 0-.7-.1-.9-.3-.2-.2-.3-.5-.3-.9 0-.6.2-1 .7-1.3.5-.3 1.3-.4 2.5-.5v2zm10.6-3.9c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2s-.2 1.4-.6 2z" }) });

  // packages/icons/build-module/library/format-strikethrough.js
  var import_jsx_runtime35 = __toESM(require_jsx_runtime());
  var import_primitives34 = __toESM(require_primitives());
  var format_strikethrough_default = /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(import_primitives34.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(import_primitives34.Path, { d: "M9.1 9v-.5c0-.6.2-1.1.7-1.4.5-.3 1.2-.5 2-.5.7 0 1.4.1 2.1.3.7.2 1.4.5 2.1.9l.2-1.9c-.6-.3-1.2-.5-1.9-.7-.8-.1-1.6-.2-2.4-.2-1.5 0-2.7.3-3.6 1-.8.7-1.2 1.5-1.2 2.6V9h2zM20 12H4v1h8.3c.3.1.6.2.8.3.5.2.9.5 1.1.8.3.3.4.7.4 1.2 0 .7-.2 1.1-.8 1.5-.5.3-1.2.5-2.1.5-.8 0-1.6-.1-2.4-.3-.8-.2-1.5-.5-2.2-.8L7 18.1c.5.2 1.2.4 2 .6.8.2 1.6.3 2.4.3 1.7 0 3-.3 3.9-1 .9-.7 1.3-1.6 1.3-2.8 0-.9-.2-1.7-.7-2.2H20v-1z" }) });

  // packages/icons/build-module/library/format-underline.js
  var import_jsx_runtime36 = __toESM(require_jsx_runtime());
  var import_primitives35 = __toESM(require_primitives());
  var format_underline_default = /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(import_primitives35.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(import_primitives35.Path, { d: "M7 18v1h10v-1H7zm5-2c1.5 0 2.6-.4 3.4-1.2.8-.8 1.1-2 1.1-3.5V5H15v5.8c0 1.2-.2 2.1-.6 2.8-.4.7-1.2 1-2.4 1s-2-.3-2.4-1c-.4-.7-.6-1.6-.6-2.8V5H7.5v6.2c0 1.5.4 2.7 1.1 3.5.8.9 1.9 1.3 3.4 1.3z" }) });

  // packages/icons/build-module/library/format-uppercase.js
  var import_jsx_runtime37 = __toESM(require_jsx_runtime());
  var import_primitives36 = __toESM(require_primitives());
  var format_uppercase_default = /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(import_primitives36.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(import_primitives36.Path, { d: "M6.1 6.8L2.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H6.1zm-.8 6.8L7 8.9l1.7 4.7H5.3zm15.1-.7c-.4-.5-.9-.8-1.6-1 .4-.2.7-.5.8-.9.2-.4.3-.9.3-1.4 0-.9-.3-1.6-.8-2-.6-.5-1.3-.7-2.4-.7h-3.5V18h4.2c1.1 0 2-.3 2.6-.8.6-.6 1-1.4 1-2.4-.1-.8-.3-1.4-.6-1.9zm-5.7-4.7h1.8c.6 0 1.1.1 1.4.4.3.2.5.7.5 1.3 0 .6-.2 1.1-.5 1.3-.3.2-.8.4-1.4.4h-1.8V8.2zm4 8c-.4.3-.9.5-1.5.5h-2.6v-3.8h2.6c1.4 0 2 .6 2 1.9.1.6-.1 1-.5 1.4z" }) });

  // packages/icons/build-module/library/fullscreen.js
  var import_jsx_runtime38 = __toESM(require_jsx_runtime());
  var import_primitives37 = __toESM(require_primitives());
  var fullscreen_default = /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(import_primitives37.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(import_primitives37.Path, { d: "M6 4a2 2 0 0 0-2 2v3h1.5V6a.5.5 0 0 1 .5-.5h3V4H6Zm3 14.5H6a.5.5 0 0 1-.5-.5v-3H4v3a2 2 0 0 0 2 2h3v-1.5Zm6 1.5v-1.5h3a.5.5 0 0 0 .5-.5v-3H20v3a2 2 0 0 1-2 2h-3Zm3-16a2 2 0 0 1 2 2v3h-1.5V6a.5.5 0 0 0-.5-.5h-3V4h3Z" }) });

  // packages/icons/build-module/library/globe.js
  var import_jsx_runtime39 = __toESM(require_jsx_runtime());
  var import_primitives38 = __toESM(require_primitives());
  var globe_default = /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(import_primitives38.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(import_primitives38.Path, { d: "M12 4c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8Zm6.5 8c0 .6 0 1.2-.2 1.8h-2.7c0-.6.2-1.1.2-1.8s0-1.2-.2-1.8h2.7c.2.6.2 1.1.2 1.8Zm-.9-3.2h-2.4c-.3-.9-.7-1.8-1.1-2.4-.1-.2-.2-.4-.3-.5 1.6.5 3 1.6 3.8 3ZM12.8 17c-.3.5-.6 1-.8 1.3-.2-.3-.5-.8-.8-1.3-.3-.5-.6-1.1-.8-1.7h3.3c-.2.6-.5 1.2-.8 1.7Zm-2.9-3.2c-.1-.6-.2-1.1-.2-1.8s0-1.2.2-1.8H14c.1.6.2 1.1.2 1.8s0 1.2-.2 1.8H9.9ZM11.2 7c.3-.5.6-1 .8-1.3.2.3.5.8.8 1.3.3.5.6 1.1.8 1.7h-3.3c.2-.6.5-1.2.8-1.7Zm-1-1.2c-.1.2-.2.3-.3.5-.4.7-.8 1.5-1.1 2.4H6.4c.8-1.4 2.2-2.5 3.8-3Zm-1.8 8H5.7c-.2-.6-.2-1.1-.2-1.8s0-1.2.2-1.8h2.7c0 .6-.2 1.1-.2 1.8s0 1.2.2 1.8Zm-2 1.4h2.4c.3.9.7 1.8 1.1 2.4.1.2.2.4.3.5-1.6-.5-3-1.6-3.8-3Zm7.4 3c.1-.2.2-.3.3-.5.4-.7.8-1.5 1.1-2.4h2.4c-.8 1.4-2.2 2.5-3.8 3Z" }) });

  // packages/icons/build-module/library/grid.js
  var import_jsx_runtime40 = __toESM(require_jsx_runtime());
  var import_primitives39 = __toESM(require_primitives());
  var grid_default = /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(import_primitives39.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    import_primitives39.Path,
    {
      d: "m3 5c0-1.10457.89543-2 2-2h13.5c1.1046 0 2 .89543 2 2v13.5c0 1.1046-.8954 2-2 2h-13.5c-1.10457 0-2-.8954-2-2zm2-.5h6v6.5h-6.5v-6c0-.27614.22386-.5.5-.5zm-.5 8v6c0 .2761.22386.5.5.5h6v-6.5zm8 0v6.5h6c.2761 0 .5-.2239.5-.5v-6zm0-8v6.5h6.5v-6c0-.27614-.2239-.5-.5-.5z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  ) });

  // packages/icons/build-module/library/group.js
  var import_jsx_runtime41 = __toESM(require_jsx_runtime());
  var import_primitives40 = __toESM(require_primitives());
  var group_default = /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(import_primitives40.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(import_primitives40.Path, { d: "M18 4h-7c-1.1 0-2 .9-2 2v3H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-3h3c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4.5 14c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h3V13c0 1.1.9 2 2 2h2.5v3zm0-4.5H11c-.3 0-.5-.2-.5-.5v-2.5H13c.3 0 .5.2.5.5v2.5zm5-.5c0 .3-.2.5-.5.5h-3V11c0-1.1-.9-2-2-2h-2.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7z" }) });

  // packages/icons/build-module/library/heading-level-1.js
  var import_jsx_runtime42 = __toESM(require_jsx_runtime());
  var import_primitives41 = __toESM(require_primitives());
  var heading_level_1_default = /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(import_primitives41.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(import_primitives41.Path, { d: "M17.6 7c-.6.9-1.5 1.7-2.6 2v1h2v7h2V7h-1.4zM11 11H7V7H5v10h2v-4h4v4h2V7h-2v4z" }) });

  // packages/icons/build-module/library/heading-level-2.js
  var import_jsx_runtime43 = __toESM(require_jsx_runtime());
  var import_primitives42 = __toESM(require_primitives());
  var heading_level_2_default = /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(import_primitives42.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(import_primitives42.Path, { d: "M9 11.1H5v-4H3v10h2v-4h4v4h2v-10H9v4zm8 4c.5-.4.6-.6 1.1-1.1.4-.4.8-.8 1.2-1.3.3-.4.6-.8.9-1.3.2-.4.3-.8.3-1.3 0-.4-.1-.9-.3-1.3-.2-.4-.4-.7-.8-1-.3-.3-.7-.5-1.2-.6-.5-.2-1-.2-1.5-.2-.4 0-.7 0-1.1.1-.3.1-.7.2-1 .3-.3.1-.6.3-.9.5-.3.2-.6.4-.8.7l1.2 1.2c.3-.3.6-.5 1-.7.4-.2.7-.3 1.2-.3s.9.1 1.3.4c.3.3.5.7.5 1.1 0 .4-.1.8-.4 1.1-.3.5-.6.9-1 1.2-.4.4-1 .9-1.6 1.4-.6.5-1.4 1.1-2.2 1.6v1.5h8v-2H17z" }) });

  // packages/icons/build-module/library/heading-level-3.js
  var import_jsx_runtime44 = __toESM(require_jsx_runtime());
  var import_primitives43 = __toESM(require_primitives());
  var heading_level_3_default = /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(import_primitives43.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(import_primitives43.Path, { d: "M9 11H5V7H3v10h2v-4h4v4h2V7H9v4zm11.3 1.7c-.4-.4-1-.7-1.6-.8v-.1c.6-.2 1.1-.5 1.5-.9.3-.4.5-.8.5-1.3 0-.4-.1-.8-.3-1.1-.2-.3-.5-.6-.8-.8-.4-.2-.8-.4-1.2-.5-.6-.1-1.1-.2-1.6-.2-.6 0-1.3.1-1.8.3s-1.1.5-1.6.9l1.2 1.4c.4-.2.7-.4 1.1-.6.3-.2.7-.3 1.1-.3.4 0 .8.1 1.1.3.3.2.4.5.4.8 0 .4-.2.7-.6.9-.7.3-1.5.5-2.2.4v1.6c.5 0 1 0 1.5.1.3.1.7.2 1 .3.2.1.4.2.5.4s.1.4.1.6c0 .3-.2.7-.5.8-.4.2-.9.3-1.4.3s-1-.1-1.4-.3c-.4-.2-.8-.4-1.2-.7L13 15.6c.5.4 1 .8 1.6 1 .7.3 1.5.4 2.3.4.6 0 1.1-.1 1.6-.2.4-.1.9-.2 1.3-.5.4-.2.7-.5.9-.9.2-.4.3-.8.3-1.2 0-.6-.3-1.1-.7-1.5z" }) });

  // packages/icons/build-module/library/heading-level-4.js
  var import_jsx_runtime45 = __toESM(require_jsx_runtime());
  var import_primitives44 = __toESM(require_primitives());
  var heading_level_4_default = /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(import_primitives44.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(import_primitives44.Path, { d: "M20 13V7h-3l-4 6v2h5v2h2v-2h1v-2h-1zm-2 0h-2.8L18 9v4zm-9-2H5V7H3v10h2v-4h4v4h2V7H9v4z" }) });

  // packages/icons/build-module/library/heading-level-5.js
  var import_jsx_runtime46 = __toESM(require_jsx_runtime());
  var import_primitives45 = __toESM(require_primitives());
  var heading_level_5_default = /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(import_primitives45.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(import_primitives45.Path, { d: "M9 11H5V7H3v10h2v-4h4v4h2V7H9v4zm11.7 1.2c-.2-.3-.5-.7-.8-.9-.3-.3-.7-.5-1.1-.6-.5-.1-.9-.2-1.4-.2-.2 0-.5.1-.7.1-.2.1-.5.1-.7.2l.1-1.9h4.3V7H14l-.3 5 1 .6.5-.2.4-.1c.1-.1.3-.1.4-.1h.5c.5 0 1 .1 1.4.4.4.2.6.7.6 1.1 0 .4-.2.8-.6 1.1-.4.3-.9.4-1.4.4-.4 0-.9-.1-1.3-.3-.4-.2-.7-.4-1.1-.7 0 0-1.1 1.4-1 1.5.5.4 1 .8 1.6 1 .7.3 1.5.4 2.3.4.5 0 1-.1 1.5-.3s.9-.4 1.3-.7c.4-.3.7-.7.9-1.1s.3-.9.3-1.4-.1-1-.3-1.4z" }) });

  // packages/icons/build-module/library/heading-level-6.js
  var import_jsx_runtime47 = __toESM(require_jsx_runtime());
  var import_primitives46 = __toESM(require_primitives());
  var heading_level_6_default = /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(import_primitives46.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(import_primitives46.Path, { d: "M20.7 12.4c-.2-.3-.4-.6-.7-.9s-.6-.5-1-.6c-.4-.2-.8-.2-1.2-.2-.5 0-.9.1-1.3.3s-.8.5-1.2.8c0-.5 0-.9.2-1.4l.6-.9c.2-.2.5-.4.8-.5.6-.2 1.3-.2 1.9 0 .3.1.6.3.8.5 0 0 1.3-1.3 1.3-1.4-.4-.3-.9-.6-1.4-.8-.6-.2-1.3-.3-2-.3-.6 0-1.1.1-1.7.4-.5.2-1 .5-1.4.9-.4.4-.8 1-1 1.6-.3.7-.4 1.5-.4 2.3s.1 1.5.3 2.1c.2.6.6 1.1 1 1.5.4.4.9.7 1.4.9 1 .3 2 .3 3 0 .4-.1.8-.3 1.2-.6.3-.3.6-.6.8-1 .2-.5.3-.9.3-1.4s-.1-.9-.3-1.3zm-2 2.1c-.1.2-.3.4-.4.5-.1.1-.3.2-.5.2-.2.1-.4.1-.6.1-.2.1-.5 0-.7-.1-.2 0-.3-.2-.5-.3-.1-.2-.3-.4-.4-.6-.2-.3-.3-.7-.3-1 .3-.3.6-.5 1-.7.3-.1.7-.2 1-.2.4 0 .8.1 1.1.3.3.3.4.7.4 1.1 0 .2 0 .5-.1.7zM9 11H5V7H3v10h2v-4h4v4h2V7H9v4z" }) });

  // packages/icons/build-module/library/home.js
  var import_jsx_runtime48 = __toESM(require_jsx_runtime());
  var import_primitives47 = __toESM(require_primitives());
  var home_default = /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(import_primitives47.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(import_primitives47.Path, { d: "M12 4L4 7.9V20h16V7.9L12 4zm6.5 14.5H14V13h-4v5.5H5.5V8.8L12 5.7l6.5 3.1v9.7z" }) });

  // packages/icons/build-module/library/image.js
  var import_jsx_runtime49 = __toESM(require_jsx_runtime());
  var import_primitives48 = __toESM(require_primitives());
  var image_default = /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(import_primitives48.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(import_primitives48.Path, { d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM5 4.5h14c.3 0 .5.2.5.5v8.4l-3-2.9c-.3-.3-.8-.3-1 0L11.9 14 9 12c-.3-.2-.6-.2-.8 0l-3.6 2.6V5c-.1-.3.1-.5.4-.5zm14 15H5c-.3 0-.5-.2-.5-.5v-2.4l4.1-3 3 1.9c.3.2.7.2.9-.1L16 12l3.5 3.4V19c0 .3-.2.5-.5.5z" }) });

  // packages/icons/build-module/library/info.js
  var import_jsx_runtime50 = __toESM(require_jsx_runtime());
  var import_primitives49 = __toESM(require_primitives());
  var info_default = /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(import_primitives49.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
    import_primitives49.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.5 12a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm.75 4v1.5h-1.5V8h1.5Zm0 8v-5h-1.5v5h1.5Z"
    }
  ) });

  // packages/icons/build-module/library/justify-bottom.js
  var import_jsx_runtime51 = __toESM(require_jsx_runtime());
  var import_primitives50 = __toESM(require_primitives());
  var justify_bottom_default = /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(import_primitives50.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(import_primitives50.Path, { d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z" }) });

  // packages/icons/build-module/library/justify-center-vertical.js
  var import_jsx_runtime52 = __toESM(require_jsx_runtime());
  var import_primitives51 = __toESM(require_primitives());
  var justify_center_vertical_default = /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(import_primitives51.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(import_primitives51.Path, { d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z" }) });

  // packages/icons/build-module/library/justify-center.js
  var import_jsx_runtime53 = __toESM(require_jsx_runtime());
  var import_primitives52 = __toESM(require_primitives());
  var justify_center_default = /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(import_primitives52.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(import_primitives52.Path, { d: "M12.5 15v5H11v-5H4V9h7V4h1.5v5h7v6h-7Z" }) });

  // packages/icons/build-module/library/justify-left.js
  var import_jsx_runtime54 = __toESM(require_jsx_runtime());
  var import_primitives53 = __toESM(require_primitives());
  var justify_left_default = /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(import_primitives53.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(import_primitives53.Path, { d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z" }) });

  // packages/icons/build-module/library/justify-right.js
  var import_jsx_runtime55 = __toESM(require_jsx_runtime());
  var import_primitives54 = __toESM(require_primitives());
  var justify_right_default = /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(import_primitives54.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(import_primitives54.Path, { d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z" }) });

  // packages/icons/build-module/library/justify-space-between-vertical.js
  var import_jsx_runtime56 = __toESM(require_jsx_runtime());
  var import_primitives55 = __toESM(require_primitives());
  var justify_space_between_vertical_default = /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(import_primitives55.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(import_primitives55.Path, { d: "M7 4H17V8L7 8V4ZM7 16L17 16V20L7 20V16ZM20 11.25H4V12.75H20V11.25Z" }) });

  // packages/icons/build-module/library/justify-space-between.js
  var import_jsx_runtime57 = __toESM(require_jsx_runtime());
  var import_primitives56 = __toESM(require_primitives());
  var justify_space_between_default = /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(import_primitives56.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(import_primitives56.Path, { d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z" }) });

  // packages/icons/build-module/library/justify-stretch-vertical.js
  var import_jsx_runtime58 = __toESM(require_jsx_runtime());
  var import_primitives57 = __toESM(require_primitives());
  var justify_stretch_vertical_default = /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(import_primitives57.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(import_primitives57.Path, { d: "M4 4L20 4L20 5.5L4 5.5L4 4ZM10 7L14 7L14 17L10 17L10 7ZM20 18.5L4 18.5L4 20L20 20L20 18.5Z" }) });

  // packages/icons/build-module/library/justify-stretch.js
  var import_jsx_runtime59 = __toESM(require_jsx_runtime());
  var import_primitives58 = __toESM(require_primitives());
  var justify_stretch_default = /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(import_primitives58.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(import_primitives58.Path, { d: "M4 4H5.5V20H4V4ZM7 10L17 10V14L7 14V10ZM20 4H18.5V20H20V4Z" }) });

  // packages/icons/build-module/library/justify-top.js
  var import_jsx_runtime60 = __toESM(require_jsx_runtime());
  var import_primitives59 = __toESM(require_primitives());
  var justify_top_default = /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(import_primitives59.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(import_primitives59.Path, { d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z" }) });

  // packages/icons/build-module/library/keyboard-return.js
  var import_jsx_runtime61 = __toESM(require_jsx_runtime());
  var import_primitives60 = __toESM(require_primitives());
  var keyboard_return_default = /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(import_primitives60.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(import_primitives60.Path, { d: "m6.734 16.106 2.176-2.38-1.093-1.028-3.846 4.158 3.846 4.158 1.093-1.028-2.176-2.38h2.811c1.125 0 2.25.03 3.374 0 1.428-.001 3.362-.25 4.963-1.277 1.66-1.065 2.868-2.906 2.868-5.859 0-2.479-1.327-4.896-3.65-5.93-1.82-.813-3.044-.8-4.806-.788l-.567.002v1.5c.184 0 .368 0 .553-.002 1.82-.007 2.704-.014 4.21.657 1.854.827 2.76 2.657 2.76 4.561 0 2.472-.973 3.824-2.178 4.596-1.258.807-2.864 1.04-4.163 1.04h-.02c-1.115.03-2.229 0-3.344 0H6.734Z" }) });

  // packages/icons/build-module/library/layout.js
  var import_jsx_runtime62 = __toESM(require_jsx_runtime());
  var import_primitives61 = __toESM(require_primitives());
  var layout_default = /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(import_primitives61.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(import_primitives61.Path, { d: "M18 5.5H6a.5.5 0 00-.5.5v3h13V6a.5.5 0 00-.5-.5zm.5 5H10v8h8a.5.5 0 00.5-.5v-7.5zm-10 0h-3V18a.5.5 0 00.5.5h2.5v-8zM6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2z" }) });

  // packages/icons/build-module/library/link-off.js
  var import_jsx_runtime63 = __toESM(require_jsx_runtime());
  var import_primitives62 = __toESM(require_primitives());
  var link_off_default = /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(import_primitives62.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(import_primitives62.Path, { d: "M17.031 4.703 15.576 4l-1.56 3H14v.03l-2.324 4.47H9.5V13h1.396l-1.502 2.889h-.95a3.694 3.694 0 0 1 0-7.389H10V7H8.444a5.194 5.194 0 1 0 0 10.389h.17L7.5 19.53l1.416.719L15.049 8.5h.507a3.694 3.694 0 0 1 0 7.39H14v1.5h1.556a5.194 5.194 0 0 0 .273-10.383l1.202-2.304Z" }) });

  // packages/icons/build-module/library/link.js
  var import_jsx_runtime64 = __toESM(require_jsx_runtime());
  var import_primitives63 = __toESM(require_primitives());
  var link_default = /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(import_primitives63.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(import_primitives63.Path, { d: "M10 17.389H8.444A5.194 5.194 0 1 1 8.444 7H10v1.5H8.444a3.694 3.694 0 0 0 0 7.389H10v1.5ZM14 7h1.556a5.194 5.194 0 0 1 0 10.39H14v-1.5h1.556a3.694 3.694 0 0 0 0-7.39H14V7Zm-4.5 6h5v-1.5h-5V13Z" }) });

  // packages/icons/build-module/library/list-view.js
  var import_jsx_runtime65 = __toESM(require_jsx_runtime());
  var import_primitives64 = __toESM(require_primitives());
  var list_view_default = /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(import_primitives64.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(import_primitives64.Path, { d: "M3 6h11v1.5H3V6Zm3.5 5.5h11V13h-11v-1.5ZM21 17H10v1.5h11V17Z" }) });

  // packages/icons/build-module/library/lock-outline.js
  var import_jsx_runtime66 = __toESM(require_jsx_runtime());
  var import_primitives65 = __toESM(require_primitives());
  var lock_outline_default = /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(import_primitives65.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(import_primitives65.Path, { d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zM9.8 7c0-1.2 1-2.2 2.2-2.2 1.2 0 2.2 1 2.2 2.2v3H9.8V7zm6.7 11.5h-9v-7h9v7z" }) });

  // packages/icons/build-module/library/lock-small.js
  var import_jsx_runtime67 = __toESM(require_jsx_runtime());
  var import_primitives66 = __toESM(require_primitives());
  var lock_small_default = /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(import_primitives66.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
    import_primitives66.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M15 11h-.2V9c0-1.5-1.2-2.8-2.8-2.8S9.2 7.5 9.2 9v2H9c-.6 0-1 .4-1 1v4c0 .6.4 1 1 1h6c.6 0 1-.4 1-1v-4c0-.6-.4-1-1-1zm-1.8 0h-2.5V9c0-.7.6-1.2 1.2-1.2s1.2.6 1.2 1.2v2z"
    }
  ) });

  // packages/icons/build-module/library/lock.js
  var import_jsx_runtime68 = __toESM(require_jsx_runtime());
  var import_primitives67 = __toESM(require_primitives());
  var lock_default = /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(import_primitives67.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(import_primitives67.Path, { d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zm-2.8 0H9.8V7c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3z" }) });

  // packages/icons/build-module/library/media.js
  var import_jsx_runtime69 = __toESM(require_jsx_runtime());
  var import_primitives68 = __toESM(require_primitives());
  var media_default = /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)(import_primitives68.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(import_primitives68.Path, { d: "m7 6.5 4 2.5-4 2.5z" }),
    /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
      import_primitives68.Path,
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m5 3c-1.10457 0-2 .89543-2 2v14c0 1.1046.89543 2 2 2h14c1.1046 0 2-.8954 2-2v-14c0-1.10457-.8954-2-2-2zm14 1.5h-14c-.27614 0-.5.22386-.5.5v10.7072l3.62953-2.6465c.25108-.1831.58905-.1924.84981-.0234l2.92666 1.8969 3.5712-3.4719c.2911-.2831.7545-.2831 1.0456 0l2.9772 2.8945v-9.3568c0-.27614-.2239-.5-.5-.5zm-14.5 14.5v-1.4364l4.09643-2.987 2.99567 1.9417c.2936.1903.6798.1523.9307-.0917l3.4772-3.3806 3.4772 3.3806.0228-.0234v2.5968c0 .2761-.2239.5-.5.5h-14c-.27614 0-.5-.2239-.5-.5z"
      }
    )
  ] });

  // packages/icons/build-module/library/more-vertical.js
  var import_jsx_runtime70 = __toESM(require_jsx_runtime());
  var import_primitives69 = __toESM(require_primitives());
  var more_vertical_default = /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(import_primitives69.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(import_primitives69.Path, { d: "M13 19h-2v-2h2v2zm0-6h-2v-2h2v2zm0-6h-2V5h2v2z" }) });

  // packages/icons/build-module/library/page.js
  var import_jsx_runtime71 = __toESM(require_jsx_runtime());
  var import_primitives70 = __toESM(require_primitives());
  var page_default = /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_primitives70.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(import_primitives70.Path, { d: "M15.5 7.5h-7V9h7V7.5Zm-7 3.5h7v1.5h-7V11Zm7 3.5h-7V16h7v-1.5Z" }),
    /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(import_primitives70.Path, { d: "M17 4H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2ZM7 5.5h10a.5.5 0 0 1 .5.5v12a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V6a.5.5 0 0 1 .5-.5Z" })
  ] });

  // packages/icons/build-module/library/paragraph.js
  var import_jsx_runtime72 = __toESM(require_jsx_runtime());
  var import_primitives71 = __toESM(require_primitives());
  var paragraph_default = /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(import_primitives71.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(import_primitives71.Path, { d: "m9.99609 14v-.2251l.00391.0001v6.225h1.5v-14.5h2.5v14.5h1.5v-14.5h3v-1.5h-8.50391c-2.76142 0-5 2.23858-5 5 0 2.7614 2.23858 5 5 5z" }) });

  // packages/icons/build-module/library/pencil.js
  var import_jsx_runtime73 = __toESM(require_jsx_runtime());
  var import_primitives72 = __toESM(require_primitives());
  var pencil_default = /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(import_primitives72.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(import_primitives72.Path, { d: "m19 7-3-3-8.5 8.5-1 4 4-1L19 7Zm-7 11.5H5V20h7v-1.5Z" }) });

  // packages/icons/build-module/library/pin-small.js
  var import_jsx_runtime74 = __toESM(require_jsx_runtime());
  var import_primitives73 = __toESM(require_primitives());
  var pin_small_default = /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(import_primitives73.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(import_primitives73.Path, { d: "M10.97 10.159a3.382 3.382 0 0 0-2.857.955l1.724 1.723-2.836 2.913L7 17h1.25l2.913-2.837 1.723 1.723a3.38 3.38 0 0 0 .606-.825c.33-.63.446-1.343.35-2.032L17 10.695 13.305 7l-2.334 3.159Z" }) });

  // packages/icons/build-module/library/plus.js
  var import_jsx_runtime75 = __toESM(require_jsx_runtime());
  var import_primitives74 = __toESM(require_primitives());
  var plus_default = /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(import_primitives74.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(import_primitives74.Path, { d: "M11 12.5V17.5H12.5V12.5H17.5V11H12.5V6H11V11H6V12.5H11Z" }) });

  // packages/icons/build-module/library/position-center.js
  var import_jsx_runtime76 = __toESM(require_jsx_runtime());
  var import_primitives75 = __toESM(require_primitives());
  var position_center_default = /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(import_primitives75.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(import_primitives75.Path, { d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM7 9h10v6H7V9Z" }) });

  // packages/icons/build-module/library/position-left.js
  var import_jsx_runtime77 = __toESM(require_jsx_runtime());
  var import_primitives76 = __toESM(require_primitives());
  var position_left_default = /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(import_primitives76.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(import_primitives76.Path, { d: "M5 5.5h8V4H5v1.5ZM5 20h8v-1.5H5V20ZM19 9H5v6h14V9Z" }) });

  // packages/icons/build-module/library/position-right.js
  var import_jsx_runtime78 = __toESM(require_jsx_runtime());
  var import_primitives77 = __toESM(require_primitives());
  var position_right_default = /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(import_primitives77.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(import_primitives77.Path, { d: "M19 5.5h-8V4h8v1.5ZM19 20h-8v-1.5h8V20ZM5 9h14v6H5V9Z" }) });

  // packages/icons/build-module/library/post-featured-image.js
  var import_jsx_runtime79 = __toESM(require_jsx_runtime());
  var import_primitives78 = __toESM(require_primitives());
  var post_featured_image_default = /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(import_primitives78.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(import_primitives78.Path, { d: "M19 3H5c-.6 0-1 .4-1 1v7c0 .5.4 1 1 1h14c.5 0 1-.4 1-1V4c0-.6-.4-1-1-1zM5.5 10.5v-.4l1.8-1.3 1.3.8c.3.2.7.2.9-.1L11 8.1l2.4 2.4H5.5zm13 0h-2.9l-4-4c-.3-.3-.8-.3-1.1 0L8.9 8l-1.2-.8c-.3-.2-.6-.2-.9 0l-1.3 1V4.5h13v6zM4 20h9v-1.5H4V20zm0-4h16v-1.5H4V16z" }) });

  // packages/icons/build-module/library/post-list.js
  var import_jsx_runtime80 = __toESM(require_jsx_runtime());
  var import_primitives79 = __toESM(require_primitives());
  var post_list_default = /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(import_primitives79.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(import_primitives79.Path, { d: "M18 5.5H6a.5.5 0 0 0-.5.5v12a.5.5 0 0 0 .5.5h12a.5.5 0 0 0 .5-.5V6a.5.5 0 0 0-.5-.5ZM6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm1 5h1.5v1.5H7V9Zm1.5 4.5H7V15h1.5v-1.5ZM10 9h7v1.5h-7V9Zm7 4.5h-7V15h7v-1.5Z" }) });

  // packages/icons/build-module/library/post.js
  var import_jsx_runtime81 = __toESM(require_jsx_runtime());
  var import_primitives80 = __toESM(require_primitives());
  var post_default = /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(import_primitives80.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(import_primitives80.Path, { d: "m7.3 9.7 1.4 1.4c.2-.2.3-.3.4-.5 0 0 0-.1.1-.1.3-.5.4-1.1.3-1.6L12 7 9 4 7.2 6.5c-.6-.1-1.1 0-1.6.3 0 0-.1 0-.1.1-.3.1-.4.2-.6.4l1.4 1.4L4 11v1h1l2.3-2.3zM4 20h9v-1.5H4V20zm0-5.5V16h16v-1.5H4z" }) });

  // packages/icons/build-module/library/reset.js
  var import_jsx_runtime82 = __toESM(require_jsx_runtime());
  var import_primitives81 = __toESM(require_primitives());
  var reset_default = /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(import_primitives81.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(import_primitives81.Path, { d: "M7 11.5h10V13H7z" }) });

  // packages/icons/build-module/library/rotate-right.js
  var import_jsx_runtime83 = __toESM(require_jsx_runtime());
  var import_primitives82 = __toESM(require_primitives());
  var rotate_right_default = /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(import_primitives82.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(import_primitives82.Path, { d: "M15.1 4.8l-3-2.5V4c-4.4 0-8 3.6-8 8 0 3.7 2.5 6.9 6 7.7.3.1.6.1 1 .2l.2-1.5c-.4 0-.7-.1-1.1-.2l-.1.2v-.2c-2.6-.8-4.5-3.3-4.5-6.2 0-3.6 2.9-6.5 6.5-6.5v1.8l3-2.5zM20 11c-.2-1.4-.7-2.7-1.6-3.8l-1.2.8c.7.9 1.1 2 1.3 3.1L20 11zm-1.5 1.8c-.1.5-.2 1.1-.4 1.6s-.5 1-.8 1.5l1.2.9c.4-.5.8-1.1 1-1.8s.5-1.3.5-2l-1.5-.2zm-5.6 5.6l.2 1.5c1.4-.2 2.7-.7 3.8-1.6l-.9-1.1c-.9.7-2 1.1-3.1 1.2z" }) });

  // packages/icons/build-module/library/row.js
  var import_jsx_runtime84 = __toESM(require_jsx_runtime());
  var import_primitives83 = __toESM(require_primitives());
  var row_default = /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(import_primitives83.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(import_primitives83.Path, { d: "M4 6.5h5a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4V16h5a.5.5 0 0 0 .5-.5v-7A.5.5 0 0 0 9 8H4V6.5Zm16 0h-5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h5V16h-5a.5.5 0 0 1-.5-.5v-7A.5.5 0 0 1 15 8h5V6.5Z" }) });

  // packages/icons/build-module/library/search.js
  var import_jsx_runtime85 = __toESM(require_jsx_runtime());
  var import_primitives84 = __toESM(require_primitives());
  var search_default = /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(import_primitives84.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(import_primitives84.Path, { d: "M13 5c-3.3 0-6 2.7-6 6 0 1.4.5 2.7 1.3 3.7l-3.8 3.8 1.1 1.1 3.8-3.8c1 .8 2.3 1.3 3.7 1.3 3.3 0 6-2.7 6-6S16.3 5 13 5zm0 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z" }) });

  // packages/icons/build-module/library/seen.js
  var import_jsx_runtime86 = __toESM(require_jsx_runtime());
  var import_primitives85 = __toESM(require_primitives());
  var seen_default = /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(import_primitives85.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(import_primitives85.Path, { d: "M3.99961 13C4.67043 13.3354 4.6703 13.3357 4.67017 13.3359L4.67298 13.3305C4.67621 13.3242 4.68184 13.3135 4.68988 13.2985C4.70595 13.2686 4.7316 13.2218 4.76695 13.1608C4.8377 13.0385 4.94692 12.8592 5.09541 12.6419C5.39312 12.2062 5.84436 11.624 6.45435 11.0431C7.67308 9.88241 9.49719 8.75 11.9996 8.75C14.502 8.75 16.3261 9.88241 17.5449 11.0431C18.1549 11.624 18.6061 12.2062 18.9038 12.6419C19.0523 12.8592 19.1615 13.0385 19.2323 13.1608C19.2676 13.2218 19.2933 13.2686 19.3093 13.2985C19.3174 13.3135 19.323 13.3242 19.3262 13.3305L19.3291 13.3359C19.3289 13.3357 19.3288 13.3354 19.9996 13C20.6704 12.6646 20.6703 12.6643 20.6701 12.664L20.6697 12.6632L20.6688 12.6614L20.6662 12.6563L20.6583 12.6408C20.6517 12.6282 20.6427 12.6108 20.631 12.5892C20.6078 12.5459 20.5744 12.4852 20.5306 12.4096C20.4432 12.2584 20.3141 12.0471 20.1423 11.7956C19.7994 11.2938 19.2819 10.626 18.5794 9.9569C17.1731 8.61759 14.9972 7.25 11.9996 7.25C9.00203 7.25 6.82614 8.61759 5.41987 9.9569C4.71736 10.626 4.19984 11.2938 3.85694 11.7956C3.68511 12.0471 3.55605 12.2584 3.4686 12.4096C3.42484 12.4852 3.39142 12.5459 3.36818 12.5892C3.35656 12.6108 3.34748 12.6282 3.34092 12.6408L3.33297 12.6563L3.33041 12.6614L3.32948 12.6632L3.32911 12.664C3.32894 12.6643 3.32879 12.6646 3.99961 13ZM11.9996 16C13.9326 16 15.4996 14.433 15.4996 12.5C15.4996 10.567 13.9326 9 11.9996 9C10.0666 9 8.49961 10.567 8.49961 12.5C8.49961 14.433 10.0666 16 11.9996 16Z" }) });

  // packages/icons/build-module/library/settings.js
  var import_jsx_runtime87 = __toESM(require_jsx_runtime());
  var import_primitives86 = __toESM(require_primitives());
  var settings_default = /* @__PURE__ */ (0, import_jsx_runtime87.jsxs)(import_primitives86.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(import_primitives86.Path, { d: "m19 7.5h-7.628c-.3089-.87389-1.1423-1.5-2.122-1.5-.97966 0-1.81309.62611-2.12197 1.5h-2.12803v1.5h2.12803c.30888.87389 1.14231 1.5 2.12197 1.5.9797 0 1.8131-.62611 2.122-1.5h7.628z" }),
    /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(import_primitives86.Path, { d: "m19 15h-2.128c-.3089-.8739-1.1423-1.5-2.122-1.5s-1.8131.6261-2.122 1.5h-7.628v1.5h7.628c.3089.8739 1.1423 1.5 2.122 1.5s1.8131-.6261 2.122-1.5h2.128z" })
  ] });

  // packages/icons/build-module/library/shadow.js
  var import_jsx_runtime88 = __toESM(require_jsx_runtime());
  var import_primitives87 = __toESM(require_primitives());
  var shadow_default = /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(import_primitives87.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(import_primitives87.Path, { d: "M12 8c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 6.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5zM12.8 3h-1.5v3h1.5V3zm-1.6 18h1.5v-3h-1.5v3zm6.8-9.8v1.5h3v-1.5h-3zm-12 0H3v1.5h3v-1.5zm9.7 5.6 2.1 2.1 1.1-1.1-2.1-2.1-1.1 1.1zM8.3 7.2 6.2 5.1 5.1 6.2l2.1 2.1 1.1-1.1zM5.1 17.8l1.1 1.1 2.1-2.1-1.1-1.1-2.1 2.1zM18.9 6.2l-1.1-1.1-2.1 2.1 1.1 1.1 2.1-2.1z" }) });

  // packages/icons/build-module/library/sides-all.js
  var import_jsx_runtime89 = __toESM(require_jsx_runtime());
  var import_primitives88 = __toESM(require_primitives());
  var sides_all_default = /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(import_primitives88.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(import_primitives88.Path, { d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z" }) });

  // packages/icons/build-module/library/sides-bottom.js
  var import_jsx_runtime90 = __toESM(require_jsx_runtime());
  var import_primitives89 = __toESM(require_primitives());
  var sides_bottom_default = /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(import_primitives89.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
      import_primitives89.Path,
      {
        d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
        style: { opacity: 0.25 }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(import_primitives89.Path, { d: "m16.5 19.5h-9v-1.5h9z" })
  ] });

  // packages/icons/build-module/library/sides-horizontal.js
  var import_jsx_runtime91 = __toESM(require_jsx_runtime());
  var import_primitives90 = __toESM(require_primitives());
  var sides_horizontal_default = /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(import_primitives90.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
      import_primitives90.Path,
      {
        d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
        style: { opacity: 0.25 }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(import_primitives90.Path, { d: "m4.5 7.5v9h1.5v-9z" }),
    /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(import_primitives90.Path, { d: "m18 7.5v9h1.5v-9z" })
  ] });

  // packages/icons/build-module/library/sides-left.js
  var import_jsx_runtime92 = __toESM(require_jsx_runtime());
  var import_primitives91 = __toESM(require_primitives());
  var sides_left_default = /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)(import_primitives91.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
      import_primitives91.Path,
      {
        d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
        style: { opacity: 0.25 }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(import_primitives91.Path, { d: "m4.5 16.5v-9h1.5v9z" })
  ] });

  // packages/icons/build-module/library/sides-right.js
  var import_jsx_runtime93 = __toESM(require_jsx_runtime());
  var import_primitives92 = __toESM(require_primitives());
  var sides_right_default = /* @__PURE__ */ (0, import_jsx_runtime93.jsxs)(import_primitives92.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
      import_primitives92.Path,
      {
        d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
        style: { opacity: 0.25 }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(import_primitives92.Path, { d: "m18 16.5v-9h1.5v9z" })
  ] });

  // packages/icons/build-module/library/sides-top.js
  var import_jsx_runtime94 = __toESM(require_jsx_runtime());
  var import_primitives93 = __toESM(require_primitives());
  var sides_top_default = /* @__PURE__ */ (0, import_jsx_runtime94.jsxs)(import_primitives93.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
      import_primitives93.Path,
      {
        d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
        style: { opacity: 0.25 }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(import_primitives93.Path, { d: "m16.5 6h-9v-1.5h9z" })
  ] });

  // packages/icons/build-module/library/sides-vertical.js
  var import_jsx_runtime95 = __toESM(require_jsx_runtime());
  var import_primitives94 = __toESM(require_primitives());
  var sides_vertical_default = /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)(import_primitives94.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(
      import_primitives94.Path,
      {
        d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
        style: { opacity: 0.25 }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(import_primitives94.Path, { d: "m7.5 6h9v-1.5h-9z" }),
    /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(import_primitives94.Path, { d: "m7.5 19.5h9v-1.5h-9z" })
  ] });

  // packages/icons/build-module/library/stack.js
  var import_jsx_runtime96 = __toESM(require_jsx_runtime());
  var import_primitives95 = __toESM(require_primitives());
  var stack_default = /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(import_primitives95.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(import_primitives95.Path, { d: "M17.5 4v5a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V4H8v5a.5.5 0 0 0 .5.5h7A.5.5 0 0 0 16 9V4h1.5Zm0 16v-5a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2v5H8v-5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v5h1.5Z" }) });

  // packages/icons/build-module/library/stretch-full-width.js
  var import_jsx_runtime97 = __toESM(require_jsx_runtime());
  var import_primitives96 = __toESM(require_primitives());
  var stretch_full_width_default = /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(import_primitives96.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(import_primitives96.Path, { d: "M5 4h14v11H5V4Zm11 16H8v-1.5h8V20Z" }) });

  // packages/icons/build-module/library/stretch-wide.js
  var import_jsx_runtime98 = __toESM(require_jsx_runtime());
  var import_primitives97 = __toESM(require_primitives());
  var stretch_wide_default = /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(import_primitives97.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(import_primitives97.Path, { d: "M16 5.5H8V4h8v1.5ZM16 20H8v-1.5h8V20ZM5 9h14v6H5V9Z" }) });

  // packages/icons/build-module/library/styles.js
  var import_jsx_runtime99 = __toESM(require_jsx_runtime());
  var import_primitives98 = __toESM(require_primitives());
  var styles_default = /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(import_primitives98.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(
    import_primitives98.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M20 12a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-1.5 0a6.5 6.5 0 0 1-6.5 6.5v-13a6.5 6.5 0 0 1 6.5 6.5Z"
    }
  ) });

  // packages/icons/build-module/library/symbol.js
  var import_jsx_runtime100 = __toESM(require_jsx_runtime());
  var import_primitives99 = __toESM(require_primitives());
  var symbol_default = /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(import_primitives99.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(import_primitives99.Path, { d: "M21.3 10.8l-5.6-5.6c-.7-.7-1.8-.7-2.5 0l-5.6 5.6c-.7.7-.7 1.8 0 2.5l5.6 5.6c.3.3.8.5 1.2.5s.9-.2 1.2-.5l5.6-5.6c.8-.7.8-1.9.1-2.5zm-1 1.4l-5.6 5.6c-.1.1-.3.1-.4 0l-5.6-5.6c-.1-.1-.1-.3 0-.4l5.6-5.6s.1-.1.2-.1.1 0 .2.1l5.6 5.6c.1.1.1.3 0 .4zm-16.6-.4L10 5.5l-1-1-6.3 6.3c-.7.7-.7 1.8 0 2.5L9 19.5l1.1-1.1-6.3-6.3c-.2 0-.2-.2-.1-.3z" }) });

  // packages/icons/build-module/library/tag.js
  var import_jsx_runtime101 = __toESM(require_jsx_runtime());
  var import_primitives100 = __toESM(require_primitives());
  var tag_default = /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(import_primitives100.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(import_primitives100.Path, { d: "M4.75 4a.75.75 0 0 0-.75.75v7.826c0 .2.08.39.22.53l6.72 6.716a2.313 2.313 0 0 0 3.276-.001l5.61-5.611-.531-.53.532.528a2.315 2.315 0 0 0 0-3.264L13.104 4.22a.75.75 0 0 0-.53-.22H4.75ZM19 12.576a.815.815 0 0 1-.236.574l-5.61 5.611a.814.814 0 0 1-1.153 0L5.5 12.264V5.5h6.763l6.5 6.502a.816.816 0 0 1 .237.574ZM8.75 9.75a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" }) });

  // packages/icons/build-module/library/text-horizontal.js
  var import_jsx_runtime102 = __toESM(require_jsx_runtime());
  var import_primitives101 = __toESM(require_primitives());
  var text_horizontal_default = /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(import_primitives101.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(import_primitives101.Path, { d: "M8.2 14.4h3.9L13 17h1.7L11 6.5H9.3L5.6 17h1.7l.9-2.6zm2-5.5 1.4 4H8.8l1.4-4zm7.4 7.5-1.3.8.8 1.4H5.5V20h14.3l-2.2-3.6z" }) });

  // packages/icons/build-module/library/text-vertical.js
  var import_jsx_runtime103 = __toESM(require_jsx_runtime());
  var import_primitives102 = __toESM(require_primitives());
  var text_vertical_default = /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(import_primitives102.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(import_primitives102.Path, { d: "M7 5.6v1.7l2.6.9v3.9L7 13v1.7L17.5 11V9.3L7 5.6zm4.2 6V8.8l4 1.4-4 1.4zm-5.7 5.6V5.5H4v14.3l3.6-2.2-.8-1.3-1.3.9z" }) });

  // packages/icons/build-module/library/trash.js
  var import_jsx_runtime104 = __toESM(require_jsx_runtime());
  var import_primitives103 = __toESM(require_primitives());
  var trash_default = /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(import_primitives103.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
    import_primitives103.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12 5.5A2.25 2.25 0 0 0 9.878 7h4.244A2.251 2.251 0 0 0 12 5.5ZM12 4a3.751 3.751 0 0 0-3.675 3H5v1.5h1.27l.818 8.997a2.75 2.75 0 0 0 2.739 2.501h4.347a2.75 2.75 0 0 0 2.738-2.5L17.73 8.5H19V7h-3.325A3.751 3.751 0 0 0 12 4Zm4.224 4.5H7.776l.806 8.861a1.25 1.25 0 0 0 1.245 1.137h4.347a1.25 1.25 0 0 0 1.245-1.137l.805-8.861Z"
    }
  ) });

  // packages/icons/build-module/library/ungroup.js
  var import_jsx_runtime105 = __toESM(require_jsx_runtime());
  var import_primitives104 = __toESM(require_primitives());
  var ungroup_default = /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(import_primitives104.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(import_primitives104.Path, { d: "M18 4h-7c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm.5 9c0 .3-.2.5-.5.5h-7c-.3 0-.5-.2-.5-.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7zm-5 5c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h1V9H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-1h-1.5v1z" }) });

  // packages/icons/build-module/library/unlock.js
  var import_jsx_runtime106 = __toESM(require_jsx_runtime());
  var import_primitives105 = __toESM(require_primitives());
  var unlock_default = /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(import_primitives105.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(import_primitives105.Path, { d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8h1.5c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1z" }) });

  // packages/icons/build-module/library/unseen.js
  var import_jsx_runtime107 = __toESM(require_jsx_runtime());
  var import_primitives106 = __toESM(require_primitives());
  var unseen_default = /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(import_primitives106.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(import_primitives106.Path, { d: "M20.7 12.7s0-.1-.1-.2c0-.2-.2-.4-.4-.6-.3-.5-.9-1.2-1.6-1.8-.7-.6-1.5-1.3-2.6-1.8l-.6 1.4c.9.4 1.6 1 2.1 1.5.6.6 1.1 1.2 1.4 1.6.1.2.3.4.3.5v.1l.7-.3.7-.3Zm-5.2-9.3-1.8 4c-.5-.1-1.1-.2-1.7-.2-3 0-5.2 1.4-6.6 2.7-.7.7-1.2 1.3-1.6 1.8-.2.3-.3.5-.4.6 0 0 0 .1-.1.2s0 0 .7.3l.7.3V13c0-.1.2-.3.3-.5.3-.4.7-1 1.4-1.6 1.2-1.2 3-2.3 5.5-2.3H13v.3c-.4 0-.8-.1-1.1-.1-1.9 0-3.5 1.6-3.5 3.5s.6 2.3 1.6 2.9l-2 4.4.9.4 7.6-16.2-.9-.4Zm-3 12.6c1.7-.2 3-1.7 3-3.5s-.2-1.4-.6-1.9L12.4 16Z" }) });

  // packages/icons/build-module/library/upload.js
  var import_jsx_runtime108 = __toESM(require_jsx_runtime());
  var import_primitives107 = __toESM(require_primitives());
  var upload_default = /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(import_primitives107.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(import_primitives107.Path, { d: "M18.5 15v3.5H13V6.7l4.5 4.1 1-1.1-6.2-5.8-5.8 5.8 1 1.1 4-4v11.7h-6V15H4v5h16v-5z" }) });

  // packages/icons/build-module/library/verse.js
  var import_jsx_runtime109 = __toESM(require_jsx_runtime());
  var import_primitives108 = __toESM(require_primitives());
  var verse_default = /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(import_primitives108.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(import_primitives108.Path, { d: "M17.8 2l-.9.3c-.1 0-3.6 1-5.2 2.1C10 5.5 9.3 6.5 8.9 7.1c-.6.9-1.7 4.7-1.7 6.3l-.9 2.3c-.2.4 0 .8.4 1 .1 0 .2.1.3.1.3 0 .6-.2.7-.5l.6-1.5c.3 0 .7-.1 1.2-.2.7-.1 1.4-.3 2.2-.5.8-.2 1.6-.5 2.4-.8.7-.3 1.4-.7 1.9-1.2s.8-1.2 1-1.9c.2-.7.3-1.6.4-2.4.1-.8.1-1.7.2-2.5 0-.8.1-1.5.2-2.1V2zm-1.9 5.6c-.1.8-.2 1.5-.3 2.1-.2.6-.4 1-.6 1.3-.3.3-.8.6-1.4.9-.7.3-1.4.5-2.2.8-.6.2-1.3.3-1.8.4L15 7.5c.3-.3.6-.7 1-1.1 0 .4 0 .8-.1 1.2zM6 20h8v-1.5H6V20z" }) });

  // packages/block-editor/build-module/store/selectors.js
  var import_rich_text = __toESM(require_rich_text());
  var import_deprecated2 = __toESM(require_deprecated());
  var import_data3 = __toESM(require_data());

  // packages/block-editor/build-module/store/utils.js
  var import_blocks4 = __toESM(require_blocks());
  var import_block_serialization_default_parser = __toESM(require_block_serialization_default_parser());

  // packages/block-editor/build-module/store/constants.js
  var STORE_NAME = "core/block-editor";

  // packages/block-editor/build-module/store/private-selectors.js
  var private_selectors_exports = {};
  __export(private_selectors_exports, {
    getAllPatterns: () => getAllPatterns,
    getBlockRemovalRules: () => getBlockRemovalRules,
    getBlockSettings: () => getBlockSettings,
    getBlockStyles: () => getBlockStyles,
    getBlockWithoutAttributes: () => getBlockWithoutAttributes,
    getClosestAllowedInsertionPoint: () => getClosestAllowedInsertionPoint,
    getClosestAllowedInsertionPointForPattern: () => getClosestAllowedInsertionPointForPattern,
    getContentLockingParent: () => getContentLockingParent,
    getEnabledBlockParents: () => getEnabledBlockParents,
    getEnabledClientIdsTree: () => getEnabledClientIdsTree,
    getExpandedBlock: () => getExpandedBlock,
    getInserterMediaCategories: () => getInserterMediaCategories,
    getInsertionPoint: () => getInsertionPoint,
    getLastFocus: () => getLastFocus,
    getLastInsertedBlocksClientIds: () => getLastInsertedBlocksClientIds,
    getOpenedBlockSettingsMenu: () => getOpenedBlockSettingsMenu,
    getParentSectionBlock: () => getParentSectionBlock,
    getPatternBySlug: () => getPatternBySlug,
    getRegisteredInserterMediaCategories: () => getRegisteredInserterMediaCategories,
    getRemovalPromptData: () => getRemovalPromptData,
    getReusableBlocks: () => getReusableBlocks,
    getSectionRootClientId: () => getSectionRootClientId,
    getStyleOverrides: () => getStyleOverrides,
    getTemporarilyEditingAsBlocks: () => getTemporarilyEditingAsBlocks,
    getTemporarilyEditingFocusModeToRevert: () => getTemporarilyEditingFocusModeToRevert,
    getZoomLevel: () => getZoomLevel,
    hasAllowedPatterns: () => hasAllowedPatterns,
    hasBlockSpotlight: () => hasBlockSpotlight2,
    isBlockHidden: () => isBlockHidden,
    isBlockInterfaceHidden: () => isBlockInterfaceHidden2,
    isBlockSubtreeDisabled: () => isBlockSubtreeDisabled,
    isContainerInsertableToInWriteMode: () => isContainerInsertableToInWriteMode,
    isDragging: () => isDragging2,
    isSectionBlock: () => isSectionBlock,
    isZoomOut: () => isZoomOut
  });
  var import_data2 = __toESM(require_data());
  var import_blocks3 = __toESM(require_blocks());

  // packages/block-editor/build-module/store/get-block-settings.js
  var import_blocks2 = __toESM(require_blocks());
  var import_hooks = __toESM(require_hooks());

  // packages/block-editor/build-module/utils/object.js
  function setImmutably(object, path, value) {
    path = Array.isArray(path) ? [...path] : [path];
    object = Array.isArray(object) ? [...object] : { ...object };
    const leaf = path.pop();
    let prev2 = object;
    for (const key of path) {
      const lvl = prev2[key];
      prev2 = prev2[key] = Array.isArray(lvl) ? [...lvl] : { ...lvl };
    }
    prev2[leaf] = value;
    return object;
  }
  var getValueFromObjectPath = (object, path, defaultValue) => {
    const arrayPath = Array.isArray(path) ? path : path.split(".");
    let value = object;
    arrayPath.forEach((fieldName) => {
      value = value?.[fieldName];
    });
    return value ?? defaultValue;
  };

  // packages/block-editor/build-module/store/get-block-settings.js
  var blockedPaths = [
    "color",
    "border",
    "dimensions",
    "typography",
    "spacing"
  ];
  var deprecatedFlags = {
    "color.palette": (settings2) => settings2.colors,
    "color.gradients": (settings2) => settings2.gradients,
    "color.custom": (settings2) => settings2.disableCustomColors === void 0 ? void 0 : !settings2.disableCustomColors,
    "color.customGradient": (settings2) => settings2.disableCustomGradients === void 0 ? void 0 : !settings2.disableCustomGradients,
    "typography.fontSizes": (settings2) => settings2.fontSizes,
    "typography.customFontSize": (settings2) => settings2.disableCustomFontSizes === void 0 ? void 0 : !settings2.disableCustomFontSizes,
    "typography.lineHeight": (settings2) => settings2.enableCustomLineHeight,
    "spacing.units": (settings2) => {
      if (settings2.enableCustomUnits === void 0) {
        return;
      }
      if (settings2.enableCustomUnits === true) {
        return ["px", "em", "rem", "vh", "vw", "%"];
      }
      return settings2.enableCustomUnits;
    },
    "spacing.padding": (settings2) => settings2.enableCustomSpacing
  };
  var prefixedFlags = {
    /*
     * These were only available in the plugin
     * and can be removed when the minimum WordPress version
     * for the plugin is 5.9.
     */
    "border.customColor": "border.color",
    "border.customStyle": "border.style",
    "border.customWidth": "border.width",
    "typography.customFontStyle": "typography.fontStyle",
    "typography.customFontWeight": "typography.fontWeight",
    "typography.customLetterSpacing": "typography.letterSpacing",
    "typography.customTextDecorations": "typography.textDecoration",
    "typography.customTextTransforms": "typography.textTransform",
    /*
     * These were part of WordPress 5.8 and we need to keep them.
     */
    "border.customRadius": "border.radius",
    "spacing.customMargin": "spacing.margin",
    "spacing.customPadding": "spacing.padding",
    "typography.customLineHeight": "typography.lineHeight"
  };
  var removeCustomPrefixes = (path) => {
    return prefixedFlags[path] || path;
  };
  function getBlockSettings(state, clientId, ...paths) {
    const blockName = getBlockName(state, clientId);
    const candidates = [];
    if (clientId) {
      let id = clientId;
      do {
        const name = getBlockName(state, id);
        if ((0, import_blocks2.hasBlockSupport)(name, "__experimentalSettings", false)) {
          candidates.push(id);
        }
      } while (id = state.blocks.parents.get(id));
    }
    return paths.map((path) => {
      if (blockedPaths.includes(path)) {
        console.warn(
          "Top level useSetting paths are disabled. Please use a subpath to query the information needed."
        );
        return void 0;
      }
      let result = (0, import_hooks.applyFilters)(
        "blockEditor.useSetting.before",
        void 0,
        path,
        clientId,
        blockName
      );
      if (void 0 !== result) {
        return result;
      }
      const normalizedPath = removeCustomPrefixes(path);
      for (const candidateClientId of candidates) {
        const candidateAtts = getBlockAttributes(
          state,
          candidateClientId
        );
        result = getValueFromObjectPath(
          candidateAtts.settings?.blocks?.[blockName],
          normalizedPath
        ) ?? getValueFromObjectPath(
          candidateAtts.settings,
          normalizedPath
        );
        if (result !== void 0) {
          break;
        }
      }
      const settings2 = getSettings(state);
      if (result === void 0 && blockName) {
        result = getValueFromObjectPath(
          settings2.__experimentalFeatures?.blocks?.[blockName],
          normalizedPath
        );
      }
      if (result === void 0) {
        result = getValueFromObjectPath(
          settings2.__experimentalFeatures,
          normalizedPath
        );
      }
      if (result !== void 0) {
        if (import_blocks2.__EXPERIMENTAL_PATHS_WITH_OVERRIDE[normalizedPath]) {
          return result.custom ?? result.theme ?? result.default;
        }
        return result;
      }
      const deprecatedSettingsValue = deprecatedFlags[normalizedPath]?.(settings2);
      if (deprecatedSettingsValue !== void 0) {
        return deprecatedSettingsValue;
      }
      return normalizedPath === "typography.dropCap" ? true : void 0;
    });
  }

  // packages/block-editor/build-module/store/private-selectors.js
  var { isContentBlock: isContentBlock2 } = unlock(import_blocks3.privateApis);
  function isBlockInterfaceHidden2(state) {
    return state.isBlockInterfaceHidden;
  }
  function getLastInsertedBlocksClientIds(state) {
    return state?.lastBlockInserted?.clientIds;
  }
  function getBlockWithoutAttributes(state, clientId) {
    return state.blocks.byClientId.get(clientId);
  }
  var isBlockSubtreeDisabled = (state, clientId) => {
    const isChildSubtreeDisabled = (childClientId) => {
      return getBlockEditingMode(state, childClientId) === "disabled" && getBlockOrder(state, childClientId).every(
        isChildSubtreeDisabled
      );
    };
    return getBlockOrder(state, clientId).every(isChildSubtreeDisabled);
  };
  function isContainerInsertableToInWriteMode(state, blockName, rootClientId) {
    const isBlockContentBlock = isContentBlock2(blockName);
    const rootBlockName = getBlockName(state, rootClientId);
    const isContainerContentBlock = isContentBlock2(rootBlockName);
    const isRootBlockMain = getSectionRootClientId(state) === rootClientId;
    return isRootBlockMain || isContainerContentBlock && isBlockContentBlock;
  }
  function getEnabledClientIdsTreeUnmemoized(state, rootClientId) {
    const blockOrder = getBlockOrder(state, rootClientId);
    const result = [];
    for (const clientId of blockOrder) {
      const innerBlocks = getEnabledClientIdsTreeUnmemoized(
        state,
        clientId
      );
      if (getBlockEditingMode(state, clientId) !== "disabled") {
        result.push({ clientId, innerBlocks });
      } else {
        result.push(...innerBlocks);
      }
    }
    return result;
  }
  var getEnabledClientIdsTree = (0, import_data2.createRegistrySelector)(
    () => (0, import_data2.createSelector)(getEnabledClientIdsTreeUnmemoized, (state) => [
      state.blocks.order,
      state.derivedBlockEditingModes,
      state.blockEditingModes
    ])
  );
  var getEnabledBlockParents = (0, import_data2.createSelector)(
    (state, clientId, ascending = false) => {
      return getBlockParents(state, clientId, ascending).filter(
        (parent) => getBlockEditingMode(state, parent) !== "disabled"
      );
    },
    (state) => [
      state.blocks.parents,
      state.blockEditingModes,
      state.settings.templateLock,
      state.blockListSettings
    ]
  );
  function getRemovalPromptData(state) {
    return state.removalPromptData;
  }
  function getBlockRemovalRules(state) {
    return state.blockRemovalRules;
  }
  function getOpenedBlockSettingsMenu(state) {
    return state.openedBlockSettingsMenu;
  }
  var getStyleOverrides = (0, import_data2.createSelector)(
    (state) => {
      const clientIds = getClientIdsWithDescendants(state);
      const clientIdMap = clientIds.reduce((acc, clientId, index) => {
        acc[clientId] = index;
        return acc;
      }, {});
      return [...state.styleOverrides].sort((overrideA, overrideB) => {
        const [, { clientId: clientIdA }] = overrideA;
        const [, { clientId: clientIdB }] = overrideB;
        const aIndex = clientIdMap[clientIdA] ?? -1;
        const bIndex = clientIdMap[clientIdB] ?? -1;
        return aIndex - bIndex;
      });
    },
    (state) => [state.blocks.order, state.styleOverrides]
  );
  function getRegisteredInserterMediaCategories(state) {
    return state.registeredInserterMediaCategories;
  }
  var getInserterMediaCategories = (0, import_data2.createSelector)(
    (state) => {
      const {
        settings: {
          inserterMediaCategories,
          allowedMimeTypes,
          enableOpenverseMediaCategory
        },
        registeredInserterMediaCategories: registeredInserterMediaCategories2
      } = state;
      if (!inserterMediaCategories && !registeredInserterMediaCategories2.length || !allowedMimeTypes) {
        return;
      }
      const coreInserterMediaCategoriesNames = inserterMediaCategories?.map(({ name }) => name) || [];
      const mergedCategories = [
        ...inserterMediaCategories || [],
        ...(registeredInserterMediaCategories2 || []).filter(
          ({ name }) => !coreInserterMediaCategoriesNames.includes(name)
        )
      ];
      return mergedCategories.filter((category) => {
        if (!enableOpenverseMediaCategory && category.name === "openverse") {
          return false;
        }
        return Object.values(allowedMimeTypes).some(
          (mimeType) => mimeType.startsWith(`${category.mediaType}/`)
        );
      });
    },
    (state) => [
      state.settings.inserterMediaCategories,
      state.settings.allowedMimeTypes,
      state.settings.enableOpenverseMediaCategory,
      state.registeredInserterMediaCategories
    ]
  );
  var hasAllowedPatterns = (0, import_data2.createRegistrySelector)(
    (select2) => (0, import_data2.createSelector)(
      (state, rootClientId = null) => {
        const { getAllPatterns: getAllPatterns2 } = unlock(select2(STORE_NAME));
        const patterns = getAllPatterns2();
        const { allowedBlockTypes } = getSettings(state);
        return patterns.some((pattern) => {
          const { inserter = true } = pattern;
          if (!inserter) {
            return false;
          }
          const grammar = getGrammar(pattern);
          return checkAllowListRecursive(grammar, allowedBlockTypes) && grammar.every(
            ({ name: blockName }) => canInsertBlockType(state, blockName, rootClientId)
          );
        });
      },
      (state, rootClientId) => [
        ...getAllPatternsDependants(select2)(state),
        ...getInsertBlockTypeDependants(select2)(state, rootClientId)
      ]
    )
  );
  var getPatternBySlug = (0, import_data2.createRegistrySelector)(
    (select2) => (0, import_data2.createSelector)(
      (state, patternName) => {
        if (patternName?.startsWith("core/block/")) {
          const _id = parseInt(
            patternName.slice("core/block/".length),
            10
          );
          const block = unlock(select2(STORE_NAME)).getReusableBlocks().find(({ id }) => id === _id);
          if (!block) {
            return null;
          }
          return mapUserPattern(
            block,
            state.settings.__experimentalUserPatternCategories
          );
        }
        return [
          // This setting is left for back compat.
          ...state.settings.__experimentalBlockPatterns ?? [],
          ...state.settings[selectBlockPatternsKey]?.(select2) ?? []
        ].find(({ name }) => name === patternName);
      },
      (state, patternName) => patternName?.startsWith("core/block/") ? [
        unlock(select2(STORE_NAME)).getReusableBlocks(),
        state.settings.__experimentalReusableBlocks
      ] : [
        state.settings.__experimentalBlockPatterns,
        state.settings[selectBlockPatternsKey]?.(select2)
      ]
    )
  );
  var getAllPatterns = (0, import_data2.createRegistrySelector)(
    (select2) => (0, import_data2.createSelector)((state) => {
      return [
        ...unlock(select2(STORE_NAME)).getReusableBlocks().map(
          (userPattern) => mapUserPattern(
            userPattern,
            state.settings.__experimentalUserPatternCategories
          )
        ),
        // This setting is left for back compat.
        ...state.settings.__experimentalBlockPatterns ?? [],
        ...state.settings[selectBlockPatternsKey]?.(select2) ?? []
      ].filter(
        (x2, index, arr) => index === arr.findIndex((y2) => x2.name === y2.name)
      );
    }, getAllPatternsDependants(select2))
  );
  var EMPTY_ARRAY = [];
  var getReusableBlocks = (0, import_data2.createRegistrySelector)(
    (select2) => (state) => {
      const reusableBlocksSelect = state.settings[reusableBlocksSelectKey];
      return (reusableBlocksSelect ? reusableBlocksSelect(select2) : state.settings.__experimentalReusableBlocks) ?? EMPTY_ARRAY;
    }
  );
  function getLastFocus(state) {
    return state.lastFocus;
  }
  function isDragging2(state) {
    return state.isDragging;
  }
  function getExpandedBlock(state) {
    return state.expandedBlock;
  }
  var getContentLockingParent = (state, clientId) => {
    let current = clientId;
    let result;
    while (!result && (current = state.blocks.parents.get(current))) {
      if (getTemplateLock(state, current) === "contentOnly") {
        result = current;
      }
    }
    return result;
  };
  var getParentSectionBlock = (state, clientId) => {
    let current = clientId;
    let result;
    while (!result && (current = state.blocks.parents.get(current))) {
      if (isSectionBlock(state, current)) {
        result = current;
      }
    }
    return result;
  };
  function isSectionBlock(state, clientId) {
    const blockName = getBlockName(state, clientId);
    if (blockName === "core/block" || getTemplateLock(state, clientId) === "contentOnly") {
      return true;
    }
    const attributes = getBlockAttributes(state, clientId);
    const isTemplatePart6 = blockName === "core/template-part";
    if ((attributes?.metadata?.patternName || isTemplatePart6) && !!window?.__experimentalContentOnlyPatternInsertion) {
      return true;
    }
    return false;
  }
  function getTemporarilyEditingAsBlocks(state) {
    return state.temporarilyEditingAsBlocks;
  }
  function getTemporarilyEditingFocusModeToRevert(state) {
    return state.temporarilyEditingFocusModeRevert;
  }
  var getBlockStyles = (0, import_data2.createSelector)(
    (state, clientIds) => clientIds.reduce((styles, clientId) => {
      styles[clientId] = state.blocks.attributes.get(clientId)?.style;
      return styles;
    }, {}),
    (state, clientIds) => [
      ...clientIds.map(
        (clientId) => state.blocks.attributes.get(clientId)?.style
      )
    ]
  );
  function getSectionRootClientId(state) {
    return state.settings?.[sectionRootClientIdKey];
  }
  function isZoomOut(state) {
    return state.zoomLevel === "auto-scaled" || state.zoomLevel < 100;
  }
  function getZoomLevel(state) {
    return state.zoomLevel;
  }
  function getClosestAllowedInsertionPoint(state, name, clientId = "") {
    const blockNames = Array.isArray(name) ? name : [name];
    const areBlockNamesAllowedInClientId = (id) => blockNames.every(
      (currentName) => canInsertBlockType(state, currentName, id)
    );
    if (!clientId) {
      if (areBlockNamesAllowedInClientId(clientId)) {
        return clientId;
      }
      const sectionRootClientId = getSectionRootClientId(state);
      if (sectionRootClientId && areBlockNamesAllowedInClientId(sectionRootClientId)) {
        return sectionRootClientId;
      }
      return null;
    }
    let current = clientId;
    while (current !== null && !areBlockNamesAllowedInClientId(current)) {
      const parentClientId = getBlockRootClientId(state, current);
      current = parentClientId;
    }
    return current;
  }
  function getClosestAllowedInsertionPointForPattern(state, pattern, clientId) {
    const { allowedBlockTypes } = getSettings(state);
    const isAllowed = checkAllowListRecursive(
      getGrammar(pattern),
      allowedBlockTypes
    );
    if (!isAllowed) {
      return null;
    }
    const names = getGrammar(pattern).map(({ blockName: name }) => name);
    return getClosestAllowedInsertionPoint(state, names, clientId);
  }
  function getInsertionPoint(state) {
    return state.insertionPoint;
  }
  var isBlockHidden = (state, clientId) => {
    const blockName = getBlockName(state, clientId);
    if (!(0, import_blocks3.hasBlockSupport)(state, blockName, "blockVisibility", true)) {
      return false;
    }
    const attributes = state.blocks.attributes.get(clientId);
    return attributes?.metadata?.blockVisibility === false;
  };
  function hasBlockSpotlight2(state) {
    return !!state.hasBlockSpotlight;
  }

  // packages/block-editor/build-module/components/inserter/block-patterns-tab/utils.js
  var import_i18n2 = __toESM(require_i18n());
  var INSERTER_PATTERN_TYPES = {
    user: "user",
    theme: "theme",
    directory: "directory"
  };
  var INSERTER_SYNC_TYPES = {
    full: "fully",
    unsynced: "unsynced"
  };
  var allPatternsCategory = {
    name: "allPatterns",
    label: (0, import_i18n2._x)("All", "patterns")
  };
  var myPatternsCategory = {
    name: "myPatterns",
    label: (0, import_i18n2.__)("My patterns")
  };
  var starterPatternsCategory = {
    name: "core/starter-content",
    label: (0, import_i18n2.__)("Starter content")
  };
  function isPatternFiltered(pattern, sourceFilter, syncFilter) {
    const isUserPattern = pattern.name.startsWith("core/block");
    const isDirectoryPattern = pattern.source === "core" || pattern.source?.startsWith("pattern-directory");
    if (sourceFilter === INSERTER_PATTERN_TYPES.theme && (isUserPattern || isDirectoryPattern)) {
      return true;
    }
    if (sourceFilter === INSERTER_PATTERN_TYPES.directory && (isUserPattern || !isDirectoryPattern)) {
      return true;
    }
    if (sourceFilter === INSERTER_PATTERN_TYPES.user && pattern.type !== INSERTER_PATTERN_TYPES.user) {
      return true;
    }
    if (syncFilter === INSERTER_SYNC_TYPES.full && pattern.syncStatus !== "") {
      return true;
    }
    if (syncFilter === INSERTER_SYNC_TYPES.unsynced && pattern.syncStatus !== "unsynced" && isUserPattern) {
      return true;
    }
    return false;
  }

  // packages/block-editor/build-module/store/utils.js
  var isFiltered = Symbol("isFiltered");
  var parsedPatternCache = /* @__PURE__ */ new WeakMap();
  var grammarMapCache = /* @__PURE__ */ new WeakMap();
  function mapUserPattern(userPattern, __experimentalUserPatternCategories = []) {
    return {
      name: `core/block/${userPattern.id}`,
      id: userPattern.id,
      type: INSERTER_PATTERN_TYPES.user,
      title: userPattern.title?.raw,
      categories: userPattern.wp_pattern_category?.map((catId) => {
        const category = __experimentalUserPatternCategories.find(
          ({ id }) => id === catId
        );
        return category ? category.slug : catId;
      }),
      content: userPattern.content?.raw,
      syncStatus: userPattern.wp_pattern_sync_status
    };
  }
  function parsePattern(pattern) {
    const blocks2 = (0, import_blocks4.parse)(pattern.content, {
      __unstableSkipMigrationLogs: true
    });
    if (blocks2.length === 1) {
      blocks2[0].attributes = {
        ...blocks2[0].attributes,
        metadata: {
          ...blocks2[0].attributes.metadata || {},
          categories: pattern.categories,
          patternName: pattern.name,
          name: blocks2[0].attributes.metadata?.name || pattern.title
        }
      };
    }
    return {
      ...pattern,
      blocks: blocks2
    };
  }
  function getParsedPattern(pattern) {
    let parsedPattern = parsedPatternCache.get(pattern);
    if (!parsedPattern) {
      parsedPattern = parsePattern(pattern);
      parsedPatternCache.set(pattern, parsedPattern);
    }
    return parsedPattern;
  }
  function getGrammar(pattern) {
    let grammarMap = grammarMapCache.get(pattern);
    if (!grammarMap) {
      grammarMap = (0, import_block_serialization_default_parser.parse)(pattern.content);
      grammarMap = grammarMap.filter((block) => block.blockName !== null);
      grammarMapCache.set(pattern, grammarMap);
    }
    return grammarMap;
  }
  var checkAllowList = (list, item, defaultResult = null) => {
    if (typeof list === "boolean") {
      return list;
    }
    if (Array.isArray(list)) {
      if (list.includes("core/post-content") && item === null) {
        return true;
      }
      return list.includes(item);
    }
    return defaultResult;
  };
  var checkAllowListRecursive = (blocks2, allowedBlockTypes) => {
    if (typeof allowedBlockTypes === "boolean") {
      return allowedBlockTypes;
    }
    const blocksQueue = [...blocks2];
    while (blocksQueue.length > 0) {
      const block = blocksQueue.shift();
      const isAllowed = checkAllowList(
        allowedBlockTypes,
        block.name || block.blockName,
        true
      );
      if (!isAllowed) {
        return false;
      }
      block.innerBlocks?.forEach((innerBlock) => {
        blocksQueue.push(innerBlock);
      });
    }
    return true;
  };
  var getAllPatternsDependants = (select2) => (state) => {
    return [
      state.settings.__experimentalBlockPatterns,
      state.settings.__experimentalUserPatternCategories,
      state.settings.__experimentalReusableBlocks,
      state.settings[selectBlockPatternsKey]?.(select2),
      state.blockPatterns,
      unlock(select2(STORE_NAME)).getReusableBlocks()
    ];
  };
  var getInsertBlockTypeDependants = () => (state, rootClientId) => {
    return [
      state.blockListSettings[rootClientId],
      state.blocks.byClientId.get(rootClientId),
      state.settings.allowedBlockTypes,
      state.settings.templateLock,
      getBlockEditingMode(state, rootClientId),
      getSectionRootClientId(state)
    ];
  };

  // packages/block-editor/build-module/utils/sorting.js
  var comparator = (field, items, order) => {
    return (a2, b2) => {
      let cmpA, cmpB;
      if (typeof field === "function") {
        cmpA = field(a2);
        cmpB = field(b2);
      } else {
        cmpA = a2[field];
        cmpB = b2[field];
      }
      if (cmpA > cmpB) {
        return order === "asc" ? 1 : -1;
      } else if (cmpB > cmpA) {
        return order === "asc" ? -1 : 1;
      }
      const orderA = items.findIndex((item) => item === a2);
      const orderB = items.findIndex((item) => item === b2);
      if (orderA > orderB) {
        return 1;
      } else if (orderB > orderA) {
        return -1;
      }
      return 0;
    };
  };
  function orderBy(items, field, order = "asc") {
    return items.concat().sort(comparator(field, items, order));
  }

  // packages/block-editor/build-module/store/selectors.js
  var { isContentBlock: isContentBlock3 } = unlock(import_blocks5.privateApis);
  var MILLISECONDS_PER_HOUR = 3600 * 1e3;
  var MILLISECONDS_PER_DAY = 24 * 3600 * 1e3;
  var MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1e3;
  var EMPTY_ARRAY2 = [];
  var EMPTY_SET = /* @__PURE__ */ new Set();
  var DEFAULT_INSERTER_OPTIONS = {
    [isFiltered]: true
  };
  function getBlockName(state, clientId) {
    const block = state.blocks.byClientId.get(clientId);
    const socialLinkName = "core/social-link";
    if (import_element4.Platform.OS !== "web" && block?.name === socialLinkName) {
      const attributes = state.blocks.attributes.get(clientId);
      const { service } = attributes ?? {};
      return service ? `${socialLinkName}-${service}` : socialLinkName;
    }
    return block ? block.name : null;
  }
  function isBlockValid(state, clientId) {
    const block = state.blocks.byClientId.get(clientId);
    return !!block && block.isValid;
  }
  function getBlockAttributes(state, clientId) {
    const block = state.blocks.byClientId.get(clientId);
    if (!block) {
      return null;
    }
    return state.blocks.attributes.get(clientId);
  }
  function getBlock(state, clientId) {
    if (!state.blocks.byClientId.has(clientId)) {
      return null;
    }
    return state.blocks.tree.get(clientId);
  }
  var __unstableGetBlockWithoutInnerBlocks = (0, import_data3.createSelector)(
    (state, clientId) => {
      const block = state.blocks.byClientId.get(clientId);
      if (!block) {
        return null;
      }
      return {
        ...block,
        attributes: getBlockAttributes(state, clientId)
      };
    },
    (state, clientId) => [
      state.blocks.byClientId.get(clientId),
      state.blocks.attributes.get(clientId)
    ]
  );
  function getBlocks(state, rootClientId) {
    const treeKey = !rootClientId || !areInnerBlocksControlled(state, rootClientId) ? rootClientId || "" : "controlled||" + rootClientId;
    return state.blocks.tree.get(treeKey)?.innerBlocks || EMPTY_ARRAY2;
  }
  var __unstableGetClientIdWithClientIdsTree = (0, import_data3.createSelector)(
    (state, clientId) => {
      (0, import_deprecated2.default)(
        "wp.data.select( 'core/block-editor' ).__unstableGetClientIdWithClientIdsTree",
        {
          since: "6.3",
          version: "6.5"
        }
      );
      return {
        clientId,
        innerBlocks: __unstableGetClientIdsTree(state, clientId)
      };
    },
    (state) => [state.blocks.order]
  );
  var __unstableGetClientIdsTree = (0, import_data3.createSelector)(
    (state, rootClientId = "") => {
      (0, import_deprecated2.default)(
        "wp.data.select( 'core/block-editor' ).__unstableGetClientIdsTree",
        {
          since: "6.3",
          version: "6.5"
        }
      );
      return getBlockOrder(state, rootClientId).map(
        (clientId) => __unstableGetClientIdWithClientIdsTree(state, clientId)
      );
    },
    (state) => [state.blocks.order]
  );
  var getClientIdsOfDescendants = (0, import_data3.createSelector)(
    (state, rootIds) => {
      rootIds = Array.isArray(rootIds) ? [...rootIds] : [rootIds];
      const ids = [];
      for (const rootId of rootIds) {
        const order = state.blocks.order.get(rootId);
        if (order) {
          ids.push(...order);
        }
      }
      let index = 0;
      while (index < ids.length) {
        const id = ids[index];
        const order = state.blocks.order.get(id);
        if (order) {
          ids.splice(index + 1, 0, ...order);
        }
        index++;
      }
      return ids;
    },
    (state) => [state.blocks.order]
  );
  var getClientIdsWithDescendants = (state) => getClientIdsOfDescendants(state, "");
  var getGlobalBlockCount = (0, import_data3.createSelector)(
    (state, blockName) => {
      const clientIds = getClientIdsWithDescendants(state);
      if (!blockName) {
        return clientIds.length;
      }
      let count = 0;
      for (const clientId of clientIds) {
        const block = state.blocks.byClientId.get(clientId);
        if (block.name === blockName) {
          count++;
        }
      }
      return count;
    },
    (state) => [state.blocks.order, state.blocks.byClientId]
  );
  var getBlocksByName = (0, import_data3.createSelector)(
    (state, blockName) => {
      if (!blockName) {
        return EMPTY_ARRAY2;
      }
      const blockNames = Array.isArray(blockName) ? blockName : [blockName];
      const clientIds = getClientIdsWithDescendants(state);
      const foundBlocks = clientIds.filter((clientId) => {
        const block = state.blocks.byClientId.get(clientId);
        return blockNames.includes(block.name);
      });
      return foundBlocks.length > 0 ? foundBlocks : EMPTY_ARRAY2;
    },
    (state) => [state.blocks.order, state.blocks.byClientId]
  );
  function __experimentalGetGlobalBlocksByName(state, blockName) {
    (0, import_deprecated2.default)(
      "wp.data.select( 'core/block-editor' ).__experimentalGetGlobalBlocksByName",
      {
        since: "6.5",
        alternative: `wp.data.select( 'core/block-editor' ).getBlocksByName`
      }
    );
    return getBlocksByName(state, blockName);
  }
  var getBlocksByClientId = (0, import_data3.createSelector)(
    (state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(
      (clientId) => getBlock(state, clientId)
    ),
    (state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(
      (clientId) => state.blocks.tree.get(clientId)
    )
  );
  var getBlockNamesByClientId = (0, import_data3.createSelector)(
    (state, clientIds) => getBlocksByClientId(state, clientIds).filter(Boolean).map((block) => block.name),
    (state, clientIds) => getBlocksByClientId(state, clientIds)
  );
  function getBlockCount(state, rootClientId) {
    return getBlockOrder(state, rootClientId).length;
  }
  function getSelectionStart(state) {
    return state.selection.selectionStart;
  }
  function getSelectionEnd(state) {
    return state.selection.selectionEnd;
  }
  function getBlockSelectionStart(state) {
    return state.selection.selectionStart.clientId;
  }
  function getBlockSelectionEnd(state) {
    return state.selection.selectionEnd.clientId;
  }
  function getSelectedBlockCount(state) {
    const multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;
    if (multiSelectedBlockCount) {
      return multiSelectedBlockCount;
    }
    return state.selection.selectionStart.clientId ? 1 : 0;
  }
  function hasSelectedBlock(state) {
    const { selectionStart, selectionEnd } = state.selection;
    return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
  }
  function getSelectedBlockClientId(state) {
    const { selectionStart, selectionEnd } = state.selection;
    const { clientId } = selectionStart;
    if (!clientId || clientId !== selectionEnd.clientId) {
      return null;
    }
    return clientId;
  }
  function getSelectedBlock(state) {
    const clientId = getSelectedBlockClientId(state);
    return clientId ? getBlock(state, clientId) : null;
  }
  function getBlockRootClientId(state, clientId) {
    return state.blocks.parents.get(clientId) ?? null;
  }
  var getBlockParents = (0, import_data3.createSelector)(
    (state, clientId, ascending = false) => {
      const parents = [];
      let current = clientId;
      while (current = state.blocks.parents.get(current)) {
        parents.push(current);
      }
      if (!parents.length) {
        return EMPTY_ARRAY2;
      }
      return ascending ? parents : parents.reverse();
    },
    (state) => [state.blocks.parents]
  );
  var getBlockParentsByBlockName = (0, import_data3.createSelector)(
    (state, clientId, blockName, ascending = false) => {
      const parents = getBlockParents(state, clientId, ascending);
      const hasName = Array.isArray(blockName) ? (name) => blockName.includes(name) : (name) => blockName === name;
      return parents.filter((id) => hasName(getBlockName(state, id)));
    },
    (state) => [state.blocks.parents]
  );
  function getBlockHierarchyRootClientId(state, clientId) {
    let current = clientId;
    let parent;
    do {
      parent = current;
      current = state.blocks.parents.get(current);
    } while (current);
    return parent;
  }
  function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
    const selectedId = getSelectedBlockClientId(state);
    const clientParents = [...getBlockParents(state, clientId), clientId];
    const selectedParents = [
      ...getBlockParents(state, selectedId),
      selectedId
    ];
    let lowestCommonAncestor;
    const maxDepth = Math.min(clientParents.length, selectedParents.length);
    for (let index = 0; index < maxDepth; index++) {
      if (clientParents[index] === selectedParents[index]) {
        lowestCommonAncestor = clientParents[index];
      } else {
        break;
      }
    }
    return lowestCommonAncestor;
  }
  function getAdjacentBlockClientId(state, startClientId, modifier = 1) {
    if (startClientId === void 0) {
      startClientId = getSelectedBlockClientId(state);
    }
    if (startClientId === void 0) {
      if (modifier < 0) {
        startClientId = getFirstMultiSelectedBlockClientId(state);
      } else {
        startClientId = getLastMultiSelectedBlockClientId(state);
      }
    }
    if (!startClientId) {
      return null;
    }
    const rootClientId = getBlockRootClientId(state, startClientId);
    if (rootClientId === null) {
      return null;
    }
    const { order } = state.blocks;
    const orderSet = order.get(rootClientId);
    const index = orderSet.indexOf(startClientId);
    const nextIndex = index + 1 * modifier;
    if (nextIndex < 0) {
      return null;
    }
    if (nextIndex === orderSet.length) {
      return null;
    }
    return orderSet[nextIndex];
  }
  function getPreviousBlockClientId(state, startClientId) {
    return getAdjacentBlockClientId(state, startClientId, -1);
  }
  function getNextBlockClientId(state, startClientId) {
    return getAdjacentBlockClientId(state, startClientId, 1);
  }
  function getSelectedBlocksInitialCaretPosition(state) {
    return state.initialPosition;
  }
  var getSelectedBlockClientIds = (0, import_data3.createSelector)(
    (state) => {
      const { selectionStart, selectionEnd } = state.selection;
      if (!selectionStart.clientId || !selectionEnd.clientId) {
        return EMPTY_ARRAY2;
      }
      if (selectionStart.clientId === selectionEnd.clientId) {
        return [selectionStart.clientId];
      }
      const rootClientId = getBlockRootClientId(
        state,
        selectionStart.clientId
      );
      if (rootClientId === null) {
        return EMPTY_ARRAY2;
      }
      const blockOrder = getBlockOrder(state, rootClientId);
      const startIndex = blockOrder.indexOf(selectionStart.clientId);
      const endIndex = blockOrder.indexOf(selectionEnd.clientId);
      if (startIndex > endIndex) {
        return blockOrder.slice(endIndex, startIndex + 1);
      }
      return blockOrder.slice(startIndex, endIndex + 1);
    },
    (state) => [
      state.blocks.order,
      state.selection.selectionStart.clientId,
      state.selection.selectionEnd.clientId
    ]
  );
  function getMultiSelectedBlockClientIds(state) {
    const { selectionStart, selectionEnd } = state.selection;
    if (selectionStart.clientId === selectionEnd.clientId) {
      return EMPTY_ARRAY2;
    }
    return getSelectedBlockClientIds(state);
  }
  var getMultiSelectedBlocks = (0, import_data3.createSelector)(
    (state) => {
      const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
      if (!multiSelectedBlockClientIds.length) {
        return EMPTY_ARRAY2;
      }
      return multiSelectedBlockClientIds.map(
        (clientId) => getBlock(state, clientId)
      );
    },
    (state) => [
      ...getSelectedBlockClientIds.getDependants(state),
      state.blocks.byClientId,
      state.blocks.order,
      state.blocks.attributes
    ]
  );
  function getFirstMultiSelectedBlockClientId(state) {
    return getMultiSelectedBlockClientIds(state)[0] || null;
  }
  function getLastMultiSelectedBlockClientId(state) {
    const selectedClientIds = getMultiSelectedBlockClientIds(state);
    return selectedClientIds[selectedClientIds.length - 1] || null;
  }
  function isFirstMultiSelectedBlock(state, clientId) {
    return getFirstMultiSelectedBlockClientId(state) === clientId;
  }
  function isBlockMultiSelected(state, clientId) {
    return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
  }
  var isAncestorMultiSelected = (0, import_data3.createSelector)(
    (state, clientId) => {
      let ancestorClientId = clientId;
      let isMultiSelected = false;
      while (ancestorClientId && !isMultiSelected) {
        ancestorClientId = getBlockRootClientId(state, ancestorClientId);
        isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
      }
      return isMultiSelected;
    },
    (state) => [
      state.blocks.order,
      state.selection.selectionStart.clientId,
      state.selection.selectionEnd.clientId
    ]
  );
  function getMultiSelectedBlocksStartClientId(state) {
    const { selectionStart, selectionEnd } = state.selection;
    if (selectionStart.clientId === selectionEnd.clientId) {
      return null;
    }
    return selectionStart.clientId || null;
  }
  function getMultiSelectedBlocksEndClientId(state) {
    const { selectionStart, selectionEnd } = state.selection;
    if (selectionStart.clientId === selectionEnd.clientId) {
      return null;
    }
    return selectionEnd.clientId || null;
  }
  function __unstableIsFullySelected(state) {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    return !selectionAnchor.attributeKey && !selectionFocus.attributeKey && typeof selectionAnchor.offset === "undefined" && typeof selectionFocus.offset === "undefined";
  }
  function __unstableIsSelectionCollapsed(state) {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    return !!selectionAnchor && !!selectionFocus && selectionAnchor.clientId === selectionFocus.clientId && selectionAnchor.attributeKey === selectionFocus.attributeKey && selectionAnchor.offset === selectionFocus.offset;
  }
  function __unstableSelectionHasUnmergeableBlock(state) {
    return getSelectedBlockClientIds(state).some((clientId) => {
      const blockName = getBlockName(state, clientId);
      const blockType = (0, import_blocks5.getBlockType)(blockName);
      return !blockType.merge;
    });
  }
  function __unstableIsSelectionMergeable(state, isForward) {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    if (selectionAnchor.clientId === selectionFocus.clientId) {
      return false;
    }
    if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
      return false;
    }
    const anchorRootClientId = getBlockRootClientId(
      state,
      selectionAnchor.clientId
    );
    const focusRootClientId = getBlockRootClientId(
      state,
      selectionFocus.clientId
    );
    if (anchorRootClientId !== focusRootClientId) {
      return false;
    }
    const blockOrder = getBlockOrder(state, anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    let selectionStart, selectionEnd;
    if (anchorIndex > focusIndex) {
      selectionStart = selectionFocus;
      selectionEnd = selectionAnchor;
    } else {
      selectionStart = selectionAnchor;
      selectionEnd = selectionFocus;
    }
    const targetBlockClientId = isForward ? selectionEnd.clientId : selectionStart.clientId;
    const blockToMergeClientId = isForward ? selectionStart.clientId : selectionEnd.clientId;
    const targetBlockName = getBlockName(state, targetBlockClientId);
    const targetBlockType = (0, import_blocks5.getBlockType)(targetBlockName);
    if (!targetBlockType.merge) {
      return false;
    }
    const blockToMerge = getBlock(state, blockToMergeClientId);
    if (blockToMerge.name === targetBlockName) {
      return true;
    }
    const blocksToMerge = (0, import_blocks5.switchToBlockType)(blockToMerge, targetBlockName);
    return blocksToMerge && blocksToMerge.length;
  }
  var __unstableGetSelectedBlocksWithPartialSelection = (state) => {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    if (selectionAnchor.clientId === selectionFocus.clientId) {
      return EMPTY_ARRAY2;
    }
    if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
      return EMPTY_ARRAY2;
    }
    const anchorRootClientId = getBlockRootClientId(
      state,
      selectionAnchor.clientId
    );
    const focusRootClientId = getBlockRootClientId(
      state,
      selectionFocus.clientId
    );
    if (anchorRootClientId !== focusRootClientId) {
      return EMPTY_ARRAY2;
    }
    const blockOrder = getBlockOrder(state, anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    const [selectionStart, selectionEnd] = anchorIndex > focusIndex ? [selectionFocus, selectionAnchor] : [selectionAnchor, selectionFocus];
    const blockA = getBlock(state, selectionStart.clientId);
    const blockB = getBlock(state, selectionEnd.clientId);
    const htmlA = blockA.attributes[selectionStart.attributeKey];
    const htmlB = blockB.attributes[selectionEnd.attributeKey];
    let valueA = (0, import_rich_text.create)({ html: htmlA });
    let valueB = (0, import_rich_text.create)({ html: htmlB });
    valueA = (0, import_rich_text.remove)(valueA, 0, selectionStart.offset);
    valueB = (0, import_rich_text.remove)(valueB, selectionEnd.offset, valueB.text.length);
    return [
      {
        ...blockA,
        attributes: {
          ...blockA.attributes,
          [selectionStart.attributeKey]: (0, import_rich_text.toHTMLString)({
            value: valueA
          })
        }
      },
      {
        ...blockB,
        attributes: {
          ...blockB.attributes,
          [selectionEnd.attributeKey]: (0, import_rich_text.toHTMLString)({
            value: valueB
          })
        }
      }
    ];
  };
  function getBlockOrder(state, rootClientId) {
    return state.blocks.order.get(rootClientId || "") || EMPTY_ARRAY2;
  }
  function getBlockIndex(state, clientId) {
    const rootClientId = getBlockRootClientId(state, clientId);
    return getBlockOrder(state, rootClientId).indexOf(clientId);
  }
  function isBlockSelected(state, clientId) {
    const { selectionStart, selectionEnd } = state.selection;
    if (selectionStart.clientId !== selectionEnd.clientId) {
      return false;
    }
    return selectionStart.clientId === clientId;
  }
  function hasSelectedInnerBlock(state, clientId, deep = false) {
    const selectedBlockClientIds = getSelectedBlockClientIds(state);
    if (!selectedBlockClientIds.length) {
      return false;
    }
    if (deep) {
      return selectedBlockClientIds.some(
        (id) => (
          // Pass true because we don't care about order and it's more
          // performant.
          getBlockParents(state, id, true).includes(clientId)
        )
      );
    }
    return selectedBlockClientIds.some(
      (id) => getBlockRootClientId(state, id) === clientId
    );
  }
  function hasDraggedInnerBlock(state, clientId, deep = false) {
    return getBlockOrder(state, clientId).some(
      (innerClientId) => isBlockBeingDragged(state, innerClientId) || deep && hasDraggedInnerBlock(state, innerClientId, deep)
    );
  }
  function isBlockWithinSelection(state, clientId) {
    if (!clientId) {
      return false;
    }
    const clientIds = getMultiSelectedBlockClientIds(state);
    const index = clientIds.indexOf(clientId);
    return index > -1 && index < clientIds.length - 1;
  }
  function hasMultiSelection(state) {
    const { selectionStart, selectionEnd } = state.selection;
    return selectionStart.clientId !== selectionEnd.clientId;
  }
  function isMultiSelecting2(state) {
    return state.isMultiSelecting;
  }
  function isSelectionEnabled2(state) {
    return state.isSelectionEnabled;
  }
  function getBlockMode(state, clientId) {
    return state.blocksMode[clientId] || "visual";
  }
  function isTyping2(state) {
    return state.isTyping;
  }
  function isDraggingBlocks(state) {
    return !!state.draggedBlocks.length;
  }
  function getDraggedBlockClientIds(state) {
    return state.draggedBlocks;
  }
  function isBlockBeingDragged(state, clientId) {
    return state.draggedBlocks.includes(clientId);
  }
  function isAncestorBeingDragged(state, clientId) {
    if (!isDraggingBlocks(state)) {
      return false;
    }
    const parents = getBlockParents(state, clientId);
    return parents.some(
      (parentClientId) => isBlockBeingDragged(state, parentClientId)
    );
  }
  function isCaretWithinFormattedText() {
    (0, import_deprecated2.default)(
      'wp.data.select( "core/block-editor" ).isCaretWithinFormattedText',
      {
        since: "6.1",
        version: "6.3"
      }
    );
    return false;
  }
  var getBlockInsertionPoint = (0, import_data3.createSelector)(
    (state) => {
      let rootClientId, index;
      const {
        insertionCue: insertionCue2,
        selection: { selectionEnd }
      } = state;
      if (insertionCue2 !== null) {
        return insertionCue2;
      }
      const { clientId } = selectionEnd;
      if (clientId) {
        rootClientId = getBlockRootClientId(state, clientId) || void 0;
        index = getBlockIndex(state, selectionEnd.clientId) + 1;
      } else {
        index = getBlockOrder(state).length;
      }
      return { rootClientId, index };
    },
    (state) => [
      state.insertionCue,
      state.selection.selectionEnd.clientId,
      state.blocks.parents,
      state.blocks.order
    ]
  );
  function isBlockInsertionPointVisible(state) {
    return state.insertionCue !== null;
  }
  function isValidTemplate(state) {
    return state.template.isValid;
  }
  function getTemplate(state) {
    return state.settings.template;
  }
  function getTemplateLock(state, rootClientId) {
    if (!rootClientId) {
      return state.settings.templateLock ?? false;
    }
    return getBlockListSettings(state, rootClientId)?.templateLock ?? false;
  }
  var isBlockVisibleInTheInserter = (state, blockNameOrType, rootClientId = null) => {
    let blockType;
    let blockName;
    if (blockNameOrType && "object" === typeof blockNameOrType) {
      blockType = blockNameOrType;
      blockName = blockNameOrType.name;
    } else {
      blockType = (0, import_blocks5.getBlockType)(blockNameOrType);
      blockName = blockNameOrType;
    }
    if (!blockType) {
      return false;
    }
    const { allowedBlockTypes } = getSettings(state);
    const isBlockAllowedInEditor = checkAllowList(
      allowedBlockTypes,
      blockName,
      true
    );
    if (!isBlockAllowedInEditor) {
      return false;
    }
    const parents = (Array.isArray(blockType.parent) ? blockType.parent : []).concat(Array.isArray(blockType.ancestor) ? blockType.ancestor : []);
    if (parents.length > 0) {
      if (parents.includes("core/post-content")) {
        return true;
      }
      let current = rootClientId;
      let hasParent = false;
      do {
        if (parents.includes(getBlockName(state, current))) {
          hasParent = true;
          break;
        }
        current = state.blocks.parents.get(current);
      } while (current);
      return hasParent;
    }
    return true;
  };
  var canInsertBlockTypeUnmemoized = (state, blockName, rootClientId = null) => {
    if (!isBlockVisibleInTheInserter(state, blockName, rootClientId)) {
      return false;
    }
    let blockType;
    if (blockName && "object" === typeof blockName) {
      blockType = blockName;
      blockName = blockType.name;
    } else {
      blockType = (0, import_blocks5.getBlockType)(blockName);
    }
    const isLocked = !!getTemplateLock(state, rootClientId);
    if (isLocked) {
      return false;
    }
    const isContentRoleBlock = isContentBlock3(blockName);
    const isParentSectionBlock = !!isSectionBlock(state, rootClientId);
    if (isParentSectionBlock && !isContentRoleBlock) {
      return false;
    }
    const blockEditingMode = getBlockEditingMode(state, rootClientId ?? "");
    if (blockEditingMode === "disabled") {
      return false;
    }
    const parentBlockListSettings = getBlockListSettings(state, rootClientId);
    if (rootClientId && parentBlockListSettings === void 0) {
      return false;
    }
    if (blockEditingMode === "contentOnly" && !isContainerInsertableToInWriteMode(state, blockName, rootClientId)) {
      return false;
    }
    const parentName = getBlockName(state, rootClientId);
    const parentBlockType = (0, import_blocks5.getBlockType)(parentName);
    const parentAllowedChildBlocks = parentBlockType?.allowedBlocks;
    let hasParentAllowedBlock = checkAllowList(
      parentAllowedChildBlocks,
      blockName
    );
    if (hasParentAllowedBlock !== false) {
      const parentAllowedBlocks = parentBlockListSettings?.allowedBlocks;
      const hasParentListAllowedBlock = checkAllowList(
        parentAllowedBlocks,
        blockName
      );
      if (hasParentListAllowedBlock !== null) {
        hasParentAllowedBlock = hasParentListAllowedBlock;
      }
    }
    const blockAllowedParentBlocks = blockType.parent;
    const hasBlockAllowedParent = checkAllowList(
      blockAllowedParentBlocks,
      parentName
    );
    let hasBlockAllowedAncestor = true;
    const blockAllowedAncestorBlocks = blockType.ancestor;
    if (blockAllowedAncestorBlocks) {
      const ancestors = [
        rootClientId,
        ...getBlockParents(state, rootClientId)
      ];
      hasBlockAllowedAncestor = ancestors.some(
        (ancestorClientId) => checkAllowList(
          blockAllowedAncestorBlocks,
          getBlockName(state, ancestorClientId)
        )
      );
    }
    const canInsert = hasBlockAllowedAncestor && (hasParentAllowedBlock === null && hasBlockAllowedParent === null || hasParentAllowedBlock === true || hasBlockAllowedParent === true);
    if (!canInsert) {
      return canInsert;
    }
    return (0, import_hooks2.applyFilters)(
      "blockEditor.__unstableCanInsertBlockType",
      canInsert,
      blockType,
      rootClientId,
      {
        // Pass bound selectors of the current registry. If we're in a nested
        // context, the data will differ from the one selected from the root
        // registry.
        getBlock: getBlock.bind(null, state),
        getBlockParentsByBlockName: getBlockParentsByBlockName.bind(
          null,
          state
        )
      }
    );
  };
  var canInsertBlockType = (0, import_data3.createRegistrySelector)(
    (select2) => (0, import_data3.createSelector)(
      canInsertBlockTypeUnmemoized,
      (state, blockName, rootClientId) => getInsertBlockTypeDependants(select2)(state, rootClientId)
    )
  );
  function canInsertBlocks(state, clientIds, rootClientId = null) {
    return clientIds.every(
      (id) => canInsertBlockType(state, getBlockName(state, id), rootClientId)
    );
  }
  function canRemoveBlock(state, clientId) {
    const attributes = getBlockAttributes(state, clientId);
    if (attributes === null) {
      return true;
    }
    if (attributes.lock?.remove !== void 0) {
      return !attributes.lock.remove;
    }
    const rootClientId = getBlockRootClientId(state, clientId);
    if (getTemplateLock(state, rootClientId)) {
      return false;
    }
    const isBlockWithinSection = !!getParentSectionBlock(state, clientId);
    const isContentRoleBlock = isContentBlock3(
      getBlockName(state, clientId)
    );
    if (isBlockWithinSection && !isContentRoleBlock) {
      return false;
    }
    const blockEditingMode = getBlockEditingMode(state, rootClientId);
    if (blockEditingMode === "contentOnly" && !isContainerInsertableToInWriteMode(
      state,
      getBlockName(state, rootClientId),
      rootClientId
    )) {
      return false;
    }
    return blockEditingMode !== "disabled";
  }
  function canRemoveBlocks(state, clientIds) {
    return clientIds.every((clientId) => canRemoveBlock(state, clientId));
  }
  function canMoveBlock(state, clientId) {
    const attributes = getBlockAttributes(state, clientId);
    if (attributes === null) {
      return true;
    }
    if (attributes.lock?.move !== void 0) {
      return !attributes.lock.move;
    }
    const rootClientId = getBlockRootClientId(state, clientId);
    if (getTemplateLock(state, rootClientId) === "all") {
      return false;
    }
    return getBlockEditingMode(state, rootClientId) !== "disabled";
  }
  function canMoveBlocks(state, clientIds) {
    return clientIds.every((clientId) => canMoveBlock(state, clientId));
  }
  function canEditBlock(state, clientId) {
    const attributes = getBlockAttributes(state, clientId);
    if (attributes === null) {
      return true;
    }
    const { lock: lock3 } = attributes;
    return !lock3?.edit;
  }
  function canLockBlockType(state, nameOrType) {
    if (!(0, import_blocks5.hasBlockSupport)(nameOrType, "lock", true)) {
      return false;
    }
    return !!state.settings?.canLockBlocks;
  }
  function getInsertUsage(state, id) {
    return state.preferences.insertUsage?.[id] ?? null;
  }
  var canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
    if (!(0, import_blocks5.hasBlockSupport)(blockType, "inserter", true)) {
      return false;
    }
    return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
  };
  var getItemFromVariation = (state, item) => (variation) => {
    const variationId = `${item.id}/${variation.name}`;
    const { time, count = 0 } = getInsertUsage(state, variationId) || {};
    return {
      ...item,
      id: variationId,
      icon: variation.icon || item.icon,
      title: variation.title || item.title,
      description: variation.description || item.description,
      category: variation.category || item.category,
      // If `example` is explicitly undefined for the variation, the preview will not be shown.
      example: variation.hasOwnProperty("example") ? variation.example : item.example,
      initialAttributes: {
        ...item.initialAttributes,
        ...variation.attributes
      },
      innerBlocks: variation.innerBlocks,
      keywords: variation.keywords || item.keywords,
      frecency: calculateFrecency(time, count)
    };
  };
  var calculateFrecency = (time, count) => {
    if (!time) {
      return count;
    }
    const duration = Date.now() - time;
    switch (true) {
      case duration < MILLISECONDS_PER_HOUR:
        return count * 4;
      case duration < MILLISECONDS_PER_DAY:
        return count * 2;
      case duration < MILLISECONDS_PER_WEEK:
        return count / 2;
      default:
        return count / 4;
    }
  };
  var buildBlockTypeItem = (state, { buildScope = "inserter" }) => (blockType) => {
    const id = blockType.name;
    let isDisabled = false;
    if (!(0, import_blocks5.hasBlockSupport)(blockType.name, "multiple", true)) {
      isDisabled = getBlocksByClientId(
        state,
        getClientIdsWithDescendants(state)
      ).some(({ name }) => name === blockType.name);
    }
    const { time, count = 0 } = getInsertUsage(state, id) || {};
    const blockItemBase = {
      id,
      name: blockType.name,
      title: blockType.title,
      icon: blockType.icon,
      isDisabled,
      frecency: calculateFrecency(time, count)
    };
    if (buildScope === "transform") {
      return blockItemBase;
    }
    const inserterVariations = (0, import_blocks5.getBlockVariations)(
      blockType.name,
      "inserter"
    );
    return {
      ...blockItemBase,
      initialAttributes: {},
      description: blockType.description,
      category: blockType.category,
      keywords: blockType.keywords,
      parent: blockType.parent,
      ancestor: blockType.ancestor,
      variations: inserterVariations,
      example: blockType.example,
      utility: 1
      // Deprecated.
    };
  };
  var getInserterItems = (0, import_data3.createRegistrySelector)(
    (select2) => (0, import_data3.createSelector)(
      (state, rootClientId = null, options = DEFAULT_INSERTER_OPTIONS) => {
        const buildReusableBlockInserterItem = (reusableBlock) => {
          const icon = !reusableBlock.wp_pattern_sync_status ? {
            src: symbol_default,
            foreground: "var(--wp-block-synced-color)"
          } : symbol_default;
          const userPattern = mapUserPattern(reusableBlock);
          const { time, count = 0 } = getInsertUsage(state, userPattern.name) || {};
          const frecency = calculateFrecency(time, count);
          return {
            id: userPattern.name,
            name: "core/block",
            initialAttributes: { ref: reusableBlock.id },
            title: userPattern.title,
            icon,
            category: "reusable",
            keywords: ["reusable"],
            isDisabled: false,
            utility: 1,
            // Deprecated.
            frecency,
            content: userPattern.content,
            get blocks() {
              return getParsedPattern(userPattern).blocks;
            },
            syncStatus: userPattern.syncStatus
          };
        };
        const patternInserterItems = canInsertBlockTypeUnmemoized(
          state,
          "core/block",
          rootClientId
        ) ? unlock(select2(STORE_NAME)).getReusableBlocks().map(buildReusableBlockInserterItem) : [];
        const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
          buildScope: "inserter"
        });
        let blockTypeInserterItems = (0, import_blocks5.getBlockTypes)().filter(
          (blockType) => (0, import_blocks5.hasBlockSupport)(blockType, "inserter", true)
        ).map(buildBlockTypeInserterItem);
        if (options[isFiltered] !== false) {
          blockTypeInserterItems = blockTypeInserterItems.filter(
            (blockType) => canIncludeBlockTypeInInserter(
              state,
              blockType,
              rootClientId
            )
          );
        } else {
          blockTypeInserterItems = blockTypeInserterItems.filter(
            (blockType) => isBlockVisibleInTheInserter(
              state,
              blockType,
              rootClientId
            )
          ).map((blockType) => ({
            ...blockType,
            isAllowedInCurrentRoot: canIncludeBlockTypeInInserter(
              state,
              blockType,
              rootClientId
            )
          }));
        }
        const items = blockTypeInserterItems.reduce(
          (accumulator, item) => {
            const { variations = [] } = item;
            if (!variations.some(({ isDefault }) => isDefault)) {
              accumulator.push(item);
            }
            if (variations.length) {
              const variationMapper = getItemFromVariation(
                state,
                item
              );
              accumulator.push(
                ...variations.map(variationMapper)
              );
            }
            return accumulator;
          },
          []
        );
        const groupByType = (blocks2, block) => {
          const { core, noncore } = blocks2;
          const type = block.name.startsWith("core/") ? core : noncore;
          type.push(block);
          return blocks2;
        };
        const { core: coreItems, noncore: nonCoreItems } = items.reduce(
          groupByType,
          { core: [], noncore: [] }
        );
        const sortedBlockTypes = [...coreItems, ...nonCoreItems];
        return [...sortedBlockTypes, ...patternInserterItems];
      },
      (state, rootClientId) => [
        (0, import_blocks5.getBlockTypes)(),
        unlock(select2(STORE_NAME)).getReusableBlocks(),
        state.blocks.order,
        state.preferences.insertUsage,
        ...getInsertBlockTypeDependants(select2)(state, rootClientId)
      ]
    )
  );
  var getBlockTransformItems = (0, import_data3.createRegistrySelector)(
    (select2) => (0, import_data3.createSelector)(
      (state, blocks2, rootClientId = null) => {
        const normalizedBlocks = Array.isArray(blocks2) ? blocks2 : [blocks2];
        const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
          buildScope: "transform"
        });
        const blockTypeTransformItems = (0, import_blocks5.getBlockTypes)().filter(
          (blockType) => canIncludeBlockTypeInInserter(
            state,
            blockType,
            rootClientId
          )
        ).map(buildBlockTypeTransformItem);
        const itemsByName = Object.fromEntries(
          Object.entries(blockTypeTransformItems).map(
            ([, value]) => [value.name, value]
          )
        );
        const possibleTransforms = (0, import_blocks5.getPossibleBlockTransformations)(
          normalizedBlocks
        ).reduce((accumulator, block) => {
          if (itemsByName[block?.name]) {
            accumulator.push(itemsByName[block.name]);
          }
          return accumulator;
        }, []);
        return orderBy(
          possibleTransforms,
          (block) => itemsByName[block.name].frecency,
          "desc"
        );
      },
      (state, blocks2, rootClientId) => [
        (0, import_blocks5.getBlockTypes)(),
        state.preferences.insertUsage,
        ...getInsertBlockTypeDependants(select2)(state, rootClientId)
      ]
    )
  );
  var hasInserterItems = (state, rootClientId = null) => {
    const hasBlockType = (0, import_blocks5.getBlockTypes)().some(
      (blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId)
    );
    if (hasBlockType) {
      return true;
    }
    const hasReusableBlock = canInsertBlockTypeUnmemoized(
      state,
      "core/block",
      rootClientId
    );
    return hasReusableBlock;
  };
  var getAllowedBlocks = (0, import_data3.createRegistrySelector)(
    (select2) => (0, import_data3.createSelector)(
      (state, rootClientId = null) => {
        if (!rootClientId) {
          return;
        }
        const blockTypes = (0, import_blocks5.getBlockTypes)().filter(
          (blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId)
        );
        const hasReusableBlock = canInsertBlockTypeUnmemoized(
          state,
          "core/block",
          rootClientId
        );
        if (hasReusableBlock) {
          blockTypes.push("core/block");
        }
        return blockTypes;
      },
      (state, rootClientId) => [
        (0, import_blocks5.getBlockTypes)(),
        ...getInsertBlockTypeDependants(select2)(state, rootClientId)
      ]
    )
  );
  var __experimentalGetAllowedBlocks = (0, import_data3.createSelector)(
    (state, rootClientId = null) => {
      (0, import_deprecated2.default)(
        'wp.data.select( "core/block-editor" ).__experimentalGetAllowedBlocks',
        {
          alternative: 'wp.data.select( "core/block-editor" ).getAllowedBlocks',
          since: "6.2",
          version: "6.4"
        }
      );
      return getAllowedBlocks(state, rootClientId);
    },
    (state, rootClientId) => getAllowedBlocks.getDependants(state, rootClientId)
  );
  function getDirectInsertBlock(state, rootClientId = null) {
    if (!rootClientId) {
      return;
    }
    const { defaultBlock, directInsert } = state.blockListSettings[rootClientId] ?? {};
    if (!defaultBlock || !directInsert) {
      return;
    }
    return defaultBlock;
  }
  function __experimentalGetDirectInsertBlock(state, rootClientId = null) {
    (0, import_deprecated2.default)(
      'wp.data.select( "core/block-editor" ).__experimentalGetDirectInsertBlock',
      {
        alternative: 'wp.data.select( "core/block-editor" ).getDirectInsertBlock',
        since: "6.3",
        version: "6.4"
      }
    );
    return getDirectInsertBlock(state, rootClientId);
  }
  var __experimentalGetParsedPattern = (0, import_data3.createRegistrySelector)(
    (select2) => (state, patternName) => {
      const pattern = unlock(select2(STORE_NAME)).getPatternBySlug(
        patternName
      );
      return pattern ? getParsedPattern(pattern) : null;
    }
  );
  var getAllowedPatternsDependants = (select2) => (state, rootClientId) => [
    ...getAllPatternsDependants(select2)(state),
    ...getInsertBlockTypeDependants(select2)(state, rootClientId)
  ];
  var patternsWithParsedBlocks = /* @__PURE__ */ new WeakMap();
  function enhancePatternWithParsedBlocks(pattern) {
    let enhancedPattern = patternsWithParsedBlocks.get(pattern);
    if (!enhancedPattern) {
      enhancedPattern = {
        ...pattern,
        get blocks() {
          return getParsedPattern(pattern).blocks;
        }
      };
      patternsWithParsedBlocks.set(pattern, enhancedPattern);
    }
    return enhancedPattern;
  }
  var __experimentalGetAllowedPatterns = (0, import_data3.createRegistrySelector)(
    (select2) => {
      return (0, import_data3.createSelector)(
        (state, rootClientId = null, options = DEFAULT_INSERTER_OPTIONS) => {
          const { getAllPatterns: getAllPatterns2 } = unlock(select2(STORE_NAME));
          const patterns = getAllPatterns2();
          const { allowedBlockTypes } = getSettings(state);
          const parsedPatterns = patterns.filter(({ inserter = true }) => !!inserter).map(enhancePatternWithParsedBlocks);
          const availableParsedPatterns = parsedPatterns.filter(
            (pattern) => checkAllowListRecursive(
              getGrammar(pattern),
              allowedBlockTypes
            )
          );
          const patternsAllowed = availableParsedPatterns.filter(
            (pattern) => getGrammar(pattern).every(
              ({ blockName: name }) => options[isFiltered] !== false ? canInsertBlockType(
                state,
                name,
                rootClientId
              ) : isBlockVisibleInTheInserter(
                state,
                name,
                rootClientId
              )
            )
          );
          return patternsAllowed;
        },
        getAllowedPatternsDependants(select2)
      );
    }
  );
  var getPatternsByBlockTypes = (0, import_data3.createRegistrySelector)(
    (select2) => (0, import_data3.createSelector)(
      (state, blockNames, rootClientId = null) => {
        if (!blockNames) {
          return EMPTY_ARRAY2;
        }
        const patterns = select2(STORE_NAME).__experimentalGetAllowedPatterns(
          rootClientId
        );
        const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
        const filteredPatterns = patterns.filter(
          (pattern) => pattern?.blockTypes?.some?.(
            (blockName) => normalizedBlockNames.includes(blockName)
          )
        );
        if (filteredPatterns.length === 0) {
          return EMPTY_ARRAY2;
        }
        return filteredPatterns;
      },
      (state, blockNames, rootClientId) => getAllowedPatternsDependants(select2)(state, rootClientId)
    )
  );
  var __experimentalGetPatternsByBlockTypes = (0, import_data3.createRegistrySelector)(
    (select2) => {
      (0, import_deprecated2.default)(
        'wp.data.select( "core/block-editor" ).__experimentalGetPatternsByBlockTypes',
        {
          alternative: 'wp.data.select( "core/block-editor" ).getPatternsByBlockTypes',
          since: "6.2",
          version: "6.4"
        }
      );
      return select2(STORE_NAME).getPatternsByBlockTypes;
    }
  );
  var __experimentalGetPatternTransformItems = (0, import_data3.createRegistrySelector)(
    (select2) => (0, import_data3.createSelector)(
      (state, blocks2, rootClientId = null) => {
        if (!blocks2) {
          return EMPTY_ARRAY2;
        }
        if (blocks2.some(
          ({ clientId, innerBlocks }) => innerBlocks.length || areInnerBlocksControlled(state, clientId)
        )) {
          return EMPTY_ARRAY2;
        }
        const selectedBlockNames = Array.from(
          new Set(blocks2.map(({ name }) => name))
        );
        return select2(STORE_NAME).getPatternsByBlockTypes(
          selectedBlockNames,
          rootClientId
        );
      },
      (state, blocks2, rootClientId) => getAllowedPatternsDependants(select2)(state, rootClientId)
    )
  );
  function getBlockListSettings(state, clientId) {
    return state.blockListSettings[clientId];
  }
  function getSettings(state) {
    return state.settings;
  }
  function isLastBlockChangePersistent(state) {
    return state.blocks.isPersistentChange;
  }
  var __experimentalGetBlockListSettingsForBlocks = (0, import_data3.createSelector)(
    (state, clientIds = []) => {
      return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
        if (!state.blockListSettings[clientId]) {
          return blockListSettingsForBlocks;
        }
        return {
          ...blockListSettingsForBlocks,
          [clientId]: state.blockListSettings[clientId]
        };
      }, {});
    },
    (state) => [state.blockListSettings]
  );
  var __experimentalGetReusableBlockTitle = (0, import_data3.createRegistrySelector)(
    (select2) => (0, import_data3.createSelector)(
      (state, ref) => {
        (0, import_deprecated2.default)(
          "wp.data.select( 'core/block-editor' ).__experimentalGetReusableBlockTitle",
          {
            since: "6.6",
            version: "6.8"
          }
        );
        const reusableBlock = unlock(select2(STORE_NAME)).getReusableBlocks().find((block) => block.id === ref);
        if (!reusableBlock) {
          return null;
        }
        return reusableBlock.title?.raw;
      },
      () => [unlock(select2(STORE_NAME)).getReusableBlocks()]
    )
  );
  function __unstableIsLastBlockChangeIgnored(state) {
    return state.blocks.isIgnoredChange;
  }
  function __experimentalGetLastBlockAttributeChanges(state) {
    return state.lastBlockAttributesChange;
  }
  function hasBlockMovingClientId() {
    (0, import_deprecated2.default)(
      'wp.data.select( "core/block-editor" ).hasBlockMovingClientId',
      {
        since: "6.7",
        hint: "Block moving mode feature has been removed"
      }
    );
    return false;
  }
  function didAutomaticChange(state) {
    return !!state.automaticChangeStatus;
  }
  function isBlockHighlighted(state, clientId) {
    return state.highlightedBlock === clientId;
  }
  function areInnerBlocksControlled(state, clientId) {
    return !!state.blocks.controlledInnerBlocks[clientId];
  }
  var __experimentalGetActiveBlockIdByBlockNames = (0, import_data3.createSelector)(
    (state, validBlockNames) => {
      if (!validBlockNames.length) {
        return null;
      }
      const selectedBlockClientId = getSelectedBlockClientId(state);
      if (validBlockNames.includes(
        getBlockName(state, selectedBlockClientId)
      )) {
        return selectedBlockClientId;
      }
      const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
      const entityAreaParents = getBlockParentsByBlockName(
        state,
        selectedBlockClientId || multiSelectedBlockClientIds[0],
        validBlockNames
      );
      if (entityAreaParents) {
        return entityAreaParents[entityAreaParents.length - 1];
      }
      return null;
    },
    (state, validBlockNames) => [
      state.selection.selectionStart.clientId,
      state.selection.selectionEnd.clientId,
      validBlockNames
    ]
  );
  function wasBlockJustInserted(state, clientId, source) {
    const { lastBlockInserted: lastBlockInserted2 } = state;
    return lastBlockInserted2.clientIds?.includes(clientId) && lastBlockInserted2.source === source;
  }
  function isBlockVisible(state, clientId) {
    return state.blockVisibility?.[clientId] ?? true;
  }
  function getHoveredBlockClientId() {
    (0, import_deprecated2.default)(
      "wp.data.select( 'core/block-editor' ).getHoveredBlockClientId",
      {
        since: "6.9",
        version: "7.1"
      }
    );
    return void 0;
  }
  var __unstableGetVisibleBlocks = (0, import_data3.createSelector)(
    (state) => {
      const visibleBlocks = new Set(
        Object.keys(state.blockVisibility).filter(
          (key) => state.blockVisibility[key]
        )
      );
      if (visibleBlocks.size === 0) {
        return EMPTY_SET;
      }
      return visibleBlocks;
    },
    (state) => [state.blockVisibility]
  );
  function __unstableHasActiveBlockOverlayActive(state, clientId) {
    if (getBlockEditingMode(state, clientId) !== "default") {
      return false;
    }
    if (!canEditBlock(state, clientId)) {
      return true;
    }
    if (isZoomOut(state)) {
      const sectionRootClientId = getSectionRootClientId(state);
      if (sectionRootClientId) {
        const sectionClientIds = getBlockOrder(
          state,
          sectionRootClientId
        );
        if (sectionClientIds?.includes(clientId)) {
          return true;
        }
      } else if (clientId && !getBlockRootClientId(state, clientId)) {
        return true;
      }
    }
    const blockSupportDisable = (0, import_blocks5.hasBlockSupport)(
      getBlockName(state, clientId),
      "__experimentalDisableBlockOverlay",
      false
    );
    const shouldEnableIfUnselected = blockSupportDisable ? false : areInnerBlocksControlled(state, clientId);
    return shouldEnableIfUnselected && !isBlockSelected(state, clientId) && !hasSelectedInnerBlock(state, clientId, true);
  }
  function __unstableIsWithinBlockOverlay(state, clientId) {
    let parent = state.blocks.parents.get(clientId);
    while (!!parent) {
      if (__unstableHasActiveBlockOverlayActive(state, parent)) {
        return true;
      }
      parent = state.blocks.parents.get(parent);
    }
    return false;
  }
  function getBlockEditingMode(state, clientId = "") {
    if (clientId === null) {
      clientId = "";
    }
    if (state.derivedBlockEditingModes?.has(clientId)) {
      return state.derivedBlockEditingModes.get(clientId);
    }
    if (state.blockEditingModes.has(clientId)) {
      return state.blockEditingModes.get(clientId);
    }
    return "default";
  }
  var isUngroupable = (0, import_data3.createRegistrySelector)(
    (select2) => (state, clientId = "") => {
      const _clientId = clientId || getSelectedBlockClientId(state);
      if (!_clientId) {
        return false;
      }
      const { getGroupingBlockName } = select2(import_blocks5.store);
      const block = getBlock(state, _clientId);
      const groupingBlockName = getGroupingBlockName();
      const _isUngroupable = block && (block.name === groupingBlockName || (0, import_blocks5.getBlockType)(block.name)?.transforms?.ungroup) && !!block.innerBlocks.length;
      return _isUngroupable && canRemoveBlock(state, _clientId);
    }
  );
  var isGroupable = (0, import_data3.createRegistrySelector)(
    (select2) => (state, clientIds = EMPTY_ARRAY2) => {
      const { getGroupingBlockName } = select2(import_blocks5.store);
      const groupingBlockName = getGroupingBlockName();
      const _clientIds = clientIds?.length ? clientIds : getSelectedBlockClientIds(state);
      const rootClientId = _clientIds?.length ? getBlockRootClientId(state, _clientIds[0]) : void 0;
      const groupingBlockAvailable = canInsertBlockType(
        state,
        groupingBlockName,
        rootClientId
      );
      const _isGroupable = groupingBlockAvailable && _clientIds.length;
      return _isGroupable && canRemoveBlocks(state, _clientIds);
    }
  );
  var __unstableGetContentLockingParent = (state, clientId) => {
    (0, import_deprecated2.default)(
      "wp.data.select( 'core/block-editor' ).__unstableGetContentLockingParent",
      {
        since: "6.1",
        version: "6.7"
      }
    );
    return getContentLockingParent(state, clientId);
  };
  function __unstableGetTemporarilyEditingAsBlocks(state) {
    (0, import_deprecated2.default)(
      "wp.data.select( 'core/block-editor' ).__unstableGetTemporarilyEditingAsBlocks",
      {
        since: "6.1",
        version: "6.7"
      }
    );
    return getTemporarilyEditingAsBlocks(state);
  }
  function __unstableGetTemporarilyEditingFocusModeToRevert(state) {
    (0, import_deprecated2.default)(
      "wp.data.select( 'core/block-editor' ).__unstableGetTemporarilyEditingFocusModeToRevert",
      {
        since: "6.5",
        version: "6.7"
      }
    );
    return getTemporarilyEditingFocusModeToRevert(state);
  }

  // packages/block-editor/build-module/store/private-actions.js
  var private_actions_exports = {};
  __export(private_actions_exports, {
    __experimentalUpdateSettings: () => __experimentalUpdateSettings,
    clearBlockRemovalPrompt: () => clearBlockRemovalPrompt,
    deleteStyleOverride: () => deleteStyleOverride,
    ensureDefaultBlock: () => ensureDefaultBlock,
    expandBlock: () => expandBlock,
    hideBlockInterface: () => hideBlockInterface,
    modifyContentLockBlock: () => modifyContentLockBlock,
    privateRemoveBlocks: () => privateRemoveBlocks,
    resetZoomLevel: () => resetZoomLevel,
    setBlockRemovalRules: () => setBlockRemovalRules,
    setInsertionPoint: () => setInsertionPoint,
    setLastFocus: () => setLastFocus,
    setOpenedBlockSettingsMenu: () => setOpenedBlockSettingsMenu,
    setStyleOverride: () => setStyleOverride,
    setZoomLevel: () => setZoomLevel,
    showBlockInterface: () => showBlockInterface,
    startDragging: () => startDragging,
    stopDragging: () => stopDragging,
    stopEditingAsBlocks: () => stopEditingAsBlocks,
    toggleBlockSpotlight: () => toggleBlockSpotlight
  });
  var import_element5 = __toESM(require_element());
  var import_deprecated3 = __toESM(require_deprecated());
  var import_a11y2 = __toESM(require_a11y());
  var import_i18n3 = __toESM(require_i18n());
  var castArray = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
  var privateSettings = [
    "inserterMediaCategories",
    "blockInspectorAnimation",
    "mediaSideload"
  ];
  function __experimentalUpdateSettings(settings2, { stripExperimentalSettings = false, reset = false } = {}) {
    let incomingSettings = settings2;
    if (Object.hasOwn(incomingSettings, "__unstableIsPreviewMode")) {
      (0, import_deprecated3.default)(
        "__unstableIsPreviewMode argument in wp.data.dispatch('core/block-editor').updateSettings",
        {
          since: "6.8",
          alternative: "isPreviewMode"
        }
      );
      incomingSettings = { ...incomingSettings };
      incomingSettings.isPreviewMode = incomingSettings.__unstableIsPreviewMode;
      delete incomingSettings.__unstableIsPreviewMode;
    }
    let cleanSettings = incomingSettings;
    if (stripExperimentalSettings && import_element5.Platform.OS === "web") {
      cleanSettings = {};
      for (const key in incomingSettings) {
        if (!privateSettings.includes(key)) {
          cleanSettings[key] = incomingSettings[key];
        }
      }
    }
    return {
      type: "UPDATE_SETTINGS",
      settings: cleanSettings,
      reset
    };
  }
  function hideBlockInterface() {
    return {
      type: "HIDE_BLOCK_INTERFACE"
    };
  }
  function showBlockInterface() {
    return {
      type: "SHOW_BLOCK_INTERFACE"
    };
  }
  var privateRemoveBlocks = (clientIds, selectPrevious = true, forceRemove = false) => ({ select: select2, dispatch, registry }) => {
    if (!clientIds || !clientIds.length) {
      return;
    }
    clientIds = castArray(clientIds);
    const canRemoveBlocks2 = select2.canRemoveBlocks(clientIds);
    if (!canRemoveBlocks2) {
      return;
    }
    const rules = !forceRemove && select2.getBlockRemovalRules();
    if (rules) {
      let flattenBlocks22 = function(blocks2) {
        const result = [];
        const stack = [...blocks2];
        while (stack.length) {
          const { innerBlocks, ...block } = stack.shift();
          stack.push(...innerBlocks);
          result.push(block);
        }
        return result;
      };
      var flattenBlocks2 = flattenBlocks22;
      const blockList = clientIds.map(select2.getBlock);
      const flattenedBlocks = flattenBlocks22(blockList);
      let message;
      for (const rule of rules) {
        message = rule.callback(flattenedBlocks);
        if (message) {
          dispatch(
            displayBlockRemovalPrompt(
              clientIds,
              selectPrevious,
              message
            )
          );
          return;
        }
      }
    }
    if (selectPrevious) {
      dispatch.selectPreviousBlock(clientIds[0], selectPrevious);
    }
    registry.batch(() => {
      dispatch({ type: "REMOVE_BLOCKS", clientIds });
      dispatch(ensureDefaultBlock());
    });
  };
  var ensureDefaultBlock = () => ({ select: select2, dispatch }) => {
    const count = select2.getBlockCount();
    if (count > 0) {
      return;
    }
    const { __unstableHasCustomAppender } = select2.getSettings();
    if (__unstableHasCustomAppender) {
      return;
    }
    dispatch.insertDefaultBlock();
  };
  function displayBlockRemovalPrompt(clientIds, selectPrevious, message) {
    return {
      type: "DISPLAY_BLOCK_REMOVAL_PROMPT",
      clientIds,
      selectPrevious,
      message
    };
  }
  function clearBlockRemovalPrompt() {
    return {
      type: "CLEAR_BLOCK_REMOVAL_PROMPT"
    };
  }
  function setBlockRemovalRules(rules = false) {
    return {
      type: "SET_BLOCK_REMOVAL_RULES",
      rules
    };
  }
  function setOpenedBlockSettingsMenu(clientId) {
    return {
      type: "SET_OPENED_BLOCK_SETTINGS_MENU",
      clientId
    };
  }
  function setStyleOverride(id, style) {
    return {
      type: "SET_STYLE_OVERRIDE",
      id,
      style
    };
  }
  function deleteStyleOverride(id) {
    return {
      type: "DELETE_STYLE_OVERRIDE",
      id
    };
  }
  function setLastFocus(lastFocus2 = null) {
    return {
      type: "LAST_FOCUS",
      lastFocus: lastFocus2
    };
  }
  function stopEditingAsBlocks(clientId) {
    return ({ select: select2, dispatch, registry }) => {
      const focusModeToRevert = unlock(
        registry.select(store)
      ).getTemporarilyEditingFocusModeToRevert();
      dispatch.__unstableMarkNextChangeAsNotPersistent();
      dispatch.updateBlockAttributes(clientId, {
        templateLock: "contentOnly"
      });
      dispatch.updateBlockListSettings(clientId, {
        ...select2.getBlockListSettings(clientId),
        templateLock: "contentOnly"
      });
      dispatch.updateSettings({ focusMode: focusModeToRevert });
      dispatch.__unstableSetTemporarilyEditingAsBlocks();
    };
  }
  function startDragging() {
    return {
      type: "START_DRAGGING"
    };
  }
  function stopDragging() {
    return {
      type: "STOP_DRAGGING"
    };
  }
  function expandBlock(clientId) {
    return {
      type: "SET_BLOCK_EXPANDED_IN_LIST_VIEW",
      clientId
    };
  }
  function setInsertionPoint(value) {
    return {
      type: "SET_INSERTION_POINT",
      value
    };
  }
  var modifyContentLockBlock = (clientId) => ({ select: select2, dispatch }) => {
    dispatch.selectBlock(clientId);
    dispatch.__unstableMarkNextChangeAsNotPersistent();
    dispatch.updateBlockAttributes(clientId, {
      templateLock: void 0
    });
    dispatch.updateBlockListSettings(clientId, {
      ...select2.getBlockListSettings(clientId),
      templateLock: false
    });
    const focusModeToRevert = select2.getSettings().focusMode;
    dispatch.updateSettings({ focusMode: true });
    dispatch.__unstableSetTemporarilyEditingAsBlocks(
      clientId,
      focusModeToRevert
    );
  };
  var setZoomLevel = (zoom = 100) => ({ select: select2, dispatch }) => {
    if (zoom !== 100) {
      const firstSelectedClientId = select2.getBlockSelectionStart();
      const sectionRootClientId = select2.getSectionRootClientId();
      if (firstSelectedClientId) {
        let sectionClientId;
        if (sectionRootClientId) {
          const sectionClientIds = select2.getBlockOrder(sectionRootClientId);
          if (sectionClientIds?.includes(firstSelectedClientId)) {
            sectionClientId = firstSelectedClientId;
          } else {
            sectionClientId = select2.getBlockParents(firstSelectedClientId).find(
              (parent) => sectionClientIds.includes(parent)
            );
          }
        } else {
          sectionClientId = select2.getBlockHierarchyRootClientId(
            firstSelectedClientId
          );
        }
        if (sectionClientId) {
          dispatch.selectBlock(sectionClientId);
        } else {
          dispatch.clearSelectedBlock();
        }
        (0, import_a11y2.speak)((0, import_i18n3.__)("You are currently in zoom-out mode."));
      }
    }
    dispatch({
      type: "SET_ZOOM_LEVEL",
      zoom
    });
  };
  function resetZoomLevel() {
    return {
      type: "RESET_ZOOM_LEVEL"
    };
  }
  function toggleBlockSpotlight(clientId, hasBlockSpotlight3) {
    return {
      type: "TOGGLE_BLOCK_SPOTLIGHT",
      clientId,
      hasBlockSpotlight: hasBlockSpotlight3
    };
  }

  // packages/block-editor/build-module/store/actions.js
  var actions_exports = {};
  __export(actions_exports, {
    __unstableDeleteSelection: () => __unstableDeleteSelection,
    __unstableExpandSelection: () => __unstableExpandSelection,
    __unstableMarkAutomaticChange: () => __unstableMarkAutomaticChange,
    __unstableMarkLastChangeAsPersistent: () => __unstableMarkLastChangeAsPersistent,
    __unstableMarkNextChangeAsNotPersistent: () => __unstableMarkNextChangeAsNotPersistent,
    __unstableSaveReusableBlock: () => __unstableSaveReusableBlock,
    __unstableSetEditorMode: () => __unstableSetEditorMode,
    __unstableSetTemporarilyEditingAsBlocks: () => __unstableSetTemporarilyEditingAsBlocks,
    __unstableSplitSelection: () => __unstableSplitSelection,
    clearSelectedBlock: () => clearSelectedBlock,
    duplicateBlocks: () => duplicateBlocks,
    enterFormattedText: () => enterFormattedText,
    exitFormattedText: () => exitFormattedText,
    flashBlock: () => flashBlock,
    hideInsertionPoint: () => hideInsertionPoint,
    hoverBlock: () => hoverBlock,
    insertAfterBlock: () => insertAfterBlock,
    insertBeforeBlock: () => insertBeforeBlock,
    insertBlock: () => insertBlock,
    insertBlocks: () => insertBlocks,
    insertDefaultBlock: () => insertDefaultBlock,
    mergeBlocks: () => mergeBlocks,
    moveBlockToPosition: () => moveBlockToPosition,
    moveBlocksDown: () => moveBlocksDown,
    moveBlocksToPosition: () => moveBlocksToPosition,
    moveBlocksUp: () => moveBlocksUp,
    multiSelect: () => multiSelect,
    receiveBlocks: () => receiveBlocks,
    registerInserterMediaCategory: () => registerInserterMediaCategory,
    removeBlock: () => removeBlock,
    removeBlocks: () => removeBlocks,
    replaceBlock: () => replaceBlock,
    replaceBlocks: () => replaceBlocks,
    replaceInnerBlocks: () => replaceInnerBlocks,
    resetBlocks: () => resetBlocks,
    resetSelection: () => resetSelection,
    selectBlock: () => selectBlock,
    selectNextBlock: () => selectNextBlock,
    selectPreviousBlock: () => selectPreviousBlock,
    selectionChange: () => selectionChange,
    setBlockEditingMode: () => setBlockEditingMode,
    setBlockMovingClientId: () => setBlockMovingClientId,
    setBlockVisibility: () => setBlockVisibility,
    setHasControlledInnerBlocks: () => setHasControlledInnerBlocks,
    setTemplateValidity: () => setTemplateValidity,
    showInsertionPoint: () => showInsertionPoint,
    startDraggingBlocks: () => startDraggingBlocks,
    startMultiSelect: () => startMultiSelect,
    startTyping: () => startTyping,
    stopDraggingBlocks: () => stopDraggingBlocks,
    stopMultiSelect: () => stopMultiSelect,
    stopTyping: () => stopTyping,
    synchronizeTemplate: () => synchronizeTemplate,
    toggleBlockHighlight: () => toggleBlockHighlight,
    toggleBlockMode: () => toggleBlockMode,
    toggleSelection: () => toggleSelection,
    unsetBlockEditingMode: () => unsetBlockEditingMode,
    updateBlock: () => updateBlock,
    updateBlockAttributes: () => updateBlockAttributes,
    updateBlockListSettings: () => updateBlockListSettings,
    updateSettings: () => updateSettings,
    validateBlocksToTemplate: () => validateBlocksToTemplate
  });
  var import_blocks6 = __toESM(require_blocks());
  var import_a11y3 = __toESM(require_a11y());
  var import_i18n4 = __toESM(require_i18n());
  var import_notices = __toESM(require_notices());
  var import_rich_text3 = __toESM(require_rich_text());
  var import_deprecated4 = __toESM(require_deprecated());
  var import_preferences = __toESM(require_preferences());

  // packages/block-editor/build-module/utils/selection.js
  var import_rich_text2 = __toESM(require_rich_text());
  var START_OF_SELECTED_AREA = "\x86";
  function retrieveSelectedAttribute(blockAttributes) {
    if (!blockAttributes) {
      return;
    }
    return Object.keys(blockAttributes).find((name) => {
      const value = blockAttributes[name];
      return (typeof value === "string" || value instanceof import_rich_text2.RichTextData) && // To do: refactor this to use rich text's selection instead, so we
      // no longer have to use on this hack inserting a special character.
      value.toString().indexOf(START_OF_SELECTED_AREA) !== -1;
    });
  }
  function findRichTextAttributeKey(blockType) {
    for (const [key, value] of Object.entries(blockType.attributes)) {
      if (value.source === "rich-text" || value.source === "html") {
        return key;
      }
    }
  }

  // packages/block-editor/build-module/store/actions.js
  var castArray2 = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
  var resetBlocks = (blocks2) => ({ dispatch }) => {
    dispatch({ type: "RESET_BLOCKS", blocks: blocks2 });
    dispatch(validateBlocksToTemplate(blocks2));
  };
  var validateBlocksToTemplate = (blocks2) => ({ select: select2, dispatch }) => {
    const template2 = select2.getTemplate();
    const templateLock = select2.getTemplateLock();
    const isBlocksValidToTemplate = !template2 || templateLock !== "all" || (0, import_blocks6.doBlocksMatchTemplate)(blocks2, template2);
    const isValidTemplate2 = select2.isValidTemplate();
    if (isBlocksValidToTemplate !== isValidTemplate2) {
      dispatch.setTemplateValidity(isBlocksValidToTemplate);
      return isBlocksValidToTemplate;
    }
  };
  function resetSelection(selectionStart, selectionEnd, initialPosition2) {
    return {
      type: "RESET_SELECTION",
      selectionStart,
      selectionEnd,
      initialPosition: initialPosition2
    };
  }
  function receiveBlocks(blocks2) {
    (0, import_deprecated4.default)('wp.data.dispatch( "core/block-editor" ).receiveBlocks', {
      since: "5.9",
      alternative: "resetBlocks or insertBlocks"
    });
    return {
      type: "RECEIVE_BLOCKS",
      blocks: blocks2
    };
  }
  function updateBlockAttributes(clientIds, attributes, options = { uniqueByBlock: false }) {
    if (typeof options === "boolean") {
      options = { uniqueByBlock: options };
    }
    return {
      type: "UPDATE_BLOCK_ATTRIBUTES",
      clientIds: castArray2(clientIds),
      attributes,
      options
    };
  }
  function updateBlock(clientId, updates) {
    return {
      type: "UPDATE_BLOCK",
      clientId,
      updates
    };
  }
  function selectBlock(clientId, initialPosition2 = 0) {
    return {
      type: "SELECT_BLOCK",
      initialPosition: initialPosition2,
      clientId
    };
  }
  function hoverBlock() {
    (0, import_deprecated4.default)('wp.data.dispatch( "core/block-editor" ).hoverBlock', {
      since: "6.9",
      version: "7.1"
    });
    return {
      type: "DO_NOTHING"
    };
  }
  var selectPreviousBlock = (clientId, fallbackToParent = false) => ({ select: select2, dispatch }) => {
    const previousBlockClientId = select2.getPreviousBlockClientId(clientId);
    if (previousBlockClientId) {
      dispatch.selectBlock(previousBlockClientId, -1);
    } else if (fallbackToParent) {
      const firstParentClientId = select2.getBlockRootClientId(clientId);
      if (firstParentClientId) {
        dispatch.selectBlock(firstParentClientId, -1);
      }
    }
  };
  var selectNextBlock = (clientId) => ({ select: select2, dispatch }) => {
    const nextBlockClientId = select2.getNextBlockClientId(clientId);
    if (nextBlockClientId) {
      dispatch.selectBlock(nextBlockClientId);
    }
  };
  function startMultiSelect() {
    return {
      type: "START_MULTI_SELECT"
    };
  }
  function stopMultiSelect() {
    return {
      type: "STOP_MULTI_SELECT"
    };
  }
  var multiSelect = (start2, end, __experimentalInitialPosition = 0) => ({ select: select2, dispatch }) => {
    const startBlockRootClientId = select2.getBlockRootClientId(start2);
    const endBlockRootClientId = select2.getBlockRootClientId(end);
    if (startBlockRootClientId !== endBlockRootClientId) {
      return;
    }
    dispatch({
      type: "MULTI_SELECT",
      start: start2,
      end,
      initialPosition: __experimentalInitialPosition
    });
    const blockCount = select2.getSelectedBlockCount();
    (0, import_a11y3.speak)(
      (0, import_i18n4.sprintf)(
        /* translators: %s: number of selected blocks */
        (0, import_i18n4._n)("%s block selected.", "%s blocks selected.", blockCount),
        blockCount
      ),
      "assertive"
    );
  };
  function clearSelectedBlock() {
    return {
      type: "CLEAR_SELECTED_BLOCK"
    };
  }
  function toggleSelection(isSelectionEnabled3 = true) {
    return {
      type: "TOGGLE_SELECTION",
      isSelectionEnabled: isSelectionEnabled3
    };
  }
  var replaceBlocks = (clientIds, blocks2, indexToSelect, initialPosition2 = 0, meta) => ({ select: select2, dispatch, registry }) => {
    clientIds = castArray2(clientIds);
    blocks2 = castArray2(blocks2);
    const rootClientId = select2.getBlockRootClientId(clientIds[0]);
    for (let index = 0; index < blocks2.length; index++) {
      const block = blocks2[index];
      const canInsertBlock = select2.canInsertBlockType(
        block.name,
        rootClientId
      );
      if (!canInsertBlock) {
        return;
      }
    }
    registry.batch(() => {
      dispatch({
        type: "REPLACE_BLOCKS",
        clientIds,
        blocks: blocks2,
        time: Date.now(),
        indexToSelect,
        initialPosition: initialPosition2,
        meta
      });
      dispatch.ensureDefaultBlock();
    });
  };
  function replaceBlock(clientId, block) {
    return replaceBlocks(clientId, block);
  }
  var createOnMove = (type) => (clientIds, rootClientId) => ({ select: select2, dispatch }) => {
    const canMoveBlocks2 = select2.canMoveBlocks(clientIds);
    if (!canMoveBlocks2) {
      return;
    }
    dispatch({ type, clientIds: castArray2(clientIds), rootClientId });
  };
  var moveBlocksDown = createOnMove("MOVE_BLOCKS_DOWN");
  var moveBlocksUp = createOnMove("MOVE_BLOCKS_UP");
  var moveBlocksToPosition = (clientIds, fromRootClientId = "", toRootClientId = "", index) => ({ select: select2, dispatch }) => {
    const canMoveBlocks2 = select2.canMoveBlocks(clientIds);
    if (!canMoveBlocks2) {
      return;
    }
    if (fromRootClientId !== toRootClientId) {
      const canRemoveBlocks2 = select2.canRemoveBlocks(clientIds);
      if (!canRemoveBlocks2) {
        return;
      }
      const canInsertBlocks2 = select2.canInsertBlocks(
        clientIds,
        toRootClientId
      );
      if (!canInsertBlocks2) {
        return;
      }
    }
    dispatch({
      type: "MOVE_BLOCKS_TO_POSITION",
      fromRootClientId,
      toRootClientId,
      clientIds,
      index
    });
  };
  function moveBlockToPosition(clientId, fromRootClientId = "", toRootClientId = "", index) {
    return moveBlocksToPosition(
      [clientId],
      fromRootClientId,
      toRootClientId,
      index
    );
  }
  function insertBlock(block, index, rootClientId, updateSelection, meta) {
    return insertBlocks(
      [block],
      index,
      rootClientId,
      updateSelection,
      0,
      meta
    );
  }
  var insertBlocks = (blocks2, index, rootClientId, updateSelection = true, initialPosition2 = 0, meta) => ({ select: select2, dispatch }) => {
    if (initialPosition2 !== null && typeof initialPosition2 === "object") {
      meta = initialPosition2;
      initialPosition2 = 0;
      (0, import_deprecated4.default)(
        "meta argument in wp.data.dispatch('core/block-editor')",
        {
          since: "5.8",
          hint: "The meta argument is now the 6th argument of the function"
        }
      );
    }
    blocks2 = castArray2(blocks2);
    const allowedBlocks = [];
    for (const block of blocks2) {
      const isValid = select2.canInsertBlockType(
        block.name,
        rootClientId
      );
      if (isValid) {
        allowedBlocks.push(block);
      }
    }
    if (allowedBlocks.length) {
      dispatch({
        type: "INSERT_BLOCKS",
        blocks: allowedBlocks,
        index,
        rootClientId,
        time: Date.now(),
        updateSelection,
        initialPosition: updateSelection ? initialPosition2 : null,
        meta
      });
    }
  };
  function showInsertionPoint(rootClientId, index, __unstableOptions = {}) {
    const { __unstableWithInserter, operation, nearestSide } = __unstableOptions;
    return {
      type: "SHOW_INSERTION_POINT",
      rootClientId,
      index,
      __unstableWithInserter,
      operation,
      nearestSide
    };
  }
  var hideInsertionPoint = () => ({ select: select2, dispatch }) => {
    if (!select2.isBlockInsertionPointVisible()) {
      return;
    }
    dispatch({
      type: "HIDE_INSERTION_POINT"
    });
  };
  function setTemplateValidity(isValid) {
    return {
      type: "SET_TEMPLATE_VALIDITY",
      isValid
    };
  }
  var synchronizeTemplate = () => ({ select: select2, dispatch }) => {
    dispatch({ type: "SYNCHRONIZE_TEMPLATE" });
    const blocks2 = select2.getBlocks();
    const template2 = select2.getTemplate();
    const updatedBlockList = (0, import_blocks6.synchronizeBlocksWithTemplate)(
      blocks2,
      template2
    );
    dispatch.resetBlocks(updatedBlockList);
  };
  var __unstableDeleteSelection = (isForward) => ({ registry, select: select2, dispatch }) => {
    const selectionAnchor = select2.getSelectionStart();
    const selectionFocus = select2.getSelectionEnd();
    if (selectionAnchor.clientId === selectionFocus.clientId) {
      return;
    }
    if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
      return false;
    }
    const anchorRootClientId = select2.getBlockRootClientId(
      selectionAnchor.clientId
    );
    const focusRootClientId = select2.getBlockRootClientId(
      selectionFocus.clientId
    );
    if (anchorRootClientId !== focusRootClientId) {
      return;
    }
    const blockOrder = select2.getBlockOrder(anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    let selectionStart, selectionEnd;
    if (anchorIndex > focusIndex) {
      selectionStart = selectionFocus;
      selectionEnd = selectionAnchor;
    } else {
      selectionStart = selectionAnchor;
      selectionEnd = selectionFocus;
    }
    const targetSelection = isForward ? selectionEnd : selectionStart;
    const targetBlock = select2.getBlock(targetSelection.clientId);
    const targetBlockType = (0, import_blocks6.getBlockType)(targetBlock.name);
    if (!targetBlockType.merge) {
      return;
    }
    const selectionA = selectionStart;
    const selectionB = selectionEnd;
    const blockA = select2.getBlock(selectionA.clientId);
    const blockB = select2.getBlock(selectionB.clientId);
    const htmlA = blockA.attributes[selectionA.attributeKey];
    const htmlB = blockB.attributes[selectionB.attributeKey];
    let valueA = (0, import_rich_text3.create)({ html: htmlA });
    let valueB = (0, import_rich_text3.create)({ html: htmlB });
    valueA = (0, import_rich_text3.remove)(valueA, selectionA.offset, valueA.text.length);
    valueB = (0, import_rich_text3.insert)(valueB, START_OF_SELECTED_AREA, 0, selectionB.offset);
    const cloneA = (0, import_blocks6.cloneBlock)(blockA, {
      [selectionA.attributeKey]: (0, import_rich_text3.toHTMLString)({ value: valueA })
    });
    const cloneB = (0, import_blocks6.cloneBlock)(blockB, {
      [selectionB.attributeKey]: (0, import_rich_text3.toHTMLString)({ value: valueB })
    });
    const followingBlock = isForward ? cloneA : cloneB;
    const blocksWithTheSameType = blockA.name === blockB.name ? [followingBlock] : (0, import_blocks6.switchToBlockType)(followingBlock, targetBlockType.name);
    if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
      return;
    }
    let updatedAttributes;
    if (isForward) {
      const blockToMerge = blocksWithTheSameType.pop();
      updatedAttributes = targetBlockType.merge(
        blockToMerge.attributes,
        cloneB.attributes
      );
    } else {
      const blockToMerge = blocksWithTheSameType.shift();
      updatedAttributes = targetBlockType.merge(
        cloneA.attributes,
        blockToMerge.attributes
      );
    }
    const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const convertedValue = (0, import_rich_text3.create)({ html: convertedHtml });
    const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
    const newValue = (0, import_rich_text3.remove)(convertedValue, newOffset, newOffset + 1);
    const newHtml = (0, import_rich_text3.toHTMLString)({ value: newValue });
    updatedAttributes[newAttributeKey] = newHtml;
    const selectedBlockClientIds = select2.getSelectedBlockClientIds();
    const replacement = [
      ...isForward ? blocksWithTheSameType : [],
      {
        // Preserve the original client ID.
        ...targetBlock,
        attributes: {
          ...targetBlock.attributes,
          ...updatedAttributes
        }
      },
      ...isForward ? [] : blocksWithTheSameType
    ];
    registry.batch(() => {
      dispatch.selectionChange(
        targetBlock.clientId,
        newAttributeKey,
        newOffset,
        newOffset
      );
      dispatch.replaceBlocks(
        selectedBlockClientIds,
        replacement,
        0,
        // If we don't pass the `indexToSelect` it will default to the last block.
        select2.getSelectedBlocksInitialCaretPosition()
      );
    });
  };
  var __unstableSplitSelection = (blocks2 = []) => ({ registry, select: select2, dispatch }) => {
    const selectionAnchor = select2.getSelectionStart();
    const selectionFocus = select2.getSelectionEnd();
    const anchorRootClientId = select2.getBlockRootClientId(
      selectionAnchor.clientId
    );
    const focusRootClientId = select2.getBlockRootClientId(
      selectionFocus.clientId
    );
    if (anchorRootClientId !== focusRootClientId) {
      return;
    }
    const blockOrder = select2.getBlockOrder(anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    let selectionStart, selectionEnd;
    if (anchorIndex > focusIndex) {
      selectionStart = selectionFocus;
      selectionEnd = selectionAnchor;
    } else {
      selectionStart = selectionAnchor;
      selectionEnd = selectionFocus;
    }
    const selectionA = selectionStart;
    const selectionB = selectionEnd;
    const blockA = select2.getBlock(selectionA.clientId);
    const blockB = select2.getBlock(selectionB.clientId);
    const blockAType = (0, import_blocks6.getBlockType)(blockA.name);
    const blockBType = (0, import_blocks6.getBlockType)(blockB.name);
    const attributeKeyA = typeof selectionA.attributeKey === "string" ? selectionA.attributeKey : findRichTextAttributeKey(blockAType);
    const attributeKeyB = typeof selectionB.attributeKey === "string" ? selectionB.attributeKey : findRichTextAttributeKey(blockBType);
    const blockAttributes = select2.getBlockAttributes(
      selectionA.clientId
    );
    const bindings = blockAttributes?.metadata?.bindings;
    if (bindings?.[attributeKeyA]) {
      if (blocks2.length) {
        const { createWarningNotice } = registry.dispatch(import_notices.store);
        createWarningNotice(
          (0, import_i18n4.__)(
            "Blocks can't be inserted into other blocks with bindings"
          ),
          {
            type: "snackbar"
          }
        );
        return;
      }
      dispatch.insertAfterBlock(selectionA.clientId);
      return;
    }
    if (!attributeKeyA || !attributeKeyB || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
      return;
    }
    if (selectionA.clientId === selectionB.clientId && attributeKeyA === attributeKeyB && selectionA.offset === selectionB.offset) {
      if (blocks2.length) {
        if ((0, import_blocks6.isUnmodifiedDefaultBlock)(blockA)) {
          dispatch.replaceBlocks(
            [selectionA.clientId],
            blocks2,
            blocks2.length - 1,
            -1
          );
          return;
        }
      } else if (!select2.getBlockOrder(selectionA.clientId).length) {
        let createEmpty2 = function() {
          const defaultBlockName2 = (0, import_blocks6.getDefaultBlockName)();
          return select2.canInsertBlockType(
            defaultBlockName2,
            anchorRootClientId
          ) ? (0, import_blocks6.createBlock)(defaultBlockName2) : (0, import_blocks6.createBlock)(
            select2.getBlockName(selectionA.clientId)
          );
        };
        var createEmpty = createEmpty2;
        const length2 = blockAttributes[attributeKeyA].length;
        if (selectionA.offset === 0 && length2) {
          dispatch.insertBlocks(
            [createEmpty2()],
            select2.getBlockIndex(selectionA.clientId),
            anchorRootClientId,
            false
          );
          return;
        }
        if (selectionA.offset === length2) {
          dispatch.insertBlocks(
            [createEmpty2()],
            select2.getBlockIndex(selectionA.clientId) + 1,
            anchorRootClientId
          );
          return;
        }
      }
    }
    const htmlA = blockA.attributes[attributeKeyA];
    const htmlB = blockB.attributes[attributeKeyB];
    let valueA = (0, import_rich_text3.create)({ html: htmlA });
    let valueB = (0, import_rich_text3.create)({ html: htmlB });
    valueA = (0, import_rich_text3.remove)(valueA, selectionA.offset, valueA.text.length);
    valueB = (0, import_rich_text3.remove)(valueB, 0, selectionB.offset);
    let head = {
      // Preserve the original client ID.
      ...blockA,
      // If both start and end are the same, should only copy innerBlocks
      // once.
      innerBlocks: blockA.clientId === blockB.clientId ? [] : blockA.innerBlocks,
      attributes: {
        ...blockA.attributes,
        [attributeKeyA]: (0, import_rich_text3.toHTMLString)({ value: valueA })
      }
    };
    let tail = {
      ...blockB,
      // Only preserve the original client ID if the end is different.
      clientId: blockA.clientId === blockB.clientId ? (0, import_blocks6.createBlock)(blockB.name).clientId : blockB.clientId,
      attributes: {
        ...blockB.attributes,
        [attributeKeyB]: (0, import_rich_text3.toHTMLString)({ value: valueB })
      }
    };
    const defaultBlockName = (0, import_blocks6.getDefaultBlockName)();
    if (
      // A block is only split when the selection is within the same
      // block.
      blockA.clientId === blockB.clientId && defaultBlockName && tail.name !== defaultBlockName && select2.canInsertBlockType(defaultBlockName, anchorRootClientId)
    ) {
      const switched = (0, import_blocks6.switchToBlockType)(tail, defaultBlockName);
      if (switched?.length === 1) {
        tail = switched[0];
      }
    }
    if (!blocks2.length) {
      dispatch.replaceBlocks(select2.getSelectedBlockClientIds(), [
        head,
        tail
      ]);
      return;
    }
    let selection2;
    const output = [];
    const clonedBlocks = [...blocks2];
    const firstBlock = clonedBlocks.shift();
    const headType = (0, import_blocks6.getBlockType)(head.name);
    const firstBlocks = headType.merge && firstBlock.name === headType.name ? [firstBlock] : (0, import_blocks6.switchToBlockType)(firstBlock, headType.name);
    if (firstBlocks?.length) {
      const first = firstBlocks.shift();
      head = {
        ...head,
        attributes: {
          ...head.attributes,
          ...headType.merge(head.attributes, first.attributes)
        }
      };
      output.push(head);
      selection2 = {
        clientId: head.clientId,
        attributeKey: attributeKeyA,
        offset: (0, import_rich_text3.create)({ html: head.attributes[attributeKeyA] }).text.length
      };
      clonedBlocks.unshift(...firstBlocks);
    } else {
      if (!(0, import_blocks6.isUnmodifiedBlock)(head)) {
        output.push(head);
      }
      output.push(firstBlock);
    }
    const lastBlock = clonedBlocks.pop();
    const tailType = (0, import_blocks6.getBlockType)(tail.name);
    if (clonedBlocks.length) {
      output.push(...clonedBlocks);
    }
    if (lastBlock) {
      const lastBlocks = tailType.merge && tailType.name === lastBlock.name ? [lastBlock] : (0, import_blocks6.switchToBlockType)(lastBlock, tailType.name);
      if (lastBlocks?.length) {
        const last3 = lastBlocks.pop();
        output.push({
          ...tail,
          attributes: {
            ...tail.attributes,
            ...tailType.merge(last3.attributes, tail.attributes)
          }
        });
        output.push(...lastBlocks);
        selection2 = {
          clientId: tail.clientId,
          attributeKey: attributeKeyB,
          offset: (0, import_rich_text3.create)({
            html: last3.attributes[attributeKeyB]
          }).text.length
        };
      } else {
        output.push(lastBlock);
        if (!(0, import_blocks6.isUnmodifiedBlock)(tail)) {
          output.push(tail);
        }
      }
    } else if (!(0, import_blocks6.isUnmodifiedBlock)(tail)) {
      output.push(tail);
    }
    registry.batch(() => {
      dispatch.replaceBlocks(
        select2.getSelectedBlockClientIds(),
        output,
        output.length - 1,
        0
      );
      if (selection2) {
        dispatch.selectionChange(
          selection2.clientId,
          selection2.attributeKey,
          selection2.offset,
          selection2.offset
        );
      }
    });
  };
  var __unstableExpandSelection = () => ({ select: select2, dispatch }) => {
    const selectionAnchor = select2.getSelectionStart();
    const selectionFocus = select2.getSelectionEnd();
    dispatch.selectionChange({
      start: { clientId: selectionAnchor.clientId },
      end: { clientId: selectionFocus.clientId }
    });
  };
  var mergeBlocks = (firstBlockClientId, secondBlockClientId) => ({ registry, select: select2, dispatch }) => {
    const clientIdA = firstBlockClientId;
    const clientIdB = secondBlockClientId;
    const blockA = select2.getBlock(clientIdA);
    const blockAType = (0, import_blocks6.getBlockType)(blockA.name);
    if (!blockAType || select2.getBlockEditingMode(clientIdA) === "disabled" || select2.getBlockEditingMode(clientIdB) === "disabled") {
      return;
    }
    const blockB = select2.getBlock(clientIdB);
    if (!blockAType.merge && (0, import_blocks6.getBlockSupport)(blockA.name, "__experimentalOnMerge")) {
      const blocksWithTheSameType2 = (0, import_blocks6.switchToBlockType)(
        blockB,
        blockAType.name
      );
      if (blocksWithTheSameType2?.length !== 1) {
        dispatch.selectBlock(blockA.clientId);
        return;
      }
      const [blockWithSameType] = blocksWithTheSameType2;
      if (blockWithSameType.innerBlocks.length < 1) {
        dispatch.selectBlock(blockA.clientId);
        return;
      }
      registry.batch(() => {
        dispatch.insertBlocks(
          blockWithSameType.innerBlocks,
          void 0,
          clientIdA
        );
        dispatch.removeBlock(clientIdB);
        dispatch.selectBlock(
          blockWithSameType.innerBlocks[0].clientId
        );
        const nextBlockClientId = select2.getNextBlockClientId(clientIdA);
        if (nextBlockClientId && select2.getBlockName(clientIdA) === select2.getBlockName(nextBlockClientId)) {
          const rootAttributes = select2.getBlockAttributes(clientIdA);
          const previousRootAttributes = select2.getBlockAttributes(nextBlockClientId);
          if (Object.keys(rootAttributes).every(
            (key) => rootAttributes[key] === previousRootAttributes[key]
          )) {
            dispatch.moveBlocksToPosition(
              select2.getBlockOrder(nextBlockClientId),
              nextBlockClientId,
              clientIdA
            );
            dispatch.removeBlock(nextBlockClientId, false);
          }
        }
      });
      return;
    }
    if ((0, import_blocks6.isUnmodifiedDefaultBlock)(blockA)) {
      dispatch.removeBlock(
        clientIdA,
        select2.isBlockSelected(clientIdA)
      );
      return;
    }
    if ((0, import_blocks6.isUnmodifiedDefaultBlock)(blockB)) {
      dispatch.removeBlock(
        clientIdB,
        select2.isBlockSelected(clientIdB)
      );
      return;
    }
    if (!blockAType.merge) {
      if ((0, import_blocks6.isUnmodifiedBlock)(blockB, "content")) {
        dispatch.removeBlock(
          clientIdB,
          select2.isBlockSelected(clientIdB)
        );
      } else {
        dispatch.selectBlock(blockA.clientId);
      }
      return;
    }
    const blockBType = (0, import_blocks6.getBlockType)(blockB.name);
    const { clientId, attributeKey, offset } = select2.getSelectionStart();
    const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
    const attributeDefinition = selectedBlockType.attributes[attributeKey];
    const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== void 0 && offset !== void 0 && // We cannot restore text selection if the RichText identifier
    // is not a defined block attribute key. This can be the case if the
    // fallback instance ID is used to store selection (and no RichText
    // identifier is set), or when the identifier is wrong.
    !!attributeDefinition;
    if (!attributeDefinition) {
      if (typeof attributeKey === "number") {
        window.console.error(
          `RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`
        );
      } else {
        window.console.error(
          "The RichText identifier prop does not match any attributes defined by the block."
        );
      }
    }
    const cloneA = (0, import_blocks6.cloneBlock)(blockA);
    const cloneB = (0, import_blocks6.cloneBlock)(blockB);
    if (canRestoreTextSelection) {
      const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
      const html = selectedBlock.attributes[attributeKey];
      const value = (0, import_rich_text3.insert)(
        (0, import_rich_text3.create)({ html }),
        START_OF_SELECTED_AREA,
        offset,
        offset
      );
      selectedBlock.attributes[attributeKey] = (0, import_rich_text3.toHTMLString)({
        value
      });
    }
    const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : (0, import_blocks6.switchToBlockType)(cloneB, blockA.name);
    if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
      return;
    }
    const updatedAttributes = blockAType.merge(
      cloneA.attributes,
      blocksWithTheSameType[0].attributes
    );
    if (canRestoreTextSelection) {
      const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
      const convertedHtml = updatedAttributes[newAttributeKey];
      const convertedValue = (0, import_rich_text3.create)({ html: convertedHtml });
      const newOffset = convertedValue.text.indexOf(
        START_OF_SELECTED_AREA
      );
      const newValue = (0, import_rich_text3.remove)(convertedValue, newOffset, newOffset + 1);
      const newHtml = (0, import_rich_text3.toHTMLString)({ value: newValue });
      updatedAttributes[newAttributeKey] = newHtml;
      dispatch.selectionChange(
        blockA.clientId,
        newAttributeKey,
        newOffset,
        newOffset
      );
    }
    dispatch.replaceBlocks(
      [blockA.clientId, blockB.clientId],
      [
        {
          ...blockA,
          attributes: {
            ...blockA.attributes,
            ...updatedAttributes
          }
        },
        ...blocksWithTheSameType.slice(1)
      ],
      0
      // If we don't pass the `indexToSelect` it will default to the last block.
    );
  };
  var removeBlocks = (clientIds, selectPrevious = true) => privateRemoveBlocks(clientIds, selectPrevious);
  function removeBlock(clientId, selectPrevious) {
    return removeBlocks([clientId], selectPrevious);
  }
  function replaceInnerBlocks(rootClientId, blocks2, updateSelection = false, initialPosition2 = 0) {
    return {
      type: "REPLACE_INNER_BLOCKS",
      rootClientId,
      blocks: blocks2,
      updateSelection,
      initialPosition: updateSelection ? initialPosition2 : null,
      time: Date.now()
    };
  }
  function toggleBlockMode(clientId) {
    return {
      type: "TOGGLE_BLOCK_MODE",
      clientId
    };
  }
  function startTyping() {
    return {
      type: "START_TYPING"
    };
  }
  function stopTyping() {
    return {
      type: "STOP_TYPING"
    };
  }
  function startDraggingBlocks(clientIds = []) {
    return {
      type: "START_DRAGGING_BLOCKS",
      clientIds
    };
  }
  function stopDraggingBlocks() {
    return {
      type: "STOP_DRAGGING_BLOCKS"
    };
  }
  function enterFormattedText() {
    (0, import_deprecated4.default)('wp.data.dispatch( "core/block-editor" ).enterFormattedText', {
      since: "6.1",
      version: "6.3"
    });
    return {
      type: "DO_NOTHING"
    };
  }
  function exitFormattedText() {
    (0, import_deprecated4.default)('wp.data.dispatch( "core/block-editor" ).exitFormattedText', {
      since: "6.1",
      version: "6.3"
    });
    return {
      type: "DO_NOTHING"
    };
  }
  function selectionChange(clientId, attributeKey, startOffset, endOffset) {
    if (typeof clientId === "string") {
      return {
        type: "SELECTION_CHANGE",
        clientId,
        attributeKey,
        startOffset,
        endOffset
      };
    }
    return { type: "SELECTION_CHANGE", ...clientId };
  }
  var insertDefaultBlock = (attributes, rootClientId, index) => ({ dispatch }) => {
    const defaultBlockName = (0, import_blocks6.getDefaultBlockName)();
    if (!defaultBlockName) {
      return;
    }
    const block = (0, import_blocks6.createBlock)(defaultBlockName, attributes);
    return dispatch.insertBlock(block, index, rootClientId);
  };
  function updateBlockListSettings(clientId, settings2) {
    return {
      type: "UPDATE_BLOCK_LIST_SETTINGS",
      clientId,
      settings: settings2
    };
  }
  function updateSettings(settings2) {
    return __experimentalUpdateSettings(settings2, {
      stripExperimentalSettings: true
    });
  }
  function __unstableSaveReusableBlock(id, updatedId) {
    return {
      type: "SAVE_REUSABLE_BLOCK_SUCCESS",
      id,
      updatedId
    };
  }
  function __unstableMarkLastChangeAsPersistent() {
    return { type: "MARK_LAST_CHANGE_AS_PERSISTENT" };
  }
  function __unstableMarkNextChangeAsNotPersistent() {
    return { type: "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT" };
  }
  var __unstableMarkAutomaticChange = () => ({ dispatch }) => {
    dispatch({ type: "MARK_AUTOMATIC_CHANGE" });
    const { requestIdleCallback = (cb) => setTimeout(cb, 100) } = window;
    requestIdleCallback(() => {
      dispatch({ type: "MARK_AUTOMATIC_CHANGE_FINAL" });
    });
  };
  var __unstableSetEditorMode = (mode2) => ({ registry }) => {
    registry.dispatch(import_preferences.store).set("core", "editorTool", mode2);
    if (mode2 === "navigation") {
      (0, import_a11y3.speak)((0, import_i18n4.__)("You are currently in Write mode."));
    } else if (mode2 === "edit") {
      (0, import_a11y3.speak)((0, import_i18n4.__)("You are currently in Design mode."));
    }
  };
  function setBlockMovingClientId() {
    (0, import_deprecated4.default)(
      'wp.data.dispatch( "core/block-editor" ).setBlockMovingClientId',
      {
        since: "6.7",
        hint: "Block moving mode feature has been removed"
      }
    );
    return {
      type: "DO_NOTHING"
    };
  }
  var duplicateBlocks = (clientIds, updateSelection = true) => ({ select: select2, dispatch }) => {
    if (!clientIds || !clientIds.length) {
      return;
    }
    const blocks2 = select2.getBlocksByClientId(clientIds);
    if (blocks2.some((block) => !block)) {
      return;
    }
    const blockNames = blocks2.map((block) => block.name);
    if (blockNames.some(
      (blockName) => !(0, import_blocks6.hasBlockSupport)(blockName, "multiple", true)
    )) {
      return;
    }
    const rootClientId = select2.getBlockRootClientId(clientIds[0]);
    const clientIdsArray = castArray2(clientIds);
    const lastSelectedIndex = select2.getBlockIndex(
      clientIdsArray[clientIdsArray.length - 1]
    );
    const clonedBlocks = blocks2.map(
      (block) => (0, import_blocks6.__experimentalCloneSanitizedBlock)(block)
    );
    dispatch.insertBlocks(
      clonedBlocks,
      lastSelectedIndex + 1,
      rootClientId,
      updateSelection
    );
    if (clonedBlocks.length > 1 && updateSelection) {
      dispatch.multiSelect(
        clonedBlocks[0].clientId,
        clonedBlocks[clonedBlocks.length - 1].clientId
      );
    }
    return clonedBlocks.map((block) => block.clientId);
  };
  var insertBeforeBlock = (clientId) => ({ select: select2, dispatch }) => {
    if (!clientId) {
      return;
    }
    const rootClientId = select2.getBlockRootClientId(clientId);
    const isLocked = select2.getTemplateLock(rootClientId);
    if (isLocked) {
      return;
    }
    const blockIndex = select2.getBlockIndex(clientId);
    const directInsertBlock = rootClientId ? select2.getDirectInsertBlock(rootClientId) : null;
    if (!directInsertBlock) {
      return dispatch.insertDefaultBlock({}, rootClientId, blockIndex);
    }
    const copiedAttributes = {};
    if (directInsertBlock.attributesToCopy) {
      const attributes = select2.getBlockAttributes(clientId);
      directInsertBlock.attributesToCopy.forEach((key) => {
        if (attributes[key]) {
          copiedAttributes[key] = attributes[key];
        }
      });
    }
    const block = (0, import_blocks6.createBlock)(directInsertBlock.name, {
      ...directInsertBlock.attributes,
      ...copiedAttributes
    });
    return dispatch.insertBlock(block, blockIndex, rootClientId);
  };
  var insertAfterBlock = (clientId) => ({ select: select2, dispatch }) => {
    if (!clientId) {
      return;
    }
    const rootClientId = select2.getBlockRootClientId(clientId);
    const isLocked = select2.getTemplateLock(rootClientId);
    if (isLocked) {
      return;
    }
    const blockIndex = select2.getBlockIndex(clientId);
    const directInsertBlock = rootClientId ? select2.getDirectInsertBlock(rootClientId) : null;
    if (!directInsertBlock) {
      return dispatch.insertDefaultBlock(
        {},
        rootClientId,
        blockIndex + 1
      );
    }
    const copiedAttributes = {};
    if (directInsertBlock.attributesToCopy) {
      const attributes = select2.getBlockAttributes(clientId);
      directInsertBlock.attributesToCopy.forEach((key) => {
        if (attributes[key]) {
          copiedAttributes[key] = attributes[key];
        }
      });
    }
    const block = (0, import_blocks6.createBlock)(directInsertBlock.name, {
      ...directInsertBlock.attributes,
      ...copiedAttributes
    });
    return dispatch.insertBlock(block, blockIndex + 1, rootClientId);
  };
  function toggleBlockHighlight(clientId, isHighlighted) {
    return {
      type: "TOGGLE_BLOCK_HIGHLIGHT",
      clientId,
      isHighlighted
    };
  }
  var flashBlock = (clientId, timeout = 150) => async ({ dispatch }) => {
    dispatch(toggleBlockHighlight(clientId, true));
    await new Promise((resolve) => setTimeout(resolve, timeout));
    dispatch(toggleBlockHighlight(clientId, false));
  };
  function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
    return {
      type: "SET_HAS_CONTROLLED_INNER_BLOCKS",
      hasControlledInnerBlocks,
      clientId
    };
  }
  function setBlockVisibility(updates) {
    return {
      type: "SET_BLOCK_VISIBILITY",
      updates
    };
  }
  function __unstableSetTemporarilyEditingAsBlocks(temporarilyEditingAsBlocks2, focusModeToRevert) {
    return {
      type: "SET_TEMPORARILY_EDITING_AS_BLOCKS",
      temporarilyEditingAsBlocks: temporarilyEditingAsBlocks2,
      focusModeToRevert
    };
  }
  var registerInserterMediaCategory = (category) => ({ select: select2, dispatch }) => {
    if (!category || typeof category !== "object") {
      console.error(
        "Category should be an `InserterMediaCategory` object."
      );
      return;
    }
    if (!category.name) {
      console.error(
        "Category should have a `name` that should be unique among all media categories."
      );
      return;
    }
    if (!category.labels?.name) {
      console.error("Category should have a `labels.name`.");
      return;
    }
    if (!["image", "audio", "video"].includes(category.mediaType)) {
      console.error(
        "Category should have `mediaType` property that is one of `image|audio|video`."
      );
      return;
    }
    if (!category.fetch || typeof category.fetch !== "function") {
      console.error(
        "Category should have a `fetch` function defined with the following signature `(InserterMediaRequest) => Promise<InserterMediaItem[]>`."
      );
      return;
    }
    const registeredInserterMediaCategories2 = select2.getRegisteredInserterMediaCategories();
    if (registeredInserterMediaCategories2.some(
      ({ name }) => name === category.name
    )) {
      console.error(
        `A category is already registered with the same name: "${category.name}".`
      );
      return;
    }
    if (registeredInserterMediaCategories2.some(
      ({ labels: { name } = {} }) => name === category.labels?.name
    )) {
      console.error(
        `A category is already registered with the same labels.name: "${category.labels.name}".`
      );
      return;
    }
    dispatch({
      type: "REGISTER_INSERTER_MEDIA_CATEGORY",
      category: { ...category, isExternalResource: true }
    });
  };
  function setBlockEditingMode(clientId = "", mode2) {
    return {
      type: "SET_BLOCK_EDITING_MODE",
      clientId,
      mode: mode2
    };
  }
  function unsetBlockEditingMode(clientId = "") {
    return {
      type: "UNSET_BLOCK_EDITING_MODE",
      clientId
    };
  }

  // packages/block-editor/build-module/store/index.js
  var storeConfig = {
    reducer: reducer_default,
    selectors: selectors_exports,
    actions: actions_exports
  };
  var store = (0, import_data4.createReduxStore)(STORE_NAME, {
    ...storeConfig,
    persist: ["preferences"]
  });
  var registeredStore = (0, import_data4.registerStore)(STORE_NAME, {
    ...storeConfig,
    persist: ["preferences"]
  });
  unlock(registeredStore).registerPrivateActions(private_actions_exports);
  unlock(registeredStore).registerPrivateSelectors(private_selectors_exports);
  unlock(store).registerPrivateActions(private_actions_exports);
  unlock(store).registerPrivateSelectors(private_selectors_exports);

  // packages/block-editor/build-module/utils/block-bindings.js
  var DEFAULT_ATTRIBUTE = "__default";
  var PATTERN_OVERRIDES_SOURCE = "core/pattern-overrides";
  function isObjectEmpty(object) {
    return !object || Object.keys(object).length === 0;
  }
  function hasPatternOverridesDefaultBinding(bindings) {
    return bindings?.[DEFAULT_ATTRIBUTE]?.source === PATTERN_OVERRIDES_SOURCE;
  }
  function replacePatternOverridesDefaultBinding(bindings, supportedAttributes) {
    if (hasPatternOverridesDefaultBinding(bindings)) {
      const bindingsWithDefaults = {};
      for (const attributeName of supportedAttributes) {
        const bindingSource = bindings[attributeName] ? bindings[attributeName] : { source: PATTERN_OVERRIDES_SOURCE };
        bindingsWithDefaults[attributeName] = bindingSource;
      }
      return bindingsWithDefaults;
    }
    return bindings;
  }
  function useBlockBindingsUtils(clientId) {
    const { clientId: contextClientId } = useBlockEditContext();
    const blockClientId = clientId || contextClientId;
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data5.useDispatch)(store);
    const { getBlockAttributes: getBlockAttributes3 } = (0, import_data5.useRegistry)().select(store);
    const updateBlockBindings = (bindings) => {
      const { metadata: { bindings: currentBindings, ...metadata } = {} } = getBlockAttributes3(blockClientId);
      const newBindings = { ...currentBindings };
      Object.entries(bindings).forEach(([attribute, binding]) => {
        if (!binding && newBindings[attribute]) {
          delete newBindings[attribute];
          return;
        }
        newBindings[attribute] = binding;
      });
      const newMetadata = {
        ...metadata,
        bindings: newBindings
      };
      if (isObjectEmpty(newMetadata.bindings)) {
        delete newMetadata.bindings;
      }
      updateBlockAttributes2(blockClientId, {
        metadata: isObjectEmpty(newMetadata) ? void 0 : newMetadata
      });
    };
    const removeAllBlockBindings = () => {
      const { metadata: { bindings, ...metadata } = {} } = getBlockAttributes3(blockClientId);
      updateBlockAttributes2(blockClientId, {
        metadata: isObjectEmpty(metadata) ? void 0 : metadata
      });
    };
    return { updateBlockBindings, removeAllBlockBindings };
  }

  // packages/block-editor/build-module/components/block-list/private-block-context.js
  var import_element6 = __toESM(require_element());
  var PrivateBlockContext = (0, import_element6.createContext)({});
  PrivateBlockContext.displayName = "PrivateBlockContext";

  // packages/block-editor/build-module/components/block-edit/edit.js
  var DEFAULT_BLOCK_CONTEXT = {};
  var Edit = (props) => {
    const { name } = props;
    const blockType = (0, import_blocks7.getBlockType)(name);
    if (!blockType) {
      return null;
    }
    const Component7 = blockType.edit || blockType.save;
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Component7, { ...props });
  };
  var EditWithFilters = (0, import_components2.withFilters)("editor.BlockEdit")(Edit);
  var EditWithGeneratedProps = (props) => {
    const { name, clientId, attributes, setAttributes } = props;
    const registry = (0, import_data6.useRegistry)();
    const blockType = (0, import_blocks7.getBlockType)(name);
    const blockContext = (0, import_element7.useContext)(block_context_default);
    const registeredSources = (0, import_data6.useSelect)(
      (select2) => unlock(select2(import_blocks7.store)).getAllBlockBindingsSources(),
      []
    );
    const { bindableAttributes } = (0, import_element7.useContext)(PrivateBlockContext);
    const { blockBindings, context, hasPatternOverrides } = (0, import_element7.useMemo)(() => {
      const computedContext = blockType?.usesContext ? Object.fromEntries(
        Object.entries(blockContext).filter(
          ([key]) => blockType.usesContext.includes(key)
        )
      ) : DEFAULT_BLOCK_CONTEXT;
      if (attributes?.metadata?.bindings) {
        Object.values(attributes?.metadata?.bindings || {}).forEach(
          (binding) => {
            registeredSources[binding?.source]?.usesContext?.forEach(
              (key) => {
                computedContext[key] = blockContext[key];
              }
            );
          }
        );
      }
      return {
        blockBindings: replacePatternOverridesDefaultBinding(
          attributes?.metadata?.bindings,
          bindableAttributes
        ),
        context: computedContext,
        hasPatternOverrides: hasPatternOverridesDefaultBinding(
          attributes?.metadata?.bindings
        )
      };
    }, [
      name,
      blockType?.usesContext,
      blockContext,
      attributes?.metadata?.bindings,
      registeredSources
    ]);
    const computedAttributes = (0, import_data6.useSelect)(
      (select2) => {
        if (!blockBindings) {
          return attributes;
        }
        const attributesFromSources = {};
        const blockBindingsBySource = /* @__PURE__ */ new Map();
        for (const [attributeName, binding] of Object.entries(
          blockBindings
        )) {
          const { source: sourceName, args: sourceArgs } = binding;
          const source = registeredSources[sourceName];
          if (!source || !bindableAttributes?.includes(attributeName)) {
            continue;
          }
          blockBindingsBySource.set(source, {
            ...blockBindingsBySource.get(source),
            [attributeName]: {
              args: sourceArgs
            }
          });
        }
        if (blockBindingsBySource.size) {
          for (const [source, bindings] of blockBindingsBySource) {
            let values = {};
            if (!source.getValues) {
              Object.keys(bindings).forEach((attr) => {
                values[attr] = source.label;
              });
            } else {
              values = source.getValues({
                select: select2,
                context,
                clientId,
                bindings
              });
            }
            for (const [attributeName, value] of Object.entries(
              values
            )) {
              if (attributeName === "url" && (!value || !isURLLike(value))) {
                attributesFromSources[attributeName] = null;
              } else {
                attributesFromSources[attributeName] = value;
              }
            }
          }
        }
        return {
          ...attributes,
          ...attributesFromSources
        };
      },
      [
        attributes,
        bindableAttributes,
        blockBindings,
        clientId,
        context,
        name,
        registeredSources
      ]
    );
    const setBoundAttributes = (0, import_element7.useCallback)(
      (nextAttributes) => {
        if (!blockBindings) {
          setAttributes(nextAttributes);
          return;
        }
        registry.batch(() => {
          const keptAttributes = { ...nextAttributes };
          const blockBindingsBySource = /* @__PURE__ */ new Map();
          for (const [attributeName, newValue] of Object.entries(
            keptAttributes
          )) {
            if (!blockBindings[attributeName] || !bindableAttributes?.includes(attributeName)) {
              continue;
            }
            const binding = blockBindings[attributeName];
            const source = registeredSources[binding?.source];
            if (!source?.setValues) {
              continue;
            }
            blockBindingsBySource.set(source, {
              ...blockBindingsBySource.get(source),
              [attributeName]: {
                args: binding.args,
                newValue
              }
            });
            delete keptAttributes[attributeName];
          }
          if (blockBindingsBySource.size) {
            for (const [
              source,
              bindings
            ] of blockBindingsBySource) {
              source.setValues({
                select: registry.select,
                dispatch: registry.dispatch,
                context,
                clientId,
                bindings
              });
            }
          }
          const hasParentPattern = !!context["pattern/overrides"];
          if (
            // Don't update non-connected attributes if the block is using pattern overrides
            // and the editing is happening while overriding the pattern (not editing the original).
            !(hasPatternOverrides && hasParentPattern) && Object.keys(keptAttributes).length
          ) {
            if (hasPatternOverrides) {
              delete keptAttributes.caption;
              delete keptAttributes.href;
            }
            setAttributes(keptAttributes);
          }
        });
      },
      [
        bindableAttributes,
        blockBindings,
        clientId,
        context,
        hasPatternOverrides,
        setAttributes,
        registeredSources,
        name,
        registry
      ]
    );
    if (!blockType) {
      return null;
    }
    if (blockType.apiVersion > 1) {
      return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
        EditWithFilters,
        {
          ...props,
          attributes: computedAttributes,
          context,
          setAttributes: setBoundAttributes
        }
      );
    }
    const generatedClassName = (0, import_blocks7.hasBlockSupport)(blockType, "className", true) ? (0, import_blocks7.getBlockDefaultClassName)(name) : null;
    const className = clsx_default(
      generatedClassName,
      attributes?.className,
      props.className
    );
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
      EditWithFilters,
      {
        ...props,
        attributes: computedAttributes,
        className,
        context,
        setAttributes: setBoundAttributes
      }
    );
  };
  var edit_default = EditWithGeneratedProps;

  // packages/block-editor/build-module/components/block-edit/multiple-usage-warning.js
  var import_jsx_runtime112 = __toESM(require_jsx_runtime());
  var import_blocks8 = __toESM(require_blocks());
  var import_components4 = __toESM(require_components());
  var import_data7 = __toESM(require_data());
  var import_i18n6 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/warning/index.js
  var import_jsx_runtime111 = __toESM(require_jsx_runtime());
  var import_components3 = __toESM(require_components());
  var import_i18n5 = __toESM(require_i18n());
  function Warning({ className, actions, children, secondaryActions }) {
    return /* @__PURE__ */ (0, import_jsx_runtime111.jsx)("div", { style: { display: "contents", all: "initial" }, children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)("div", { className: clsx_default(className, "block-editor-warning"), children: /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)("div", { className: "block-editor-warning__contents", children: [
      /* @__PURE__ */ (0, import_jsx_runtime111.jsx)("p", { className: "block-editor-warning__message", children }),
      (actions?.length > 0 || secondaryActions) && /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)("div", { className: "block-editor-warning__actions", children: [
        actions?.length > 0 && actions.map((action, i2) => /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
          "span",
          {
            className: "block-editor-warning__action",
            children: action
          },
          i2
        )),
        secondaryActions && /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
          import_components3.DropdownMenu,
          {
            className: "block-editor-warning__secondary",
            icon: more_vertical_default,
            label: (0, import_i18n5.__)("More options"),
            popoverProps: {
              placement: "bottom-end",
              className: "block-editor-warning__dropdown"
            },
            noIcons: true,
            children: () => /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(import_components3.MenuGroup, { children: secondaryActions.map(
              (item, pos) => /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
                import_components3.MenuItem,
                {
                  onClick: item.onClick,
                  children: item.title
                },
                pos
              )
            ) })
          }
        )
      ] })
    ] }) }) });
  }
  var warning_default = Warning;

  // packages/block-editor/build-module/components/block-edit/multiple-usage-warning.js
  function MultipleUsageWarning({
    originalBlockClientId,
    name,
    onReplace
  }) {
    const { selectBlock: selectBlock2 } = (0, import_data7.useDispatch)(store);
    const blockType = (0, import_blocks8.getBlockType)(name);
    return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)(
      warning_default,
      {
        actions: [
          /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
            import_components4.Button,
            {
              __next40pxDefaultSize: true,
              variant: "secondary",
              onClick: () => selectBlock2(originalBlockClientId),
              children: (0, import_i18n6.__)("Find original")
            },
            "find-original"
          ),
          /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
            import_components4.Button,
            {
              __next40pxDefaultSize: true,
              variant: "secondary",
              onClick: () => onReplace([]),
              children: (0, import_i18n6.__)("Remove")
            },
            "remove"
          )
        ],
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)("strong", { children: [
            blockType?.title,
            ": "
          ] }),
          (0, import_i18n6.__)("This block can only be used once.")
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/block-edit/index.js
  function BlockEdit({
    mayDisplayControls,
    mayDisplayParentControls,
    blockEditingMode,
    isPreviewMode,
    // The remaining props are passed through the BlockEdit filters and are thus
    // public API!
    ...props
  }) {
    const {
      name,
      isSelected,
      clientId,
      attributes = {},
      __unstableLayoutClassNames
    } = props;
    const { layout = null, metadata = {} } = attributes;
    const { bindings } = metadata;
    const layoutSupport = (0, import_blocks9.hasBlockSupport)(name, "layout", false) || (0, import_blocks9.hasBlockSupport)(name, "__experimentalLayout", false);
    const { originalBlockClientId } = (0, import_element8.useContext)(PrivateBlockContext);
    return /* @__PURE__ */ (0, import_jsx_runtime113.jsxs)(
      Provider,
      {
        value: (0, import_element8.useMemo)(
          () => ({
            name,
            isSelected,
            clientId,
            layout: layoutSupport ? layout : null,
            __unstableLayoutClassNames,
            // We use symbols in favour of an __unstable prefix to avoid
            // usage outside of the package (this context is exposed).
            [mayDisplayControlsKey]: mayDisplayControls,
            [mayDisplayParentControlsKey]: mayDisplayParentControls,
            [blockEditingModeKey]: blockEditingMode,
            [blockBindingsKey]: bindings,
            [isPreviewModeKey]: isPreviewMode
          }),
          [
            name,
            isSelected,
            clientId,
            layoutSupport,
            layout,
            __unstableLayoutClassNames,
            mayDisplayControls,
            mayDisplayParentControls,
            blockEditingMode,
            bindings,
            isPreviewMode
          ]
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime113.jsx)(edit_default, { ...props }),
          originalBlockClientId && /* @__PURE__ */ (0, import_jsx_runtime113.jsx)(
            MultipleUsageWarning,
            {
              originalBlockClientId,
              name,
              onReplace: props.onReplace
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/use-settings/index.js
  function useSettings(...paths) {
    const { clientId = null } = useBlockEditContext();
    return (0, import_data8.useSelect)(
      (select2) => unlock(select2(store)).getBlockSettings(
        clientId,
        ...paths
      ),
      [clientId, ...paths]
    );
  }
  function useSetting(path) {
    (0, import_deprecated5.default)("wp.blockEditor.useSetting", {
      since: "6.5",
      alternative: "wp.blockEditor.useSettings",
      note: "The new useSettings function can retrieve multiple settings at once, with better performance."
    });
    const [value] = useSettings(path);
    return value;
  }

  // packages/block-editor/build-module/components/colors/with-colors.js
  var { kebabCase: kebabCase2 } = unlock(import_components5.privateApis);
  var upperFirst = ([firstLetter, ...rest]) => firstLetter.toUpperCase() + rest.join("");
  var withCustomColorPalette = (colorsArray) => (0, import_compose2.createHigherOrderComponent)(
    (WrappedComponent) => (props) => /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(WrappedComponent, { ...props, colors: colorsArray }),
    "withCustomColorPalette"
  );
  var withEditorColorPalette = () => (0, import_compose2.createHigherOrderComponent)(
    (WrappedComponent) => (props) => {
      const [userPalette, themePalette, defaultPalette] = useSettings(
        "color.palette.custom",
        "color.palette.theme",
        "color.palette.default"
      );
      const allColors = (0, import_element9.useMemo)(
        () => [
          ...userPalette || [],
          ...themePalette || [],
          ...defaultPalette || []
        ],
        [userPalette, themePalette, defaultPalette]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(WrappedComponent, { ...props, colors: allColors });
    },
    "withEditorColorPalette"
  );
  function createColorHOC(colorTypes, withColorPalette) {
    const colorMap = colorTypes.reduce((colorObject, colorType) => {
      return {
        ...colorObject,
        ...typeof colorType === "string" ? { [colorType]: kebabCase2(colorType) } : colorType
      };
    }, {});
    return (0, import_compose2.compose)([
      withColorPalette,
      (WrappedComponent) => {
        return class extends import_element9.Component {
          constructor(props) {
            super(props);
            this.setters = this.createSetters();
            this.colorUtils = {
              getMostReadableColor: this.getMostReadableColor.bind(this)
            };
            this.state = {};
          }
          getMostReadableColor(colorValue) {
            const { colors: colors2 } = this.props;
            return getMostReadableColor(colors2, colorValue);
          }
          createSetters() {
            return Object.keys(colorMap).reduce(
              (settersAccumulator, colorAttributeName) => {
                const upperFirstColorAttributeName = upperFirst(colorAttributeName);
                const customColorAttributeName = `custom${upperFirstColorAttributeName}`;
                settersAccumulator[`set${upperFirstColorAttributeName}`] = this.createSetColor(
                  colorAttributeName,
                  customColorAttributeName
                );
                return settersAccumulator;
              },
              {}
            );
          }
          createSetColor(colorAttributeName, customColorAttributeName) {
            return (colorValue) => {
              const colorObject = getColorObjectByColorValue(
                this.props.colors,
                colorValue
              );
              this.props.setAttributes({
                [colorAttributeName]: colorObject && colorObject.slug ? colorObject.slug : void 0,
                [customColorAttributeName]: colorObject && colorObject.slug ? void 0 : colorValue
              });
            };
          }
          static getDerivedStateFromProps({ attributes, colors: colors2 }, previousState) {
            return Object.entries(colorMap).reduce(
              (newState, [colorAttributeName, colorContext]) => {
                const colorObject = getColorObjectByAttributeValues(
                  colors2,
                  attributes[colorAttributeName],
                  attributes[`custom${upperFirst(
                    colorAttributeName
                  )}`]
                );
                const previousColorObject = previousState[colorAttributeName];
                const previousColor = previousColorObject?.color;
                if (previousColor === colorObject.color && previousColorObject) {
                  newState[colorAttributeName] = previousColorObject;
                } else {
                  newState[colorAttributeName] = {
                    ...colorObject,
                    class: getColorClassName(
                      colorContext,
                      colorObject.slug
                    )
                  };
                }
                return newState;
              },
              {}
            );
          }
          render() {
            return /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(
              WrappedComponent,
              {
                ...{
                  ...this.props,
                  colors: void 0,
                  ...this.state,
                  ...this.setters,
                  colorUtils: this.colorUtils
                }
              }
            );
          }
        };
      }
    ]);
  }
  function createCustomColorsHOC(colorsArray) {
    return (...colorTypes) => {
      const withColorPalette = withCustomColorPalette(colorsArray);
      return (0, import_compose2.createHigherOrderComponent)(
        createColorHOC(colorTypes, withColorPalette),
        "withCustomColors"
      );
    };
  }
  function withColors(...colorTypes) {
    const withColorPalette = withEditorColorPalette();
    return (0, import_compose2.createHigherOrderComponent)(
      createColorHOC(colorTypes, withColorPalette),
      "withColors"
    );
  }

  // packages/block-editor/build-module/components/gradients/use-gradient.js
  var import_element10 = __toESM(require_element());
  var import_data9 = __toESM(require_data());
  function __experimentalGetGradientClass(gradientSlug) {
    if (!gradientSlug) {
      return void 0;
    }
    return `has-${gradientSlug}-gradient-background`;
  }
  function getGradientValueBySlug(gradients, slug) {
    const gradient = gradients?.find((g2) => g2.slug === slug);
    return gradient && gradient.gradient;
  }
  function __experimentalGetGradientObjectByGradientValue(gradients, value) {
    const gradient = gradients?.find((g2) => g2.gradient === value);
    return gradient;
  }
  function getGradientSlugByValue(gradients, value) {
    const gradient = __experimentalGetGradientObjectByGradientValue(
      gradients,
      value
    );
    return gradient && gradient.slug;
  }
  function __experimentalUseGradient({
    gradientAttribute = "gradient",
    customGradientAttribute = "customGradient"
  } = {}) {
    const { clientId } = useBlockEditContext();
    const [
      userGradientPalette,
      themeGradientPalette,
      defaultGradientPalette
    ] = useSettings(
      "color.gradients.custom",
      "color.gradients.theme",
      "color.gradients.default"
    );
    const allGradients = (0, import_element10.useMemo)(
      () => [
        ...userGradientPalette || [],
        ...themeGradientPalette || [],
        ...defaultGradientPalette || []
      ],
      [userGradientPalette, themeGradientPalette, defaultGradientPalette]
    );
    const { gradient, customGradient } = (0, import_data9.useSelect)(
      (select2) => {
        const { getBlockAttributes: getBlockAttributes3 } = select2(store);
        const attributes = getBlockAttributes3(clientId) || {};
        return {
          customGradient: attributes[customGradientAttribute],
          gradient: attributes[gradientAttribute]
        };
      },
      [clientId, gradientAttribute, customGradientAttribute]
    );
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data9.useDispatch)(store);
    const setGradient = (0, import_element10.useCallback)(
      (newGradientValue) => {
        const slug = getGradientSlugByValue(
          allGradients,
          newGradientValue
        );
        if (slug) {
          updateBlockAttributes2(clientId, {
            [gradientAttribute]: slug,
            [customGradientAttribute]: void 0
          });
          return;
        }
        updateBlockAttributes2(clientId, {
          [gradientAttribute]: void 0,
          [customGradientAttribute]: newGradientValue
        });
      },
      [allGradients, clientId, updateBlockAttributes2]
    );
    const gradientClass = __experimentalGetGradientClass(gradient);
    let gradientValue;
    if (gradient) {
      gradientValue = getGradientValueBySlug(allGradients, gradient);
    } else {
      gradientValue = customGradient;
    }
    return { gradientClass, gradientValue, setGradient };
  }

  // packages/block-editor/build-module/components/font-sizes/utils.js
  var import_components6 = __toESM(require_components());
  var { kebabCase: kebabCase3 } = unlock(import_components6.privateApis);
  var getFontSize = (fontSizes, fontSizeAttribute, customFontSizeAttribute) => {
    if (fontSizeAttribute) {
      const fontSizeObject = fontSizes?.find(
        ({ slug }) => slug === fontSizeAttribute
      );
      if (fontSizeObject) {
        return fontSizeObject;
      }
    }
    return {
      size: customFontSizeAttribute
    };
  };
  function getFontSizeObjectByValue(fontSizes, value) {
    const fontSizeObject = fontSizes?.find(({ size }) => size === value);
    if (fontSizeObject) {
      return fontSizeObject;
    }
    return {
      size: value
    };
  }
  function getFontSizeClass(fontSizeSlug) {
    if (!fontSizeSlug) {
      return;
    }
    return `has-${kebabCase3(fontSizeSlug)}-font-size`;
  }

  // packages/block-editor/build-module/components/font-sizes/fluid-utils.js
  var DEFAULT_MAXIMUM_VIEWPORT_WIDTH = "1600px";
  var DEFAULT_MINIMUM_VIEWPORT_WIDTH = "320px";
  var DEFAULT_SCALE_FACTOR = 1;
  var DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN = 0.25;
  var DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX = 0.75;
  var DEFAULT_MINIMUM_FONT_SIZE_LIMIT = "14px";
  function getComputedFluidTypographyValue({
    minimumFontSize,
    maximumFontSize,
    fontSize,
    minimumViewportWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,
    maximumViewportWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,
    scaleFactor = DEFAULT_SCALE_FACTOR,
    minimumFontSizeLimit
  }) {
    minimumFontSizeLimit = !!getTypographyValueAndUnit(minimumFontSizeLimit) ? minimumFontSizeLimit : DEFAULT_MINIMUM_FONT_SIZE_LIMIT;
    if (fontSize) {
      const fontSizeParsed = getTypographyValueAndUnit(fontSize);
      if (!fontSizeParsed?.unit) {
        return null;
      }
      const minimumFontSizeLimitParsed = getTypographyValueAndUnit(
        minimumFontSizeLimit,
        {
          coerceTo: fontSizeParsed.unit
        }
      );
      if (!!minimumFontSizeLimitParsed?.value && !minimumFontSize && !maximumFontSize) {
        if (fontSizeParsed?.value <= minimumFontSizeLimitParsed?.value) {
          return null;
        }
      }
      if (!maximumFontSize) {
        maximumFontSize = `${fontSizeParsed.value}${fontSizeParsed.unit}`;
      }
      if (!minimumFontSize) {
        const fontSizeValueInPx = fontSizeParsed.unit === "px" ? fontSizeParsed.value : fontSizeParsed.value * 16;
        const minimumFontSizeFactor = Math.min(
          Math.max(
            1 - 0.075 * Math.log2(fontSizeValueInPx),
            DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN
          ),
          DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX
        );
        const calculatedMinimumFontSize = roundToPrecision(
          fontSizeParsed.value * minimumFontSizeFactor,
          3
        );
        if (!!minimumFontSizeLimitParsed?.value && calculatedMinimumFontSize < minimumFontSizeLimitParsed?.value) {
          minimumFontSize = `${minimumFontSizeLimitParsed.value}${minimumFontSizeLimitParsed.unit}`;
        } else {
          minimumFontSize = `${calculatedMinimumFontSize}${fontSizeParsed.unit}`;
        }
      }
    }
    const minimumFontSizeParsed = getTypographyValueAndUnit(minimumFontSize);
    const fontSizeUnit = minimumFontSizeParsed?.unit || "rem";
    const maximumFontSizeParsed = getTypographyValueAndUnit(maximumFontSize, {
      coerceTo: fontSizeUnit
    });
    if (!minimumFontSizeParsed || !maximumFontSizeParsed) {
      return null;
    }
    const minimumFontSizeRem = getTypographyValueAndUnit(minimumFontSize, {
      coerceTo: "rem"
    });
    const maximumViewportWidthParsed = getTypographyValueAndUnit(
      maximumViewportWidth,
      { coerceTo: fontSizeUnit }
    );
    const minimumViewportWidthParsed = getTypographyValueAndUnit(
      minimumViewportWidth,
      { coerceTo: fontSizeUnit }
    );
    if (!maximumViewportWidthParsed || !minimumViewportWidthParsed || !minimumFontSizeRem) {
      return null;
    }
    const linearDenominator = maximumViewportWidthParsed.value - minimumViewportWidthParsed.value;
    if (!linearDenominator) {
      return null;
    }
    const minViewportWidthOffsetValue = roundToPrecision(
      minimumViewportWidthParsed.value / 100,
      3
    );
    const viewportWidthOffset = roundToPrecision(minViewportWidthOffsetValue, 3) + fontSizeUnit;
    const linearFactor = 100 * ((maximumFontSizeParsed.value - minimumFontSizeParsed.value) / linearDenominator);
    const linearFactorScaled = roundToPrecision(
      (linearFactor || 1) * scaleFactor,
      3
    );
    const fluidTargetFontSize = `${minimumFontSizeRem.value}${minimumFontSizeRem.unit} + ((1vw - ${viewportWidthOffset}) * ${linearFactorScaled})`;
    return `clamp(${minimumFontSize}, ${fluidTargetFontSize}, ${maximumFontSize})`;
  }
  function getTypographyValueAndUnit(rawValue, options = {}) {
    if (typeof rawValue !== "string" && typeof rawValue !== "number") {
      return null;
    }
    if (isFinite(rawValue)) {
      rawValue = `${rawValue}px`;
    }
    const { coerceTo, rootSizeValue, acceptableUnits } = {
      coerceTo: "",
      // Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( "html" ) ).fontSize`.
      rootSizeValue: 16,
      acceptableUnits: ["rem", "px", "em"],
      ...options
    };
    const acceptableUnitsGroup = acceptableUnits?.join("|");
    const regexUnits = new RegExp(
      `^(\\d*\\.?\\d+)(${acceptableUnitsGroup}){1,1}$`
    );
    const matches = rawValue.match(regexUnits);
    if (!matches || matches.length < 3) {
      return null;
    }
    let [, value, unit] = matches;
    let returnValue = parseFloat(value);
    if ("px" === coerceTo && ("em" === unit || "rem" === unit)) {
      returnValue = returnValue * rootSizeValue;
      unit = coerceTo;
    }
    if ("px" === unit && ("em" === coerceTo || "rem" === coerceTo)) {
      returnValue = returnValue / rootSizeValue;
      unit = coerceTo;
    }
    if (("em" === coerceTo || "rem" === coerceTo) && ("em" === unit || "rem" === unit)) {
      unit = coerceTo;
    }
    return {
      value: roundToPrecision(returnValue, 3),
      unit
    };
  }
  function roundToPrecision(value, digits = 3) {
    const base = Math.pow(10, digits);
    return Number.isFinite(value) ? parseFloat(Math.round(value * base) / base) : void 0;
  }

  // packages/block-editor/build-module/components/font-sizes/font-size-picker.js
  var import_jsx_runtime115 = __toESM(require_jsx_runtime());
  var import_components7 = __toESM(require_components());
  function FontSizePicker(props) {
    const [fontSizes, customFontSize] = useSettings(
      "typography.fontSizes",
      "typography.customFontSize"
    );
    return /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(
      import_components7.FontSizePicker,
      {
        ...props,
        fontSizes,
        disableCustomFontSizes: !customFontSize
      }
    );
  }
  var font_size_picker_default = FontSizePicker;

  // packages/block-editor/build-module/components/font-sizes/with-font-sizes.js
  var import_jsx_runtime116 = __toESM(require_jsx_runtime());
  var import_compose3 = __toESM(require_compose());
  var import_element11 = __toESM(require_element());
  var DEFAULT_FONT_SIZES = [];
  var upperFirst2 = ([firstLetter, ...rest]) => firstLetter.toUpperCase() + rest.join("");
  var with_font_sizes_default = (...fontSizeNames) => {
    const fontSizeAttributeNames = fontSizeNames.reduce(
      (fontSizeAttributeNamesAccumulator, fontSizeAttributeName) => {
        fontSizeAttributeNamesAccumulator[fontSizeAttributeName] = `custom${upperFirst2(fontSizeAttributeName)}`;
        return fontSizeAttributeNamesAccumulator;
      },
      {}
    );
    return (0, import_compose3.createHigherOrderComponent)(
      (0, import_compose3.compose)([
        (0, import_compose3.createHigherOrderComponent)(
          (WrappedComponent) => (props) => {
            const [fontSizes] = useSettings("typography.fontSizes");
            return /* @__PURE__ */ (0, import_jsx_runtime116.jsx)(
              WrappedComponent,
              {
                ...props,
                fontSizes: fontSizes || DEFAULT_FONT_SIZES
              }
            );
          },
          "withFontSizes"
        ),
        (WrappedComponent) => {
          return class extends import_element11.Component {
            constructor(props) {
              super(props);
              this.setters = this.createSetters();
              this.state = {};
            }
            createSetters() {
              return Object.entries(fontSizeAttributeNames).reduce(
                (settersAccumulator, [
                  fontSizeAttributeName,
                  customFontSizeAttributeName
                ]) => {
                  const upperFirstFontSizeAttributeName = upperFirst2(fontSizeAttributeName);
                  settersAccumulator[`set${upperFirstFontSizeAttributeName}`] = this.createSetFontSize(
                    fontSizeAttributeName,
                    customFontSizeAttributeName
                  );
                  return settersAccumulator;
                },
                {}
              );
            }
            createSetFontSize(fontSizeAttributeName, customFontSizeAttributeName) {
              return (fontSizeValue) => {
                const fontSizeObject = this.props.fontSizes?.find(
                  ({ size }) => size === Number(fontSizeValue)
                );
                this.props.setAttributes({
                  [fontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? fontSizeObject.slug : void 0,
                  [customFontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? void 0 : fontSizeValue
                });
              };
            }
            static getDerivedStateFromProps({ attributes, fontSizes }, previousState) {
              const didAttributesChange = (customFontSizeAttributeName, fontSizeAttributeName) => {
                if (previousState[fontSizeAttributeName]) {
                  if (attributes[fontSizeAttributeName]) {
                    return attributes[fontSizeAttributeName] !== previousState[fontSizeAttributeName].slug;
                  }
                  return previousState[fontSizeAttributeName].size !== attributes[customFontSizeAttributeName];
                }
                return true;
              };
              if (!Object.values(fontSizeAttributeNames).some(
                didAttributesChange
              )) {
                return null;
              }
              const newState = Object.entries(
                fontSizeAttributeNames
              ).filter(
                ([key, value]) => didAttributesChange(value, key)
              ).reduce(
                (newStateAccumulator, [
                  fontSizeAttributeName,
                  customFontSizeAttributeName
                ]) => {
                  const fontSizeAttributeValue = attributes[fontSizeAttributeName];
                  const fontSizeObject = getFontSize(
                    fontSizes,
                    fontSizeAttributeValue,
                    attributes[customFontSizeAttributeName]
                  );
                  newStateAccumulator[fontSizeAttributeName] = {
                    ...fontSizeObject,
                    class: getFontSizeClass(
                      fontSizeAttributeValue
                    )
                  };
                  return newStateAccumulator;
                },
                {}
              );
              return {
                ...previousState,
                ...newState
              };
            }
            render() {
              return /* @__PURE__ */ (0, import_jsx_runtime116.jsx)(
                WrappedComponent,
                {
                  ...{
                    ...this.props,
                    fontSizes: void 0,
                    ...this.state,
                    ...this.setters
                  }
                }
              );
            }
          };
        }
      ]),
      "withFontSizes"
    );
  };

  // packages/block-editor/build-module/components/alignment-control/index.js
  var import_jsx_runtime118 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/alignment-control/ui.js
  var import_jsx_runtime117 = __toESM(require_jsx_runtime());
  var import_i18n7 = __toESM(require_i18n());
  var import_components8 = __toESM(require_components());
  var DEFAULT_ALIGNMENT_CONTROLS = [
    {
      icon: align_left_default,
      title: (0, import_i18n7.__)("Align text left"),
      align: "left"
    },
    {
      icon: align_center_default,
      title: (0, import_i18n7.__)("Align text center"),
      align: "center"
    },
    {
      icon: align_right_default,
      title: (0, import_i18n7.__)("Align text right"),
      align: "right"
    }
  ];
  var POPOVER_PROPS = {
    placement: "bottom-start"
  };
  function AlignmentUI({
    value,
    onChange,
    alignmentControls = DEFAULT_ALIGNMENT_CONTROLS,
    label = (0, import_i18n7.__)("Align text"),
    description = (0, import_i18n7.__)("Change text alignment"),
    isCollapsed: isCollapsed3 = true,
    isToolbar
  }) {
    function applyOrUnset(align) {
      return () => onChange(value === align ? void 0 : align);
    }
    const activeAlignment = alignmentControls.find(
      (control) => control.align === value
    );
    function setIcon() {
      if (activeAlignment) {
        return activeAlignment.icon;
      }
      return (0, import_i18n7.isRTL)() ? align_right_default : align_left_default;
    }
    const UIComponent = isToolbar ? import_components8.ToolbarGroup : import_components8.ToolbarDropdownMenu;
    const extraProps = isToolbar ? { isCollapsed: isCollapsed3 } : {
      toggleProps: {
        description
      },
      popoverProps: POPOVER_PROPS
    };
    return /* @__PURE__ */ (0, import_jsx_runtime117.jsx)(
      UIComponent,
      {
        icon: setIcon(),
        label,
        controls: alignmentControls.map((control) => {
          const { align } = control;
          const isActive = value === align;
          return {
            ...control,
            isActive,
            role: isCollapsed3 ? "menuitemradio" : void 0,
            onClick: applyOrUnset(align)
          };
        }),
        ...extraProps
      }
    );
  }
  var ui_default = AlignmentUI;

  // packages/block-editor/build-module/components/alignment-control/index.js
  var AlignmentControl = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(ui_default, { ...props, isToolbar: false });
  };
  var AlignmentToolbar = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(ui_default, { ...props, isToolbar: true });
  };

  // packages/block-editor/build-module/components/autocomplete/index.js
  var import_jsx_runtime122 = __toESM(require_jsx_runtime());
  var import_hooks3 = __toESM(require_hooks());
  var import_components10 = __toESM(require_components());
  var import_element15 = __toESM(require_element());
  var import_blocks12 = __toESM(require_blocks());

  // packages/block-editor/build-module/autocompleters/block.js
  var import_jsx_runtime120 = __toESM(require_jsx_runtime());
  var import_data11 = __toESM(require_data());
  var import_blocks11 = __toESM(require_blocks());
  var import_element14 = __toESM(require_element());

  // packages/block-editor/build-module/components/inserter/search-items.js
  var import_remove_accents = __toESM(require_remove_accents());

  // node_modules/lower-case/dist.es2015/index.js
  function lowerCase(str) {
    return str.toLowerCase();
  }

  // node_modules/no-case/dist.es2015/index.js
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.splitRegexp, splitRegexp2 = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp2 = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter2 = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp2, "$1\0$2"), stripRegexp2, "\0");
    var start2 = 0;
    var end = result.length;
    while (result.charAt(start2) === "\0")
      start2++;
    while (result.charAt(end - 1) === "\0")
      end--;
    return result.slice(start2, end).split("\0").map(transform).join(delimiter2);
  }
  function replace(input, re, value) {
    if (re instanceof RegExp)
      return input.replace(re, value);
    return re.reduce(function(input2, re2) {
      return input2.replace(re2, value);
    }, input);
  }

  // packages/block-editor/build-module/components/inserter/search-items.js
  var defaultGetName = (item) => item.name || "";
  var defaultGetTitle = (item) => item.title;
  var defaultGetDescription = (item) => item.description || "";
  var defaultGetKeywords = (item) => item.keywords || [];
  var defaultGetCategory = (item) => item.category;
  var defaultGetCollection = () => null;
  var splitRegexp = [
    /([\p{Ll}\p{Lo}\p{N}])([\p{Lu}\p{Lt}])/gu,
    // One lowercase or digit, followed by one uppercase.
    /([\p{Lu}\p{Lt}])([\p{Lu}\p{Lt}][\p{Ll}\p{Lo}])/gu
    // One uppercase followed by one uppercase and one lowercase.
  ];
  var stripRegexp = new RegExp("(\\p{C}|\\p{P}|\\p{S})+", "giu");
  var extractedWords = /* @__PURE__ */ new Map();
  var normalizedStrings = /* @__PURE__ */ new Map();
  function extractWords(input = "") {
    if (extractedWords.has(input)) {
      return extractedWords.get(input);
    }
    const result = noCase(input, {
      splitRegexp,
      stripRegexp
    }).split(" ").filter(Boolean);
    extractedWords.set(input, result);
    return result;
  }
  function normalizeString(input = "") {
    if (normalizedStrings.has(input)) {
      return normalizedStrings.get(input);
    }
    let result = (0, import_remove_accents.default)(input);
    result = result.replace(/^\//, "");
    result = result.toLowerCase();
    normalizedStrings.set(input, result);
    return result;
  }
  var getNormalizedSearchTerms = (input = "") => {
    return extractWords(normalizeString(input));
  };
  var removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
    return unmatchedTerms.filter(
      (term) => !getNormalizedSearchTerms(unprocessedTerms).some(
        (unprocessedTerm) => unprocessedTerm.includes(term)
      )
    );
  };
  var searchBlockItems = (items, categories, collections, searchInput) => {
    const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
    if (normalizedSearchTerms.length === 0) {
      return items;
    }
    const config2 = {
      getCategory: (item) => categories.find(({ slug }) => slug === item.category)?.title,
      getCollection: (item) => collections[item.name.split("/")[0]]?.title
    };
    return searchItems(items, searchInput, config2);
  };
  var searchItems = (items = [], searchInput = "", config2 = {}) => {
    const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
    if (normalizedSearchTerms.length === 0) {
      return items;
    }
    const rankedItems = items.map((item) => {
      return [item, getItemSearchRank(item, searchInput, config2)];
    }).filter(([, rank]) => rank > 0);
    rankedItems.sort(([, rank1], [, rank2]) => rank2 - rank1);
    return rankedItems.map(([item]) => item);
  };
  function getItemSearchRank(item, searchTerm, config2 = {}) {
    const {
      getName = defaultGetName,
      getTitle = defaultGetTitle,
      getDescription = defaultGetDescription,
      getKeywords = defaultGetKeywords,
      getCategory = defaultGetCategory,
      getCollection = defaultGetCollection
    } = config2;
    const name = getName(item);
    const title = getTitle(item);
    const description = getDescription(item);
    const keywords = getKeywords(item);
    const category = getCategory(item);
    const collection = getCollection(item);
    const normalizedSearchInput = normalizeString(searchTerm);
    const normalizedTitle = normalizeString(title);
    let rank = 0;
    if (normalizedSearchInput === normalizedTitle) {
      rank += 30;
    } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
      rank += 20;
    } else {
      const terms = [
        name,
        title,
        description,
        ...keywords,
        category,
        collection
      ].join(" ");
      const normalizedSearchTerms = extractWords(normalizedSearchInput);
      const unmatchedTerms = removeMatchingTerms(
        normalizedSearchTerms,
        terms
      );
      if (unmatchedTerms.length === 0) {
        rank += 10;
      }
    }
    if (rank !== 0 && name.startsWith("core/")) {
      const isCoreBlockVariation = name !== item.id;
      rank += isCoreBlockVariation ? 1 : 2;
    }
    return rank;
  }

  // packages/block-editor/build-module/components/inserter/hooks/use-block-types-state.js
  var import_blocks10 = __toESM(require_blocks());
  var import_data10 = __toESM(require_data());
  var import_element12 = __toESM(require_element());
  var import_notices2 = __toESM(require_notices());
  var import_i18n8 = __toESM(require_i18n());
  var useBlockTypesState = (rootClientId, onInsert, isQuick) => {
    const options = (0, import_element12.useMemo)(
      () => ({ [isFiltered]: !!isQuick }),
      [isQuick]
    );
    const [items] = (0, import_data10.useSelect)(
      (select2) => [
        select2(store).getInserterItems(
          rootClientId,
          options
        )
      ],
      [rootClientId, options]
    );
    const { getClosestAllowedInsertionPoint: getClosestAllowedInsertionPoint2 } = unlock(
      (0, import_data10.useSelect)(store)
    );
    const { createErrorNotice } = (0, import_data10.useDispatch)(import_notices2.store);
    const [categories, collections] = (0, import_data10.useSelect)((select2) => {
      const { getCategories, getCollections } = select2(import_blocks10.store);
      return [getCategories(), getCollections()];
    }, []);
    const onSelectItem = (0, import_element12.useCallback)(
      ({ name, initialAttributes, innerBlocks, syncStatus, content }, shouldFocusBlock) => {
        const destinationClientId = getClosestAllowedInsertionPoint2(
          name,
          rootClientId
        );
        if (destinationClientId === null) {
          const title = (0, import_blocks10.getBlockType)(name)?.title ?? name;
          createErrorNotice(
            (0, import_i18n8.sprintf)(
              /* translators: %s: block pattern title. */
              (0, import_i18n8.__)(`Block "%s" can't be inserted.`),
              title
            ),
            {
              type: "snackbar",
              id: "inserter-notice"
            }
          );
          return;
        }
        const insertedBlock = syncStatus === "unsynced" ? (0, import_blocks10.parse)(content, {
          __unstableSkipMigrationLogs: true
        }) : (0, import_blocks10.createBlock)(
          name,
          initialAttributes,
          (0, import_blocks10.createBlocksFromInnerBlocksTemplate)(innerBlocks)
        );
        onInsert(
          insertedBlock,
          void 0,
          shouldFocusBlock,
          destinationClientId
        );
      },
      [
        getClosestAllowedInsertionPoint2,
        rootClientId,
        onInsert,
        createErrorNotice
      ]
    );
    return [items, categories, collections, onSelectItem];
  };
  var use_block_types_state_default = useBlockTypesState;

  // packages/block-editor/build-module/components/block-icon/index.js
  var import_jsx_runtime119 = __toESM(require_jsx_runtime());
  var import_components9 = __toESM(require_components());
  var import_element13 = __toESM(require_element());
  function BlockIcon({ icon, showColors = false, className, context }) {
    if (icon?.src === "block-default") {
      icon = {
        src: block_default_default
      };
    }
    const renderedIcon = /* @__PURE__ */ (0, import_jsx_runtime119.jsx)(import_components9.Icon, { icon: icon && icon.src ? icon.src : icon, context });
    const style = showColors ? {
      backgroundColor: icon && icon.background,
      color: icon && icon.foreground
    } : {};
    return /* @__PURE__ */ (0, import_jsx_runtime119.jsx)(
      "span",
      {
        style,
        className: clsx_default("block-editor-block-icon", className, {
          "has-colors": showColors
        }),
        children: renderedIcon
      }
    );
  }
  var block_icon_default = (0, import_element13.memo)(BlockIcon);

  // packages/block-editor/build-module/utils/order-inserter-block-items.js
  var orderInserterBlockItems = (items, priority2) => {
    if (!priority2) {
      return items;
    }
    items.sort(({ id: aName }, { id: bName }) => {
      let aIndex = priority2.indexOf(aName);
      let bIndex = priority2.indexOf(bName);
      if (aIndex < 0) {
        aIndex = priority2.length;
      }
      if (bIndex < 0) {
        bIndex = priority2.length;
      }
      return aIndex - bIndex;
    });
    return items;
  };

  // packages/block-editor/build-module/autocompleters/block.js
  var noop = () => {
  };
  var SHOWN_BLOCK_TYPES = 9;
  function createBlockCompleter() {
    return {
      name: "blocks",
      className: "block-editor-autocompleters__block",
      triggerPrefix: "/",
      useItems(filterValue) {
        const { rootClientId, selectedBlockId, prioritizedBlocks } = (0, import_data11.useSelect)((select2) => {
          const {
            getSelectedBlockClientId: getSelectedBlockClientId2,
            getBlock: getBlock2,
            getBlockListSettings: getBlockListSettings2,
            getBlockRootClientId: getBlockRootClientId2
          } = select2(store);
          const { getActiveBlockVariation } = select2(import_blocks11.store);
          const selectedBlockClientId = getSelectedBlockClientId2();
          const { name: blockName, attributes } = getBlock2(
            selectedBlockClientId
          );
          const activeBlockVariation = getActiveBlockVariation(
            blockName,
            attributes
          );
          const _rootClientId = getBlockRootClientId2(
            selectedBlockClientId
          );
          return {
            selectedBlockId: activeBlockVariation ? `${blockName}/${activeBlockVariation.name}` : blockName,
            rootClientId: _rootClientId,
            prioritizedBlocks: getBlockListSettings2(_rootClientId)?.prioritizedInserterBlocks
          };
        }, []);
        const [items, categories, collections] = use_block_types_state_default(
          rootClientId,
          noop,
          true
        );
        const filteredItems = (0, import_element14.useMemo)(() => {
          const initialFilteredItems = !!filterValue.trim() ? searchBlockItems(
            items,
            categories,
            collections,
            filterValue
          ) : orderInserterBlockItems(
            orderBy(items, "frecency", "desc"),
            prioritizedBlocks
          );
          return initialFilteredItems.filter((item) => item.id !== selectedBlockId).slice(0, SHOWN_BLOCK_TYPES);
        }, [
          filterValue,
          selectedBlockId,
          items,
          categories,
          collections,
          prioritizedBlocks
        ]);
        const options = (0, import_element14.useMemo)(
          () => filteredItems.map((blockItem) => {
            const { title, icon, isDisabled } = blockItem;
            return {
              key: `block-${blockItem.id}`,
              value: blockItem,
              label: /* @__PURE__ */ (0, import_jsx_runtime120.jsxs)(import_jsx_runtime120.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime120.jsx)(
                  block_icon_default,
                  {
                    icon,
                    showColors: true
                  },
                  "icon"
                ),
                title
              ] }),
              isDisabled
            };
          }),
          [filteredItems]
        );
        return [options];
      },
      allowContext(before, after) {
        return !(/\S/.test(before) || /\S/.test(after));
      },
      getOptionCompletion(inserterItem) {
        const { name, initialAttributes, innerBlocks, syncStatus, blocks: blocks2 } = inserterItem;
        return {
          action: "replace",
          value: syncStatus === "unsynced" ? (blocks2 ?? []).map(
            (block) => (0, import_blocks11.cloneBlock)(block)
          ) : (0, import_blocks11.createBlock)(
            name,
            initialAttributes,
            (0, import_blocks11.createBlocksFromInnerBlocksTemplate)(
              innerBlocks
            )
          )
        };
      }
    };
  }
  var block_default = createBlockCompleter();

  // packages/block-editor/build-module/autocompleters/link.js
  var import_jsx_runtime121 = __toESM(require_jsx_runtime());
  var import_api_fetch = __toESM(require_api_fetch());
  var import_url2 = __toESM(require_url());
  var import_html_entities = __toESM(require_html_entities());
  var SHOWN_SUGGESTIONS = 10;
  function createLinkCompleter() {
    return {
      name: "links",
      className: "block-editor-autocompleters__link",
      triggerPrefix: "[[",
      options: async (letters) => {
        let options = await (0, import_api_fetch.default)({
          path: (0, import_url2.addQueryArgs)("/wp/v2/search", {
            per_page: SHOWN_SUGGESTIONS,
            search: letters,
            type: "post",
            order_by: "menu_order"
          })
        });
        options = options.filter((option) => option.title !== "");
        return options;
      },
      getOptionKeywords(item) {
        const expansionWords = item.title.split(/\s+/);
        return [...expansionWords];
      },
      getOptionLabel(item) {
        return /* @__PURE__ */ (0, import_jsx_runtime121.jsxs)(import_jsx_runtime121.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime121.jsx)(
            icon_default,
            {
              icon: item.subtype === "page" ? page_default : post_default
            },
            "icon"
          ),
          (0, import_html_entities.decodeEntities)(item.title)
        ] });
      },
      getOptionCompletion(item) {
        return /* @__PURE__ */ (0, import_jsx_runtime121.jsx)("a", { href: item.url, children: item.title });
      }
    };
  }
  var link_default2 = createLinkCompleter();

  // packages/block-editor/build-module/components/autocomplete/index.js
  var EMPTY_ARRAY3 = [];
  function useCompleters({ completers = EMPTY_ARRAY3 }) {
    const { name } = useBlockEditContext();
    return (0, import_element15.useMemo)(() => {
      let filteredCompleters = [...completers, link_default2];
      if (name === (0, import_blocks12.getDefaultBlockName)() || (0, import_blocks12.getBlockSupport)(name, "__experimentalSlashInserter", false)) {
        filteredCompleters = [...filteredCompleters, block_default];
      }
      if ((0, import_hooks3.hasFilter)("editor.Autocomplete.completers")) {
        if (filteredCompleters === completers) {
          filteredCompleters = filteredCompleters.map(
            (completer) => ({ ...completer })
          );
        }
        filteredCompleters = (0, import_hooks3.applyFilters)(
          "editor.Autocomplete.completers",
          filteredCompleters,
          name
        );
      }
      return filteredCompleters;
    }, [completers, name]);
  }
  function useBlockEditorAutocompleteProps(props) {
    return (0, import_components10.__unstableUseAutocompleteProps)({
      ...props,
      completers: useCompleters(props)
    });
  }
  function BlockEditorAutocomplete(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime122.jsx)(import_components10.Autocomplete, { ...props, completers: useCompleters(props) });
  }
  var autocomplete_default = BlockEditorAutocomplete;

  // packages/block-editor/build-module/components/block-alignment-control/index.js
  var import_jsx_runtime128 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/block-alignment-control/ui.js
  var import_jsx_runtime127 = __toESM(require_jsx_runtime());
  var import_i18n16 = __toESM(require_i18n());
  var import_components16 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-alignment-control/use-available-alignments.js
  var import_data12 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-list/layout.js
  var import_jsx_runtime126 = __toESM(require_jsx_runtime());
  var import_element17 = __toESM(require_element());

  // packages/block-editor/build-module/layouts/flex.js
  var import_jsx_runtime123 = __toESM(require_jsx_runtime());
  var import_i18n11 = __toESM(require_i18n());
  var import_components11 = __toESM(require_components());

  // packages/block-editor/build-module/layouts/utils.js
  var import_i18n9 = __toESM(require_i18n());

  // packages/block-editor/build-module/layouts/definitions.js
  var LAYOUT_DEFINITIONS = {
    default: {
      name: "default",
      slug: "flow",
      className: "is-layout-flow",
      baseStyles: [
        {
          selector: " > .alignleft",
          rules: {
            float: "left",
            "margin-inline-start": "0",
            "margin-inline-end": "2em"
          }
        },
        {
          selector: " > .alignright",
          rules: {
            float: "right",
            "margin-inline-start": "2em",
            "margin-inline-end": "0"
          }
        },
        {
          selector: " > .aligncenter",
          rules: {
            "margin-left": "auto !important",
            "margin-right": "auto !important"
          }
        }
      ],
      spacingStyles: [
        {
          selector: " > :first-child",
          rules: {
            "margin-block-start": "0"
          }
        },
        {
          selector: " > :last-child",
          rules: {
            "margin-block-end": "0"
          }
        },
        {
          selector: " > *",
          rules: {
            "margin-block-start": null,
            "margin-block-end": "0"
          }
        }
      ]
    },
    constrained: {
      name: "constrained",
      slug: "constrained",
      className: "is-layout-constrained",
      baseStyles: [
        {
          selector: " > .alignleft",
          rules: {
            float: "left",
            "margin-inline-start": "0",
            "margin-inline-end": "2em"
          }
        },
        {
          selector: " > .alignright",
          rules: {
            float: "right",
            "margin-inline-start": "2em",
            "margin-inline-end": "0"
          }
        },
        {
          selector: " > .aligncenter",
          rules: {
            "margin-left": "auto !important",
            "margin-right": "auto !important"
          }
        },
        {
          selector: " > :where(:not(.alignleft):not(.alignright):not(.alignfull))",
          rules: {
            "max-width": "var(--wp--style--global--content-size)",
            "margin-left": "auto !important",
            "margin-right": "auto !important"
          }
        },
        {
          selector: " > .alignwide",
          rules: {
            "max-width": "var(--wp--style--global--wide-size)"
          }
        }
      ],
      spacingStyles: [
        {
          selector: " > :first-child",
          rules: {
            "margin-block-start": "0"
          }
        },
        {
          selector: " > :last-child",
          rules: {
            "margin-block-end": "0"
          }
        },
        {
          selector: " > *",
          rules: {
            "margin-block-start": null,
            "margin-block-end": "0"
          }
        }
      ]
    },
    flex: {
      name: "flex",
      slug: "flex",
      className: "is-layout-flex",
      displayMode: "flex",
      baseStyles: [
        {
          selector: "",
          rules: {
            "flex-wrap": "wrap",
            "align-items": "center"
          }
        },
        {
          selector: " > :is(*, div)",
          // :is(*, div) instead of just * increases the specificity by 001.
          rules: {
            margin: "0"
          }
        }
      ],
      spacingStyles: [
        {
          selector: "",
          rules: {
            gap: null
          }
        }
      ]
    },
    grid: {
      name: "grid",
      slug: "grid",
      className: "is-layout-grid",
      displayMode: "grid",
      baseStyles: [
        {
          selector: " > :is(*, div)",
          // :is(*, div) instead of just * increases the specificity by 001.
          rules: {
            margin: "0"
          }
        }
      ],
      spacingStyles: [
        {
          selector: "",
          rules: {
            gap: null
          }
        }
      ]
    }
  };

  // packages/block-editor/build-module/layouts/utils.js
  function appendSelectors(selectors, append2 = "") {
    return selectors.split(",").map(
      (subselector) => `${subselector}${append2 ? ` ${append2}` : ""}`
    ).join(",");
  }
  function getBlockGapCSS(selector3, layoutDefinitions = LAYOUT_DEFINITIONS, layoutType, blockGapValue) {
    let output = "";
    if (layoutDefinitions?.[layoutType]?.spacingStyles?.length && blockGapValue) {
      layoutDefinitions[layoutType].spacingStyles.forEach((gapStyle) => {
        output += `${appendSelectors(
          selector3,
          gapStyle.selector.trim()
        )} { `;
        output += Object.entries(gapStyle.rules).map(
          ([cssProperty, value]) => `${cssProperty}: ${value ? value : blockGapValue}`
        ).join("; ");
        output += "; }";
      });
    }
    return output;
  }
  function getAlignmentsInfo(layout) {
    const { contentSize, wideSize, type = "default" } = layout;
    const alignmentInfo = {};
    const sizeRegex = /^(?!0)\d+(px|em|rem|vw|vh|%|svw|lvw|dvw|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax)?$/i;
    if (sizeRegex.test(contentSize) && type === "constrained") {
      alignmentInfo.none = (0, import_i18n9.sprintf)((0, import_i18n9.__)("Max %s wide"), contentSize);
    }
    if (sizeRegex.test(wideSize)) {
      alignmentInfo.wide = (0, import_i18n9.sprintf)((0, import_i18n9.__)("Max %s wide"), wideSize);
    }
    return alignmentInfo;
  }

  // packages/block-editor/build-module/components/spacing-sizes-control/utils.js
  var import_i18n10 = __toESM(require_i18n());
  var RANGE_CONTROL_MAX_SIZE = 8;
  var ALL_SIDES = ["top", "right", "bottom", "left"];
  var DEFAULT_VALUES = {
    top: void 0,
    right: void 0,
    bottom: void 0,
    left: void 0
  };
  var ICONS = {
    custom: sides_all_default,
    axial: sides_all_default,
    horizontal: sides_horizontal_default,
    vertical: sides_vertical_default,
    top: sides_top_default,
    right: sides_right_default,
    bottom: sides_bottom_default,
    left: sides_left_default
  };
  var LABELS = {
    default: (0, import_i18n10.__)("Spacing control"),
    top: (0, import_i18n10.__)("Top"),
    bottom: (0, import_i18n10.__)("Bottom"),
    left: (0, import_i18n10.__)("Left"),
    right: (0, import_i18n10.__)("Right"),
    mixed: (0, import_i18n10.__)("Mixed"),
    vertical: (0, import_i18n10.__)("Vertical"),
    horizontal: (0, import_i18n10.__)("Horizontal"),
    axial: (0, import_i18n10.__)("Horizontal & vertical"),
    custom: (0, import_i18n10.__)("Custom")
  };
  var VIEWS = {
    axial: "axial",
    top: "top",
    right: "right",
    bottom: "bottom",
    left: "left",
    custom: "custom"
  };
  function isValueSpacingPreset(value) {
    if (!value?.includes) {
      return false;
    }
    return value === "0" || value.includes("var:preset|spacing|");
  }
  function getCustomValueFromPreset(value, spacingSizes) {
    if (!isValueSpacingPreset(value)) {
      return value;
    }
    const slug = getSpacingPresetSlug(value);
    const spacingSize = spacingSizes.find(
      (size) => String(size.slug) === slug
    );
    return spacingSize?.size;
  }
  function getPresetValueFromCustomValue(value, spacingSizes) {
    if (!value || isValueSpacingPreset(value) || value === "0") {
      return value;
    }
    const spacingMatch = spacingSizes.find(
      (size) => String(size.size) === String(value)
    );
    if (spacingMatch?.slug) {
      return `var:preset|spacing|${spacingMatch.slug}`;
    }
    return value;
  }
  function getSpacingPresetCssVar(value) {
    if (!value) {
      return;
    }
    const slug = value.match(/var:preset\|spacing\|(.+)/);
    if (!slug) {
      return value;
    }
    return `var(--wp--preset--spacing--${slug[1]})`;
  }
  function getSpacingPresetSlug(value) {
    if (!value) {
      return;
    }
    if (value === "0" || value === "default") {
      return value;
    }
    const slug = value.match(/var:preset\|spacing\|(.+)/);
    return slug ? slug[1] : void 0;
  }
  function getSliderValueFromPreset(presetValue, spacingSizes) {
    if (presetValue === void 0) {
      return 0;
    }
    const slug = parseFloat(presetValue, 10) === 0 ? "0" : getSpacingPresetSlug(presetValue);
    const sliderValue = spacingSizes.findIndex((spacingSize) => {
      return String(spacingSize.slug) === slug;
    });
    return sliderValue !== -1 ? sliderValue : NaN;
  }
  function hasAxisSupport(sides, axis) {
    if (!sides || !sides.length) {
      return false;
    }
    const hasHorizontalSupport = sides.includes("horizontal") || sides.includes("left") && sides.includes("right");
    const hasVerticalSupport = sides.includes("vertical") || sides.includes("top") && sides.includes("bottom");
    if (axis === "horizontal") {
      return hasHorizontalSupport;
    }
    if (axis === "vertical") {
      return hasVerticalSupport;
    }
    return hasHorizontalSupport || hasVerticalSupport;
  }
  function hasBalancedSidesSupport(sides = []) {
    const counts = { top: 0, right: 0, bottom: 0, left: 0 };
    sides.forEach((side) => counts[side] += 1);
    return (counts.top + counts.bottom) % 2 === 0 && (counts.left + counts.right) % 2 === 0;
  }
  function getInitialView(values = {}, sides) {
    const { top, right, bottom, left } = values;
    const sideValues = [top, right, bottom, left].filter(Boolean);
    const hasMatchingAxialValues = top === bottom && left === right && (!!top || !!left);
    const hasNoValuesAndBalancedSides = !sideValues.length && hasBalancedSidesSupport(sides);
    const hasOnlyAxialSides = sides?.includes("horizontal") && sides?.includes("vertical") && sides?.length === 2;
    if (hasAxisSupport(sides) && (hasMatchingAxialValues || hasNoValuesAndBalancedSides)) {
      return VIEWS.axial;
    }
    if (hasOnlyAxialSides && sideValues.length === 1) {
      let side;
      Object.entries(values).some(([key, value]) => {
        side = key;
        return value !== void 0;
      });
      return side;
    }
    if (sides?.length === 1 && !sideValues.length) {
      return sides[0];
    }
    return VIEWS.custom;
  }

  // packages/block-editor/build-module/hooks/gap.js
  function getGapBoxControlValueFromStyle(blockGapValue) {
    if (!blockGapValue) {
      return null;
    }
    const isValueString = typeof blockGapValue === "string";
    return {
      top: isValueString ? blockGapValue : blockGapValue?.top,
      left: isValueString ? blockGapValue : blockGapValue?.left
    };
  }
  function getGapCSSValue(blockGapValue, defaultValue = "0") {
    const blockGapBoxControlValue = getGapBoxControlValueFromStyle(blockGapValue);
    if (!blockGapBoxControlValue) {
      return null;
    }
    const row = getSpacingPresetCssVar(blockGapBoxControlValue?.top) || defaultValue;
    const column2 = getSpacingPresetCssVar(blockGapBoxControlValue?.left) || defaultValue;
    return row === column2 ? row : `${row} ${column2}`;
  }

  // packages/block-editor/build-module/layouts/flex.js
  var justifyContentMap = {
    left: "flex-start",
    right: "flex-end",
    center: "center",
    "space-between": "space-between"
  };
  var alignItemsMap = {
    left: "flex-start",
    right: "flex-end",
    center: "center",
    stretch: "stretch"
  };
  var verticalAlignmentMap = {
    top: "flex-start",
    center: "center",
    bottom: "flex-end",
    stretch: "stretch",
    "space-between": "space-between"
  };
  var defaultAlignments = {
    horizontal: "center",
    vertical: "top"
  };
  var flexWrapOptions = ["wrap", "nowrap"];
  var flex_default = {
    name: "flex",
    label: (0, import_i18n11.__)("Flex"),
    inspectorControls: function FlexLayoutInspectorControls({
      layout = {},
      onChange,
      layoutBlockSupport = {}
    }) {
      const { allowOrientation = true, allowJustification = true } = layoutBlockSupport;
      return /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(import_jsx_runtime123.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(import_components11.Flex, { children: [
          allowJustification && /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(import_components11.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
            FlexLayoutJustifyContentControl,
            {
              layout,
              onChange
            }
          ) }),
          allowOrientation && /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(import_components11.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
            OrientationControl,
            {
              layout,
              onChange
            }
          ) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(FlexWrapControl, { layout, onChange })
      ] });
    },
    toolBarControls: function FlexLayoutToolbarControls({
      layout = {},
      onChange,
      layoutBlockSupport
    }) {
      const { allowVerticalAlignment = true, allowJustification = true } = layoutBlockSupport;
      if (!allowJustification && !allowVerticalAlignment) {
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: [
        allowJustification && /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
          FlexLayoutJustifyContentControl,
          {
            layout,
            onChange,
            isToolbar: true
          }
        ),
        allowVerticalAlignment && /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
          FlexLayoutVerticalAlignmentControl,
          {
            layout,
            onChange
          }
        )
      ] });
    },
    getLayoutStyle: function getLayoutStyle({
      selector: selector3,
      layout,
      style,
      blockName,
      hasBlockGapSupport,
      layoutDefinitions = LAYOUT_DEFINITIONS
    }) {
      const { orientation = "horizontal" } = layout;
      const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, "spacing", "blockGap") ? getGapCSSValue(style?.spacing?.blockGap, "0.5em") : void 0;
      const justifyContent = justifyContentMap[layout.justifyContent];
      const flexWrap = flexWrapOptions.includes(layout.flexWrap) ? layout.flexWrap : "wrap";
      const verticalAlignment = verticalAlignmentMap[layout.verticalAlignment];
      const alignItems = alignItemsMap[layout.justifyContent] || alignItemsMap.left;
      let output = "";
      const rules = [];
      if (flexWrap && flexWrap !== "wrap") {
        rules.push(`flex-wrap: ${flexWrap}`);
      }
      if (orientation === "horizontal") {
        if (verticalAlignment) {
          rules.push(`align-items: ${verticalAlignment}`);
        }
        if (justifyContent) {
          rules.push(`justify-content: ${justifyContent}`);
        }
      } else {
        if (verticalAlignment) {
          rules.push(`justify-content: ${verticalAlignment}`);
        }
        rules.push("flex-direction: column");
        rules.push(`align-items: ${alignItems}`);
      }
      if (rules.length) {
        output = `${appendSelectors(selector3)} {
				${rules.join("; ")};
			}`;
      }
      if (hasBlockGapSupport && blockGapValue) {
        output += getBlockGapCSS(
          selector3,
          layoutDefinitions,
          "flex",
          blockGapValue
        );
      }
      return output;
    },
    getOrientation(layout) {
      const { orientation = "horizontal" } = layout;
      return orientation;
    },
    getAlignments() {
      return [];
    }
  };
  function FlexLayoutVerticalAlignmentControl({ layout, onChange }) {
    const { orientation = "horizontal" } = layout;
    const defaultVerticalAlignment = orientation === "horizontal" ? defaultAlignments.horizontal : defaultAlignments.vertical;
    const { verticalAlignment = defaultVerticalAlignment } = layout;
    const onVerticalAlignmentChange = (value) => {
      onChange({
        ...layout,
        verticalAlignment: value
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      BlockVerticalAlignmentControl,
      {
        onChange: onVerticalAlignmentChange,
        value: verticalAlignment,
        controls: orientation === "horizontal" ? ["top", "center", "bottom", "stretch"] : ["top", "center", "bottom", "space-between"]
      }
    );
  }
  var POPOVER_PROPS2 = {
    placement: "bottom-start"
  };
  function FlexLayoutJustifyContentControl({
    layout,
    onChange,
    isToolbar = false
  }) {
    const { justifyContent = "left", orientation = "horizontal" } = layout;
    const onJustificationChange = (value) => {
      onChange({
        ...layout,
        justifyContent: value
      });
    };
    const allowedControls = ["left", "center", "right"];
    if (orientation === "horizontal") {
      allowedControls.push("space-between");
    } else {
      allowedControls.push("stretch");
    }
    if (isToolbar) {
      return /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
        JustifyContentControl,
        {
          allowedControls,
          value: justifyContent,
          onChange: onJustificationChange,
          popoverProps: POPOVER_PROPS2
        }
      );
    }
    const justificationOptions = [
      {
        value: "left",
        icon: justify_left_default,
        label: (0, import_i18n11.__)("Justify items left")
      },
      {
        value: "center",
        icon: justify_center_default,
        label: (0, import_i18n11.__)("Justify items center")
      },
      {
        value: "right",
        icon: justify_right_default,
        label: (0, import_i18n11.__)("Justify items right")
      }
    ];
    if (orientation === "horizontal") {
      justificationOptions.push({
        value: "space-between",
        icon: justify_space_between_default,
        label: (0, import_i18n11.__)("Space between items")
      });
    } else {
      justificationOptions.push({
        value: "stretch",
        icon: justify_stretch_default,
        label: (0, import_i18n11.__)("Stretch items")
      });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      import_components11.__experimentalToggleGroupControl,
      {
        __next40pxDefaultSize: true,
        __nextHasNoMarginBottom: true,
        label: (0, import_i18n11.__)("Justification"),
        value: justifyContent,
        onChange: onJustificationChange,
        className: "block-editor-hooks__flex-layout-justification-controls",
        children: justificationOptions.map(({ value, icon, label }) => {
          return /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
            import_components11.__experimentalToggleGroupControlOptionIcon,
            {
              value,
              icon,
              label
            },
            value
          );
        })
      }
    );
  }
  function FlexWrapControl({ layout, onChange }) {
    const { flexWrap = "wrap" } = layout;
    return /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      import_components11.ToggleControl,
      {
        __nextHasNoMarginBottom: true,
        label: (0, import_i18n11.__)("Allow to wrap to multiple lines"),
        onChange: (value) => {
          onChange({
            ...layout,
            flexWrap: value ? "wrap" : "nowrap"
          });
        },
        checked: flexWrap === "wrap"
      }
    );
  }
  function OrientationControl({ layout, onChange }) {
    const {
      orientation = "horizontal",
      verticalAlignment,
      justifyContent
    } = layout;
    return /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(
      import_components11.__experimentalToggleGroupControl,
      {
        __next40pxDefaultSize: true,
        __nextHasNoMarginBottom: true,
        className: "block-editor-hooks__flex-layout-orientation-controls",
        label: (0, import_i18n11.__)("Orientation"),
        value: orientation,
        onChange: (value) => {
          let newVerticalAlignment = verticalAlignment;
          let newJustification = justifyContent;
          if (value === "horizontal") {
            if (verticalAlignment === "space-between") {
              newVerticalAlignment = "center";
            }
            if (justifyContent === "stretch") {
              newJustification = "left";
            }
          } else {
            if (verticalAlignment === "stretch") {
              newVerticalAlignment = "top";
            }
            if (justifyContent === "space-between") {
              newJustification = "left";
            }
          }
          return onChange({
            ...layout,
            orientation: value,
            verticalAlignment: newVerticalAlignment,
            justifyContent: newJustification
          });
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
            import_components11.__experimentalToggleGroupControlOptionIcon,
            {
              icon: arrow_right_default,
              value: "horizontal",
              label: (0, import_i18n11.__)("Horizontal")
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
            import_components11.__experimentalToggleGroupControlOptionIcon,
            {
              icon: arrow_down_default,
              value: "vertical",
              label: (0, import_i18n11.__)("Vertical")
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/layouts/flow.js
  var import_i18n12 = __toESM(require_i18n());
  var flow_default = {
    name: "default",
    label: (0, import_i18n12.__)("Flow"),
    inspectorControls: function DefaultLayoutInspectorControls() {
      return null;
    },
    toolBarControls: function DefaultLayoutToolbarControls() {
      return null;
    },
    getLayoutStyle: function getLayoutStyle2({
      selector: selector3,
      style,
      blockName,
      hasBlockGapSupport,
      layoutDefinitions = LAYOUT_DEFINITIONS
    }) {
      const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap);
      let blockGapValue = "";
      if (!shouldSkipSerialization(blockName, "spacing", "blockGap")) {
        if (blockGapStyleValue?.top) {
          blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
        } else if (typeof blockGapStyleValue === "string") {
          blockGapValue = getGapCSSValue(blockGapStyleValue);
        }
      }
      let output = "";
      if (hasBlockGapSupport && blockGapValue) {
        output += getBlockGapCSS(
          selector3,
          layoutDefinitions,
          "default",
          blockGapValue
        );
      }
      return output;
    },
    getOrientation() {
      return "vertical";
    },
    getAlignments(layout, isBlockBasedTheme) {
      const alignmentInfo = getAlignmentsInfo(layout);
      if (layout.alignments !== void 0) {
        if (!layout.alignments.includes("none")) {
          layout.alignments.unshift("none");
        }
        return layout.alignments.map((alignment) => ({
          name: alignment,
          info: alignmentInfo[alignment]
        }));
      }
      const alignments = [
        { name: "left" },
        { name: "center" },
        { name: "right" }
      ];
      if (!isBlockBasedTheme) {
        const { contentSize, wideSize } = layout;
        if (contentSize) {
          alignments.unshift({ name: "full" });
        }
        if (wideSize) {
          alignments.unshift({
            name: "wide",
            info: alignmentInfo.wide
          });
        }
      }
      alignments.unshift({ name: "none", info: alignmentInfo.none });
      return alignments;
    }
  };

  // packages/block-editor/build-module/layouts/constrained.js
  var import_jsx_runtime124 = __toESM(require_jsx_runtime());
  var import_components13 = __toESM(require_components());
  var import_i18n13 = __toESM(require_i18n());
  var import_style_engine = __toESM(require_style_engine());
  var constrained_default = {
    name: "constrained",
    label: (0, import_i18n13.__)("Constrained"),
    inspectorControls: function DefaultLayoutInspectorControls2({
      layout,
      onChange,
      layoutBlockSupport = {}
    }) {
      const { wideSize, contentSize, justifyContent = "center" } = layout;
      const {
        allowJustification = true,
        allowCustomContentAndWideSize = true
      } = layoutBlockSupport;
      const onJustificationChange = (value) => {
        onChange({
          ...layout,
          justifyContent: value
        });
      };
      const justificationOptions = [
        {
          value: "left",
          icon: justify_left_default,
          label: (0, import_i18n13.__)("Justify items left")
        },
        {
          value: "center",
          icon: justify_center_default,
          label: (0, import_i18n13.__)("Justify items center")
        },
        {
          value: "right",
          icon: justify_right_default,
          label: (0, import_i18n13.__)("Justify items right")
        }
      ];
      const [availableUnits] = useSettings("spacing.units");
      const units2 = (0, import_components13.__experimentalUseCustomUnits)({
        availableUnits: availableUnits || ["%", "px", "em", "rem", "vw"]
      });
      return /* @__PURE__ */ (0, import_jsx_runtime124.jsxs)(
        import_components13.__experimentalVStack,
        {
          spacing: 4,
          className: "block-editor-hooks__layout-constrained",
          children: [
            allowCustomContentAndWideSize && /* @__PURE__ */ (0, import_jsx_runtime124.jsxs)(import_jsx_runtime124.Fragment, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
                import_components13.__experimentalUnitControl,
                {
                  __next40pxDefaultSize: true,
                  label: (0, import_i18n13.__)("Content width"),
                  labelPosition: "top",
                  value: contentSize || wideSize || "",
                  onChange: (nextWidth) => {
                    nextWidth = 0 > parseFloat(nextWidth) ? "0" : nextWidth;
                    onChange({
                      ...layout,
                      contentSize: nextWidth
                    });
                  },
                  units: units2,
                  prefix: /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(import_components13.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(icon_default, { icon: align_none_default }) })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
                import_components13.__experimentalUnitControl,
                {
                  __next40pxDefaultSize: true,
                  label: (0, import_i18n13.__)("Wide width"),
                  labelPosition: "top",
                  value: wideSize || contentSize || "",
                  onChange: (nextWidth) => {
                    nextWidth = 0 > parseFloat(nextWidth) ? "0" : nextWidth;
                    onChange({
                      ...layout,
                      wideSize: nextWidth
                    });
                  },
                  units: units2,
                  prefix: /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(import_components13.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(icon_default, { icon: stretch_wide_default }) })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime124.jsx)("p", { className: "block-editor-hooks__layout-constrained-helptext", children: (0, import_i18n13.__)(
                "Customize the width for all elements that are assigned to the center or wide columns."
              ) })
            ] }),
            allowJustification && /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
              import_components13.__experimentalToggleGroupControl,
              {
                __next40pxDefaultSize: true,
                __nextHasNoMarginBottom: true,
                label: (0, import_i18n13.__)("Justification"),
                value: justifyContent,
                onChange: onJustificationChange,
                children: justificationOptions.map(
                  ({ value, icon, label }) => {
                    return /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
                      import_components13.__experimentalToggleGroupControlOptionIcon,
                      {
                        value,
                        icon,
                        label
                      },
                      value
                    );
                  }
                )
              }
            )
          ]
        }
      );
    },
    toolBarControls: function DefaultLayoutToolbarControls2({
      layout = {},
      onChange,
      layoutBlockSupport
    }) {
      const { allowJustification = true } = layoutBlockSupport;
      if (!allowJustification) {
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
        DefaultLayoutJustifyContentControl,
        {
          layout,
          onChange
        }
      ) });
    },
    getLayoutStyle: function getLayoutStyle3({
      selector: selector3,
      layout = {},
      style,
      blockName,
      hasBlockGapSupport,
      layoutDefinitions = LAYOUT_DEFINITIONS
    }) {
      const { contentSize, wideSize, justifyContent } = layout;
      const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap);
      let blockGapValue = "";
      if (!shouldSkipSerialization(blockName, "spacing", "blockGap")) {
        if (blockGapStyleValue?.top) {
          blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
        } else if (typeof blockGapStyleValue === "string") {
          blockGapValue = getGapCSSValue(blockGapStyleValue);
        }
      }
      const marginLeft = justifyContent === "left" ? "0 !important" : "auto !important";
      const marginRight = justifyContent === "right" ? "0 !important" : "auto !important";
      let output = !!contentSize || !!wideSize ? `
					${appendSelectors(
        selector3,
        "> :where(:not(.alignleft):not(.alignright):not(.alignfull))"
      )} {
						max-width: ${contentSize ?? wideSize};
						margin-left: ${marginLeft};
						margin-right: ${marginRight};
					}
					${appendSelectors(selector3, "> .alignwide")}  {
						max-width: ${wideSize ?? contentSize};
					}
					${appendSelectors(selector3, "> .alignfull")} {
						max-width: none;
					}
				` : "";
      if (justifyContent === "left") {
        output += `${appendSelectors(
          selector3,
          "> :where(:not(.alignleft):not(.alignright):not(.alignfull))"
        )}
			{ margin-left: ${marginLeft}; }`;
      } else if (justifyContent === "right") {
        output += `${appendSelectors(
          selector3,
          "> :where(:not(.alignleft):not(.alignright):not(.alignfull))"
        )}
			{ margin-right: ${marginRight}; }`;
      }
      if (style?.spacing?.padding) {
        const paddingValues = (0, import_style_engine.getCSSRules)(style);
        paddingValues.forEach((rule) => {
          if (rule.key === "paddingRight") {
            const paddingRightValue = rule.value === "0" ? "0px" : rule.value;
            output += `
					${appendSelectors(selector3, "> .alignfull")} {
						margin-right: calc(${paddingRightValue} * -1);
					}
					`;
          } else if (rule.key === "paddingLeft") {
            const paddingLeftValue = rule.value === "0" ? "0px" : rule.value;
            output += `
					${appendSelectors(selector3, "> .alignfull")} {
						margin-left: calc(${paddingLeftValue} * -1);
					}
					`;
          }
        });
      }
      if (hasBlockGapSupport && blockGapValue) {
        output += getBlockGapCSS(
          selector3,
          layoutDefinitions,
          "constrained",
          blockGapValue
        );
      }
      return output;
    },
    getOrientation() {
      return "vertical";
    },
    getAlignments(layout) {
      const alignmentInfo = getAlignmentsInfo(layout);
      if (layout.alignments !== void 0) {
        if (!layout.alignments.includes("none")) {
          layout.alignments.unshift("none");
        }
        return layout.alignments.map((alignment) => ({
          name: alignment,
          info: alignmentInfo[alignment]
        }));
      }
      const { contentSize, wideSize } = layout;
      const alignments = [
        { name: "left" },
        { name: "center" },
        { name: "right" }
      ];
      if (contentSize) {
        alignments.unshift({ name: "full" });
      }
      if (wideSize) {
        alignments.unshift({ name: "wide", info: alignmentInfo.wide });
      }
      alignments.unshift({ name: "none", info: alignmentInfo.none });
      return alignments;
    }
  };
  var POPOVER_PROPS3 = {
    placement: "bottom-start"
  };
  function DefaultLayoutJustifyContentControl({ layout, onChange }) {
    const { justifyContent = "center" } = layout;
    const onJustificationChange = (value) => {
      onChange({
        ...layout,
        justifyContent: value
      });
    };
    const allowedControls = ["left", "center", "right"];
    return /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
      JustifyContentControl,
      {
        allowedControls,
        value: justifyContent,
        onChange: onJustificationChange,
        popoverProps: POPOVER_PROPS3
      }
    );
  }

  // packages/block-editor/build-module/layouts/grid.js
  var import_jsx_runtime125 = __toESM(require_jsx_runtime());
  var import_i18n14 = __toESM(require_i18n());
  var import_components15 = __toESM(require_components());
  var import_element16 = __toESM(require_element());
  var RANGE_CONTROL_MAX_VALUES = {
    px: 600,
    "%": 100,
    vw: 100,
    vh: 100,
    em: 38,
    rem: 38,
    svw: 100,
    lvw: 100,
    dvw: 100,
    svh: 100,
    lvh: 100,
    dvh: 100,
    vi: 100,
    svi: 100,
    lvi: 100,
    dvi: 100,
    vb: 100,
    svb: 100,
    lvb: 100,
    dvb: 100,
    vmin: 100,
    svmin: 100,
    lvmin: 100,
    dvmin: 100,
    vmax: 100,
    svmax: 100,
    lvmax: 100,
    dvmax: 100
  };
  var units = [
    { value: "px", label: "px", default: 0 },
    { value: "rem", label: "rem", default: 0 },
    { value: "em", label: "em", default: 0 }
  ];
  var grid_default2 = {
    name: "grid",
    label: (0, import_i18n14.__)("Grid"),
    inspectorControls: function GridLayoutInspectorControls({
      layout = {},
      onChange,
      layoutBlockSupport = {}
    }) {
      const { allowSizingOnChildren = false } = layoutBlockSupport;
      const showColumnsControl = window.__experimentalEnableGridInteractivity || !!layout?.columnCount;
      const showMinWidthControl = window.__experimentalEnableGridInteractivity || !layout?.columnCount;
      return /* @__PURE__ */ (0, import_jsx_runtime125.jsxs)(import_jsx_runtime125.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
          GridLayoutTypeControl,
          {
            layout,
            onChange
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime125.jsxs)(import_components15.__experimentalVStack, { spacing: 4, children: [
          showColumnsControl && /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
            GridLayoutColumnsAndRowsControl,
            {
              layout,
              onChange,
              allowSizingOnChildren
            }
          ),
          showMinWidthControl && /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
            GridLayoutMinimumWidthControl,
            {
              layout,
              onChange
            }
          )
        ] })
      ] });
    },
    toolBarControls: function GridLayoutToolbarControls() {
      return null;
    },
    getLayoutStyle: function getLayoutStyle4({
      selector: selector3,
      layout,
      style,
      blockName,
      hasBlockGapSupport,
      layoutDefinitions = LAYOUT_DEFINITIONS
    }) {
      const {
        minimumColumnWidth = null,
        columnCount = null,
        rowCount = null
      } = layout;
      if (true) {
        if (minimumColumnWidth && typeof minimumColumnWidth !== "string") {
          throw new Error("minimumColumnWidth must be a string");
        }
        if (columnCount && typeof columnCount !== "number") {
          throw new Error("columnCount must be a number");
        }
        if (rowCount && typeof rowCount !== "number") {
          throw new Error("rowCount must be a number");
        }
      }
      const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, "spacing", "blockGap") ? getGapCSSValue(style?.spacing?.blockGap, "0.5em") : void 0;
      let output = "";
      const rules = [];
      if (minimumColumnWidth && columnCount > 0) {
        const maxValue = `max(${minimumColumnWidth}, ( 100% - (${blockGapValue || "1.2rem"}*${columnCount - 1}) ) / ${columnCount})`;
        rules.push(
          `grid-template-columns: repeat(auto-fill, minmax(${maxValue}, 1fr))`,
          `container-type: inline-size`
        );
        if (rowCount) {
          rules.push(
            `grid-template-rows: repeat(${rowCount}, minmax(1rem, auto))`
          );
        }
      } else if (columnCount) {
        rules.push(
          `grid-template-columns: repeat(${columnCount}, minmax(0, 1fr))`
        );
        if (rowCount) {
          rules.push(
            `grid-template-rows: repeat(${rowCount}, minmax(1rem, auto))`
          );
        }
      } else {
        rules.push(
          `grid-template-columns: repeat(auto-fill, minmax(min(${minimumColumnWidth || "12rem"}, 100%), 1fr))`,
          "container-type: inline-size"
        );
      }
      if (rules.length) {
        output = `${appendSelectors(selector3)} { ${rules.join(
          "; "
        )}; }`;
      }
      if (hasBlockGapSupport && blockGapValue) {
        output += getBlockGapCSS(
          selector3,
          layoutDefinitions,
          "grid",
          blockGapValue
        );
      }
      return output;
    },
    getOrientation() {
      return "horizontal";
    },
    getAlignments() {
      return [];
    }
  };
  function GridLayoutMinimumWidthControl({ layout, onChange }) {
    const { minimumColumnWidth, columnCount, isManualPlacement } = layout;
    const defaultValue = isManualPlacement || columnCount ? null : "12rem";
    const value = minimumColumnWidth || defaultValue;
    const [quantity, unit = "rem"] = (0, import_components15.__experimentalParseQuantityAndUnitFromRawValue)(value);
    const handleSliderChange = (next2) => {
      onChange({
        ...layout,
        minimumColumnWidth: [next2, unit].join("")
      });
    };
    const handleUnitChange = (newUnit) => {
      let newValue;
      if (["em", "rem"].includes(newUnit) && unit === "px") {
        newValue = (quantity / 16).toFixed(2) + newUnit;
      } else if (["em", "rem"].includes(unit) && newUnit === "px") {
        newValue = Math.round(quantity * 16) + newUnit;
      }
      onChange({
        ...layout,
        minimumColumnWidth: newValue
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime125.jsxs)("fieldset", { className: "block-editor-hooks__grid-layout-minimum-width-control", children: [
      /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(import_components15.BaseControl.VisualLabel, { as: "legend", children: (0, import_i18n14.__)("Minimum column width") }),
      /* @__PURE__ */ (0, import_jsx_runtime125.jsxs)(import_components15.Flex, { gap: 4, children: [
        /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(import_components15.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
          import_components15.__experimentalUnitControl,
          {
            size: "__unstable-large",
            onChange: (newValue) => {
              onChange({
                ...layout,
                minimumColumnWidth: newValue === "" ? void 0 : newValue
              });
            },
            onUnitChange: handleUnitChange,
            value,
            units,
            min: 0,
            label: (0, import_i18n14.__)("Minimum column width"),
            hideLabelFromVision: true
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(import_components15.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
          import_components15.RangeControl,
          {
            __next40pxDefaultSize: true,
            __nextHasNoMarginBottom: true,
            onChange: handleSliderChange,
            value: quantity || 0,
            min: 0,
            max: RANGE_CONTROL_MAX_VALUES[unit] || 600,
            withInputField: false,
            label: (0, import_i18n14.__)("Minimum column width"),
            hideLabelFromVision: true
          }
        ) })
      ] })
    ] });
  }
  function GridLayoutColumnsAndRowsControl({
    layout,
    onChange,
    allowSizingOnChildren
  }) {
    const defaultColumnCount = window.__experimentalEnableGridInteractivity ? void 0 : 3;
    const {
      columnCount = defaultColumnCount,
      rowCount,
      isManualPlacement
    } = layout;
    return /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(import_jsx_runtime125.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime125.jsxs)("fieldset", { className: "block-editor-hooks__grid-layout-columns-and-rows-controls", children: [
      (!window.__experimentalEnableGridInteractivity || !isManualPlacement) && /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(import_components15.BaseControl.VisualLabel, { as: "legend", children: (0, import_i18n14.__)("Columns") }),
      /* @__PURE__ */ (0, import_jsx_runtime125.jsxs)(import_components15.Flex, { gap: 4, children: [
        /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(import_components15.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
          import_components15.__experimentalNumberControl,
          {
            size: "__unstable-large",
            onChange: (value) => {
              if (window.__experimentalEnableGridInteractivity) {
                const defaultNewColumnCount = isManualPlacement ? 1 : void 0;
                const newColumnCount = value === "" || value === "0" ? defaultNewColumnCount : parseInt(value, 10);
                onChange({
                  ...layout,
                  columnCount: newColumnCount
                });
              } else {
                const newColumnCount = value === "" || value === "0" ? 1 : parseInt(value, 10);
                onChange({
                  ...layout,
                  columnCount: newColumnCount
                });
              }
            },
            value: columnCount,
            min: 1,
            label: (0, import_i18n14.__)("Columns"),
            hideLabelFromVision: !window.__experimentalEnableGridInteractivity || !isManualPlacement
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(import_components15.FlexItem, { isBlock: true, children: window.__experimentalEnableGridInteractivity && allowSizingOnChildren && isManualPlacement ? /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
          import_components15.__experimentalNumberControl,
          {
            size: "__unstable-large",
            onChange: (value) => {
              const newRowCount = value === "" || value === "0" ? 1 : parseInt(value, 10);
              onChange({
                ...layout,
                rowCount: newRowCount
              });
            },
            value: rowCount,
            min: 1,
            label: (0, import_i18n14.__)("Rows")
          }
        ) : /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
          import_components15.RangeControl,
          {
            __next40pxDefaultSize: true,
            __nextHasNoMarginBottom: true,
            value: columnCount ?? 1,
            onChange: (value) => onChange({
              ...layout,
              columnCount: value === "" || value === "0" ? 1 : value
            }),
            min: 1,
            max: 16,
            withInputField: false,
            label: (0, import_i18n14.__)("Columns"),
            hideLabelFromVision: true
          }
        ) })
      ] })
    ] }) });
  }
  function GridLayoutTypeControl({ layout, onChange }) {
    const { columnCount, rowCount, minimumColumnWidth, isManualPlacement } = layout;
    const [tempColumnCount, setTempColumnCount] = (0, import_element16.useState)(
      columnCount || 3
    );
    const [tempRowCount, setTempRowCount] = (0, import_element16.useState)(rowCount);
    const [tempMinimumColumnWidth, setTempMinimumColumnWidth] = (0, import_element16.useState)(
      minimumColumnWidth || "12rem"
    );
    const gridPlacement = isManualPlacement || !!columnCount && !window.__experimentalEnableGridInteractivity ? "manual" : "auto";
    const onChangeType = (value) => {
      if (value === "manual") {
        setTempMinimumColumnWidth(minimumColumnWidth || "12rem");
      } else {
        setTempColumnCount(columnCount || 3);
        setTempRowCount(rowCount);
      }
      onChange({
        ...layout,
        columnCount: value === "manual" ? tempColumnCount : null,
        rowCount: value === "manual" && window.__experimentalEnableGridInteractivity ? tempRowCount : void 0,
        isManualPlacement: value === "manual" && window.__experimentalEnableGridInteractivity ? true : void 0,
        minimumColumnWidth: value === "auto" ? tempMinimumColumnWidth : null
      });
    };
    const helpText2 = gridPlacement === "manual" ? (0, import_i18n14.__)(
      "Grid items can be manually placed in any position on the grid."
    ) : (0, import_i18n14.__)(
      "Grid items are placed automatically depending on their order."
    );
    return /* @__PURE__ */ (0, import_jsx_runtime125.jsxs)(
      import_components15.__experimentalToggleGroupControl,
      {
        __next40pxDefaultSize: true,
        __nextHasNoMarginBottom: true,
        label: (0, import_i18n14.__)("Grid item position"),
        value: gridPlacement,
        onChange: onChangeType,
        isBlock: true,
        help: window.__experimentalEnableGridInteractivity ? helpText2 : void 0,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
            import_components15.__experimentalToggleGroupControlOption,
            {
              value: "auto",
              label: (0, import_i18n14.__)("Auto")
            },
            "auto"
          ),
          /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
            import_components15.__experimentalToggleGroupControlOption,
            {
              value: "manual",
              label: (0, import_i18n14.__)("Manual")
            },
            "manual"
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/layouts/index.js
  var layoutTypes = [flow_default, flex_default, constrained_default, grid_default2];
  function getLayoutType(name = "default") {
    return layoutTypes.find((layoutType) => layoutType.name === name);
  }
  function getLayoutTypes() {
    return layoutTypes;
  }

  // packages/block-editor/build-module/components/block-list/layout.js
  var defaultLayout = { type: "default" };
  var Layout = (0, import_element17.createContext)(defaultLayout);
  Layout.displayName = "BlockLayoutContext";
  var LayoutProvider = Layout.Provider;
  function useLayout() {
    return (0, import_element17.useContext)(Layout);
  }
  function LayoutStyle({ layout = {}, css, ...props }) {
    const layoutType = getLayoutType(layout.type);
    const [blockGapSupport] = useSettings("spacing.blockGap");
    const hasBlockGapSupport = blockGapSupport !== null;
    if (layoutType) {
      if (css) {
        return /* @__PURE__ */ (0, import_jsx_runtime126.jsx)("style", { children: css });
      }
      const layoutStyle = layoutType.getLayoutStyle?.({
        hasBlockGapSupport,
        layout,
        ...props
      });
      if (layoutStyle) {
        return /* @__PURE__ */ (0, import_jsx_runtime126.jsx)("style", { children: layoutStyle });
      }
    }
    return null;
  }

  // packages/block-editor/build-module/components/block-alignment-control/use-available-alignments.js
  var EMPTY_ARRAY4 = [];
  var DEFAULT_CONTROLS = ["none", "left", "center", "right", "wide", "full"];
  var WIDE_CONTROLS = ["wide", "full"];
  function useAvailableAlignments(controls = DEFAULT_CONTROLS) {
    if (!controls.includes("none")) {
      controls = ["none", ...controls];
    }
    const isNoneOnly = controls.length === 1 && controls[0] === "none";
    const [wideControlsEnabled, themeSupportsLayout, isBlockBasedTheme] = (0, import_data12.useSelect)(
      (select2) => {
        if (isNoneOnly) {
          return [false, false, false];
        }
        const settings2 = select2(store).getSettings();
        return [
          settings2.alignWide ?? false,
          settings2.supportsLayout,
          settings2.__unstableIsBlockBasedTheme
        ];
      },
      [isNoneOnly]
    );
    const layout = useLayout();
    if (isNoneOnly) {
      return EMPTY_ARRAY4;
    }
    const layoutType = getLayoutType(layout?.type);
    if (themeSupportsLayout) {
      const layoutAlignments = layoutType.getAlignments(
        layout,
        isBlockBasedTheme
      );
      const alignments2 = layoutAlignments.filter(
        (alignment) => controls.includes(alignment.name)
      );
      if (alignments2.length === 1 && alignments2[0].name === "none") {
        return EMPTY_ARRAY4;
      }
      return alignments2;
    }
    if (layoutType.name !== "default" && layoutType.name !== "constrained") {
      return EMPTY_ARRAY4;
    }
    const alignments = controls.filter((control) => {
      if (layout.alignments) {
        return layout.alignments.includes(control);
      }
      if (!wideControlsEnabled && WIDE_CONTROLS.includes(control)) {
        return false;
      }
      return DEFAULT_CONTROLS.includes(control);
    }).map((name) => ({ name }));
    if (alignments.length === 1 && alignments[0].name === "none") {
      return EMPTY_ARRAY4;
    }
    return alignments;
  }

  // packages/block-editor/build-module/components/block-alignment-control/constants.js
  var import_i18n15 = __toESM(require_i18n());
  var BLOCK_ALIGNMENTS_CONTROLS = {
    none: {
      icon: align_none_default,
      title: (0, import_i18n15._x)("None", "Alignment option")
    },
    left: {
      icon: position_left_default,
      title: (0, import_i18n15.__)("Align left")
    },
    center: {
      icon: position_center_default,
      title: (0, import_i18n15.__)("Align center")
    },
    right: {
      icon: position_right_default,
      title: (0, import_i18n15.__)("Align right")
    },
    wide: {
      icon: stretch_wide_default,
      title: (0, import_i18n15.__)("Wide width")
    },
    full: {
      icon: stretch_full_width_default,
      title: (0, import_i18n15.__)("Full width")
    }
  };
  var DEFAULT_CONTROL = "none";

  // packages/block-editor/build-module/components/block-alignment-control/ui.js
  function BlockAlignmentUI({
    value,
    onChange,
    controls,
    isToolbar,
    isCollapsed: isCollapsed3 = true
  }) {
    const enabledControls = useAvailableAlignments(controls);
    const hasEnabledControls = !!enabledControls.length;
    if (!hasEnabledControls) {
      return null;
    }
    function onChangeAlignment(align) {
      onChange([value, "none"].includes(align) ? void 0 : align);
    }
    const activeAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[value];
    const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[DEFAULT_CONTROL];
    const UIComponent = isToolbar ? import_components16.ToolbarGroup : import_components16.ToolbarDropdownMenu;
    const commonProps = {
      icon: activeAlignmentControl ? activeAlignmentControl.icon : defaultAlignmentControl.icon,
      label: (0, import_i18n16.__)("Align")
    };
    const extraProps = isToolbar ? {
      isCollapsed: isCollapsed3,
      controls: enabledControls.map(({ name: controlName }) => {
        return {
          ...BLOCK_ALIGNMENTS_CONTROLS[controlName],
          isActive: value === controlName || !value && controlName === "none",
          role: isCollapsed3 ? "menuitemradio" : void 0,
          onClick: () => onChangeAlignment(controlName)
        };
      })
    } : {
      toggleProps: { description: (0, import_i18n16.__)("Change alignment") },
      children: ({ onClose }) => {
        return /* @__PURE__ */ (0, import_jsx_runtime127.jsx)(import_jsx_runtime127.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime127.jsx)(import_components16.MenuGroup, { className: "block-editor-block-alignment-control__menu-group", children: enabledControls.map(
          ({ name: controlName, info }) => {
            const { icon, title } = BLOCK_ALIGNMENTS_CONTROLS[controlName];
            const isSelected = controlName === value || !value && controlName === "none";
            return /* @__PURE__ */ (0, import_jsx_runtime127.jsx)(
              import_components16.MenuItem,
              {
                icon,
                iconPosition: "left",
                className: clsx_default(
                  "components-dropdown-menu__menu-item",
                  {
                    "is-active": isSelected
                  }
                ),
                isSelected,
                onClick: () => {
                  onChangeAlignment(
                    controlName
                  );
                  onClose();
                },
                role: "menuitemradio",
                info,
                children: title
              },
              controlName
            );
          }
        ) }) });
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime127.jsx)(UIComponent, { ...commonProps, ...extraProps });
  }
  var ui_default2 = BlockAlignmentUI;

  // packages/block-editor/build-module/components/block-alignment-control/index.js
  var BlockAlignmentControl = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime128.jsx)(ui_default2, { ...props, isToolbar: false });
  };
  var BlockAlignmentToolbar = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime128.jsx)(ui_default2, { ...props, isToolbar: true });
  };

  // packages/block-editor/build-module/components/block-full-height-alignment-control/index.js
  var import_jsx_runtime129 = __toESM(require_jsx_runtime());
  var import_i18n17 = __toESM(require_i18n());
  var import_components17 = __toESM(require_components());
  function BlockFullHeightAlignmentControl({
    isActive,
    label = (0, import_i18n17.__)("Full height"),
    onToggle,
    isDisabled
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime129.jsx)(
      import_components17.ToolbarButton,
      {
        isActive,
        icon: fullscreen_default,
        label,
        onClick: () => onToggle(!isActive),
        disabled: isDisabled
      }
    );
  }
  var block_full_height_alignment_control_default = BlockFullHeightAlignmentControl;

  // packages/block-editor/build-module/components/block-alignment-matrix-control/index.js
  var import_jsx_runtime130 = __toESM(require_jsx_runtime());
  var import_i18n18 = __toESM(require_i18n());
  var import_keycodes = __toESM(require_keycodes());
  var import_components18 = __toESM(require_components());
  var noop2 = () => {
  };
  function BlockAlignmentMatrixControl(props) {
    const {
      label = (0, import_i18n18.__)("Change matrix alignment"),
      onChange = noop2,
      value = "center",
      isDisabled
    } = props;
    const icon = /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(import_components18.AlignmentMatrixControl.Icon, { value });
    return /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
      import_components18.Dropdown,
      {
        popoverProps: { placement: "bottom-start" },
        renderToggle: ({ onToggle, isOpen }) => {
          const openOnArrowDown = (event) => {
            if (!isOpen && event.keyCode === import_keycodes.DOWN) {
              event.preventDefault();
              onToggle();
            }
          };
          return /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
            import_components18.ToolbarButton,
            {
              onClick: onToggle,
              "aria-haspopup": "true",
              "aria-expanded": isOpen,
              onKeyDown: openOnArrowDown,
              label,
              icon,
              showTooltip: true,
              disabled: isDisabled
            }
          );
        },
        renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
          import_components18.AlignmentMatrixControl,
          {
            hasFocusBorder: false,
            onChange,
            value
          }
        )
      }
    );
  }
  var block_alignment_matrix_control_default = BlockAlignmentMatrixControl;

  // packages/block-editor/build-module/components/block-breadcrumb/index.js
  var import_jsx_runtime132 = __toESM(require_jsx_runtime());
  var import_components19 = __toESM(require_components());
  var import_data14 = __toESM(require_data());
  var import_i18n19 = __toESM(require_i18n());
  var import_element20 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-title/use-block-display-title.js
  var import_data13 = __toESM(require_data());
  var import_blocks13 = __toESM(require_blocks());
  function useBlockDisplayTitle({
    clientId,
    maximumLength,
    context
  }) {
    const blockTitle = (0, import_data13.useSelect)(
      (select2) => {
        if (!clientId) {
          return null;
        }
        const { getBlockName: getBlockName2, getBlockAttributes: getBlockAttributes3 } = select2(store);
        const { getBlockType: getBlockType21, getActiveBlockVariation } = select2(import_blocks13.store);
        const blockName = getBlockName2(clientId);
        const blockType = getBlockType21(blockName);
        if (!blockType) {
          return null;
        }
        const attributes = getBlockAttributes3(clientId);
        const label = (0, import_blocks13.__experimentalGetBlockLabel)(blockType, attributes, context);
        if (label !== blockType.title) {
          return label;
        }
        const match2 = getActiveBlockVariation(blockName, attributes);
        return match2?.title || blockType.title;
      },
      [clientId, context]
    );
    if (!blockTitle) {
      return null;
    }
    if (maximumLength && maximumLength > 0 && blockTitle.length > maximumLength) {
      const omission = "...";
      return blockTitle.slice(0, maximumLength - omission.length) + omission;
    }
    return blockTitle;
  }

  // packages/block-editor/build-module/components/block-title/index.js
  function BlockTitle({ clientId, maximumLength, context }) {
    return useBlockDisplayTitle({ clientId, maximumLength, context });
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js
  var import_element19 = __toESM(require_element());
  var import_compose5 = __toESM(require_compose());

  // packages/block-editor/build-module/components/provider/block-refs-provider.js
  var import_jsx_runtime131 = __toESM(require_jsx_runtime());
  var import_element18 = __toESM(require_element());
  var import_compose4 = __toESM(require_compose());
  var BlockRefs = (0, import_element18.createContext)({ refsMap: (0, import_compose4.observableMap)() });
  BlockRefs.displayName = "BlockRefsContext";
  function BlockRefsProvider({ children }) {
    const value = (0, import_element18.useMemo)(() => ({ refsMap: (0, import_compose4.observableMap)() }), []);
    return /* @__PURE__ */ (0, import_jsx_runtime131.jsx)(BlockRefs.Provider, { value, children });
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js
  function useBlockRefProvider(clientId) {
    const { refsMap } = (0, import_element19.useContext)(BlockRefs);
    return (0, import_compose5.useRefEffect)(
      (element) => {
        refsMap.set(clientId, element);
        return () => refsMap.delete(clientId);
      },
      [clientId]
    );
  }
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }
  function useBlockElementRef(clientId, ref) {
    const { refsMap } = (0, import_element19.useContext)(BlockRefs);
    (0, import_element19.useLayoutEffect)(() => {
      assignRef(ref, refsMap.get(clientId));
      const unsubscribe = refsMap.subscribe(
        clientId,
        () => assignRef(ref, refsMap.get(clientId))
      );
      return () => {
        unsubscribe();
        assignRef(ref, null);
      };
    }, [refsMap, clientId, ref]);
  }
  function useBlockElement(clientId) {
    const [blockElement, setBlockElement] = (0, import_element19.useState)(null);
    useBlockElementRef(clientId, setBlockElement);
    return blockElement;
  }

  // packages/block-editor/build-module/utils/get-editor-region.js
  function getEditorRegion(editor) {
    if (!editor) {
      return null;
    }
    const editorCanvas = Array.from(
      document.querySelectorAll('iframe[name="editor-canvas"]').values()
    ).find((iframe) => {
      const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
      return iframeDocument === editor.ownerDocument;
    }) ?? editor;
    return editorCanvas?.closest('[role="region"]') ?? editorCanvas;
  }

  // packages/block-editor/build-module/components/block-breadcrumb/index.js
  function BlockBreadcrumb({ rootLabelText }) {
    const { selectBlock: selectBlock2, clearSelectedBlock: clearSelectedBlock2 } = (0, import_data14.useDispatch)(store);
    const { clientId, parents, hasSelection } = (0, import_data14.useSelect)((select2) => {
      const {
        getSelectionStart: getSelectionStart2,
        getSelectedBlockClientId: getSelectedBlockClientId2,
        getEnabledBlockParents: getEnabledBlockParents2
      } = unlock(select2(store));
      const selectedBlockClientId = getSelectedBlockClientId2();
      return {
        parents: getEnabledBlockParents2(selectedBlockClientId),
        clientId: selectedBlockClientId,
        hasSelection: !!getSelectionStart2().clientId
      };
    }, []);
    const rootLabel = rootLabelText || (0, import_i18n19.__)("Document");
    const blockRef = (0, import_element20.useRef)();
    useBlockElementRef(clientId, blockRef);
    return /* @__PURE__ */ (0, import_jsx_runtime132.jsxs)(
      "ul",
      {
        className: "block-editor-block-breadcrumb",
        role: "list",
        "aria-label": (0, import_i18n19.__)("Block breadcrumb"),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime132.jsxs)(
            "li",
            {
              className: !hasSelection ? "block-editor-block-breadcrumb__current" : void 0,
              "aria-current": !hasSelection ? "true" : void 0,
              children: [
                hasSelection && /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
                  import_components19.Button,
                  {
                    size: "small",
                    className: "block-editor-block-breadcrumb__button",
                    onClick: () => {
                      const blockEditor = blockRef.current?.closest(
                        ".editor-styles-wrapper"
                      );
                      clearSelectedBlock2();
                      getEditorRegion(blockEditor)?.focus();
                    },
                    children: rootLabel
                  }
                ),
                !hasSelection && /* @__PURE__ */ (0, import_jsx_runtime132.jsx)("span", { children: rootLabel }),
                !!clientId && /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
                  icon_default,
                  {
                    icon: chevron_right_small_default,
                    className: "block-editor-block-breadcrumb__separator"
                  }
                )
              ]
            }
          ),
          parents.map((parentClientId) => /* @__PURE__ */ (0, import_jsx_runtime132.jsxs)("li", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
              import_components19.Button,
              {
                size: "small",
                className: "block-editor-block-breadcrumb__button",
                onClick: () => selectBlock2(parentClientId),
                children: /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
                  BlockTitle,
                  {
                    clientId: parentClientId,
                    maximumLength: 35
                  }
                )
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
              icon_default,
              {
                icon: chevron_right_small_default,
                className: "block-editor-block-breadcrumb__separator"
              }
            )
          ] }, parentClientId)),
          !!clientId && /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
            "li",
            {
              className: "block-editor-block-breadcrumb__current",
              "aria-current": "true",
              children: /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(BlockTitle, { clientId, maximumLength: 35 })
            }
          )
        ]
      }
    );
  }
  var block_breadcrumb_default = BlockBreadcrumb;

  // packages/block-editor/build-module/components/block-content-overlay/index.js
  var import_data15 = __toESM(require_data());
  function useBlockOverlayActive(clientId) {
    return (0, import_data15.useSelect)(
      (select2) => {
        const { __unstableHasActiveBlockOverlayActive: __unstableHasActiveBlockOverlayActive2 } = select2(store);
        return __unstableHasActiveBlockOverlayActive2(clientId);
      },
      [clientId]
    );
  }

  // packages/block-editor/build-module/components/block-canvas/index.js
  var import_jsx_runtime288 = __toESM(require_jsx_runtime());
  var import_compose70 = __toESM(require_compose());
  var import_element155 = __toESM(require_element());
  var import_data128 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-list/index.js
  var import_jsx_runtime197 = __toESM(require_jsx_runtime());
  var import_data73 = __toESM(require_data());
  var import_compose53 = __toESM(require_compose());
  var import_element87 = __toESM(require_element());
  var import_blocks40 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/block-list/block.js
  var import_jsx_runtime138 = __toESM(require_jsx_runtime());
  var import_element29 = __toESM(require_element());
  var import_blocks18 = __toESM(require_blocks());
  var import_components22 = __toESM(require_components());
  var import_data23 = __toESM(require_data());
  var import_compose14 = __toESM(require_compose());
  var import_dom7 = __toESM(require_dom());

  // packages/block-editor/build-module/components/block-list/block-invalid-warning.js
  var import_jsx_runtime135 = __toESM(require_jsx_runtime());
  var import_i18n21 = __toESM(require_i18n());
  var import_components21 = __toESM(require_components());
  var import_element22 = __toESM(require_element());
  var import_blocks15 = __toESM(require_blocks());
  var import_data16 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-compare/index.js
  var import_jsx_runtime134 = __toESM(require_jsx_runtime());
  var import_character = __toESM(require_character());
  var import_i18n20 = __toESM(require_i18n());
  var import_blocks14 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/block-compare/block-view.js
  var import_jsx_runtime133 = __toESM(require_jsx_runtime());
  var import_components20 = __toESM(require_components());
  var import_element21 = __toESM(require_element());
  var import_dom = __toESM(require_dom());
  function BlockView({
    title,
    rawContent,
    renderedContent,
    action,
    actionText,
    className
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime133.jsxs)("div", { className, children: [
      /* @__PURE__ */ (0, import_jsx_runtime133.jsxs)("div", { className: "block-editor-block-compare__content", children: [
        /* @__PURE__ */ (0, import_jsx_runtime133.jsx)("h2", { className: "block-editor-block-compare__heading", children: title }),
        /* @__PURE__ */ (0, import_jsx_runtime133.jsx)("div", { className: "block-editor-block-compare__html", children: rawContent }),
        /* @__PURE__ */ (0, import_jsx_runtime133.jsx)("div", { className: "block-editor-block-compare__preview edit-post-visual-editor", children: /* @__PURE__ */ (0, import_jsx_runtime133.jsx)(import_element21.RawHTML, { children: (0, import_dom.safeHTML)(renderedContent) }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime133.jsx)("div", { className: "block-editor-block-compare__action", children: /* @__PURE__ */ (0, import_jsx_runtime133.jsx)(
        import_components20.Button,
        {
          __next40pxDefaultSize: true,
          variant: "secondary",
          tabIndex: "0",
          onClick: action,
          children: actionText
        }
      ) })
    ] });
  }

  // packages/block-editor/build-module/components/block-compare/index.js
  function BlockCompare({
    block,
    onKeep,
    onConvert,
    convertor,
    convertButtonText
  }) {
    function getDifference(originalContent, newContent) {
      const difference2 = (0, import_character.diffChars)(originalContent, newContent);
      return difference2.map((item, pos) => {
        const classes = clsx_default({
          "block-editor-block-compare__added": item.added,
          "block-editor-block-compare__removed": item.removed
        });
        return /* @__PURE__ */ (0, import_jsx_runtime134.jsx)("span", { className: classes, children: item.value }, pos);
      });
    }
    function getConvertedContent(convertedBlock) {
      const newBlocks = Array.isArray(convertedBlock) ? convertedBlock : [convertedBlock];
      const newContent = newBlocks.map(
        (item) => (0, import_blocks14.getSaveContent)(item.name, item.attributes, item.innerBlocks)
      );
      return newContent.join("");
    }
    const converted = getConvertedContent(convertor(block));
    const difference = getDifference(block.originalContent, converted);
    return /* @__PURE__ */ (0, import_jsx_runtime134.jsxs)("div", { className: "block-editor-block-compare__wrapper", children: [
      /* @__PURE__ */ (0, import_jsx_runtime134.jsx)(
        BlockView,
        {
          title: (0, import_i18n20.__)("Current"),
          className: "block-editor-block-compare__current",
          action: onKeep,
          actionText: (0, import_i18n20.__)("Convert to HTML"),
          rawContent: block.originalContent,
          renderedContent: block.originalContent
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime134.jsx)(
        BlockView,
        {
          title: (0, import_i18n20.__)("After Conversion"),
          className: "block-editor-block-compare__converted",
          action: onConvert,
          actionText: convertButtonText,
          rawContent: difference,
          renderedContent: converted
        }
      )
    ] });
  }
  var block_compare_default = BlockCompare;

  // packages/block-editor/build-module/components/block-list/block-invalid-warning.js
  var blockToBlocks = (block) => (0, import_blocks15.rawHandler)({
    HTML: block.originalContent
  });
  function BlockInvalidWarning({ clientId }) {
    const { block, canInsertHTMLBlock, canInsertClassicBlock } = (0, import_data16.useSelect)(
      (select2) => {
        const { canInsertBlockType: canInsertBlockType2, getBlock: getBlock2, getBlockRootClientId: getBlockRootClientId2 } = select2(store);
        const rootClientId = getBlockRootClientId2(clientId);
        return {
          block: getBlock2(clientId),
          canInsertHTMLBlock: canInsertBlockType2(
            "core/html",
            rootClientId
          ),
          canInsertClassicBlock: canInsertBlockType2(
            "core/freeform",
            rootClientId
          )
        };
      },
      [clientId]
    );
    const { replaceBlock: replaceBlock2 } = (0, import_data16.useDispatch)(store);
    const [compare2, setCompare] = (0, import_element22.useState)(false);
    const onCompareClose = (0, import_element22.useCallback)(() => setCompare(false), []);
    const convert = (0, import_element22.useMemo)(
      () => ({
        toClassic() {
          const classicBlock = (0, import_blocks15.createBlock)("core/freeform", {
            content: block.originalContent
          });
          return replaceBlock2(block.clientId, classicBlock);
        },
        toHTML() {
          const htmlBlock = (0, import_blocks15.createBlock)("core/html", {
            content: block.originalContent
          });
          return replaceBlock2(block.clientId, htmlBlock);
        },
        toBlocks() {
          const newBlocks = blockToBlocks(block);
          return replaceBlock2(block.clientId, newBlocks);
        },
        toRecoveredBlock() {
          const recoveredBlock = (0, import_blocks15.createBlock)(
            block.name,
            block.attributes,
            block.innerBlocks
          );
          return replaceBlock2(block.clientId, recoveredBlock);
        }
      }),
      [block, replaceBlock2]
    );
    const secondaryActions = (0, import_element22.useMemo)(
      () => [
        {
          // translators: Button to fix block content
          title: (0, import_i18n21._x)("Resolve", "imperative verb"),
          onClick: () => setCompare(true)
        },
        canInsertHTMLBlock && {
          title: (0, import_i18n21.__)("Convert to HTML"),
          onClick: convert.toHTML
        },
        canInsertClassicBlock && {
          title: (0, import_i18n21.__)("Convert to Classic Block"),
          onClick: convert.toClassic
        }
      ].filter(Boolean),
      [canInsertHTMLBlock, canInsertClassicBlock, convert]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(import_jsx_runtime135.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
        warning_default,
        {
          actions: [
            /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
              import_components21.Button,
              {
                __next40pxDefaultSize: true,
                onClick: convert.toRecoveredBlock,
                variant: "primary",
                children: (0, import_i18n21.__)("Attempt recovery")
              },
              "recover"
            )
          ],
          secondaryActions,
          children: (0, import_i18n21.__)("Block contains unexpected or invalid content.")
        }
      ),
      compare2 && /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
        import_components21.Modal,
        {
          title: (
            // translators: Dialog title to fix block content
            (0, import_i18n21.__)("Resolve Block")
          ),
          onRequestClose: onCompareClose,
          className: "block-editor-block-compare",
          children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
            block_compare_default,
            {
              block,
              onKeep: convert.toHTML,
              onConvert: convert.toBlocks,
              convertor: blockToBlocks,
              convertButtonText: (0, import_i18n21.__)("Convert to Blocks")
            }
          )
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/block-list/block-crash-warning.js
  var import_jsx_runtime136 = __toESM(require_jsx_runtime());
  var import_i18n22 = __toESM(require_i18n());
  var warning = /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(warning_default, { className: "block-editor-block-list__block-crash-warning", children: (0, import_i18n22.__)("This block has encountered an error and cannot be previewed.") });
  var block_crash_warning_default = () => warning;

  // packages/block-editor/build-module/components/block-list/block-crash-boundary.js
  var import_element23 = __toESM(require_element());
  var BlockCrashBoundary = class extends import_element23.Component {
    constructor() {
      super(...arguments);
      this.state = {
        hasError: false
      };
    }
    componentDidCatch() {
      this.setState({
        hasError: true
      });
    }
    render() {
      if (this.state.hasError) {
        return this.props.fallback;
      }
      return this.props.children;
    }
  };
  var block_crash_boundary_default = BlockCrashBoundary;

  // packages/block-editor/build-module/components/block-list/block-html.js
  var import_jsx_runtime137 = __toESM(require_jsx_runtime());
  var import_react_autosize_textarea = __toESM(require_lib());
  var import_element24 = __toESM(require_element());
  var import_data17 = __toESM(require_data());
  var import_blocks16 = __toESM(require_blocks());
  function BlockHTML({ clientId }) {
    const [html, setHtml] = (0, import_element24.useState)("");
    const block = (0, import_data17.useSelect)(
      (select2) => select2(store).getBlock(clientId),
      [clientId]
    );
    const { updateBlock: updateBlock2 } = (0, import_data17.useDispatch)(store);
    const onChange = () => {
      const blockType = (0, import_blocks16.getBlockType)(block.name);
      if (!blockType) {
        return;
      }
      const attributes = (0, import_blocks16.getBlockAttributes)(
        blockType,
        html,
        block.attributes
      );
      const content = html ? html : (0, import_blocks16.getSaveContent)(blockType, attributes);
      const [isValid] = html ? (0, import_blocks16.validateBlock)({
        ...block,
        attributes,
        originalContent: content
      }) : [true];
      updateBlock2(clientId, {
        attributes,
        originalContent: content,
        isValid
      });
      if (!html) {
        setHtml(content);
      }
    };
    (0, import_element24.useEffect)(() => {
      setHtml((0, import_blocks16.getBlockContent)(block));
    }, [block]);
    return /* @__PURE__ */ (0, import_jsx_runtime137.jsx)(
      import_react_autosize_textarea.default,
      {
        className: "block-editor-block-list__block-html-textarea",
        value: html,
        onBlur: onChange,
        onChange: (event) => setHtml(event.target.value)
      }
    );
  }
  var block_html_default = BlockHTML;

  // packages/block-editor/build-module/components/block-list/use-block-props/index.js
  var import_element28 = __toESM(require_element());
  var import_i18n23 = __toESM(require_i18n());
  var import_blocks17 = __toESM(require_blocks());
  var import_compose13 = __toESM(require_compose());
  var import_warning4 = __toESM(require_warning());

  // node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js
  var updateQueue = makeQueue();
  var raf = (fn) => schedule(fn, updateQueue);
  var writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  var onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  var onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  var onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  var timeouts = [];
  raf.setTimeout = (handler, ms) => {
    let time = raf.now() + ms;
    let cancel = () => {
      let i2 = timeouts.findIndex((t3) => t3.cancel == cancel);
      if (~i2) timeouts.splice(i2, 1);
      pendingCount -= ~i2 ? 1 : 0;
    };
    let timeout = {
      time,
      handler,
      cancel
    };
    timeouts.splice(findTimeout(time), 0, timeout);
    pendingCount += 1;
    start();
    return timeout;
  };
  var findTimeout = (time) => ~(~timeouts.findIndex((t3) => t3.time > time) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    onFinishQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync = true;
    raf.batchedUpdates(fn);
    sync = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
  };
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
    } else {
      update();
    }
  };
  var ts = -1;
  var pendingCount = 0;
  var sync = false;
  function schedule(fn, queue) {
    if (sync) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start();
    }
  }
  function start() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    let prevTs = ts;
    ts = raf.now();
    let count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t3) => t3.handler());
      pendingCount -= count;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next2 = /* @__PURE__ */ new Set();
    let current = next2;
    return {
      add(fn) {
        pendingCount += current == next2 && !next2.has(fn) ? 1 : 0;
        next2.add(fn);
      },
      delete(fn) {
        pendingCount -= current == next2 && next2.has(fn) ? 1 : 0;
        return next2.delete(fn);
      },
      flush(arg) {
        if (current.size) {
          next2 = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn) => fn(arg) && next2.add(fn));
          pendingCount += next2.size;
          current = next2;
        }
      }
    };
  }
  function eachSafely(values, each2) {
    values.forEach((value) => {
      try {
        each2(value);
      } catch (e2) {
        raf.catch(e2);
      }
    });
  }

  // node_modules/@react-spring/shared/dist/react-spring-shared.esm.js
  var import_react = __toESM(require_react());
  function noop3() {
  }
  var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
    value,
    writable: true,
    configurable: true
  });
  var is = {
    arr: Array.isArray,
    obj: (a2) => !!a2 && a2.constructor.name === "Object",
    fun: (a2) => typeof a2 === "function",
    str: (a2) => typeof a2 === "string",
    num: (a2) => typeof a2 === "number",
    und: (a2) => a2 === void 0
  };
  function isEqual(a2, b2) {
    if (is.arr(a2)) {
      if (!is.arr(b2) || a2.length !== b2.length) return false;
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b2[i2]) return false;
      }
      return true;
    }
    return a2 === b2;
  }
  var each = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx2) {
    if (is.arr(obj)) {
      for (let i2 = 0; i2 < obj.length; i2++) {
        fn.call(ctx2, obj[i2], `${i2}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn.call(ctx2, obj[key], key);
      }
    }
  }
  var toArray = (a2) => is.und(a2) ? [] : is.arr(a2) ? a2 : [a2];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  var createStringInterpolator$1;
  var to;
  var colors$1 = null;
  var skipAnimation = false;
  var willAdvance = noop3;
  var assign = (globals2) => {
    if (globals2.to) to = globals2.to;
    if (globals2.now) raf.now = globals2.now;
    if (globals2.colors !== void 0) colors$1 = globals2.colors;
    if (globals2.skipAnimation != null) skipAnimation = globals2.skipAnimation;
    if (globals2.createStringInterpolator) createStringInterpolator$1 = globals2.createStringInterpolator;
    if (globals2.requestAnimationFrame) raf.use(globals2.requestAnimationFrame);
    if (globals2.batchedUpdates) raf.batchedUpdates = globals2.batchedUpdates;
    if (globals2.willAdvance) willAdvance = globals2.willAdvance;
    if (globals2.frameLoop) raf.frameLoop = globals2.frameLoop;
  };
  var globals = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
      return createStringInterpolator$1;
    },
    get to() {
      return to;
    },
    get colors() {
      return colors$1;
    },
    get skipAnimation() {
      return skipAnimation;
    },
    get willAdvance() {
      return willAdvance;
    },
    assign
  });
  var startQueue = /* @__PURE__ */ new Set();
  var currentFrame = [];
  var prevFrame = [];
  var priority = 0;
  var frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    advance,
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation)) startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i2 = 0; i2 < currentFrame.length; i2++) {
      const animation = currentFrame[i2];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test) {
    const index = arr.findIndex(test);
    return index < 0 ? arr.length : index;
  }
  var colors = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  var NUMBER = "[-+]?\\d*\\.?\\d+";
  var PERCENTAGE = NUMBER + "%";
  function call(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
  var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
  var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
  var hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
  var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex6 = /^#([0-9a-fA-F]{6})$/;
  var hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color) {
    let match2;
    if (typeof color === "number") {
      return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
    }
    if (match2 = hex6.exec(color)) return parseInt(match2[1] + "ff", 16) >>> 0;
    if (colors$1 && colors$1[color] !== void 0) {
      return colors$1[color];
    }
    if (match2 = rgb.exec(color)) {
      return (parse255(match2[1]) << 24 | parse255(match2[2]) << 16 | parse255(match2[3]) << 8 | 255) >>> 0;
    }
    if (match2 = rgba.exec(color)) {
      return (parse255(match2[1]) << 24 | parse255(match2[2]) << 16 | parse255(match2[3]) << 8 | parse1(match2[4])) >>> 0;
    }
    if (match2 = hex3.exec(color)) {
      return parseInt(match2[1] + match2[1] + match2[2] + match2[2] + match2[3] + match2[3] + "ff", 16) >>> 0;
    }
    if (match2 = hex8.exec(color)) return parseInt(match2[1], 16) >>> 0;
    if (match2 = hex4.exec(color)) {
      return parseInt(match2[1] + match2[1] + match2[2] + match2[2] + match2[3] + match2[3] + match2[4] + match2[4], 16) >>> 0;
    }
    if (match2 = hsl.exec(color)) {
      return (hslToRgb(parse360(match2[1]), parsePercentage(match2[2]), parsePercentage(match2[3])) | 255) >>> 0;
    }
    if (match2 = hsla.exec(color)) {
      return (hslToRgb(parse360(match2[1]), parsePercentage(match2[2]), parsePercentage(match2[3])) | parse1(match2[4])) >>> 0;
    }
    return null;
  }
  function hue2rgb(p2, q, t3) {
    if (t3 < 0) t3 += 1;
    if (t3 > 1) t3 -= 1;
    if (t3 < 1 / 6) return p2 + (q - p2) * 6 * t3;
    if (t3 < 1 / 2) return q;
    if (t3 < 2 / 3) return p2 + (q - p2) * (2 / 3 - t3) * 6;
    return p2;
  }
  function hslToRgb(h2, s2, l2) {
    const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p2 = 2 * l2 - q;
    const r3 = hue2rgb(p2, q, h2 + 1 / 3);
    const g2 = hue2rgb(p2, q, h2);
    const b2 = hue2rgb(p2, q, h2 - 1 / 3);
    return Math.round(r3 * 255) << 24 | Math.round(g2 * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) return 0;
    if (int > 255) return 255;
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) return 0;
    if (num > 1) return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0) return 0;
    if (int > 100) return 1;
    return int / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null) return input;
    int32Color = int32Color || 0;
    let r3 = (int32Color & 4278190080) >>> 24;
    let g2 = (int32Color & 16711680) >>> 16;
    let b2 = (int32Color & 65280) >>> 8;
    let a2 = (int32Color & 255) / 255;
    return `rgba(${r3}, ${g2}, ${b2}, ${a2})`;
  }
  var createInterpolator = (range2, output, extrapolate) => {
    if (is.fun(range2)) {
      return range2;
    }
    if (is.arr(range2)) {
      return createInterpolator({
        range: range2,
        output,
        extrapolate
      });
    }
    if (is.str(range2.output[0])) {
      return createStringInterpolator$1(range2);
    }
    const config2 = range2;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing = config2.easing || ((t3) => t3);
    return (input) => {
      const range3 = findRange(input, inputRange);
      return interpolate(input, inputRange[range3], inputRange[range3 + 1], outputRange[range3], outputRange[range3 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
    };
  };
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
    let result = map ? map(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity") return result;
      else if (extrapolateLeft === "clamp") result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity") return result;
      else if (extrapolateRight === "clamp") result = inputMax;
    }
    if (outputMin === outputMax) return outputMin;
    if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity) result = -result;
    else if (inputMax === Infinity) result = result - inputMin;
    else result = (result - inputMin) / (inputMax - inputMin);
    result = easing(result);
    if (outputMin === -Infinity) result = -result;
    else if (outputMax === Infinity) result = result + outputMin;
    else result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i2 = 1; i2 < inputRange.length - 1; ++i2) if (inputRange[i2] >= input) break;
    return i2 - 1;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var $get = Symbol.for("FluidValue.get");
  var $observers = Symbol.for("FluidValue.observers");
  var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
  var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
  var getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer, event) {
    if (observer.eventObserved) {
      observer.eventObserved(event);
    } else {
      observer(event);
    }
  }
  function callFluidObservers(target, event) {
    let observers = target[$observers];
    if (observers) {
      observers.forEach((observer) => {
        callFluidObserver(observer, event);
      });
    }
  }
  var FluidValue = class {
    constructor(get) {
      this[$get] = void 0;
      this[$observers] = void 0;
      if (!get && !(get = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get);
    }
  };
  var setFluidGetter = (target, get) => setHidden(target, $get, get);
  function addFluidObserver(target, observer) {
    if (target[$get]) {
      let observers = target[$observers];
      if (!observers) {
        setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
      }
      if (!observers.has(observer)) {
        observers.add(observer);
        if (target.observerAdded) {
          target.observerAdded(observers.size, observer);
        }
      }
    }
    return observer;
  }
  function removeFluidObserver(target, observer) {
    let observers = target[$observers];
    if (observers && observers.has(observer)) {
      const count = observers.size - 1;
      if (count) {
        observers.delete(observer);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer);
      }
    }
  }
  var setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  var variableToRgba = (input) => {
    const [token2, fallback] = parseCSSVariable(input);
    if (!token2 || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token2);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (_value) {
        return _value;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  var parseCSSVariable = (current) => {
    const match2 = cssVariableRegex.exec(current);
    if (!match2) return [,];
    const [, token2, fallback] = match2;
    return [token2, fallback];
  };
  var namedColorRegex;
  var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
  var createStringInterpolator = (config2) => {
    if (!namedColorRegex) namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
    const output = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes = output.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes[0].map((_, i2) => keyframes.map((values) => {
      if (!(i2 in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i2];
    }));
    const interpolators = outputRanges.map((output2) => createInterpolator(_extends({}, config2, {
      output: output2
    })));
    return (input) => {
      var _output$find;
      const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
      let i2 = 0;
      return output[0].replace(numberRegex, () => `${interpolators[i2++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
    };
  };
  var prefix = "react-spring: ";
  var once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  var warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
  }
  var warnDirectCall = once(console.warn);
  function isAnimatedString(value) {
    return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
  }
  var useIsomorphicLayoutEffect = isSSR() ? import_react.useEffect : import_react.useLayoutEffect;
  var useIsMounted = () => {
    const isMounted = (0, import_react.useRef)(false);
    useIsomorphicLayoutEffect(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate() {
    const update3 = (0, import_react.useState)()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update3(Math.random());
      }
    };
  }
  function useMemoOne(getResult, inputs) {
    const [initial] = (0, import_react.useState)(() => ({
      inputs,
      result: getResult()
    }));
    const committed = (0, import_react.useRef)();
    const prevCache = committed.current;
    let cache = prevCache;
    if (cache) {
      const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
      if (!useCache) {
        cache = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache = initial;
    }
    (0, import_react.useEffect)(() => {
      committed.current = cache;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache]);
    return cache.result;
  }
  function areInputsEqual(next2, prev2) {
    if (next2.length !== prev2.length) {
      return false;
    }
    for (let i2 = 0; i2 < next2.length; i2++) {
      if (next2[i2] !== prev2[i2]) {
        return false;
      }
    }
    return true;
  }
  var useOnce = (effect) => (0, import_react.useEffect)(effect, emptyDeps);
  var emptyDeps = [];

  // node_modules/@react-spring/core/dist/react-spring-core.esm.js
  var React2 = __toESM(require_react());
  var import_react3 = __toESM(require_react());

  // node_modules/@react-spring/animated/dist/react-spring-animated.esm.js
  var React = __toESM(require_react());
  var import_react2 = __toESM(require_react());
  var $node = Symbol.for("Animated:node");
  var isAnimated = (value) => !!value && value[$node] === value;
  var getAnimated = (owner) => owner && owner[$node];
  var setAnimated = (owner, node2) => defineHidden(owner, $node, node2);
  var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  var Animated = class {
    constructor() {
      this.payload = void 0;
      setAnimated(this, this);
    }
    getPayload() {
      return this.payload || [];
    }
  };
  var AnimatedValue = class _AnimatedValue extends Animated {
    constructor(_value) {
      super();
      this.done = true;
      this.elapsedTime = void 0;
      this.lastPosition = void 0;
      this.lastVelocity = void 0;
      this.v0 = void 0;
      this.durationProgress = 0;
      this._value = _value;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    static create(value) {
      return new _AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const {
        done
      } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done) this.lastVelocity = null;
        this.v0 = null;
      }
    }
  };
  var AnimatedString = class _AnimatedString extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = void 0;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    static create(value) {
      return new _AnimatedString(value);
    }
    getValue() {
      let value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  };
  var TreeContext = {
    dependencies: null
  };
  var AnimatedObject = class extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values[key] = getFluidValue(source);
        } else if (!animated2) {
          values[key] = source;
        }
      });
      return values;
    }
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node2) => node2.reset());
      }
    }
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node2) => this.add(node2));
      }
    }
  };
  var AnimatedArray = class _AnimatedArray extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    static create(source) {
      return new _AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node2) => node2.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node2, i2) => node2.setValue(source[i2])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  };
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  var withAnimated = (Component7, host2) => {
    const hasInstance = !is.fun(Component7) || Component7.prototype && Component7.prototype.isReactComponent;
    return (0, import_react2.forwardRef)((givenProps, givenRef) => {
      const instanceRef = (0, import_react2.useRef)(null);
      const ref = hasInstance && (0, import_react2.useCallback)((value) => {
        instanceRef.current = updateRef(givenRef, value);
      }, [givenRef]);
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate();
      const callback = () => {
        const instance = instanceRef.current;
        if (hasInstance && !instance) {
          return;
        }
        const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = (0, import_react2.useRef)();
      useIsomorphicLayoutEffect(() => {
        observerRef.current = observer;
        each(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
            raf.cancel(observerRef.current.update);
          }
        };
      });
      (0, import_react2.useEffect)(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return React.createElement(Component7, _extends2({}, usedProps, {
        ref
      }));
    });
  };
  var PropsObserver = class {
    constructor(update3, deps) {
      this.update = update3;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  };
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style) props = _extends2({}, props, {
      style: host2.createAnimatedStyle(props.style)
    });
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value) {
    if (ref) {
      if (is.fun(ref)) ref(value);
      else ref.current = value;
    }
    return value;
  }
  var cacheKey = Symbol.for("AnimatedComponent");
  var createHost = (components, {
    applyAnimatedValues: _applyAnimatedValues = () => false,
    createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
    getComponentProps: _getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: _applyAnimatedValues,
      createAnimatedStyle: _createAnimatedStyle,
      getComponentProps: _getComponentProps
    };
    const animated2 = (Component7) => {
      const displayName = getDisplayName(Component7) || "Anonymous";
      if (is.str(Component7)) {
        Component7 = animated2[Component7] || (animated2[Component7] = withAnimated(Component7, hostConfig));
      } else {
        Component7 = Component7[cacheKey] || (Component7[cacheKey] = withAnimated(Component7, hostConfig));
      }
      Component7.displayName = `Animated(${displayName})`;
      return Component7;
    };
    eachProp(components, (Component7, key) => {
      if (is.arr(components)) {
        key = getDisplayName(Component7);
      }
      animated2[key] = animated2(Component7);
    });
    return {
      animated: animated2
    };
  };
  var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

  // node_modules/@react-spring/core/dist/react-spring-core.esm.js
  function _extends3() {
    _extends3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  function callProp(value, ...args) {
    return is.fun(value) ? value(...args) : value;
  }
  var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
  var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
  var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  var noopTransform = (value) => value;
  var getDefaultProps = (props, transform = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys) {
      const value = transform(props[key], key);
      if (!is.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  var DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
  var RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = {
        to: to2
      };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return _extends3({}, props);
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  var config = {
    default: {
      tension: 170,
      friction: 26
    },
    gentle: {
      tension: 120,
      friction: 14
    },
    wobbly: {
      tension: 180,
      friction: 12
    },
    stiff: {
      tension: 210,
      friction: 20
    },
    slow: {
      tension: 280,
      friction: 60
    },
    molasses: {
      tension: 280,
      friction: 120
    }
  };
  var c1 = 1.70158;
  var c2 = c1 * 1.525;
  var c3 = c1 + 1;
  var c4 = 2 * Math.PI / 3;
  var c5 = 2 * Math.PI / 4.5;
  var bounceOut = (x2) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x2 < 1 / d1) {
      return n1 * x2 * x2;
    } else if (x2 < 2 / d1) {
      return n1 * (x2 -= 1.5 / d1) * x2 + 0.75;
    } else if (x2 < 2.5 / d1) {
      return n1 * (x2 -= 2.25 / d1) * x2 + 0.9375;
    } else {
      return n1 * (x2 -= 2.625 / d1) * x2 + 0.984375;
    }
  };
  var easings = {
    linear: (x2) => x2,
    easeInQuad: (x2) => x2 * x2,
    easeOutQuad: (x2) => 1 - (1 - x2) * (1 - x2),
    easeInOutQuad: (x2) => x2 < 0.5 ? 2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 2) / 2,
    easeInCubic: (x2) => x2 * x2 * x2,
    easeOutCubic: (x2) => 1 - Math.pow(1 - x2, 3),
    easeInOutCubic: (x2) => x2 < 0.5 ? 4 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 3) / 2,
    easeInQuart: (x2) => x2 * x2 * x2 * x2,
    easeOutQuart: (x2) => 1 - Math.pow(1 - x2, 4),
    easeInOutQuart: (x2) => x2 < 0.5 ? 8 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 4) / 2,
    easeInQuint: (x2) => x2 * x2 * x2 * x2 * x2,
    easeOutQuint: (x2) => 1 - Math.pow(1 - x2, 5),
    easeInOutQuint: (x2) => x2 < 0.5 ? 16 * x2 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 5) / 2,
    easeInSine: (x2) => 1 - Math.cos(x2 * Math.PI / 2),
    easeOutSine: (x2) => Math.sin(x2 * Math.PI / 2),
    easeInOutSine: (x2) => -(Math.cos(Math.PI * x2) - 1) / 2,
    easeInExpo: (x2) => x2 === 0 ? 0 : Math.pow(2, 10 * x2 - 10),
    easeOutExpo: (x2) => x2 === 1 ? 1 : 1 - Math.pow(2, -10 * x2),
    easeInOutExpo: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? Math.pow(2, 20 * x2 - 10) / 2 : (2 - Math.pow(2, -20 * x2 + 10)) / 2,
    easeInCirc: (x2) => 1 - Math.sqrt(1 - Math.pow(x2, 2)),
    easeOutCirc: (x2) => Math.sqrt(1 - Math.pow(x2 - 1, 2)),
    easeInOutCirc: (x2) => x2 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x2, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x2 + 2, 2)) + 1) / 2,
    easeInBack: (x2) => c3 * x2 * x2 * x2 - c1 * x2 * x2,
    easeOutBack: (x2) => 1 + c3 * Math.pow(x2 - 1, 3) + c1 * Math.pow(x2 - 1, 2),
    easeInOutBack: (x2) => x2 < 0.5 ? Math.pow(2 * x2, 2) * ((c2 + 1) * 2 * x2 - c2) / 2 : (Math.pow(2 * x2 - 2, 2) * ((c2 + 1) * (x2 * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : -Math.pow(2, 10 * x2 - 10) * Math.sin((x2 * 10 - 10.75) * c4),
    easeOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : Math.pow(2, -10 * x2) * Math.sin((x2 * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? -(Math.pow(2, 20 * x2 - 10) * Math.sin((20 * x2 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x2 + 10) * Math.sin((20 * x2 - 11.125) * c5) / 2 + 1,
    easeInBounce: (x2) => 1 - bounceOut(1 - x2),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x2) => x2 < 0.5 ? (1 - bounceOut(1 - 2 * x2)) / 2 : (1 + bounceOut(2 * x2 - 1)) / 2
  };
  var defaults = _extends3({}, config.default, {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  });
  var AnimationConfig = class {
    constructor() {
      this.tension = void 0;
      this.friction = void 0;
      this.frequency = void 0;
      this.damping = void 0;
      this.mass = void 0;
      this.velocity = 0;
      this.restVelocity = void 0;
      this.precision = void 0;
      this.progress = void 0;
      this.duration = void 0;
      this.easing = void 0;
      this.clamp = void 0;
      this.bounce = void 0;
      this.decay = void 0;
      this.round = void 0;
      Object.assign(this, defaults);
    }
  };
  function mergeConfig(config2, newConfig, defaultConfig) {
    if (defaultConfig) {
      defaultConfig = _extends3({}, defaultConfig);
      sanitizeConfig(defaultConfig, newConfig);
      newConfig = _extends3({}, defaultConfig, newConfig);
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let {
      mass,
      frequency,
      damping
    } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01) frequency = 0.01;
      if (damping < 0) damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  var emptyArray = [];
  var Animation = class {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.to = void 0;
      this.from = void 0;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  };
  function scheduleProps(callId, {
    key,
    props,
    defaultProps,
    state,
    actions
  }) {
    return new Promise((resolve, reject) => {
      var _props$cancel;
      let delay;
      let timeout;
      let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps == null ? void 0 : defaultProps.cancel, key);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps == null ? void 0 : defaultProps.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay = timeout.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start(_extends3({}, props, {
            callId,
            cancel
          }), resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
  var getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  var getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  var getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const {
      callId,
      parentId,
      onRest
    } = props;
    const {
      asyncTo: prevTo,
      promise: prevPromise
    } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
      let preventBail;
      let bail;
      const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
      const bailIfEnded = (bailSignal) => {
        const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAniamtionSignal();
        return (async () => {
          if (globals.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? _extends3({}, arg1) : _extends3({}, arg2, {
            to: arg1
          });
          props2.parentId = callId;
          eachProp(defaultProps, (value, key) => {
            if (is.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAniamtionSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t3) => t3.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId) state.cancelId = cancelId;
  }
  var BailSignal = class extends Error {
    constructor() {
      super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      this.result = void 0;
    }
  };
  var SkipAniamtionSignal = class extends Error {
    constructor() {
      super("SkipAnimationSignal");
      this.result = void 0;
    }
  };
  var isFrameValue = (value) => value instanceof FrameValue;
  var nextId$1 = 1;
  var FrameValue = class extends FluidValue {
    constructor(...args) {
      super(...args);
      this.id = nextId$1++;
      this.key = void 0;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    get() {
      const node2 = getAnimated(this);
      return node2 && node2.getValue();
    }
    to(...args) {
      return globals.to(this, args);
    }
    interpolate(...args) {
      deprecateInterpolate();
      return globals.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1) this._attach();
    }
    observerRemoved(count) {
      if (count == 0) this._detach();
    }
    _attach() {
    }
    _detach() {
    }
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  };
  var $P = Symbol.for("SpringPhase");
  var HAS_ANIMATED = 1;
  var IS_ANIMATING = 2;
  var IS_PAUSED = 4;
  var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  var SpringValue = class extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.key = void 0;
      this.animation = new Animation();
      this.queue = void 0;
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? _extends3({}, arg1) : _extends3({}, arg2, {
          from: arg1
        });
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node2 = getAnimated(this);
      return node2 instanceof AnimatedValue ? node2.lastVelocity || 0 : node2.getPayload().map((node3) => node3.lastVelocity || 0);
    }
    get hasAnimated() {
      return hasAnimated(this);
    }
    get isAnimating() {
      return isAnimating(this);
    }
    get isPaused() {
      return isPaused(this);
    }
    get isDelayed() {
      return this._state.delayed;
    }
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let {
        config: config2,
        toValues
      } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray(getFluidValue(anim.to));
      }
      anim.values.forEach((node3, i2) => {
        if (node3.done) return;
        const to2 = node3.constructor == AnimatedString ? 1 : payload ? payload[i2].lastPosition : toValues[i2];
        let finished = anim.immediate;
        let position2 = to2;
        if (!finished) {
          position2 = node3.lastPosition;
          if (config2.tension <= 0) {
            node3.done = true;
            return;
          }
          let elapsed = node3.elapsedTime += dt;
          const from2 = anim.fromValues[i2];
          const v0 = node3.v0 != null ? node3.v0 : node3.v0 = is.arr(config2.velocity) ? config2.velocity[i2] : config2.velocity;
          let velocity;
          const precision = config2.precision || (from2 == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from2) * 1e-3));
          if (!is.und(config2.duration)) {
            let p2 = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node3.durationProgress > 0) {
                  node3.elapsedTime = config2.duration * node3.durationProgress;
                  elapsed = node3.elapsedTime += dt;
                }
              }
              p2 = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p2 = p2 > 1 ? 1 : p2 < 0 ? 0 : p2;
              node3.durationProgress = p2;
            }
            position2 = from2 + config2.easing(p2) * (to2 - from2);
            velocity = (position2 - node3.lastPosition) / dt;
            finished = p2 == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e2 = Math.exp(-(1 - decay) * elapsed);
            position2 = from2 + v0 / (1 - decay) * (1 - e2);
            finished = Math.abs(node3.lastPosition - position2) <= precision;
            velocity = v0 * e2;
          } else {
            velocity = node3.lastVelocity == null ? v0 : node3.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from2 == to2 ? node3.v0 > 0 : from2 < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n2 = 0; n2 < numSteps; ++n2) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position2) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position2 == to2 || position2 > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position2 = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position2 - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position2 = position2 + velocity * step;
            }
          }
          node3.lastVelocity = velocity;
          if (Number.isNaN(position2)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i2].done) {
          finished = false;
        }
        if (finished) {
          node3.done = true;
        } else {
          idle = false;
        }
        if (node3.setValue(position2, config2.round)) {
          changed = true;
        }
      });
      const node2 = getAnimated(this);
      const currVal = node2.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node2.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    pause() {
      this._update({
        pause: true
      });
    }
    resume() {
      this._update({
        pause: false
      });
    }
    finish() {
      if (isAnimating(this)) {
        const {
          to: to2,
          config: config2
        } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : _extends3({}, arg2, {
          to: to2
        })];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(queue.map((props) => {
        const up = this._update(props);
        return up;
      })).then((results) => getCombinedResult(this, results));
    }
    stop(cancel) {
      const {
        to: to2
      } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    reset() {
      this._update({
        reset: true
      });
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    _prepareNode(props) {
      const key = this.key || "";
      let {
        to: to2,
        from: from2
      } = props;
      to2 = is.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from2 = is.obj(from2) ? from2[key] : from2;
      if (from2 == null) {
        from2 = void 0;
      }
      const range2 = {
        to: to2,
        from: from2
      };
      if (!hasAnimated(this)) {
        if (props.reverse) [to2, from2] = [from2, to2];
        from2 = getFluidValue(from2);
        if (!is.und(from2)) {
          this._set(from2);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range2;
    }
    _update(_ref, isLoop) {
      let props = _extends3({}, _ref);
      const {
        key,
        defaultProps
      } = this;
      if (props.default) Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range2 = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          start: this._merge.bind(this, range2)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    _merge(range2, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range2.to);
      const hasFromProp = !is.und(range2.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const {
        key,
        defaultProps,
        animation: anim
      } = this;
      const {
        to: prevTo,
        from: prevFrom
      } = anim;
      let {
        to: to2 = prevTo,
        from: from2 = prevFrom
      } = range2;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from2;
      }
      if (props.reverse) [to2, from2] = [from2, to2];
      const hasFromChanged = !isEqual(from2, prevFrom);
      if (hasFromChanged) {
        anim.from = from2;
      }
      from2 = getFluidValue(from2);
      const hasToChanged = !isEqual(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const {
        config: config2
      } = anim;
      const {
        decay,
        velocity
      } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);
      }
      let node2 = getAnimated(this);
      if (!node2 || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from2) && matchProp(props.reset, key);
      const value = reset ? from2 : this.get();
      const goal = computeGoal(to2);
      const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node2.constructor) {
          if (immediate) {
            node2 = this._set(goal);
          } else throw Error(`Cannot animate between ${node2.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
        }
      }
      const goalType = node2.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node2.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const {
            onRest
          } = anim;
          each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed) raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              anim.onStart == null ? void 0 : anim.onStart(result, this);
            }
          });
        }
      }
      if (reset) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    _set(arg, idle = true) {
      const value = getFluidValue(arg);
      if (!is.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node2) => node2.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node2) => {
          node2.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  };
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    let loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate(_extends3({}, props, {
        loop: loop2,
        default: false,
        pause: void 0,
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        from: reset ? props.from : void 0,
        reset
      }, overrides));
    }
  }
  function createUpdate(props) {
    const {
      to: to2,
      from: from2
    } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is.obj(to2)) findDefined(to2, keys);
    if (is.obj(from2)) findDefined(from2, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function findDefined(values, keys) {
    eachProp(values, (value, key) => value != null && keys.add(key));
  }
  var ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
  function mergeActiveFn(target, props, type) {
    target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
  }
  function sendEvent(target, type, ...args) {
    var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
    (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
    (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
  }
  var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  var nextId = 1;
  var Controller = class {
    constructor(props, flush2) {
      this.id = nextId++;
      this.springs = {};
      this.queue = [];
      this.ref = void 0;
      this._flush = void 0;
      this._initialProps = void 0;
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._item = void 0;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush2) {
        this._flush = flush2;
      }
      if (props) {
        this.start(_extends3({
          default: true
        }, props));
      }
    }
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
        return spring.idle && !spring.isDelayed && !spring.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    get() {
      const values = {};
      this.each((spring, key) => values[key] = spring.get());
      return values;
    }
    set(values) {
      for (const key in values) {
        const value = values[key];
        if (!is.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    start(props) {
      let {
        queue
      } = this;
      if (props) {
        queue = toArray(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    stop(arg, keys) {
      if (arg !== !!arg) {
        keys = arg;
      }
      if (keys) {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].stop(!!arg));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring) => spring.stop(!!arg));
      }
      return this;
    }
    pause(keys) {
      if (is.und(keys)) {
        this.start({
          pause: true
        });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].pause());
      }
      return this;
    }
    resume(keys) {
      if (is.und(keys)) {
        this.start({
          pause: false
        });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].resume());
      }
      return this;
    }
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    _onFrame() {
      const {
        onStart,
        onChange,
        onRest
      } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values;
          onRest2(result, this, this._item);
        });
      }
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else return;
      raf.onFrame(this._onFrame);
    }
  };
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const {
      keys,
      to: to2,
      from: from2,
      loop: loop2,
      onRest,
      onResolve
    } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false) props.to = null;
    if (from2 === false) props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({
            finished,
            cancelled
          }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished) result2.finished = false;
              if (cancelled) result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop3,
          resume: noop3,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(runAsync(asyncTo, props2, state, ctrl));
            }
          }
        }
      }));
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function createSpring(key, observer) {
    const spring = new SpringValue();
    spring.key = key;
    if (observer) {
      addFluidObserver(spring, observer);
    }
    return spring;
  }
  function prepareSprings(springs, props, create6) {
    if (props.keys) {
      each(props.keys, (key) => {
        const spring = springs[key] || (springs[key] = create6(key));
        spring["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  var _excluded$3 = ["children"];
  var SpringContext = (_ref) => {
    let {
      children
    } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$3);
    const inherited = (0, import_react3.useContext)(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne(() => ({
      pause,
      immediate
    }), [pause, immediate]);
    const {
      Provider: Provider2
    } = ctx;
    return React2.createElement(Provider2, {
      value: props
    }, children);
  };
  var ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, React2.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  var TransitionPhase;
  (function(TransitionPhase2) {
    TransitionPhase2["MOUNT"] = "mount";
    TransitionPhase2["ENTER"] = "enter";
    TransitionPhase2["UPDATE"] = "update";
    TransitionPhase2["LEAVE"] = "leave";
  })(TransitionPhase || (TransitionPhase = {}));
  var Interpolation = class extends FrameValue {
    constructor(source, args) {
      super();
      this.key = void 0;
      this.idle = true;
      this.calc = void 0;
      this._active = /* @__PURE__ */ new Set();
      this.source = source;
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node2) => {
          node2.done = false;
        });
        if (globals.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    _attach() {
      let priority2 = 1;
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    _detach() {
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
      }
    }
  };
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self) {
    if (!self.idle) {
      self.idle = true;
      each(getPayload(self), (node2) => {
        node2.done = true;
      });
      callFluidObservers(self, {
        type: "idle",
        parent: self
      });
    }
  }
  globals.assign({
    createStringInterpolator,
    to: (source, args) => new Interpolation(source, args)
  });
  var update2 = frameLoop.advance;

  // node_modules/@react-spring/web/dist/react-spring-web.esm.js
  var import_react_dom = __toESM(require_react_dom());
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  var _excluded$2 = ["style", "children", "scrollTop", "scrollLeft"];
  var isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "") return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + "px";
    return ("" + value).trim();
  }
  var attributeCache = {};
  function applyAnimatedValues(instance, props) {
    if (!instance.nodeType || !instance.setAttribute) {
      return false;
    }
    const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    const _ref = props, {
      style,
      children,
      scrollTop,
      scrollLeft
    } = _ref, attributes = _objectWithoutPropertiesLoose2(_ref, _excluded$2);
    const values = Object.values(attributes);
    const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
    if (children !== void 0) {
      instance.textContent = children;
    }
    for (let name in style) {
      if (style.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style[name]);
        if (isCustomPropRE.test(name)) {
          instance.style.setProperty(name, value);
        } else {
          instance.style[name] = value;
        }
      }
    }
    names.forEach((name, i2) => {
      instance.setAttribute(name, values[i2]);
    });
    if (scrollTop !== void 0) {
      instance.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance.scrollLeft = scrollLeft;
    }
  }
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixKey = (prefix3, key) => prefix3 + key.charAt(0).toUpperCase() + key.substring(1);
  var prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix3) => acc[prefixKey(prefix3, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  var _excluded$1 = ["x", "y", "z"];
  var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  var pxTransforms = /^(translate)/;
  var degTransforms = /^(rotate|skew)/;
  var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
  var isValueIdentity = (value, id) => is.arr(value) ? value.every((v2) => isValueIdentity(v2, id)) : is.num(value) ? value === id : parseFloat(value) === id;
  var AnimatedStyle = class extends AnimatedObject {
    constructor(_ref) {
      let {
        x: x2,
        y: y2,
        z
      } = _ref, style = _objectWithoutPropertiesLoose2(_ref, _excluded$1);
      const inputs = [];
      const transforms = [];
      if (x2 || y2 || z) {
        inputs.push([x2 || 0, y2 || 0, z || 0]);
        transforms.push((xyz) => [`translate3d(${xyz.map((v2) => addUnit(v2, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
      }
      eachProp(style, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform) => [transform, transform === ""]);
        } else if (domTransforms.test(key)) {
          delete style[key];
          if (is.und(value)) return;
          const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray(value));
          transforms.push(key === "rotate3d" ? ([x3, y3, z2, deg]) => [`rotate3d(${x3},${y3},${z2},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key}(${input.map((v2) => addUnit(v2, unit)).join(",")})`, isValueIdentity(input, key.startsWith("scale") ? 1 : 0)]);
        }
      });
      if (inputs.length) {
        style.transform = new FluidTransform(inputs, transforms);
      }
      super(style);
    }
  };
  var FluidTransform = class extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this._value = null;
      this.inputs = inputs;
      this.transforms = transforms;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform = "";
      let identity2 = true;
      each(this.inputs, (input, i2) => {
        const arg1 = getFluidValue(input[0]);
        const [t3, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
        transform += " " + t3;
        identity2 = identity2 && id;
      });
      return identity2 ? "none" : transform;
    }
    observerAdded(count) {
      if (count == 1) each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
    }
    observerRemoved(count) {
      if (count == 0) each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  };
  var primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
  var _excluded = ["scrollTop", "scrollLeft"];
  globals.assign({
    batchedUpdates: import_react_dom.unstable_batchedUpdates,
    createStringInterpolator,
    colors
  });
  var host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style) => new AnimatedStyle(style),
    getComponentProps: (_ref) => {
      let props = _objectWithoutPropertiesLoose2(_ref, _excluded);
      return props;
    }
  });
  var animated = host.animated;

  // packages/block-editor/build-module/components/use-moving-animation/index.js
  var import_element25 = __toESM(require_element());
  var import_dom2 = __toESM(require_dom());
  var import_data18 = __toESM(require_data());
  var BLOCK_ANIMATION_THRESHOLD = 200;
  function getAbsolutePosition(element) {
    return {
      top: element.offsetTop,
      left: element.offsetLeft
    };
  }
  function useMovingAnimation({ triggerAnimationOnChange, clientId }) {
    const ref = (0, import_element25.useRef)();
    const {
      isTyping: isTyping3,
      getGlobalBlockCount: getGlobalBlockCount2,
      isBlockSelected: isBlockSelected2,
      isFirstMultiSelectedBlock: isFirstMultiSelectedBlock2,
      isBlockMultiSelected: isBlockMultiSelected2,
      isAncestorMultiSelected: isAncestorMultiSelected2,
      isDraggingBlocks: isDraggingBlocks2
    } = (0, import_data18.useSelect)(store);
    const { previous, prevRect } = (0, import_element25.useMemo)(
      () => ({
        previous: ref.current && getAbsolutePosition(ref.current),
        prevRect: ref.current && ref.current.getBoundingClientRect()
      }),
      [triggerAnimationOnChange]
    );
    (0, import_element25.useLayoutEffect)(() => {
      if (!previous || !ref.current) {
        return;
      }
      const scrollContainer = (0, import_dom2.getScrollContainer)(ref.current);
      const isSelected = isBlockSelected2(clientId);
      const adjustScrolling = isSelected || isFirstMultiSelectedBlock2(clientId);
      const isDragging3 = isDraggingBlocks2();
      function preserveScrollPosition() {
        if (isDragging3) {
          return;
        }
        if (adjustScrolling && prevRect) {
          const blockRect = ref.current.getBoundingClientRect();
          const diff = blockRect.top - prevRect.top;
          if (diff) {
            scrollContainer.scrollTop += diff;
          }
        }
      }
      const disableAnimation = window.matchMedia("(prefers-reduced-motion: reduce)").matches || isTyping3() || getGlobalBlockCount2() > BLOCK_ANIMATION_THRESHOLD;
      if (disableAnimation) {
        preserveScrollPosition();
        return;
      }
      const isPartOfSelection = isSelected || isBlockMultiSelected2(clientId) || isAncestorMultiSelected2(clientId);
      if (isPartOfSelection && isDragging3) {
        return;
      }
      const zIndex = isPartOfSelection ? "1" : "";
      const controller = new Controller({
        x: 0,
        y: 0,
        config: { mass: 5, tension: 2e3, friction: 200 },
        onChange({ value }) {
          if (!ref.current) {
            return;
          }
          let { x: x22, y: y22 } = value;
          x22 = Math.round(x22);
          y22 = Math.round(y22);
          const finishedMoving = x22 === 0 && y22 === 0;
          ref.current.style.transformOrigin = "center center";
          ref.current.style.transform = finishedMoving ? null : `translate3d(${x22}px,${y22}px,0)`;
          ref.current.style.zIndex = zIndex;
          preserveScrollPosition();
        }
      });
      ref.current.style.transform = void 0;
      const destination = getAbsolutePosition(ref.current);
      const x2 = Math.round(previous.left - destination.left);
      const y2 = Math.round(previous.top - destination.top);
      controller.start({ x: 0, y: 0, from: { x: x2, y: y2 } });
      return () => {
        controller.stop();
        controller.set({ x: 0, y: 0 });
      };
    }, [
      previous,
      prevRect,
      clientId,
      isTyping3,
      getGlobalBlockCount2,
      isBlockSelected2,
      isFirstMultiSelectedBlock2,
      isBlockMultiSelected2,
      isAncestorMultiSelected2,
      isDraggingBlocks2
    ]);
    return ref;
  }
  var use_moving_animation_default = useMovingAnimation;

  // packages/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js
  var import_element26 = __toESM(require_element());
  var import_dom3 = __toESM(require_dom());
  var import_data19 = __toESM(require_data());

  // packages/block-editor/build-module/utils/dom.js
  var BLOCK_SELECTOR = ".block-editor-block-list__block";
  var APPENDER_SELECTOR = ".block-list-appender";
  var BLOCK_APPENDER_CLASS = ".block-editor-button-block-appender";
  function isInSameBlock(a2, b2) {
    return a2.closest(BLOCK_SELECTOR) === b2.closest(BLOCK_SELECTOR);
  }
  function isInsideRootBlock(blockElement, element) {
    const parentBlock = element.closest(
      [BLOCK_SELECTOR, APPENDER_SELECTOR, BLOCK_APPENDER_CLASS].join(",")
    );
    return parentBlock === blockElement;
  }
  function getBlockClientId(node2) {
    while (node2 && node2.nodeType !== node2.ELEMENT_NODE) {
      node2 = node2.parentNode;
    }
    if (!node2) {
      return;
    }
    const elementNode = (
      /** @type {Element} */
      node2
    );
    const blockNode = elementNode.closest(BLOCK_SELECTOR);
    if (!blockNode) {
      return;
    }
    return blockNode.id.slice("block-".length);
  }
  function rectUnion(rect1, rect2) {
    const left = Math.min(rect1.left, rect2.left);
    const right = Math.max(rect1.right, rect2.right);
    const bottom = Math.max(rect1.bottom, rect2.bottom);
    const top = Math.min(rect1.top, rect2.top);
    return new window.DOMRectReadOnly(left, top, right - left, bottom - top);
  }
  function isElementVisible(element) {
    const viewport = element.ownerDocument.defaultView;
    if (!viewport) {
      return false;
    }
    if (element.classList.contains("components-visually-hidden")) {
      return false;
    }
    const bounds = element.getBoundingClientRect();
    if (bounds.width === 0 || bounds.height === 0) {
      return false;
    }
    if (element.checkVisibility) {
      return element.checkVisibility?.({
        opacityProperty: true,
        contentVisibilityAuto: true,
        visibilityProperty: true
      });
    }
    const style = viewport.getComputedStyle(element);
    if (style.display === "none" || style.visibility === "hidden" || style.opacity === "0") {
      return false;
    }
    return true;
  }
  function isScrollable(element) {
    const style = window.getComputedStyle(element);
    return style.overflowX === "auto" || style.overflowX === "scroll" || style.overflowY === "auto" || style.overflowY === "scroll";
  }
  var WITH_OVERFLOW_ELEMENT_BLOCKS = ["core/navigation"];
  function getElementBounds(element) {
    const viewport = element.ownerDocument.defaultView;
    if (!viewport) {
      return new window.DOMRectReadOnly();
    }
    let bounds = element.getBoundingClientRect();
    const dataType = element.getAttribute("data-type");
    if (dataType && WITH_OVERFLOW_ELEMENT_BLOCKS.includes(dataType)) {
      const stack = [element];
      let currentElement;
      while (currentElement = stack.pop()) {
        if (!isScrollable(currentElement)) {
          for (const child of currentElement.children) {
            if (isElementVisible(child)) {
              const childBounds = child.getBoundingClientRect();
              bounds = rectUnion(bounds, childBounds);
              stack.push(child);
            }
          }
        }
      }
    }
    const left = Math.max(bounds.left, 0);
    const right = Math.min(bounds.right, viewport.innerWidth);
    bounds = new window.DOMRectReadOnly(
      left,
      bounds.top,
      right - left,
      bounds.height
    );
    return bounds;
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js
  function useFocusFirstElement({ clientId, initialPosition: initialPosition2 }) {
    const ref = (0, import_element26.useRef)();
    const { isBlockSelected: isBlockSelected2, isMultiSelecting: isMultiSelecting3, isZoomOut: isZoomOut2 } = unlock(
      (0, import_data19.useSelect)(store)
    );
    (0, import_element26.useEffect)(() => {
      if (!isBlockSelected2(clientId) || isMultiSelecting3() || isZoomOut2()) {
        return;
      }
      if (initialPosition2 === void 0 || initialPosition2 === null) {
        return;
      }
      if (!ref.current) {
        return;
      }
      const { ownerDocument } = ref.current;
      if (isInsideRootBlock(ref.current, ownerDocument.activeElement)) {
        return;
      }
      const textInputs = import_dom3.focus.tabbable.find(ref.current).filter((node2) => (0, import_dom3.isTextField)(node2));
      const isReverse = -1 === initialPosition2;
      const target = textInputs[isReverse ? textInputs.length - 1 : 0] || ref.current;
      if (!isInsideRootBlock(ref.current, target)) {
        ref.current.focus();
        return;
      }
      if (!ref.current.getAttribute("contenteditable")) {
        const focusElement = import_dom3.focus.tabbable.findNext(ref.current);
        if (focusElement && isInsideRootBlock(ref.current, focusElement) && (0, import_dom3.isFormElement)(focusElement)) {
          focusElement.focus();
          return;
        }
      }
      (0, import_dom3.placeCaretAtHorizontalEdge)(target, isReverse);
    }, [initialPosition2, clientId]);
    return ref;
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-is-hovered.js
  var import_compose6 = __toESM(require_compose());
  function listener(event) {
    if (event.defaultPrevented) {
      return;
    }
    event.preventDefault();
    event.currentTarget.classList.toggle(
      "is-hovered",
      event.type === "mouseover"
    );
  }
  function useIsHovered() {
    return (0, import_compose6.useRefEffect)((node2) => {
      node2.addEventListener("mouseout", listener);
      node2.addEventListener("mouseover", listener);
      return () => {
        node2.removeEventListener("mouseout", listener);
        node2.removeEventListener("mouseover", listener);
        node2.classList.remove("is-hovered");
      };
    }, []);
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-focus-handler.js
  var import_data20 = __toESM(require_data());
  var import_compose7 = __toESM(require_compose());
  function useFocusHandler(clientId) {
    const { isBlockSelected: isBlockSelected2 } = (0, import_data20.useSelect)(store);
    const { selectBlock: selectBlock2, selectionChange: selectionChange2 } = (0, import_data20.useDispatch)(store);
    return (0, import_compose7.useRefEffect)(
      (node2) => {
        function onFocus(event) {
          if (node2.parentElement.closest('[contenteditable="true"]')) {
            return;
          }
          if (isBlockSelected2(clientId)) {
            if (!event.target.isContentEditable) {
              selectionChange2(clientId);
            }
            return;
          }
          if (!isInsideRootBlock(node2, event.target)) {
            return;
          }
          selectBlock2(clientId);
        }
        node2.addEventListener("focusin", onFocus);
        return () => {
          node2.removeEventListener("focusin", onFocus);
        };
      },
      [isBlockSelected2, selectBlock2]
    );
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-selected-block-event-handlers.js
  var import_dom6 = __toESM(require_dom());
  var import_keycodes2 = __toESM(require_keycodes());
  var import_data21 = __toESM(require_data());
  var import_compose8 = __toESM(require_compose());
  function isColorTransparent(color) {
    return !color || color === "transparent" || color === "rgba(0, 0, 0, 0)";
  }
  function useEventHandlers({ clientId, isSelected }) {
    const { getBlockRootClientId: getBlockRootClientId2, isZoomOut: isZoomOut2, hasMultiSelection: hasMultiSelection2 } = unlock(
      (0, import_data21.useSelect)(store)
    );
    const {
      insertAfterBlock: insertAfterBlock2,
      removeBlock: removeBlock2,
      resetZoomLevel: resetZoomLevel2,
      startDraggingBlocks: startDraggingBlocks2,
      stopDraggingBlocks: stopDraggingBlocks2
    } = unlock((0, import_data21.useDispatch)(store));
    return (0, import_compose8.useRefEffect)(
      (node2) => {
        if (!isSelected) {
          return;
        }
        function onKeyDown(event) {
          const { keyCode, target } = event;
          if (keyCode !== import_keycodes2.ENTER && keyCode !== import_keycodes2.BACKSPACE && keyCode !== import_keycodes2.DELETE) {
            return;
          }
          if (target !== node2 || (0, import_dom6.isTextField)(target)) {
            return;
          }
          event.preventDefault();
          if (keyCode === import_keycodes2.ENTER && isZoomOut2()) {
            resetZoomLevel2();
          } else if (keyCode === import_keycodes2.ENTER) {
            insertAfterBlock2(clientId);
          } else {
            removeBlock2(clientId);
          }
        }
        function onDragStart(event) {
          if (node2 !== event.target || node2.isContentEditable || node2.ownerDocument.activeElement !== node2 || hasMultiSelection2()) {
            event.preventDefault();
            return;
          }
          const data = JSON.stringify({
            type: "block",
            srcClientIds: [clientId],
            srcRootClientId: getBlockRootClientId2(clientId)
          });
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.clearData();
          event.dataTransfer.setData("wp-blocks", data);
          const { ownerDocument } = node2;
          const { defaultView } = ownerDocument;
          const selection2 = defaultView.getSelection();
          selection2.removeAllRanges();
          const dragElement = ownerDocument.createElement("div");
          dragElement.style.width = "1px";
          dragElement.style.height = "1px";
          dragElement.style.position = "fixed";
          dragElement.style.visibility = "hidden";
          ownerDocument.body.appendChild(dragElement);
          event.dataTransfer.setDragImage(dragElement, 0, 0);
          const rect = node2.getBoundingClientRect();
          const clone = node2.cloneNode(true);
          clone.style.visibility = "hidden";
          clone.style.display = "none";
          const id = node2.id;
          node2.id = null;
          let _scale = 1;
          {
            let parentElement = node2;
            while (parentElement = parentElement.parentElement) {
              const { scale } = defaultView.getComputedStyle(parentElement);
              if (scale && scale !== "none") {
                _scale = parseFloat(scale);
                break;
              }
            }
          }
          const inverted = 1 / _scale;
          node2.after(clone);
          const originalNodeProperties = {};
          for (const property of [
            "transform",
            "transformOrigin",
            "transition",
            "zIndex",
            "position",
            "top",
            "left",
            "pointerEvents",
            "opacity",
            "backgroundColor"
          ]) {
            originalNodeProperties[property] = node2.style[property];
          }
          const originScrollTop = defaultView.scrollY;
          const originScrollLeft = defaultView.scrollX;
          const originClientX = event.clientX;
          const originClientY = event.clientY;
          node2.style.position = "relative";
          node2.style.top = `${0}px`;
          node2.style.left = `${0}px`;
          const originX = event.clientX - rect.left;
          const originY = event.clientY - rect.top;
          const dragScale = rect.height > 200 ? 200 / rect.height : 1;
          node2.style.zIndex = "1000";
          node2.style.transformOrigin = `${originX * inverted}px ${originY * inverted}px`;
          node2.style.transition = "transform 0.2s ease-out";
          node2.style.transform = `scale(${dragScale})`;
          node2.style.opacity = "0.9";
          if (isColorTransparent(
            defaultView.getComputedStyle(node2).backgroundColor
          )) {
            let bgColor = "transparent";
            let parentElement = node2;
            while (parentElement = parentElement.parentElement) {
              const { backgroundColor } = defaultView.getComputedStyle(parentElement);
              if (!isColorTransparent(backgroundColor)) {
                bgColor = backgroundColor;
                break;
              }
            }
            node2.style.backgroundColor = bgColor;
          }
          let hasStarted = false;
          function over(e2) {
            if (!hasStarted) {
              hasStarted = true;
              node2.style.pointerEvents = "none";
            }
            const scrollTop = defaultView.scrollY;
            const scrollLeft = defaultView.scrollX;
            node2.style.top = `${(e2.clientY - originClientY + scrollTop - originScrollTop) * inverted}px`;
            node2.style.left = `${(e2.clientX - originClientX + scrollLeft - originScrollLeft) * inverted}px`;
          }
          function end() {
            ownerDocument.removeEventListener("dragover", over);
            ownerDocument.removeEventListener("dragend", end);
            ownerDocument.removeEventListener("drop", end);
            ownerDocument.removeEventListener("scroll", over);
            for (const [property, value] of Object.entries(
              originalNodeProperties
            )) {
              node2.style[property] = value;
            }
            clone.remove();
            node2.id = id;
            dragElement.remove();
            stopDraggingBlocks2();
            document.body.classList.remove(
              "is-dragging-components-draggable"
            );
            ownerDocument.documentElement.classList.remove(
              "is-dragging"
            );
          }
          ownerDocument.addEventListener("dragover", over);
          ownerDocument.addEventListener("dragend", end);
          ownerDocument.addEventListener("drop", end);
          ownerDocument.addEventListener("scroll", over);
          startDraggingBlocks2([clientId]);
          document.body.classList.add(
            "is-dragging-components-draggable"
          );
          ownerDocument.documentElement.classList.add("is-dragging");
        }
        node2.addEventListener("keydown", onKeyDown);
        node2.addEventListener("dragstart", onDragStart);
        return () => {
          node2.removeEventListener("keydown", onKeyDown);
          node2.removeEventListener("dragstart", onDragStart);
        };
      },
      [
        clientId,
        isSelected,
        getBlockRootClientId2,
        insertAfterBlock2,
        removeBlock2,
        isZoomOut2,
        resetZoomLevel2,
        hasMultiSelection2,
        startDraggingBlocks2,
        stopDraggingBlocks2
      ]
    );
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-intersection-observer.js
  var import_compose9 = __toESM(require_compose());
  var import_element27 = __toESM(require_element());
  function useIntersectionObserver() {
    const observer = (0, import_element27.useContext)(IntersectionObserver);
    return (0, import_compose9.useRefEffect)(
      (node2) => {
        if (observer) {
          observer.observe(node2);
          return () => {
            observer.unobserve(node2);
          };
        }
      },
      [observer]
    );
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-scroll-into-view.js
  var import_compose10 = __toESM(require_compose());
  function useScrollIntoView({ isSelected }) {
    const prefersReducedMotion = (0, import_compose10.useReducedMotion)();
    return (0, import_compose10.useRefEffect)(
      (node2) => {
        if (isSelected) {
          const { ownerDocument } = node2;
          const { defaultView } = ownerDocument;
          if (!defaultView.IntersectionObserver) {
            return;
          }
          const observer = new defaultView.IntersectionObserver(
            (entries) => {
              if (!entries[0].isIntersecting) {
                node2.scrollIntoView({
                  behavior: prefersReducedMotion ? "instant" : "smooth"
                });
              }
              observer.disconnect();
            }
          );
          observer.observe(node2);
          return () => {
            observer.disconnect();
          };
        }
      },
      [isSelected]
    );
  }

  // packages/block-editor/build-module/components/use-flash-editable-blocks/index.js
  var import_compose11 = __toESM(require_compose());
  var import_data22 = __toESM(require_data());
  function useFlashEditableBlocks({
    clientId = "",
    isEnabled = true
  } = {}) {
    const { getEnabledClientIdsTree: getEnabledClientIdsTree2 } = unlock((0, import_data22.useSelect)(store));
    return (0, import_compose11.useRefEffect)(
      (element) => {
        if (!isEnabled) {
          return;
        }
        const flashEditableBlocks = () => {
          getEnabledClientIdsTree2(clientId).forEach(
            ({ clientId: id }) => {
              const block = element.querySelector(
                `[data-block="${id}"]`
              );
              if (!block) {
                return;
              }
              block.classList.remove("has-editable-outline");
              block.offsetWidth;
              block.classList.add("has-editable-outline");
            }
          );
        };
        const handleClick = (event) => {
          const shouldFlash = event.target === element || event.target.classList.contains("is-root-container");
          if (!shouldFlash) {
            return;
          }
          if (event.defaultPrevented) {
            return;
          }
          event.preventDefault();
          flashEditableBlocks();
        };
        element.addEventListener("click", handleClick);
        return () => element.removeEventListener("click", handleClick);
      },
      [isEnabled]
    );
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/use-firefox-draggable-compatibility.js
  var import_compose12 = __toESM(require_compose());
  var nodesByDocument = /* @__PURE__ */ new Map();
  function add(doc, node2) {
    let set = nodesByDocument.get(doc);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      nodesByDocument.set(doc, set);
      doc.addEventListener("pointerdown", down);
    }
    set.add(node2);
  }
  function remove3(doc, node2) {
    const set = nodesByDocument.get(doc);
    if (set) {
      set.delete(node2);
      restore(node2);
      if (set.size === 0) {
        nodesByDocument.delete(doc);
        doc.removeEventListener("pointerdown", down);
      }
    }
  }
  function restore(node2) {
    const prevDraggable = node2.getAttribute("data-draggable");
    if (prevDraggable) {
      node2.removeAttribute("data-draggable");
      if (prevDraggable === "true" && !node2.getAttribute("draggable")) {
        node2.setAttribute("draggable", "true");
      }
    }
  }
  function down(event) {
    const { target } = event;
    const { ownerDocument, isContentEditable, tagName } = target;
    const isInputOrTextArea = ["INPUT", "TEXTAREA"].includes(tagName);
    const nodes = nodesByDocument.get(ownerDocument);
    if (isContentEditable || isInputOrTextArea) {
      for (const node2 of nodes) {
        if (node2.getAttribute("draggable") === "true" && node2.contains(target)) {
          node2.removeAttribute("draggable");
          node2.setAttribute("data-draggable", "true");
        }
      }
    } else {
      for (const node2 of nodes) {
        restore(node2);
      }
    }
  }
  function useFirefoxDraggableCompatibility() {
    return (0, import_compose12.useRefEffect)((node2) => {
      add(node2.ownerDocument, node2);
      return () => {
        remove3(node2.ownerDocument, node2);
      };
    }, []);
  }

  // packages/block-editor/build-module/components/block-list/use-block-props/index.js
  function useBlockProps(props = {}, { __unstableIsHtml } = {}) {
    const {
      clientId,
      className,
      wrapperProps = {},
      isAligned,
      index,
      mode: mode2,
      name,
      blockApiVersion,
      blockTitle,
      isSelected,
      isSubtreeDisabled,
      hasOverlay,
      initialPosition: initialPosition2,
      blockEditingMode,
      isHighlighted,
      isMultiSelected,
      isPartiallySelected,
      isReusable,
      isDragging: isDragging3,
      hasChildSelected,
      isEditingDisabled,
      hasEditableOutline,
      isTemporarilyEditingAsBlocks,
      defaultClassName,
      isSectionBlock: isSectionBlock2,
      canMove,
      isBlockHidden: isBlockHidden2
    } = (0, import_element28.useContext)(PrivateBlockContext);
    const blockLabel = (0, import_i18n23.sprintf)((0, import_i18n23.__)("Block: %s"), blockTitle);
    const htmlSuffix = mode2 === "html" && !__unstableIsHtml ? "-visual" : "";
    const ffDragRef = useFirefoxDraggableCompatibility();
    const mergedRefs = (0, import_compose13.useMergeRefs)([
      props.ref,
      useFocusFirstElement({ clientId, initialPosition: initialPosition2 }),
      useBlockRefProvider(clientId),
      useFocusHandler(clientId),
      useEventHandlers({ clientId, isSelected }),
      useIsHovered(),
      useIntersectionObserver(),
      use_moving_animation_default({ triggerAnimationOnChange: index, clientId }),
      (0, import_compose13.useDisabled)({ isDisabled: !hasOverlay }),
      useFlashEditableBlocks({
        clientId,
        isEnabled: isSectionBlock2
      }),
      useScrollIntoView({ isSelected }),
      canMove ? ffDragRef : void 0
    ]);
    const blockEditContext = useBlockEditContext();
    const hasBlockBindings = !!blockEditContext[blockBindingsKey];
    const bindingsStyle = hasBlockBindings ? {
      "--wp-admin-theme-color": "var(--wp-block-synced-color)",
      "--wp-admin-theme-color--rgb": "var(--wp-block-synced-color--rgb)"
    } : {};
    if (blockApiVersion < 2 && clientId === blockEditContext.clientId) {
      (0, import_warning4.default)(
        `Block type "${name}" must support API version 2 or higher to work correctly with "useBlockProps" method.`
      );
    }
    let hasNegativeMargin = false;
    if (wrapperProps?.style?.marginTop?.charAt(0) === "-" || wrapperProps?.style?.marginBottom?.charAt(0) === "-" || wrapperProps?.style?.marginLeft?.charAt(0) === "-" || wrapperProps?.style?.marginRight?.charAt(0) === "-") {
      hasNegativeMargin = true;
    }
    return {
      tabIndex: blockEditingMode === "disabled" ? -1 : 0,
      draggable: canMove && !hasChildSelected ? true : void 0,
      ...wrapperProps,
      ...props,
      ref: mergedRefs,
      id: `block-${clientId}${htmlSuffix}`,
      role: "document",
      "aria-label": blockLabel,
      "data-block": clientId,
      "data-type": name,
      "data-title": blockTitle,
      inert: isSubtreeDisabled ? "true" : void 0,
      className: clsx_default(
        "block-editor-block-list__block",
        {
          // The wp-block className is important for editor styles.
          "wp-block": !isAligned,
          "has-block-overlay": hasOverlay,
          "is-selected": isSelected,
          "is-highlighted": isHighlighted,
          "is-multi-selected": isMultiSelected,
          "is-partially-selected": isPartiallySelected,
          "is-reusable": isReusable,
          "is-dragging": isDragging3,
          "has-child-selected": hasChildSelected,
          "is-editing-disabled": isEditingDisabled,
          "has-editable-outline": hasEditableOutline,
          "has-negative-margin": hasNegativeMargin,
          "is-content-locked-temporarily-editing-as-blocks": isTemporarilyEditingAsBlocks,
          "is-block-hidden": isBlockHidden2
        },
        className,
        props.className,
        wrapperProps.className,
        defaultClassName
      ),
      style: { ...wrapperProps.style, ...props.style, ...bindingsStyle }
    };
  }
  useBlockProps.save = import_blocks17.__unstableGetBlockProps;

  // packages/block-editor/build-module/components/block-list/block.js
  function mergeWrapperProps(propsA, propsB) {
    const newProps = {
      ...propsA,
      ...propsB
    };
    if (propsA?.hasOwnProperty("className") && propsB?.hasOwnProperty("className")) {
      newProps.className = clsx_default(propsA.className, propsB.className);
    }
    if (propsA?.hasOwnProperty("style") && propsB?.hasOwnProperty("style")) {
      newProps.style = { ...propsA.style, ...propsB.style };
    }
    return newProps;
  }
  function Block({ children, isHtml, ...props }) {
    return /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("div", { ...useBlockProps(props, { __unstableIsHtml: isHtml }), children });
  }
  function BlockListBlock({
    block: { __unstableBlockSource },
    mode: mode2,
    isLocked,
    canRemove,
    clientId,
    isSelected,
    isSelectionEnabled: isSelectionEnabled3,
    className,
    __unstableLayoutClassNames: layoutClassNames,
    name,
    isValid,
    attributes,
    wrapperProps,
    setAttributes,
    onReplace,
    onRemove,
    onInsertBlocksAfter,
    onMerge,
    toggleSelection: toggleSelection2
  }) {
    const {
      mayDisplayControls,
      mayDisplayParentControls,
      themeSupportsLayout,
      ...context
    } = (0, import_element29.useContext)(PrivateBlockContext);
    const parentLayout = useLayout() || {};
    let blockEdit = /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
      BlockEdit,
      {
        name,
        isSelected,
        attributes,
        setAttributes,
        insertBlocksAfter: isLocked ? void 0 : onInsertBlocksAfter,
        onReplace: canRemove ? onReplace : void 0,
        onRemove: canRemove ? onRemove : void 0,
        mergeBlocks: canRemove ? onMerge : void 0,
        clientId,
        isSelectionEnabled: isSelectionEnabled3,
        toggleSelection: toggleSelection2,
        __unstableLayoutClassNames: layoutClassNames,
        __unstableParentLayout: Object.keys(parentLayout).length ? parentLayout : void 0,
        mayDisplayControls,
        mayDisplayParentControls,
        blockEditingMode: context.blockEditingMode,
        isPreviewMode: context.isPreviewMode
      }
    );
    const blockType = (0, import_blocks18.getBlockType)(name);
    if (blockType?.getEditWrapperProps) {
      wrapperProps = mergeWrapperProps(
        wrapperProps,
        blockType.getEditWrapperProps(attributes)
      );
    }
    const isAligned = wrapperProps && !!wrapperProps["data-align"] && !themeSupportsLayout;
    const isSticky = className?.includes("is-position-sticky");
    if (isAligned) {
      blockEdit = /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
        "div",
        {
          className: clsx_default("wp-block", isSticky && className),
          "data-align": wrapperProps["data-align"],
          children: blockEdit
        }
      );
    }
    let block;
    if (!isValid) {
      const saveContent = __unstableBlockSource ? (0, import_blocks18.serializeRawBlock)(__unstableBlockSource) : (0, import_blocks18.getSaveContent)(blockType, attributes);
      block = /* @__PURE__ */ (0, import_jsx_runtime138.jsxs)(Block, { className: "has-warning", children: [
        /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(BlockInvalidWarning, { clientId }),
        /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(import_element29.RawHTML, { children: (0, import_dom7.safeHTML)(saveContent) })
      ] });
    } else if (mode2 === "html") {
      block = /* @__PURE__ */ (0, import_jsx_runtime138.jsxs)(import_jsx_runtime138.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("div", { style: { display: "none" }, children: blockEdit }),
        /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(Block, { isHtml: true, children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(block_html_default, { clientId }) })
      ] });
    } else if (blockType?.apiVersion > 1) {
      block = blockEdit;
    } else {
      block = /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(Block, { children: blockEdit });
    }
    const { "data-align": dataAlign, ...restWrapperProps } = wrapperProps ?? {};
    const updatedWrapperProps = {
      ...restWrapperProps,
      className: clsx_default(
        restWrapperProps.className,
        dataAlign && themeSupportsLayout && `align${dataAlign}`,
        !(dataAlign && isSticky) && className
      )
    };
    return /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
      PrivateBlockContext.Provider,
      {
        value: {
          wrapperProps: updatedWrapperProps,
          isAligned,
          ...context
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
          block_crash_boundary_default,
          {
            fallback: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(Block, { className: "has-warning", children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(block_crash_warning_default, {}) }),
            children: block
          }
        )
      }
    );
  }
  var applyWithDispatch = (0, import_data23.withDispatch)((dispatch, ownProps, registry) => {
    const {
      updateBlockAttributes: updateBlockAttributes2,
      insertBlocks: insertBlocks2,
      mergeBlocks: mergeBlocks2,
      replaceBlocks: replaceBlocks2,
      toggleSelection: toggleSelection2,
      __unstableMarkLastChangeAsPersistent: __unstableMarkLastChangeAsPersistent2,
      moveBlocksToPosition: moveBlocksToPosition2,
      removeBlock: removeBlock2,
      selectBlock: selectBlock2
    } = dispatch(store);
    return {
      setAttributes(nextAttributes) {
        const { getMultiSelectedBlockClientIds: getMultiSelectedBlockClientIds2 } = registry.select(store);
        const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds2();
        const { clientId, attributes } = ownProps;
        const clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
        const newAttributes = typeof nextAttributes === "function" ? nextAttributes(attributes) : nextAttributes;
        updateBlockAttributes2(clientIds, newAttributes);
      },
      onInsertBlocks(blocks2, index) {
        const { rootClientId } = ownProps;
        insertBlocks2(blocks2, index, rootClientId);
      },
      onInsertBlocksAfter(blocks2) {
        const { clientId, rootClientId } = ownProps;
        const { getBlockIndex: getBlockIndex2 } = registry.select(store);
        const index = getBlockIndex2(clientId);
        insertBlocks2(blocks2, index + 1, rootClientId);
      },
      onMerge(forward) {
        const { clientId, rootClientId } = ownProps;
        const {
          getPreviousBlockClientId: getPreviousBlockClientId2,
          getNextBlockClientId: getNextBlockClientId2,
          getBlock: getBlock2,
          getBlockAttributes: getBlockAttributes3,
          getBlockName: getBlockName2,
          getBlockOrder: getBlockOrder2,
          getBlockIndex: getBlockIndex2,
          getBlockRootClientId: getBlockRootClientId2,
          canInsertBlockType: canInsertBlockType2
        } = registry.select(store);
        function switchToDefaultOrRemove() {
          const block = getBlock2(clientId);
          const defaultBlockName = (0, import_blocks18.getDefaultBlockName)();
          const defaultBlockType = (0, import_blocks18.getBlockType)(defaultBlockName);
          if (getBlockName2(clientId) !== defaultBlockName) {
            const replacement = (0, import_blocks18.switchToBlockType)(
              block,
              defaultBlockName
            );
            if (replacement && replacement.length) {
              replaceBlocks2(clientId, replacement);
            }
          } else if ((0, import_blocks18.isUnmodifiedDefaultBlock)(block)) {
            const nextBlockClientId = getNextBlockClientId2(clientId);
            if (nextBlockClientId) {
              registry.batch(() => {
                removeBlock2(clientId);
                selectBlock2(nextBlockClientId);
              });
            }
          } else if (defaultBlockType.merge) {
            const attributes = defaultBlockType.merge(
              {},
              block.attributes
            );
            replaceBlocks2(
              [clientId],
              [(0, import_blocks18.createBlock)(defaultBlockName, attributes)]
            );
          }
        }
        function moveFirstItemUp(_clientId, changeSelection = true) {
          const wrapperBlockName = getBlockName2(_clientId);
          const wrapperBlockType = (0, import_blocks18.getBlockType)(wrapperBlockName);
          const isTextualWrapper = wrapperBlockType.category === "text";
          const targetRootClientId = getBlockRootClientId2(_clientId);
          const blockOrder = getBlockOrder2(_clientId);
          const [firstClientId] = blockOrder;
          if (blockOrder.length === 1 && (0, import_blocks18.isUnmodifiedBlock)(getBlock2(firstClientId))) {
            removeBlock2(_clientId);
          } else if (isTextualWrapper) {
            registry.batch(() => {
              if (canInsertBlockType2(
                getBlockName2(firstClientId),
                targetRootClientId
              )) {
                moveBlocksToPosition2(
                  [firstClientId],
                  _clientId,
                  targetRootClientId,
                  getBlockIndex2(_clientId)
                );
              } else {
                const replacement = (0, import_blocks18.switchToBlockType)(
                  getBlock2(firstClientId),
                  (0, import_blocks18.getDefaultBlockName)()
                );
                if (replacement && replacement.length && replacement.every(
                  (block) => canInsertBlockType2(
                    block.name,
                    targetRootClientId
                  )
                )) {
                  insertBlocks2(
                    replacement,
                    getBlockIndex2(_clientId),
                    targetRootClientId,
                    changeSelection
                  );
                  removeBlock2(firstClientId, false);
                } else {
                  switchToDefaultOrRemove();
                }
              }
              if (!getBlockOrder2(_clientId).length && (0, import_blocks18.isUnmodifiedBlock)(getBlock2(_clientId))) {
                removeBlock2(_clientId, false);
              }
            });
          } else {
            switchToDefaultOrRemove();
          }
        }
        if (forward) {
          if (rootClientId) {
            const nextRootClientId = getNextBlockClientId2(rootClientId);
            if (nextRootClientId) {
              if (getBlockName2(rootClientId) === getBlockName2(nextRootClientId)) {
                const rootAttributes = getBlockAttributes3(rootClientId);
                const previousRootAttributes = getBlockAttributes3(nextRootClientId);
                if (Object.keys(rootAttributes).every(
                  (key) => rootAttributes[key] === previousRootAttributes[key]
                )) {
                  registry.batch(() => {
                    moveBlocksToPosition2(
                      getBlockOrder2(nextRootClientId),
                      nextRootClientId,
                      rootClientId
                    );
                    removeBlock2(nextRootClientId, false);
                  });
                  return;
                }
              } else {
                mergeBlocks2(rootClientId, nextRootClientId);
                return;
              }
            }
          }
          const nextBlockClientId = getNextBlockClientId2(clientId);
          if (!nextBlockClientId) {
            return;
          }
          if (getBlockOrder2(nextBlockClientId).length) {
            moveFirstItemUp(nextBlockClientId, false);
          } else {
            mergeBlocks2(clientId, nextBlockClientId);
          }
        } else {
          const previousBlockClientId = getPreviousBlockClientId2(clientId);
          if (previousBlockClientId) {
            mergeBlocks2(previousBlockClientId, clientId);
          } else if (rootClientId) {
            const previousRootClientId = getPreviousBlockClientId2(rootClientId);
            if (previousRootClientId && getBlockName2(rootClientId) === getBlockName2(previousRootClientId)) {
              const rootAttributes = getBlockAttributes3(rootClientId);
              const previousRootAttributes = getBlockAttributes3(previousRootClientId);
              if (Object.keys(rootAttributes).every(
                (key) => rootAttributes[key] === previousRootAttributes[key]
              )) {
                registry.batch(() => {
                  moveBlocksToPosition2(
                    getBlockOrder2(rootClientId),
                    rootClientId,
                    previousRootClientId
                  );
                  removeBlock2(rootClientId, false);
                });
                return;
              }
            }
            moveFirstItemUp(rootClientId);
          } else {
            switchToDefaultOrRemove();
          }
        }
      },
      onReplace(blocks2, indexToSelect, initialPosition2) {
        if (blocks2.length && !(0, import_blocks18.isUnmodifiedDefaultBlock)(blocks2[blocks2.length - 1])) {
          __unstableMarkLastChangeAsPersistent2();
        }
        const replacementBlocks = blocks2?.length === 1 && Array.isArray(blocks2[0]) ? blocks2[0] : blocks2;
        replaceBlocks2(
          [ownProps.clientId],
          replacementBlocks,
          indexToSelect,
          initialPosition2
        );
      },
      onRemove() {
        removeBlock2(ownProps.clientId);
      },
      toggleSelection(selectionEnabled) {
        toggleSelection2(selectionEnabled);
      }
    };
  });
  BlockListBlock = (0, import_compose14.compose)(
    applyWithDispatch,
    (0, import_components22.withFilters)("editor.BlockListBlock")
  )(BlockListBlock);
  function BlockListBlockProvider(props) {
    const { clientId, rootClientId } = props;
    const selectedProps = (0, import_data23.useSelect)(
      (select2) => {
        const {
          isBlockSelected: isBlockSelected2,
          getBlockMode: getBlockMode2,
          isSelectionEnabled: isSelectionEnabled22,
          getTemplateLock: getTemplateLock2,
          isSectionBlock: _isSectionBlock,
          getBlockWithoutAttributes: getBlockWithoutAttributes2,
          getBlockAttributes: getBlockAttributes3,
          canRemoveBlock: canRemoveBlock2,
          canMoveBlock: canMoveBlock2,
          getSettings: getSettings4,
          getTemporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks2,
          getBlockEditingMode: getBlockEditingMode2,
          getBlockName: getBlockName2,
          isFirstMultiSelectedBlock: isFirstMultiSelectedBlock2,
          getMultiSelectedBlockClientIds: getMultiSelectedBlockClientIds2,
          hasSelectedInnerBlock: hasSelectedInnerBlock2,
          getBlocksByName: getBlocksByName2,
          getBlockIndex: getBlockIndex2,
          isBlockMultiSelected: isBlockMultiSelected2,
          isBlockSubtreeDisabled: isBlockSubtreeDisabled2,
          isBlockHighlighted: isBlockHighlighted2,
          __unstableIsFullySelected: __unstableIsFullySelected2,
          __unstableSelectionHasUnmergeableBlock: __unstableSelectionHasUnmergeableBlock2,
          isBlockBeingDragged: isBlockBeingDragged2,
          isDragging: isDragging22,
          __unstableHasActiveBlockOverlayActive: __unstableHasActiveBlockOverlayActive2,
          getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2
        } = unlock(select2(store));
        const blockWithoutAttributes2 = getBlockWithoutAttributes2(clientId);
        if (!blockWithoutAttributes2) {
          return;
        }
        const {
          hasBlockSupport: _hasBlockSupport,
          getActiveBlockVariation
        } = select2(import_blocks18.store);
        const attributes2 = getBlockAttributes3(clientId);
        const { name: blockName, isValid: isValid2 } = blockWithoutAttributes2;
        const blockType = (0, import_blocks18.getBlockType)(blockName);
        const {
          supportsLayout,
          isPreviewMode: isPreviewMode2,
          __experimentalBlockBindingsSupportedAttributes
        } = getSettings4();
        const bindableAttributes2 = __experimentalBlockBindingsSupportedAttributes?.[blockName];
        const hasLightBlockWrapper = blockType?.apiVersion > 1;
        const previewContext = {
          isPreviewMode: isPreviewMode2,
          blockWithoutAttributes: blockWithoutAttributes2,
          name: blockName,
          attributes: attributes2,
          isValid: isValid2,
          themeSupportsLayout: supportsLayout,
          index: getBlockIndex2(clientId),
          isReusable: (0, import_blocks18.isReusableBlock)(blockType),
          className: hasLightBlockWrapper ? attributes2.className : void 0,
          defaultClassName: hasLightBlockWrapper ? (0, import_blocks18.getBlockDefaultClassName)(blockName) : void 0,
          blockTitle: blockType?.title,
          isBlockHidden: attributes2?.metadata?.blockVisibility === false
        };
        if (isPreviewMode2) {
          return previewContext;
        }
        const { isBlockHidden: _isBlockHidden } = unlock(
          select2(store)
        );
        const _isSelected = isBlockSelected2(clientId);
        const canRemove2 = canRemoveBlock2(clientId);
        const canMove2 = canMoveBlock2(clientId);
        const match2 = getActiveBlockVariation(blockName, attributes2);
        const isMultiSelected2 = isBlockMultiSelected2(clientId);
        const checkDeep = true;
        const isAncestorOfSelectedBlock = hasSelectedInnerBlock2(
          clientId,
          checkDeep
        );
        const blockEditingMode2 = getBlockEditingMode2(clientId);
        const multiple = (0, import_blocks18.hasBlockSupport)(blockName, "multiple", true);
        const blocksWithSameName = multiple ? [] : getBlocksByName2(blockName);
        const isInvalid = blocksWithSameName.length && blocksWithSameName[0] !== clientId;
        return {
          ...previewContext,
          mode: getBlockMode2(clientId),
          isSelectionEnabled: isSelectionEnabled22(),
          isLocked: !!getTemplateLock2(rootClientId),
          isSectionBlock: _isSectionBlock(clientId),
          canRemove: canRemove2,
          canMove: canMove2,
          isSelected: _isSelected,
          isTemporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks2() === clientId,
          blockEditingMode: blockEditingMode2,
          mayDisplayControls: _isSelected || isFirstMultiSelectedBlock2(clientId) && getMultiSelectedBlockClientIds2().every(
            (id) => getBlockName2(id) === blockName
          ),
          mayDisplayParentControls: _hasBlockSupport(
            getBlockName2(clientId),
            "__experimentalExposeControlsToChildren",
            false
          ) && hasSelectedInnerBlock2(clientId),
          blockApiVersion: blockType?.apiVersion || 1,
          blockTitle: match2?.title || blockType?.title,
          isSubtreeDisabled: blockEditingMode2 === "disabled" && isBlockSubtreeDisabled2(clientId),
          hasOverlay: __unstableHasActiveBlockOverlayActive2(clientId) && !isDragging22(),
          initialPosition: _isSelected ? getSelectedBlocksInitialCaretPosition2() : void 0,
          isHighlighted: isBlockHighlighted2(clientId),
          isMultiSelected: isMultiSelected2,
          isPartiallySelected: isMultiSelected2 && !__unstableIsFullySelected2() && !__unstableSelectionHasUnmergeableBlock2(),
          isDragging: isBlockBeingDragged2(clientId),
          hasChildSelected: isAncestorOfSelectedBlock,
          isEditingDisabled: blockEditingMode2 === "disabled",
          hasEditableOutline: blockEditingMode2 !== "disabled" && getBlockEditingMode2(rootClientId) === "disabled",
          originalBlockClientId: isInvalid ? blocksWithSameName[0] : false,
          isBlockHidden: _isBlockHidden(clientId),
          bindableAttributes: bindableAttributes2
        };
      },
      [clientId, rootClientId]
    );
    const {
      isPreviewMode,
      // Fill values that end up as a public API and may not be defined in
      // preview mode.
      mode: mode2 = "visual",
      isSelectionEnabled: isSelectionEnabled3 = false,
      isLocked = false,
      canRemove = false,
      canMove = false,
      blockWithoutAttributes,
      name,
      attributes,
      isValid,
      isSelected = false,
      themeSupportsLayout,
      isTemporarilyEditingAsBlocks,
      blockEditingMode,
      mayDisplayControls,
      mayDisplayParentControls,
      index,
      blockApiVersion,
      blockTitle,
      isSubtreeDisabled,
      hasOverlay,
      initialPosition: initialPosition2,
      isHighlighted,
      isMultiSelected,
      isPartiallySelected,
      isReusable,
      isDragging: isDragging3,
      hasChildSelected,
      isSectionBlock: isSectionBlock2,
      isEditingDisabled,
      hasEditableOutline,
      className,
      defaultClassName,
      originalBlockClientId,
      isBlockHidden: isBlockHidden2,
      bindableAttributes
    } = selectedProps;
    const block = (0, import_element29.useMemo)(
      () => ({ ...blockWithoutAttributes, attributes }),
      [blockWithoutAttributes, attributes]
    );
    if (!selectedProps) {
      return null;
    }
    const privateContext = {
      isPreviewMode,
      clientId,
      className,
      index,
      mode: mode2,
      name,
      blockApiVersion,
      blockTitle,
      isSelected,
      isSubtreeDisabled,
      hasOverlay,
      initialPosition: initialPosition2,
      blockEditingMode,
      isHighlighted,
      isMultiSelected,
      isPartiallySelected,
      isReusable,
      isDragging: isDragging3,
      hasChildSelected,
      isSectionBlock: isSectionBlock2,
      isEditingDisabled,
      hasEditableOutline,
      isTemporarilyEditingAsBlocks,
      defaultClassName,
      mayDisplayControls,
      mayDisplayParentControls,
      originalBlockClientId,
      themeSupportsLayout,
      canMove,
      isBlockHidden: isBlockHidden2,
      bindableAttributes
    };
    if (isBlockHidden2 && !isSelected && !isMultiSelected && !hasChildSelected) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(PrivateBlockContext.Provider, { value: privateContext, children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
      BlockListBlock,
      {
        ...props,
        ...{
          mode: mode2,
          isSelectionEnabled: isSelectionEnabled3,
          isLocked,
          canRemove,
          canMove,
          // Users of the editor.BlockListBlock filter used to be able
          // to access the block prop. Ideally these blocks would rely
          // on the clientId prop only. This is kept for backward
          // compatibility reasons.
          block,
          name,
          attributes,
          isValid,
          isSelected
        }
      }
    ) });
  }
  var block_default2 = (0, import_element29.memo)(BlockListBlockProvider);

  // packages/block-editor/build-module/components/block-list-appender/index.js
  var import_jsx_runtime186 = __toESM(require_jsx_runtime());
  var import_data60 = __toESM(require_data());
  var import_blocks34 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/default-block-appender/index.js
  var import_jsx_runtime184 = __toESM(require_jsx_runtime());
  var import_i18n59 = __toESM(require_i18n());
  var import_html_entities2 = __toESM(require_html_entities());
  var import_data59 = __toESM(require_data());
  var import_keycodes7 = __toESM(require_keycodes());

  // packages/block-editor/build-module/components/inserter/index.js
  var import_jsx_runtime183 = __toESM(require_jsx_runtime());
  var import_a11y10 = __toESM(require_a11y());
  var import_i18n58 = __toESM(require_i18n());
  var import_components56 = __toESM(require_components());
  var import_element74 = __toESM(require_element());
  var import_data58 = __toESM(require_data());
  var import_compose43 = __toESM(require_compose());
  var import_blocks33 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/inserter/menu.js
  var import_jsx_runtime181 = __toESM(require_jsx_runtime());
  var import_element72 = __toESM(require_element());
  var import_components54 = __toESM(require_components());
  var import_i18n56 = __toESM(require_i18n());
  var import_compose42 = __toESM(require_compose());
  var import_data56 = __toESM(require_data());

  // packages/block-editor/build-module/components/inserter/tips.js
  var import_jsx_runtime139 = __toESM(require_jsx_runtime());
  var import_i18n24 = __toESM(require_i18n());
  var import_element30 = __toESM(require_element());
  var import_components23 = __toESM(require_components());
  var globalTips = [
    (0, import_element30.createInterpolateElement)(
      (0, import_i18n24.__)(
        "While writing, you can press <kbd>/</kbd> to quickly insert new blocks."
      ),
      { kbd: /* @__PURE__ */ (0, import_jsx_runtime139.jsx)("kbd", {}) }
    ),
    (0, import_element30.createInterpolateElement)(
      (0, import_i18n24.__)(
        "Indent a list by pressing <kbd>space</kbd> at the beginning of a line."
      ),
      { kbd: /* @__PURE__ */ (0, import_jsx_runtime139.jsx)("kbd", {}) }
    ),
    (0, import_element30.createInterpolateElement)(
      (0, import_i18n24.__)(
        "Outdent a list by pressing <kbd>backspace</kbd> at the beginning of a line."
      ),
      { kbd: /* @__PURE__ */ (0, import_jsx_runtime139.jsx)("kbd", {}) }
    ),
    (0, import_i18n24.__)("Drag files into the editor to automatically insert media blocks."),
    (0, import_i18n24.__)("Change a block's type by pressing the block icon on the toolbar.")
  ];
  function Tips() {
    const [randomIndex] = (0, import_element30.useState)(
      // Disable Reason: I'm not generating an HTML id.
      // eslint-disable-next-line no-restricted-syntax
      Math.floor(Math.random() * globalTips.length)
    );
    return /* @__PURE__ */ (0, import_jsx_runtime139.jsx)(import_components23.Tip, { children: globalTips[randomIndex] });
  }
  var tips_default = Tips;

  // packages/block-editor/build-module/components/inserter/preview-panel.js
  var import_jsx_runtime152 = __toESM(require_jsx_runtime());
  var import_blocks24 = __toESM(require_blocks());
  var import_element47 = __toESM(require_element());
  var import_i18n34 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-card/index.js
  var import_jsx_runtime140 = __toESM(require_jsx_runtime());
  var import_components24 = __toESM(require_components());
  var import_data24 = __toESM(require_data());
  var import_deprecated6 = __toESM(require_deprecated());
  var import_i18n25 = __toESM(require_i18n());
  var { Badge } = unlock(import_components24.privateApis);
  function BlockCard({
    title,
    icon,
    description,
    blockType,
    className,
    name,
    allowParentNavigation,
    children
  }) {
    if (blockType) {
      (0, import_deprecated6.default)("`blockType` property in `BlockCard component`", {
        since: "5.7",
        alternative: "`title, icon and description` properties"
      });
      ({ title, icon, description } = blockType);
    }
    const parentNavBlockClientId = (0, import_data24.useSelect)(
      (select2) => {
        if (!allowParentNavigation) {
          return;
        }
        const { getSelectedBlockClientId: getSelectedBlockClientId2, getBlockParentsByBlockName: getBlockParentsByBlockName2 } = select2(store);
        const _selectedBlockClientId = getSelectedBlockClientId2();
        return getBlockParentsByBlockName2(
          _selectedBlockClientId,
          "core/navigation",
          true
        )[0];
      },
      [allowParentNavigation]
    );
    const { selectBlock: selectBlock2 } = (0, import_data24.useDispatch)(store);
    return /* @__PURE__ */ (0, import_jsx_runtime140.jsxs)("div", { className: clsx_default("block-editor-block-card", className), children: [
      allowParentNavigation && parentNavBlockClientId && // This is only used by the Navigation block for now. It's not ideal having Navigation block specific code here.
      /* @__PURE__ */ (0, import_jsx_runtime140.jsx)(
        import_components24.Button,
        {
          onClick: () => selectBlock2(parentNavBlockClientId),
          label: (0, import_i18n25.__)("Go to parent Navigation block"),
          style: (
            // TODO: This style override is also used in ToolsPanelHeader.
            // It should be supported out-of-the-box by Button.
            { minWidth: 24, padding: 0 }
          ),
          icon: (0, import_i18n25.isRTL)() ? chevron_right_default : chevron_left_default,
          size: "small"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime140.jsx)(block_icon_default, { icon, showColors: true }),
      /* @__PURE__ */ (0, import_jsx_runtime140.jsxs)(import_components24.__experimentalVStack, { spacing: 1, children: [
        /* @__PURE__ */ (0, import_jsx_runtime140.jsxs)("h2", { className: "block-editor-block-card__title", children: [
          /* @__PURE__ */ (0, import_jsx_runtime140.jsx)("span", { className: "block-editor-block-card__name", children: !!name?.length ? name : title }),
          !!name?.length && /* @__PURE__ */ (0, import_jsx_runtime140.jsx)(Badge, { children: title })
        ] }),
        description && /* @__PURE__ */ (0, import_jsx_runtime140.jsx)(import_components24.__experimentalText, { className: "block-editor-block-card__description", children: description }),
        children
      ] })
    ] });
  }
  var block_card_default = BlockCard;

  // packages/block-editor/build-module/components/block-preview/index.js
  var import_jsx_runtime151 = __toESM(require_jsx_runtime());
  var import_compose31 = __toESM(require_compose());
  var import_data47 = __toESM(require_data());
  var import_element46 = __toESM(require_element());
  var import_deprecated7 = __toESM(require_deprecated());

  // packages/block-editor/build-module/components/provider/index.js
  var import_jsx_runtime144 = __toESM(require_jsx_runtime());
  var import_data31 = __toESM(require_data());
  var import_element37 = __toESM(require_element());
  var import_components25 = __toESM(require_components());

  // packages/upload-media/build-module/store/index.js
  var import_data25 = __toESM(require_data());

  // packages/upload-media/build-module/store/types.js
  var Type = /* @__PURE__ */ ((Type2) => {
    Type2["Unknown"] = "REDUX_UNKNOWN";
    Type2["Add"] = "ADD_ITEM";
    Type2["Prepare"] = "PREPARE_ITEM";
    Type2["Cancel"] = "CANCEL_ITEM";
    Type2["Remove"] = "REMOVE_ITEM";
    Type2["PauseItem"] = "PAUSE_ITEM";
    Type2["ResumeItem"] = "RESUME_ITEM";
    Type2["PauseQueue"] = "PAUSE_QUEUE";
    Type2["ResumeQueue"] = "RESUME_QUEUE";
    Type2["OperationStart"] = "OPERATION_START";
    Type2["OperationFinish"] = "OPERATION_FINISH";
    Type2["AddOperations"] = "ADD_OPERATIONS";
    Type2["CacheBlobUrl"] = "CACHE_BLOB_URL";
    Type2["RevokeBlobUrls"] = "REVOKE_BLOB_URLS";
    Type2["UpdateSettings"] = "UPDATE_SETTINGS";
    return Type2;
  })(Type || {});
  var ItemStatus = /* @__PURE__ */ ((ItemStatus2) => {
    ItemStatus2["Processing"] = "PROCESSING";
    ItemStatus2["Paused"] = "PAUSED";
    return ItemStatus2;
  })(ItemStatus || {});
  var OperationType = /* @__PURE__ */ ((OperationType2) => {
    OperationType2["Prepare"] = "PREPARE";
    OperationType2["Upload"] = "UPLOAD";
    return OperationType2;
  })(OperationType || {});

  // packages/upload-media/build-module/store/reducer.js
  var noop4 = () => {
  };
  var DEFAULT_STATE = {
    queue: [],
    queueStatus: "active",
    blobUrls: {},
    settings: {
      mediaUpload: noop4
    }
  };
  function reducer(state = DEFAULT_STATE, action = { type: Type.Unknown }) {
    switch (action.type) {
      case Type.PauseQueue: {
        return {
          ...state,
          queueStatus: "paused"
        };
      }
      case Type.ResumeQueue: {
        return {
          ...state,
          queueStatus: "active"
        };
      }
      case Type.Add:
        return {
          ...state,
          queue: [...state.queue, action.item]
        };
      case Type.Cancel:
        return {
          ...state,
          queue: state.queue.map(
            (item) => item.id === action.id ? {
              ...item,
              error: action.error
            } : item
          )
        };
      case Type.Remove:
        return {
          ...state,
          queue: state.queue.filter((item) => item.id !== action.id)
        };
      case Type.OperationStart: {
        return {
          ...state,
          queue: state.queue.map(
            (item) => item.id === action.id ? {
              ...item,
              currentOperation: action.operation
            } : item
          )
        };
      }
      case Type.AddOperations:
        return {
          ...state,
          queue: state.queue.map((item) => {
            if (item.id !== action.id) {
              return item;
            }
            return {
              ...item,
              operations: [
                ...item.operations || [],
                ...action.operations
              ]
            };
          })
        };
      case Type.OperationFinish:
        return {
          ...state,
          queue: state.queue.map((item) => {
            if (item.id !== action.id) {
              return item;
            }
            const operations = item.operations ? item.operations.slice(1) : [];
            const attachment = item.attachment || action.item.attachment ? {
              ...item.attachment,
              ...action.item.attachment
            } : void 0;
            return {
              ...item,
              currentOperation: void 0,
              operations,
              ...action.item,
              attachment,
              additionalData: {
                ...item.additionalData,
                ...action.item.additionalData
              }
            };
          })
        };
      case Type.CacheBlobUrl: {
        const blobUrls = state.blobUrls[action.id] || [];
        return {
          ...state,
          blobUrls: {
            ...state.blobUrls,
            [action.id]: [...blobUrls, action.blobUrl]
          }
        };
      }
      case Type.RevokeBlobUrls: {
        const newBlobUrls = { ...state.blobUrls };
        delete newBlobUrls[action.id];
        return {
          ...state,
          blobUrls: newBlobUrls
        };
      }
      case Type.UpdateSettings: {
        return {
          ...state,
          settings: {
            ...state.settings,
            ...action.settings
          }
        };
      }
    }
    return state;
  }
  var reducer_default2 = reducer;

  // packages/upload-media/build-module/store/selectors.js
  var selectors_exports2 = {};
  __export(selectors_exports2, {
    getItems: () => getItems,
    getSettings: () => getSettings2,
    isUploading: () => isUploading,
    isUploadingById: () => isUploadingById,
    isUploadingByUrl: () => isUploadingByUrl
  });
  function getItems(state) {
    return state.queue;
  }
  function isUploading(state) {
    return state.queue.length >= 1;
  }
  function isUploadingByUrl(state, url) {
    return state.queue.some(
      (item) => item.attachment?.url === url || item.sourceUrl === url
    );
  }
  function isUploadingById(state, attachmentId) {
    return state.queue.some(
      (item) => item.attachment?.id === attachmentId || item.sourceAttachmentId === attachmentId
    );
  }
  function getSettings2(state) {
    return state.settings;
  }

  // packages/upload-media/build-module/store/private-selectors.js
  var private_selectors_exports2 = {};
  __export(private_selectors_exports2, {
    getAllItems: () => getAllItems,
    getBlobUrls: () => getBlobUrls,
    getItem: () => getItem,
    getPausedUploadForPost: () => getPausedUploadForPost,
    isBatchUploaded: () => isBatchUploaded,
    isPaused: () => isPaused2,
    isUploadingToPost: () => isUploadingToPost
  });
  function getAllItems(state) {
    return state.queue;
  }
  function getItem(state, id) {
    return state.queue.find((item) => item.id === id);
  }
  function isBatchUploaded(state, batchId) {
    const batchItems = state.queue.filter(
      (item) => batchId === item.batchId
    );
    return batchItems.length === 0;
  }
  function isUploadingToPost(state, postOrAttachmentId) {
    return state.queue.some(
      (item) => item.currentOperation === OperationType.Upload && item.additionalData.post === postOrAttachmentId
    );
  }
  function getPausedUploadForPost(state, postOrAttachmentId) {
    return state.queue.find(
      (item) => item.status === ItemStatus.Paused && item.additionalData.post === postOrAttachmentId
    );
  }
  function isPaused2(state) {
    return state.queueStatus === "paused";
  }
  function getBlobUrls(state, id) {
    return state.blobUrls[id] || [];
  }

  // packages/upload-media/build-module/store/actions.js
  var actions_exports2 = {};
  __export(actions_exports2, {
    addItems: () => addItems,
    cancelItem: () => cancelItem
  });

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i2 = 0; i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // packages/upload-media/build-module/validate-mime-type.js
  var import_i18n26 = __toESM(require_i18n());

  // packages/upload-media/build-module/upload-error.js
  var UploadError = class extends Error {
    code;
    file;
    constructor({ code, message, file, cause }) {
      super(message, { cause });
      Object.setPrototypeOf(this, new.target.prototype);
      this.code = code;
      this.file = file;
    }
  };

  // packages/upload-media/build-module/validate-mime-type.js
  function validateMimeType(file, allowedTypes) {
    if (!allowedTypes) {
      return;
    }
    const isAllowedType = allowedTypes.some((allowedType) => {
      if (allowedType.includes("/")) {
        return allowedType === file.type;
      }
      return file.type.startsWith(`${allowedType}/`);
    });
    if (file.type && !isAllowedType) {
      throw new UploadError({
        code: "MIME_TYPE_NOT_SUPPORTED",
        message: (0, import_i18n26.sprintf)(
          // translators: %s: file name.
          (0, import_i18n26.__)("%s: Sorry, this file type is not supported here."),
          file.name
        ),
        file
      });
    }
  }

  // packages/upload-media/build-module/validate-mime-type-for-user.js
  var import_i18n27 = __toESM(require_i18n());

  // packages/upload-media/build-module/get-mime-types-array.js
  function getMimeTypesArray(wpMimeTypesObject) {
    if (!wpMimeTypesObject) {
      return null;
    }
    return Object.entries(wpMimeTypesObject).flatMap(
      ([extensionsString, mime]) => {
        const [type] = mime.split("/");
        const extensions = extensionsString.split("|");
        return [
          mime,
          ...extensions.map(
            (extension) => `${type}/${extension}`
          )
        ];
      }
    );
  }

  // packages/upload-media/build-module/validate-mime-type-for-user.js
  function validateMimeTypeForUser(file, wpAllowedMimeTypes) {
    const allowedMimeTypesForUser = getMimeTypesArray(wpAllowedMimeTypes);
    if (!allowedMimeTypesForUser) {
      return;
    }
    const isAllowedMimeTypeForUser = allowedMimeTypesForUser.includes(
      file.type
    );
    if (file.type && !isAllowedMimeTypeForUser) {
      throw new UploadError({
        code: "MIME_TYPE_NOT_ALLOWED_FOR_USER",
        message: (0, import_i18n27.sprintf)(
          // translators: %s: file name.
          (0, import_i18n27.__)(
            "%s: Sorry, you are not allowed to upload this file type."
          ),
          file.name
        ),
        file
      });
    }
  }

  // packages/upload-media/build-module/validate-file-size.js
  var import_i18n28 = __toESM(require_i18n());
  function validateFileSize(file, maxUploadFileSize) {
    if (file.size <= 0) {
      throw new UploadError({
        code: "EMPTY_FILE",
        message: (0, import_i18n28.sprintf)(
          // translators: %s: file name.
          (0, import_i18n28.__)("%s: This file is empty."),
          file.name
        ),
        file
      });
    }
    if (maxUploadFileSize && file.size > maxUploadFileSize) {
      throw new UploadError({
        code: "SIZE_ABOVE_LIMIT",
        message: (0, import_i18n28.sprintf)(
          // translators: %s: file name.
          (0, import_i18n28.__)(
            "%s: This file exceeds the maximum upload size for this site."
          ),
          file.name
        ),
        file
      });
    }
  }

  // packages/upload-media/build-module/store/actions.js
  function addItems({
    files,
    onChange,
    onSuccess,
    onError,
    onBatchSuccess,
    additionalData,
    allowedTypes
  }) {
    return async ({ select: select2, dispatch }) => {
      const batchId = v4_default();
      for (const file of files) {
        try {
          validateMimeType(file, allowedTypes);
          validateMimeTypeForUser(
            file,
            select2.getSettings().allowedMimeTypes
          );
        } catch (error) {
          onError?.(error);
          continue;
        }
        try {
          validateFileSize(
            file,
            select2.getSettings().maxUploadFileSize
          );
        } catch (error) {
          onError?.(error);
          continue;
        }
        dispatch.addItem({
          file,
          batchId,
          onChange,
          onSuccess,
          onBatchSuccess,
          onError,
          additionalData
        });
      }
    };
  }
  function cancelItem(id, error, silent = false) {
    return async ({ select: select2, dispatch }) => {
      const item = select2.getItem(id);
      if (!item) {
        return;
      }
      item.abortController?.abort();
      if (!silent) {
        const { onError } = item;
        onError?.(error ?? new Error("Upload cancelled"));
        if (!onError && error) {
          console.error("Upload cancelled", error);
        }
      }
      dispatch({
        type: Type.Cancel,
        id,
        error
      });
      dispatch.removeItem(id);
      dispatch.revokeBlobUrls(id);
      if (item.batchId && select2.isBatchUploaded(item.batchId)) {
        item.onBatchSuccess?.();
      }
    };
  }

  // packages/upload-media/build-module/store/private-actions.js
  var private_actions_exports2 = {};
  __export(private_actions_exports2, {
    addItem: () => addItem,
    finishOperation: () => finishOperation,
    pauseQueue: () => pauseQueue,
    prepareItem: () => prepareItem,
    processItem: () => processItem,
    removeItem: () => removeItem,
    resumeQueue: () => resumeQueue,
    revokeBlobUrls: () => revokeBlobUrls,
    updateSettings: () => updateSettings2,
    uploadItem: () => uploadItem
  });
  var import_blob = __toESM(require_blob());

  // packages/upload-media/build-module/utils.js
  var import_url3 = __toESM(require_url());
  var import_i18n29 = __toESM(require_i18n());
  function convertBlobToFile(fileOrBlob) {
    if (fileOrBlob instanceof File) {
      return fileOrBlob;
    }
    const ext = fileOrBlob.type.split("/")[1];
    const mediaType = "application/pdf" === fileOrBlob.type ? "document" : fileOrBlob.type.split("/")[0];
    return new File([fileOrBlob], `${mediaType}.${ext}`, {
      type: fileOrBlob.type
    });
  }
  function renameFile(file, name) {
    return new File([file], name, {
      type: file.type,
      lastModified: file.lastModified
    });
  }
  function cloneFile(file) {
    return renameFile(file, file.name);
  }

  // packages/upload-media/build-module/stub-file.js
  var StubFile = class extends File {
    constructor(fileName = "stub-file") {
      super([], fileName);
    }
  };

  // packages/upload-media/build-module/store/private-actions.js
  function addItem({
    file: fileOrBlob,
    batchId,
    onChange,
    onSuccess,
    onBatchSuccess,
    onError,
    additionalData = {},
    sourceUrl,
    sourceAttachmentId,
    abortController,
    operations
  }) {
    return async ({ dispatch }) => {
      const itemId = v4_default();
      const file = convertBlobToFile(fileOrBlob);
      let blobUrl;
      if (!(file instanceof StubFile)) {
        blobUrl = (0, import_blob.createBlobURL)(file);
        dispatch({
          type: Type.CacheBlobUrl,
          id: itemId,
          blobUrl
        });
      }
      dispatch({
        type: Type.Add,
        item: {
          id: itemId,
          batchId,
          status: ItemStatus.Processing,
          sourceFile: cloneFile(file),
          file,
          attachment: {
            url: blobUrl
          },
          additionalData: {
            convert_format: false,
            ...additionalData
          },
          onChange,
          onSuccess,
          onBatchSuccess,
          onError,
          sourceUrl,
          sourceAttachmentId,
          abortController: abortController || new AbortController(),
          operations: Array.isArray(operations) ? operations : [OperationType.Prepare]
        }
      });
      dispatch.processItem(itemId);
    };
  }
  function processItem(id) {
    return async ({ select: select2, dispatch }) => {
      if (select2.isPaused()) {
        return;
      }
      const item = select2.getItem(id);
      const { attachment, onChange, onSuccess, onBatchSuccess, batchId } = item;
      const operation = Array.isArray(item.operations?.[0]) ? item.operations[0][0] : item.operations?.[0];
      if (attachment) {
        onChange?.([attachment]);
      }
      if (!operation) {
        if (attachment) {
          onSuccess?.([attachment]);
        }
        dispatch.revokeBlobUrls(id);
        if (batchId && select2.isBatchUploaded(batchId)) {
          onBatchSuccess?.();
        }
        return;
      }
      if (!operation) {
        return;
      }
      dispatch({
        type: Type.OperationStart,
        id,
        operation
      });
      switch (operation) {
        case OperationType.Prepare:
          dispatch.prepareItem(item.id);
          break;
        case OperationType.Upload:
          dispatch.uploadItem(id);
          break;
      }
    };
  }
  function pauseQueue() {
    return {
      type: Type.PauseQueue
    };
  }
  function resumeQueue() {
    return async ({ select: select2, dispatch }) => {
      dispatch({
        type: Type.ResumeQueue
      });
      for (const item of select2.getAllItems()) {
        dispatch.processItem(item.id);
      }
    };
  }
  function removeItem(id) {
    return async ({ select: select2, dispatch }) => {
      const item = select2.getItem(id);
      if (!item) {
        return;
      }
      dispatch({
        type: Type.Remove,
        id
      });
    };
  }
  function finishOperation(id, updates) {
    return async ({ dispatch }) => {
      dispatch({
        type: Type.OperationFinish,
        id,
        item: updates
      });
      dispatch.processItem(id);
    };
  }
  function prepareItem(id) {
    return async ({ dispatch }) => {
      const operations = [OperationType.Upload];
      dispatch({
        type: Type.AddOperations,
        id,
        operations
      });
      dispatch.finishOperation(id, {});
    };
  }
  function uploadItem(id) {
    return async ({ select: select2, dispatch }) => {
      const item = select2.getItem(id);
      select2.getSettings().mediaUpload({
        filesList: [item.file],
        additionalData: item.additionalData,
        signal: item.abortController?.signal,
        onFileChange: ([attachment]) => {
          if (!(0, import_blob.isBlobURL)(attachment.url)) {
            dispatch.finishOperation(id, {
              attachment
            });
          }
        },
        onSuccess: ([attachment]) => {
          dispatch.finishOperation(id, {
            attachment
          });
        },
        onError: (error) => {
          dispatch.cancelItem(id, error);
        }
      });
    };
  }
  function revokeBlobUrls(id) {
    return async ({ select: select2, dispatch }) => {
      const blobUrls = select2.getBlobUrls(id);
      for (const blobUrl of blobUrls) {
        (0, import_blob.revokeBlobURL)(blobUrl);
      }
      dispatch({
        type: Type.RevokeBlobUrls,
        id
      });
    };
  }
  function updateSettings2(settings2) {
    return {
      type: Type.UpdateSettings,
      settings: settings2
    };
  }

  // packages/upload-media/build-module/lock-unlock.js
  var import_private_apis2 = __toESM(require_private_apis());
  var { lock: lock2, unlock: unlock2 } = (0, import_private_apis2.__dangerousOptInToUnstableAPIsOnlyForCoreModules)(
    "I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.",
    "@wordpress/upload-media"
  );

  // packages/upload-media/build-module/store/constants.js
  var STORE_NAME2 = "core/upload-media";

  // packages/upload-media/build-module/store/index.js
  var storeConfig2 = {
    reducer: reducer_default2,
    selectors: selectors_exports2,
    actions: actions_exports2
  };
  var store2 = (0, import_data25.createReduxStore)(STORE_NAME2, {
    reducer: reducer_default2,
    selectors: selectors_exports2,
    actions: actions_exports2
  });
  (0, import_data25.register)(store2);
  unlock2(store2).registerPrivateActions(private_actions_exports2);
  unlock2(store2).registerPrivateSelectors(private_selectors_exports2);

  // packages/upload-media/build-module/components/provider/index.js
  var import_jsx_runtime142 = __toESM(require_jsx_runtime());
  var import_element32 = __toESM(require_element());
  var import_data27 = __toESM(require_data());

  // packages/upload-media/build-module/components/provider/with-registry-provider.js
  var import_jsx_runtime141 = __toESM(require_jsx_runtime());
  var import_element31 = __toESM(require_element());
  var import_data26 = __toESM(require_data());
  var import_compose15 = __toESM(require_compose());
  function getSubRegistry(subRegistries, registry, useSubRegistry) {
    if (!useSubRegistry) {
      return registry;
    }
    let subRegistry = subRegistries.get(registry);
    if (!subRegistry) {
      subRegistry = (0, import_data26.createRegistry)({}, registry);
      subRegistry.registerStore(STORE_NAME2, storeConfig2);
      subRegistries.set(registry, subRegistry);
    }
    return subRegistry;
  }
  var withRegistryProvider = (0, import_compose15.createHigherOrderComponent)(
    (WrappedComponent) => ({ useSubRegistry = true, ...props }) => {
      const registry = (0, import_data26.useRegistry)();
      const [subRegistries] = (0, import_element31.useState)(() => /* @__PURE__ */ new WeakMap());
      const subRegistry = getSubRegistry(
        subRegistries,
        registry,
        useSubRegistry
      );
      if (subRegistry === registry) {
        return /* @__PURE__ */ (0, import_jsx_runtime141.jsx)(WrappedComponent, { registry, ...props });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime141.jsx)(import_data26.RegistryProvider, { value: subRegistry, children: /* @__PURE__ */ (0, import_jsx_runtime141.jsx)(WrappedComponent, { registry: subRegistry, ...props }) });
    },
    "withRegistryProvider"
  );
  var with_registry_provider_default = withRegistryProvider;

  // packages/upload-media/build-module/components/provider/index.js
  var MediaUploadProvider = with_registry_provider_default((props) => {
    const { children, settings: settings2 } = props;
    const { updateSettings: updateSettings3 } = unlock2((0, import_data27.useDispatch)(store2));
    (0, import_element32.useEffect)(() => {
      updateSettings3(settings2);
    }, [settings2, updateSettings3]);
    return /* @__PURE__ */ (0, import_jsx_runtime142.jsx)(import_jsx_runtime142.Fragment, { children });
  });
  var provider_default = MediaUploadProvider;

  // packages/block-editor/build-module/components/provider/with-registry-provider.js
  var import_jsx_runtime143 = __toESM(require_jsx_runtime());
  var import_element33 = __toESM(require_element());
  var import_data28 = __toESM(require_data());
  var import_compose16 = __toESM(require_compose());
  function getSubRegistry2(subRegistries, registry, useSubRegistry) {
    if (!useSubRegistry) {
      return registry;
    }
    let subRegistry = subRegistries.get(registry);
    if (!subRegistry) {
      subRegistry = (0, import_data28.createRegistry)({}, registry);
      subRegistry.registerStore(STORE_NAME, storeConfig);
      subRegistries.set(registry, subRegistry);
    }
    return subRegistry;
  }
  var withRegistryProvider2 = (0, import_compose16.createHigherOrderComponent)(
    (WrappedComponent) => ({ useSubRegistry = true, ...props }) => {
      const registry = (0, import_data28.useRegistry)();
      const [subRegistries] = (0, import_element33.useState)(() => /* @__PURE__ */ new WeakMap());
      const subRegistry = getSubRegistry2(
        subRegistries,
        registry,
        useSubRegistry
      );
      if (subRegistry === registry) {
        return /* @__PURE__ */ (0, import_jsx_runtime143.jsx)(WrappedComponent, { registry, ...props });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime143.jsx)(import_data28.RegistryProvider, { value: subRegistry, children: /* @__PURE__ */ (0, import_jsx_runtime143.jsx)(WrappedComponent, { registry: subRegistry, ...props }) });
    },
    "withRegistryProvider"
  );
  var with_registry_provider_default2 = withRegistryProvider2;

  // packages/block-editor/build-module/components/provider/use-block-sync.js
  var import_element34 = __toESM(require_element());
  var import_data29 = __toESM(require_data());
  var import_blocks19 = __toESM(require_blocks());
  var noop5 = () => {
  };
  function useBlockSync({
    clientId = null,
    value: controlledBlocks,
    selection: controlledSelection,
    onChange = noop5,
    onInput = noop5
  }) {
    const registry = (0, import_data29.useRegistry)();
    const {
      resetBlocks: resetBlocks2,
      resetSelection: resetSelection2,
      replaceInnerBlocks: replaceInnerBlocks2,
      setHasControlledInnerBlocks: setHasControlledInnerBlocks2,
      __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2
    } = registry.dispatch(store);
    const { getBlockName: getBlockName2, getBlocks: getBlocks2, getSelectionStart: getSelectionStart2, getSelectionEnd: getSelectionEnd2 } = registry.select(store);
    const isControlled = (0, import_data29.useSelect)(
      (select2) => {
        return !clientId || select2(store).areInnerBlocksControlled(clientId);
      },
      [clientId]
    );
    const pendingChangesRef = (0, import_element34.useRef)({ incoming: null, outgoing: [] });
    const subscribedRef = (0, import_element34.useRef)(false);
    const setControlledBlocks = () => {
      if (!controlledBlocks) {
        return;
      }
      __unstableMarkNextChangeAsNotPersistent2();
      if (clientId) {
        registry.batch(() => {
          setHasControlledInnerBlocks2(clientId, true);
          const storeBlocks = controlledBlocks.map(
            (block) => (0, import_blocks19.cloneBlock)(block)
          );
          if (subscribedRef.current) {
            pendingChangesRef.current.incoming = storeBlocks;
          }
          __unstableMarkNextChangeAsNotPersistent2();
          replaceInnerBlocks2(clientId, storeBlocks);
        });
      } else {
        if (subscribedRef.current) {
          pendingChangesRef.current.incoming = controlledBlocks;
        }
        resetBlocks2(controlledBlocks);
      }
    };
    const unsetControlledBlocks = () => {
      __unstableMarkNextChangeAsNotPersistent2();
      if (clientId) {
        setHasControlledInnerBlocks2(clientId, false);
        __unstableMarkNextChangeAsNotPersistent2();
        replaceInnerBlocks2(clientId, []);
      } else {
        resetBlocks2([]);
      }
    };
    const onInputRef = (0, import_element34.useRef)(onInput);
    const onChangeRef = (0, import_element34.useRef)(onChange);
    (0, import_element34.useEffect)(() => {
      onInputRef.current = onInput;
      onChangeRef.current = onChange;
    }, [onInput, onChange]);
    (0, import_element34.useEffect)(() => {
      if (pendingChangesRef.current.outgoing.includes(controlledBlocks)) {
        if (pendingChangesRef.current.outgoing[pendingChangesRef.current.outgoing.length - 1] === controlledBlocks) {
          pendingChangesRef.current.outgoing = [];
        }
      } else if (getBlocks2(clientId) !== controlledBlocks) {
        pendingChangesRef.current.outgoing = [];
        setControlledBlocks();
        if (controlledSelection) {
          resetSelection2(
            controlledSelection.selectionStart,
            controlledSelection.selectionEnd,
            controlledSelection.initialPosition
          );
        }
      }
    }, [controlledBlocks, clientId]);
    const isMountedRef = (0, import_element34.useRef)(false);
    (0, import_element34.useEffect)(() => {
      if (!isMountedRef.current) {
        isMountedRef.current = true;
        return;
      }
      if (!isControlled) {
        pendingChangesRef.current.outgoing = [];
        setControlledBlocks();
      }
    }, [isControlled]);
    (0, import_element34.useEffect)(() => {
      const {
        getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2,
        isLastBlockChangePersistent: isLastBlockChangePersistent2,
        __unstableIsLastBlockChangeIgnored: __unstableIsLastBlockChangeIgnored2,
        areInnerBlocksControlled: areInnerBlocksControlled2
      } = registry.select(store);
      let blocks2 = getBlocks2(clientId);
      let isPersistent = isLastBlockChangePersistent2();
      let previousAreBlocksDifferent = false;
      subscribedRef.current = true;
      const unsubscribe = registry.subscribe(() => {
        if (clientId !== null && getBlockName2(clientId) === null) {
          return;
        }
        const isStillControlled = !clientId || areInnerBlocksControlled2(clientId);
        if (!isStillControlled) {
          return;
        }
        const newIsPersistent = isLastBlockChangePersistent2();
        const newBlocks = getBlocks2(clientId);
        const areBlocksDifferent = newBlocks !== blocks2;
        blocks2 = newBlocks;
        if (areBlocksDifferent && (pendingChangesRef.current.incoming || __unstableIsLastBlockChangeIgnored2())) {
          pendingChangesRef.current.incoming = null;
          isPersistent = newIsPersistent;
          return;
        }
        const didPersistenceChange = previousAreBlocksDifferent && !areBlocksDifferent && newIsPersistent && !isPersistent;
        if (areBlocksDifferent || didPersistenceChange) {
          isPersistent = newIsPersistent;
          pendingChangesRef.current.outgoing.push(blocks2);
          const updateParent = isPersistent ? onChangeRef.current : onInputRef.current;
          updateParent(blocks2, {
            selection: {
              selectionStart: getSelectionStart2(),
              selectionEnd: getSelectionEnd2(),
              initialPosition: getSelectedBlocksInitialCaretPosition2()
            }
          });
        }
        previousAreBlocksDifferent = areBlocksDifferent;
      }, store);
      return () => {
        subscribedRef.current = false;
        unsubscribe();
      };
    }, [registry, clientId]);
    (0, import_element34.useEffect)(() => {
      return () => {
        unsetControlledBlocks();
      };
    }, []);
  }

  // packages/block-editor/build-module/components/keyboard-shortcuts/index.js
  var import_element35 = __toESM(require_element());
  var import_data30 = __toESM(require_data());
  var import_keyboard_shortcuts = __toESM(require_keyboard_shortcuts());
  var import_i18n30 = __toESM(require_i18n());
  function KeyboardShortcuts() {
    return null;
  }
  function KeyboardShortcutsRegister() {
    const { registerShortcut } = (0, import_data30.useDispatch)(import_keyboard_shortcuts.store);
    (0, import_element35.useEffect)(() => {
      registerShortcut({
        name: "core/block-editor/copy",
        category: "block",
        description: (0, import_i18n30.__)("Copy the selected block(s)."),
        keyCombination: {
          modifier: "primary",
          character: "c"
        }
      });
      registerShortcut({
        name: "core/block-editor/cut",
        category: "block",
        description: (0, import_i18n30.__)("Cut the selected block(s)."),
        keyCombination: {
          modifier: "primary",
          character: "x"
        }
      });
      registerShortcut({
        name: "core/block-editor/paste",
        category: "block",
        description: (0, import_i18n30.__)("Paste the selected block(s)."),
        keyCombination: {
          modifier: "primary",
          character: "v"
        }
      });
      registerShortcut({
        name: "core/block-editor/duplicate",
        category: "block",
        description: (0, import_i18n30.__)("Duplicate the selected block(s)."),
        keyCombination: {
          modifier: "primaryShift",
          character: "d"
        }
      });
      registerShortcut({
        name: "core/block-editor/remove",
        category: "block",
        description: (0, import_i18n30.__)("Remove the selected block(s)."),
        keyCombination: {
          modifier: "access",
          character: "z"
        }
      });
      registerShortcut({
        name: "core/block-editor/paste-styles",
        category: "block",
        description: (0, import_i18n30.__)(
          "Paste the copied style to the selected block(s)."
        ),
        keyCombination: {
          modifier: "primaryAlt",
          character: "v"
        }
      });
      registerShortcut({
        name: "core/block-editor/insert-before",
        category: "block",
        description: (0, import_i18n30.__)(
          "Insert a new block before the selected block(s)."
        ),
        keyCombination: {
          modifier: "primaryAlt",
          character: "t"
        }
      });
      registerShortcut({
        name: "core/block-editor/insert-after",
        category: "block",
        description: (0, import_i18n30.__)(
          "Insert a new block after the selected block(s)."
        ),
        keyCombination: {
          modifier: "primaryAlt",
          character: "y"
        }
      });
      registerShortcut({
        name: "core/block-editor/delete-multi-selection",
        category: "block",
        description: (0, import_i18n30.__)("Delete selection."),
        keyCombination: {
          character: "del"
        },
        aliases: [
          {
            character: "backspace"
          }
        ]
      });
      registerShortcut({
        name: "core/block-editor/select-all",
        category: "selection",
        description: (0, import_i18n30.__)(
          "Select all text when typing. Press again to select all blocks."
        ),
        keyCombination: {
          modifier: "primary",
          character: "a"
        }
      });
      registerShortcut({
        name: "core/block-editor/unselect",
        category: "selection",
        description: (0, import_i18n30.__)("Clear selection."),
        keyCombination: {
          character: "escape"
        }
      });
      registerShortcut({
        name: "core/block-editor/multi-text-selection",
        category: "selection",
        description: (0, import_i18n30.__)("Select text across multiple blocks."),
        keyCombination: {
          modifier: "shift",
          character: "arrow"
        }
      });
      registerShortcut({
        name: "core/block-editor/focus-toolbar",
        category: "global",
        description: (0, import_i18n30.__)("Navigate to the nearest toolbar."),
        keyCombination: {
          modifier: "alt",
          character: "F10"
        }
      });
      registerShortcut({
        name: "core/block-editor/move-up",
        category: "block",
        description: (0, import_i18n30.__)("Move the selected block(s) up."),
        keyCombination: {
          modifier: "secondary",
          character: "t"
        }
      });
      registerShortcut({
        name: "core/block-editor/move-down",
        category: "block",
        description: (0, import_i18n30.__)("Move the selected block(s) down."),
        keyCombination: {
          modifier: "secondary",
          character: "y"
        }
      });
      registerShortcut({
        name: "core/block-editor/collapse-list-view",
        category: "list-view",
        description: (0, import_i18n30.__)("Collapse all other items."),
        keyCombination: {
          modifier: "alt",
          character: "l"
        }
      });
      registerShortcut({
        name: "core/block-editor/group",
        category: "block",
        description: (0, import_i18n30.__)(
          "Create a group block from the selected multiple blocks."
        ),
        keyCombination: {
          modifier: "primary",
          character: "g"
        }
      });
      registerShortcut({
        name: "core/block-editor/toggle-block-visibility",
        category: "block",
        description: (0, import_i18n30.__)("Show or hide the selected block(s)."),
        keyCombination: {
          modifier: "primaryShift",
          character: "h"
        }
      });
    }, [registerShortcut]);
    return null;
  }
  KeyboardShortcuts.Register = KeyboardShortcutsRegister;
  var keyboard_shortcuts_default = KeyboardShortcuts;

  // packages/block-editor/build-module/components/provider/use-media-upload-settings.js
  var import_element36 = __toESM(require_element());
  function useMediaUploadSettings(settings2 = {}) {
    return (0, import_element36.useMemo)(
      () => ({
        mediaUpload: settings2.mediaUpload,
        mediaSideload: settings2.mediaSideload,
        maxUploadFileSize: settings2.maxUploadFileSize,
        allowedMimeTypes: settings2.allowedMimeTypes
      }),
      [settings2]
    );
  }
  var use_media_upload_settings_default = useMediaUploadSettings;

  // packages/block-editor/build-module/components/provider/index.js
  var noop6 = () => {
  };
  function mediaUpload(registry, {
    allowedTypes,
    additionalData = {},
    filesList,
    onError = noop6,
    onFileChange,
    onSuccess,
    onBatchSuccess
  }) {
    void registry.dispatch(store2).addItems({
      files: filesList,
      onChange: onFileChange,
      onSuccess,
      onBatchSuccess,
      onError: ({ message }) => onError(message),
      additionalData,
      allowedTypes
    });
  }
  var ExperimentalBlockEditorProvider = with_registry_provider_default2(
    (props) => {
      const {
        settings: _settings,
        registry,
        stripExperimentalSettings = false
      } = props;
      const mediaUploadSettings = use_media_upload_settings_default(_settings);
      let settings2 = _settings;
      if (window.__experimentalMediaProcessing && _settings.mediaUpload) {
        settings2 = (0, import_element37.useMemo)(
          () => ({
            ..._settings,
            mediaUpload: mediaUpload.bind(null, registry)
          }),
          [_settings, registry]
        );
      }
      const { __experimentalUpdateSettings: __experimentalUpdateSettings2 } = unlock(
        (0, import_data31.useDispatch)(store)
      );
      (0, import_element37.useEffect)(() => {
        __experimentalUpdateSettings2(
          {
            ...settings2,
            __internalIsInitialized: true
          },
          {
            stripExperimentalSettings,
            reset: true
          }
        );
      }, [
        settings2,
        stripExperimentalSettings,
        __experimentalUpdateSettings2
      ]);
      useBlockSync(props);
      const children = /* @__PURE__ */ (0, import_jsx_runtime144.jsxs)(import_components25.SlotFillProvider, { passthrough: true, children: [
        !settings2?.isPreviewMode && /* @__PURE__ */ (0, import_jsx_runtime144.jsx)(keyboard_shortcuts_default.Register, {}),
        /* @__PURE__ */ (0, import_jsx_runtime144.jsx)(BlockRefsProvider, { children: props.children })
      ] });
      if (window.__experimentalMediaProcessing) {
        return /* @__PURE__ */ (0, import_jsx_runtime144.jsx)(
          provider_default,
          {
            settings: mediaUploadSettings,
            useSubRegistry: false,
            children
          }
        );
      }
      return children;
    }
  );
  var BlockEditorProvider = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime144.jsx)(ExperimentalBlockEditorProvider, { ...props, stripExperimentalSettings: true, children: props.children });
  };
  var provider_default2 = BlockEditorProvider;

  // packages/block-editor/build-module/components/block-preview/auto.js
  var import_jsx_runtime150 = __toESM(require_jsx_runtime());
  var import_compose30 = __toESM(require_compose());
  var import_data46 = __toESM(require_data());
  var import_element44 = __toESM(require_element());
  var import_components28 = __toESM(require_components());

  // packages/block-editor/build-module/components/iframe/index.js
  var import_jsx_runtime148 = __toESM(require_jsx_runtime());
  var import_element42 = __toESM(require_element());
  var import_i18n33 = __toESM(require_i18n());
  var import_compose29 = __toESM(require_compose());
  var import_components26 = __toESM(require_components());
  var import_data44 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-selection-clearer/index.js
  var import_jsx_runtime145 = __toESM(require_jsx_runtime());
  var import_data32 = __toESM(require_data());
  var import_compose17 = __toESM(require_compose());
  function useBlockSelectionClearer() {
    const { getSettings: getSettings4, hasSelectedBlock: hasSelectedBlock2, hasMultiSelection: hasMultiSelection2 } = (0, import_data32.useSelect)(store);
    const { clearSelectedBlock: clearSelectedBlock2 } = (0, import_data32.useDispatch)(store);
    const { clearBlockSelection: isEnabled } = getSettings4();
    return (0, import_compose17.useRefEffect)(
      (node2) => {
        if (!isEnabled) {
          return;
        }
        function onMouseDown(event) {
          if (!hasSelectedBlock2() && !hasMultiSelection2()) {
            return;
          }
          if (event.target !== node2) {
            return;
          }
          clearSelectedBlock2();
        }
        node2.addEventListener("mousedown", onMouseDown);
        return () => {
          node2.removeEventListener("mousedown", onMouseDown);
        };
      },
      [hasSelectedBlock2, hasMultiSelection2, clearSelectedBlock2, isEnabled]
    );
  }
  function BlockSelectionClearer(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime145.jsx)("div", { ref: useBlockSelectionClearer(), ...props });
  }

  // packages/block-editor/build-module/components/writing-flow/index.js
  var import_jsx_runtime147 = __toESM(require_jsx_runtime());
  var import_data43 = __toESM(require_data());
  var import_i18n32 = __toESM(require_i18n());
  var import_compose27 = __toESM(require_compose());
  var import_element40 = __toESM(require_element());

  // packages/block-editor/build-module/components/writing-flow/use-multi-selection.js
  var import_compose18 = __toESM(require_compose());
  var import_data33 = __toESM(require_data());
  function selector(select2) {
    const {
      isMultiSelecting: isMultiSelecting3,
      getMultiSelectedBlockClientIds: getMultiSelectedBlockClientIds2,
      hasMultiSelection: hasMultiSelection2,
      getSelectedBlockClientId: getSelectedBlockClientId2,
      getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2,
      __unstableIsFullySelected: __unstableIsFullySelected2
    } = select2(store);
    return {
      isMultiSelecting: isMultiSelecting3(),
      multiSelectedBlockClientIds: getMultiSelectedBlockClientIds2(),
      hasMultiSelection: hasMultiSelection2(),
      selectedBlockClientId: getSelectedBlockClientId2(),
      initialPosition: getSelectedBlocksInitialCaretPosition2(),
      isFullSelection: __unstableIsFullySelected2()
    };
  }
  function useMultiSelection() {
    const {
      initialPosition: initialPosition2,
      isMultiSelecting: isMultiSelecting3,
      multiSelectedBlockClientIds,
      hasMultiSelection: hasMultiSelection2,
      selectedBlockClientId,
      isFullSelection
    } = (0, import_data33.useSelect)(selector, []);
    return (0, import_compose18.useRefEffect)(
      (node2) => {
        const { ownerDocument } = node2;
        const { defaultView } = ownerDocument;
        if (initialPosition2 === void 0 || initialPosition2 === null) {
          return;
        }
        if (!hasMultiSelection2 || isMultiSelecting3) {
          return;
        }
        const { length: length2 } = multiSelectedBlockClientIds;
        if (length2 < 2) {
          return;
        }
        if (!isFullSelection) {
          return;
        }
        node2.contentEditable = true;
        node2.focus();
        defaultView.getSelection().removeAllRanges();
      },
      [
        hasMultiSelection2,
        isMultiSelecting3,
        multiSelectedBlockClientIds,
        selectedBlockClientId,
        initialPosition2,
        isFullSelection
      ]
    );
  }

  // packages/block-editor/build-module/components/writing-flow/use-tab-nav.js
  var import_jsx_runtime146 = __toESM(require_jsx_runtime());
  var import_dom8 = __toESM(require_dom());
  var import_keycodes3 = __toESM(require_keycodes());
  var import_data34 = __toESM(require_data());
  var import_compose19 = __toESM(require_compose());
  var import_element38 = __toESM(require_element());
  function useTabNav() {
    const containerRef = (
      /** @type {typeof useRef<HTMLElement>} */
      (0, import_element38.useRef)()
    );
    const focusCaptureBeforeRef = (0, import_element38.useRef)();
    const focusCaptureAfterRef = (0, import_element38.useRef)();
    const {
      hasMultiSelection: hasMultiSelection2,
      getSelectedBlockClientId: getSelectedBlockClientId2,
      getBlockCount: getBlockCount2,
      getBlockOrder: getBlockOrder2,
      getLastFocus: getLastFocus2,
      getSectionRootClientId: getSectionRootClientId2,
      isZoomOut: isZoomOut2
    } = unlock((0, import_data34.useSelect)(store));
    const { setLastFocus: setLastFocus2 } = unlock((0, import_data34.useDispatch)(store));
    const noCaptureRef = (0, import_element38.useRef)();
    function onFocusCapture(event) {
      const canvasElement = containerRef.current.ownerDocument === event.target.ownerDocument ? containerRef.current : containerRef.current.ownerDocument.defaultView.frameElement;
      if (noCaptureRef.current) {
        noCaptureRef.current = null;
      } else if (hasMultiSelection2()) {
        containerRef.current.focus();
      } else if (getSelectedBlockClientId2()) {
        if (getLastFocus2()?.current) {
          getLastFocus2().current.focus();
        } else {
          containerRef.current.querySelector(
            `[data-block="${getSelectedBlockClientId2()}"]`
          ).focus();
        }
      } else if (isZoomOut2()) {
        const sectionRootClientId = getSectionRootClientId2();
        const sectionBlocks = getBlockOrder2(sectionRootClientId);
        if (sectionBlocks.length) {
          containerRef.current.querySelector(`[data-block="${sectionBlocks[0]}"]`).focus();
        } else if (sectionRootClientId) {
          containerRef.current.querySelector(`[data-block="${sectionRootClientId}"]`).focus();
        } else {
          canvasElement.focus();
        }
      } else {
        const isBefore = (
          // eslint-disable-next-line no-bitwise
          event.target.compareDocumentPosition(canvasElement) & event.target.DOCUMENT_POSITION_FOLLOWING
        );
        const tabbables = import_dom8.focus.tabbable.find(containerRef.current);
        if (tabbables.length) {
          const next2 = isBefore ? tabbables[0] : tabbables[tabbables.length - 1];
          next2.focus();
        }
      }
    }
    const before = /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
      "div",
      {
        ref: focusCaptureBeforeRef,
        tabIndex: "0",
        onFocus: onFocusCapture
      }
    );
    const after = /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
      "div",
      {
        ref: focusCaptureAfterRef,
        tabIndex: "0",
        onFocus: onFocusCapture
      }
    );
    const ref = (0, import_compose19.useRefEffect)((node2) => {
      function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.keyCode !== import_keycodes3.TAB) {
          return;
        }
        if (
          // Bails in case the focus capture elements aren’t present. They
          // may be omitted to avoid silent tab stops in preview mode.
          // See: https://github.com/WordPress/gutenberg/pull/59317
          !focusCaptureAfterRef.current || !focusCaptureBeforeRef.current
        ) {
          return;
        }
        const { target, shiftKey: isShift } = event;
        const direction = isShift ? "findPrevious" : "findNext";
        const nextTabbable = import_dom8.focus.tabbable[direction](target);
        const currentBlock = target.closest("[data-block]");
        const isElementPartOfSelectedBlock = currentBlock && nextTabbable && (isInSameBlock(currentBlock, nextTabbable) || isInsideRootBlock(currentBlock, nextTabbable));
        if ((0, import_dom8.isFormElement)(nextTabbable) && isElementPartOfSelectedBlock) {
          return;
        }
        const next2 = isShift ? focusCaptureBeforeRef : focusCaptureAfterRef;
        noCaptureRef.current = true;
        next2.current.focus({ preventScroll: true });
      }
      function onFocusOut(event) {
        setLastFocus2({ ...getLastFocus2(), current: event.target });
        const { ownerDocument: ownerDocument2 } = node2;
        if (!event.relatedTarget && event.target.hasAttribute("data-block") && ownerDocument2.activeElement === ownerDocument2.body && getBlockCount2() === 0) {
          node2.focus();
        }
      }
      function preventScrollOnTab(event) {
        if (event.keyCode !== import_keycodes3.TAB) {
          return;
        }
        if (event.target?.getAttribute("role") === "region") {
          return;
        }
        if (containerRef.current === event.target) {
          return;
        }
        const isShift = event.shiftKey;
        const direction = isShift ? "findPrevious" : "findNext";
        const target = import_dom8.focus.tabbable[direction](event.target);
        if (target === focusCaptureBeforeRef.current || target === focusCaptureAfterRef.current) {
          event.preventDefault();
          target.focus({ preventScroll: true });
        }
      }
      const { ownerDocument } = node2;
      const { defaultView } = ownerDocument;
      defaultView.addEventListener("keydown", preventScrollOnTab);
      node2.addEventListener("keydown", onKeyDown);
      node2.addEventListener("focusout", onFocusOut);
      return () => {
        defaultView.removeEventListener("keydown", preventScrollOnTab);
        node2.removeEventListener("keydown", onKeyDown);
        node2.removeEventListener("focusout", onFocusOut);
      };
    }, []);
    const mergedRefs = (0, import_compose19.useMergeRefs)([containerRef, ref]);
    return [before, mergedRefs, after];
  }

  // packages/block-editor/build-module/components/writing-flow/use-arrow-nav.js
  var import_dom10 = __toESM(require_dom());
  var import_keycodes4 = __toESM(require_keycodes());
  var import_data35 = __toESM(require_data());
  var import_compose20 = __toESM(require_compose());
  function isNavigationCandidate(element, keyCode, hasModifier) {
    const isVertical = keyCode === import_keycodes4.UP || keyCode === import_keycodes4.DOWN;
    const { tagName } = element;
    const elementType = element.getAttribute("type");
    if (isVertical && !hasModifier) {
      if (tagName === "INPUT") {
        const verticalInputTypes = [
          "date",
          "datetime-local",
          "month",
          "number",
          "range",
          "time",
          "week"
        ];
        return !verticalInputTypes.includes(elementType);
      }
      return true;
    }
    if (tagName === "INPUT") {
      const simpleInputTypes = [
        "button",
        "checkbox",
        "number",
        "color",
        "file",
        "image",
        "radio",
        "reset",
        "submit"
      ];
      return simpleInputTypes.includes(elementType);
    }
    return tagName !== "TEXTAREA";
  }
  function getClosestTabbable(target, isReverse, containerElement, onlyVertical) {
    let focusableNodes = import_dom10.focus.focusable.find(containerElement);
    if (isReverse) {
      focusableNodes.reverse();
    }
    focusableNodes = focusableNodes.slice(
      focusableNodes.indexOf(target) + 1
    );
    let targetRect;
    if (onlyVertical) {
      targetRect = target.getBoundingClientRect();
    }
    function isTabCandidate(node2) {
      if (node2.closest("[inert]")) {
        return;
      }
      if (node2.children.length === 1 && isInSameBlock(node2, node2.firstElementChild) && node2.firstElementChild.getAttribute("contenteditable") === "true") {
        return;
      }
      if (!import_dom10.focus.tabbable.isTabbableIndex(node2)) {
        return false;
      }
      if (node2.isContentEditable && node2.contentEditable !== "true") {
        return false;
      }
      if (onlyVertical) {
        const nodeRect = node2.getBoundingClientRect();
        if (nodeRect.left >= targetRect.right || nodeRect.right <= targetRect.left) {
          return false;
        }
      }
      return true;
    }
    return focusableNodes.find(isTabCandidate);
  }
  function useArrowNav() {
    const {
      getMultiSelectedBlocksStartClientId: getMultiSelectedBlocksStartClientId2,
      getMultiSelectedBlocksEndClientId: getMultiSelectedBlocksEndClientId2,
      getSettings: getSettings4,
      hasMultiSelection: hasMultiSelection2,
      __unstableIsFullySelected: __unstableIsFullySelected2
    } = (0, import_data35.useSelect)(store);
    const { selectBlock: selectBlock2 } = (0, import_data35.useDispatch)(store);
    return (0, import_compose20.useRefEffect)((node2) => {
      let verticalRect;
      function onMouseDown() {
        verticalRect = null;
      }
      function isClosestTabbableABlock(target, isReverse) {
        const closestTabbable = getClosestTabbable(
          target,
          isReverse,
          node2
        );
        return closestTabbable && getBlockClientId(closestTabbable);
      }
      function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        const { keyCode, target, shiftKey, ctrlKey, altKey, metaKey } = event;
        const isUp = keyCode === import_keycodes4.UP;
        const isDown = keyCode === import_keycodes4.DOWN;
        const isLeft = keyCode === import_keycodes4.LEFT;
        const isRight = keyCode === import_keycodes4.RIGHT;
        const isReverse = isUp || isLeft;
        const isHorizontal = isLeft || isRight;
        const isVertical = isUp || isDown;
        const isNav = isHorizontal || isVertical;
        const hasModifier = shiftKey || ctrlKey || altKey || metaKey;
        const isNavEdge = isVertical ? import_dom10.isVerticalEdge : import_dom10.isHorizontalEdge;
        const { ownerDocument } = node2;
        const { defaultView } = ownerDocument;
        if (!isNav) {
          return;
        }
        if (hasMultiSelection2()) {
          if (shiftKey) {
            return;
          }
          if (!__unstableIsFullySelected2()) {
            return;
          }
          event.preventDefault();
          if (isReverse) {
            selectBlock2(getMultiSelectedBlocksStartClientId2());
          } else {
            selectBlock2(getMultiSelectedBlocksEndClientId2(), -1);
          }
          return;
        }
        if (!isNavigationCandidate(target, keyCode, hasModifier)) {
          return;
        }
        if (!isVertical) {
          verticalRect = null;
        } else if (!verticalRect) {
          verticalRect = (0, import_dom10.computeCaretRect)(defaultView);
        }
        const isReverseDir = (0, import_dom10.isRTL)(target) ? !isReverse : isReverse;
        const { keepCaretInsideBlock } = getSettings4();
        if (shiftKey) {
          if (isClosestTabbableABlock(target, isReverse) && isNavEdge(target, isReverse)) {
            node2.contentEditable = true;
            node2.focus();
          }
        } else if (isVertical && (0, import_dom10.isVerticalEdge)(target, isReverse) && // When Alt is pressed, only intercept if the caret is also at
        // the horizontal edge.
        (altKey ? (0, import_dom10.isHorizontalEdge)(target, isReverseDir) : true) && !keepCaretInsideBlock) {
          const closestTabbable = getClosestTabbable(
            target,
            isReverse,
            node2,
            true
          );
          if (closestTabbable) {
            (0, import_dom10.placeCaretAtVerticalEdge)(
              closestTabbable,
              // When Alt is pressed, place the caret at the furthest
              // horizontal edge and the furthest vertical edge.
              altKey ? !isReverse : isReverse,
              altKey ? void 0 : verticalRect
            );
            event.preventDefault();
          }
        } else if (isHorizontal && defaultView.getSelection().isCollapsed && (0, import_dom10.isHorizontalEdge)(target, isReverseDir) && !keepCaretInsideBlock) {
          const closestTabbable = getClosestTabbable(
            target,
            isReverseDir,
            node2
          );
          (0, import_dom10.placeCaretAtHorizontalEdge)(closestTabbable, isReverse);
          event.preventDefault();
        }
      }
      node2.addEventListener("mousedown", onMouseDown);
      node2.addEventListener("keydown", onKeyDown);
      return () => {
        node2.removeEventListener("mousedown", onMouseDown);
        node2.removeEventListener("keydown", onKeyDown);
      };
    }, []);
  }

  // packages/block-editor/build-module/components/writing-flow/use-select-all.js
  var import_dom12 = __toESM(require_dom());
  var import_data36 = __toESM(require_data());
  var import_keyboard_shortcuts3 = __toESM(require_keyboard_shortcuts());
  var import_compose21 = __toESM(require_compose());
  function useSelectAll() {
    const { getBlockOrder: getBlockOrder2, getSelectedBlockClientIds: getSelectedBlockClientIds2, getBlockRootClientId: getBlockRootClientId2 } = (0, import_data36.useSelect)(store);
    const { multiSelect: multiSelect2, selectBlock: selectBlock2 } = (0, import_data36.useDispatch)(store);
    const isMatch = (0, import_keyboard_shortcuts3.__unstableUseShortcutEventMatch)();
    return (0, import_compose21.useRefEffect)((node2) => {
      function onKeyDown(event) {
        if (!isMatch("core/block-editor/select-all", event)) {
          return;
        }
        const selectedClientIds = getSelectedBlockClientIds2();
        if (selectedClientIds.length < 2 && !(0, import_dom12.isEntirelySelected)(event.target)) {
          return;
        }
        event.preventDefault();
        const [firstSelectedClientId] = selectedClientIds;
        const rootClientId = getBlockRootClientId2(firstSelectedClientId);
        const blockClientIds = getBlockOrder2(rootClientId);
        if (selectedClientIds.length === blockClientIds.length) {
          if (rootClientId) {
            node2.ownerDocument.defaultView.getSelection().removeAllRanges();
            selectBlock2(rootClientId);
          }
          return;
        }
        multiSelect2(
          blockClientIds[0],
          blockClientIds[blockClientIds.length - 1]
        );
      }
      node2.addEventListener("keydown", onKeyDown);
      return () => {
        node2.removeEventListener("keydown", onKeyDown);
      };
    }, []);
  }

  // packages/block-editor/build-module/components/writing-flow/use-drag-selection.js
  var import_data37 = __toESM(require_data());
  var import_compose22 = __toESM(require_compose());
  function setContentEditableWrapper(node2, value) {
    node2.contentEditable = value;
    if (value) {
      node2.focus();
    }
  }
  function useDragSelection() {
    const { startMultiSelect: startMultiSelect2, stopMultiSelect: stopMultiSelect2 } = (0, import_data37.useDispatch)(store);
    const {
      isSelectionEnabled: isSelectionEnabled3,
      hasSelectedBlock: hasSelectedBlock2,
      isDraggingBlocks: isDraggingBlocks2,
      isMultiSelecting: isMultiSelecting3
    } = (0, import_data37.useSelect)(store);
    return (0, import_compose22.useRefEffect)(
      (node2) => {
        const { ownerDocument } = node2;
        const { defaultView } = ownerDocument;
        let anchorElement;
        let rafId;
        function onMouseUp() {
          stopMultiSelect2();
          defaultView.removeEventListener("mouseup", onMouseUp);
          rafId = defaultView.requestAnimationFrame(() => {
            if (!hasSelectedBlock2()) {
              return;
            }
            setContentEditableWrapper(node2, false);
            const selection2 = defaultView.getSelection();
            if (selection2.rangeCount) {
              const range2 = selection2.getRangeAt(0);
              const { commonAncestorContainer } = range2;
              const clonedRange = range2.cloneRange();
              if (anchorElement.contains(commonAncestorContainer)) {
                anchorElement.focus();
                selection2.removeAllRanges();
                selection2.addRange(clonedRange);
              }
            }
          });
        }
        let lastMouseDownTarget;
        function onMouseDown({ target }) {
          lastMouseDownTarget = target;
        }
        function onMouseLeave({ buttons, target, relatedTarget }) {
          if (!target.contains(lastMouseDownTarget)) {
            return;
          }
          if (target.contains(relatedTarget)) {
            return;
          }
          if (isDraggingBlocks2()) {
            return;
          }
          if (buttons !== 1) {
            return;
          }
          if (isMultiSelecting3()) {
            return;
          }
          if (node2 === target) {
            return;
          }
          if (target.getAttribute("contenteditable") !== "true") {
            return;
          }
          if (!isSelectionEnabled3()) {
            return;
          }
          anchorElement = target;
          startMultiSelect2();
          defaultView.addEventListener("mouseup", onMouseUp);
          setContentEditableWrapper(node2, true);
        }
        node2.addEventListener("mouseout", onMouseLeave);
        node2.addEventListener("mousedown", onMouseDown);
        return () => {
          node2.removeEventListener("mouseout", onMouseLeave);
          defaultView.removeEventListener("mouseup", onMouseUp);
          defaultView.cancelAnimationFrame(rafId);
        };
      },
      [
        startMultiSelect2,
        stopMultiSelect2,
        isSelectionEnabled3,
        hasSelectedBlock2
      ]
    );
  }

  // packages/block-editor/build-module/components/writing-flow/use-selection-observer.js
  var import_data38 = __toESM(require_data());
  var import_compose23 = __toESM(require_compose());
  var import_rich_text4 = __toESM(require_rich_text());
  var import_dom13 = __toESM(require_dom());
  function extractSelectionStartNode(selection2) {
    const { anchorNode, anchorOffset } = selection2;
    if (anchorNode.nodeType === anchorNode.TEXT_NODE) {
      return anchorNode;
    }
    if (anchorOffset === 0) {
      return anchorNode;
    }
    return anchorNode.childNodes[anchorOffset - 1];
  }
  function extractSelectionEndNode(selection2) {
    const { focusNode, focusOffset } = selection2;
    if (focusNode.nodeType === focusNode.TEXT_NODE) {
      return focusNode;
    }
    if (focusOffset === focusNode.childNodes.length) {
      return focusNode;
    }
    if (focusOffset === 0 && (0, import_dom13.isSelectionForward)(selection2)) {
      return focusNode.previousSibling ?? focusNode.parentElement;
    }
    return focusNode.childNodes[focusOffset];
  }
  function findDepth(a2, b2) {
    let depth = 0;
    while (a2[depth] === b2[depth]) {
      depth++;
    }
    return depth;
  }
  function setContentEditableWrapper2(node2, value) {
    if (node2.contentEditable !== String(value)) {
      node2.contentEditable = value;
      if (value) {
        node2.focus();
      }
    }
  }
  function getRichTextElement(node2) {
    const element = node2.nodeType === node2.ELEMENT_NODE ? node2 : node2.parentElement;
    return element?.closest("[data-wp-block-attribute-key]");
  }
  function useSelectionObserver() {
    const { multiSelect: multiSelect2, selectBlock: selectBlock2, selectionChange: selectionChange2 } = (0, import_data38.useDispatch)(store);
    const { getBlockParents: getBlockParents2, getBlockSelectionStart: getBlockSelectionStart2, isMultiSelecting: isMultiSelecting3 } = (0, import_data38.useSelect)(store);
    return (0, import_compose23.useRefEffect)(
      (node2) => {
        const { ownerDocument } = node2;
        const { defaultView } = ownerDocument;
        function onSelectionChange(event) {
          const selection2 = defaultView.getSelection();
          if (!selection2.rangeCount) {
            return;
          }
          const startNode = extractSelectionStartNode(selection2);
          const endNode = extractSelectionEndNode(selection2);
          if (!node2.contains(startNode) || !node2.contains(endNode)) {
            return;
          }
          const isClickShift = event.shiftKey && event.type === "mouseup";
          if (selection2.isCollapsed && !isClickShift) {
            if (node2.contentEditable === "true" && !isMultiSelecting3()) {
              setContentEditableWrapper2(node2, false);
              let element = startNode.nodeType === startNode.ELEMENT_NODE ? startNode : startNode.parentElement;
              element = element?.closest("[contenteditable]");
              element?.focus();
            }
            return;
          }
          let startClientId = getBlockClientId(startNode);
          let endClientId = getBlockClientId(endNode);
          if (isClickShift) {
            const selectedClientId = getBlockSelectionStart2();
            const clickedClientId = getBlockClientId(event.target);
            const focusNodeIsNonSelectable = clickedClientId !== endClientId;
            if (startClientId === endClientId && selection2.isCollapsed || !endClientId || focusNodeIsNonSelectable) {
              endClientId = clickedClientId;
            }
            if (startClientId !== selectedClientId) {
              startClientId = selectedClientId;
            }
          }
          if (startClientId === void 0 && endClientId === void 0) {
            setContentEditableWrapper2(node2, false);
            return;
          }
          const isSingularSelection = startClientId === endClientId;
          if (isSingularSelection) {
            if (!isMultiSelecting3()) {
              selectBlock2(startClientId);
            } else {
              multiSelect2(startClientId, startClientId);
            }
          } else {
            const startPath = [
              ...getBlockParents2(startClientId),
              startClientId
            ];
            const endPath = [
              ...getBlockParents2(endClientId),
              endClientId
            ];
            const depth = findDepth(startPath, endPath);
            if (startPath[depth] !== startClientId || endPath[depth] !== endClientId) {
              multiSelect2(startPath[depth], endPath[depth]);
              return;
            }
            const richTextElementStart = getRichTextElement(startNode);
            const richTextElementEnd = getRichTextElement(endNode);
            if (richTextElementStart && richTextElementEnd) {
              const range2 = selection2.getRangeAt(0);
              const richTextDataStart = (0, import_rich_text4.create)({
                element: richTextElementStart,
                range: range2,
                __unstableIsEditableTree: true
              });
              const richTextDataEnd = (0, import_rich_text4.create)({
                element: richTextElementEnd,
                range: range2,
                __unstableIsEditableTree: true
              });
              const startOffset = richTextDataStart.start ?? richTextDataStart.end;
              const endOffset = richTextDataEnd.start ?? richTextDataEnd.end;
              selectionChange2({
                start: {
                  clientId: startClientId,
                  attributeKey: richTextElementStart.dataset.wpBlockAttributeKey,
                  offset: startOffset
                },
                end: {
                  clientId: endClientId,
                  attributeKey: richTextElementEnd.dataset.wpBlockAttributeKey,
                  offset: endOffset
                }
              });
            } else {
              multiSelect2(startClientId, endClientId);
            }
          }
        }
        ownerDocument.addEventListener(
          "selectionchange",
          onSelectionChange
        );
        defaultView.addEventListener("mouseup", onSelectionChange);
        return () => {
          ownerDocument.removeEventListener(
            "selectionchange",
            onSelectionChange
          );
          defaultView.removeEventListener("mouseup", onSelectionChange);
        };
      },
      [multiSelect2, selectBlock2, selectionChange2, getBlockParents2]
    );
  }

  // packages/block-editor/build-module/components/writing-flow/use-click-selection.js
  var import_data39 = __toESM(require_data());
  var import_compose24 = __toESM(require_compose());
  function useClickSelection() {
    const { selectBlock: selectBlock2 } = (0, import_data39.useDispatch)(store);
    const { isSelectionEnabled: isSelectionEnabled3, getBlockSelectionStart: getBlockSelectionStart2, hasMultiSelection: hasMultiSelection2 } = (0, import_data39.useSelect)(store);
    return (0, import_compose24.useRefEffect)(
      (node2) => {
        function onMouseDown(event) {
          if (!isSelectionEnabled3() || event.button !== 0) {
            return;
          }
          const startClientId = getBlockSelectionStart2();
          const clickedClientId = getBlockClientId(event.target);
          if (event.shiftKey) {
            if (startClientId && startClientId !== clickedClientId) {
              node2.contentEditable = true;
              node2.focus();
            }
          } else if (hasMultiSelection2()) {
            selectBlock2(clickedClientId);
          }
        }
        node2.addEventListener("mousedown", onMouseDown);
        return () => {
          node2.removeEventListener("mousedown", onMouseDown);
        };
      },
      [
        selectBlock2,
        isSelectionEnabled3,
        getBlockSelectionStart2,
        hasMultiSelection2
      ]
    );
  }

  // packages/block-editor/build-module/components/writing-flow/use-input.js
  var import_data40 = __toESM(require_data());
  var import_compose25 = __toESM(require_compose());
  var import_keycodes5 = __toESM(require_keycodes());
  var import_blocks20 = __toESM(require_blocks());
  function useInput() {
    const {
      __unstableIsFullySelected: __unstableIsFullySelected2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      getSelectedBlockClientId: getSelectedBlockClientId2,
      __unstableIsSelectionMergeable: __unstableIsSelectionMergeable2,
      hasMultiSelection: hasMultiSelection2,
      getBlockName: getBlockName2,
      canInsertBlockType: canInsertBlockType2,
      getBlockRootClientId: getBlockRootClientId2,
      getSelectionStart: getSelectionStart2,
      getSelectionEnd: getSelectionEnd2,
      getBlockAttributes: getBlockAttributes3
    } = (0, import_data40.useSelect)(store);
    const {
      replaceBlocks: replaceBlocks2,
      __unstableSplitSelection: __unstableSplitSelection2,
      removeBlocks: removeBlocks2,
      __unstableDeleteSelection: __unstableDeleteSelection2,
      __unstableExpandSelection: __unstableExpandSelection2,
      __unstableMarkAutomaticChange: __unstableMarkAutomaticChange2
    } = (0, import_data40.useDispatch)(store);
    return (0, import_compose25.useRefEffect)((node2) => {
      function onBeforeInput(event) {
        if (node2.contentEditable === "true") {
          event.preventDefault();
        }
      }
      function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (!hasMultiSelection2()) {
          if (event.keyCode === import_keycodes5.ENTER) {
            if (event.shiftKey || __unstableIsFullySelected2()) {
              return;
            }
            const clientId = getSelectedBlockClientId2();
            const blockName = getBlockName2(clientId);
            const selectionStart = getSelectionStart2();
            const selectionEnd = getSelectionEnd2();
            if (selectionStart.attributeKey === selectionEnd.attributeKey) {
              const selectedAttributeValue = getBlockAttributes3(clientId)[selectionStart.attributeKey];
              const transforms = (0, import_blocks20.getBlockTransforms)("from").filter(
                ({ type }) => type === "enter"
              );
              const transformation = (0, import_blocks20.findTransform)(
                transforms,
                (item) => {
                  return item.regExp.test(
                    selectedAttributeValue
                  );
                }
              );
              if (transformation) {
                replaceBlocks2(
                  clientId,
                  transformation.transform({
                    content: selectedAttributeValue
                  })
                );
                __unstableMarkAutomaticChange2();
                return;
              }
            }
            if (!(0, import_blocks20.hasBlockSupport)(blockName, "splitting", false) && !event.__deprecatedOnSplit) {
              return;
            }
            if (canInsertBlockType2(
              blockName,
              getBlockRootClientId2(clientId)
            )) {
              __unstableSplitSelection2();
              event.preventDefault();
            }
          }
          return;
        }
        if (event.keyCode === import_keycodes5.ENTER) {
          node2.contentEditable = false;
          event.preventDefault();
          if (__unstableIsFullySelected2()) {
            replaceBlocks2(
              getSelectedBlockClientIds2(),
              (0, import_blocks20.createBlock)((0, import_blocks20.getDefaultBlockName)())
            );
          } else {
            __unstableSplitSelection2();
          }
        } else if (event.keyCode === import_keycodes5.BACKSPACE || event.keyCode === import_keycodes5.DELETE) {
          node2.contentEditable = false;
          event.preventDefault();
          if (__unstableIsFullySelected2()) {
            removeBlocks2(getSelectedBlockClientIds2());
          } else if (__unstableIsSelectionMergeable2()) {
            __unstableDeleteSelection2(event.keyCode === import_keycodes5.DELETE);
          } else {
            __unstableExpandSelection2();
          }
        } else if (
          // If key.length is longer than 1, it's a control key that doesn't
          // input anything.
          event.key.length === 1 && !(event.metaKey || event.ctrlKey)
        ) {
          node2.contentEditable = false;
          if (__unstableIsSelectionMergeable2()) {
            __unstableDeleteSelection2(event.keyCode === import_keycodes5.DELETE);
          } else {
            event.preventDefault();
            node2.ownerDocument.defaultView.getSelection().removeAllRanges();
          }
        }
      }
      function onCompositionStart(event) {
        if (!hasMultiSelection2()) {
          return;
        }
        node2.contentEditable = false;
        if (__unstableIsSelectionMergeable2()) {
          __unstableDeleteSelection2();
        } else {
          event.preventDefault();
          node2.ownerDocument.defaultView.getSelection().removeAllRanges();
        }
      }
      node2.addEventListener("beforeinput", onBeforeInput);
      node2.addEventListener("keydown", onKeyDown);
      node2.addEventListener("compositionstart", onCompositionStart);
      return () => {
        node2.removeEventListener("beforeinput", onBeforeInput);
        node2.removeEventListener("keydown", onKeyDown);
        node2.removeEventListener("compositionstart", onCompositionStart);
      };
    }, []);
  }

  // packages/block-editor/build-module/components/writing-flow/use-clipboard-handler.js
  var import_blocks23 = __toESM(require_blocks());
  var import_dom18 = __toESM(require_dom());
  var import_data42 = __toESM(require_data());
  var import_compose26 = __toESM(require_compose());

  // packages/block-editor/build-module/utils/use-notify-copy.js
  var import_element39 = __toESM(require_element());
  var import_blocks21 = __toESM(require_blocks());
  var import_data41 = __toESM(require_data());
  var import_i18n31 = __toESM(require_i18n());
  var import_notices3 = __toESM(require_notices());
  function useNotifyCopy() {
    const { getBlockName: getBlockName2 } = (0, import_data41.useSelect)(store);
    const { getBlockType: getBlockType21 } = (0, import_data41.useSelect)(import_blocks21.store);
    const { createSuccessNotice } = (0, import_data41.useDispatch)(import_notices3.store);
    return (0, import_element39.useCallback)(
      (eventType, selectedBlockClientIds) => {
        let notice = "";
        if (eventType === "copyStyles") {
          notice = (0, import_i18n31.__)("Styles copied to clipboard.");
        } else if (selectedBlockClientIds.length === 1) {
          const clientId = selectedBlockClientIds[0];
          const title = getBlockType21(getBlockName2(clientId))?.title;
          if (eventType === "copy") {
            notice = (0, import_i18n31.sprintf)(
              // Translators: %s: Name of the block being copied, e.g. "Paragraph".
              (0, import_i18n31.__)('Copied "%s" to clipboard.'),
              title
            );
          } else {
            notice = (0, import_i18n31.sprintf)(
              // Translators: %s: Name of the block being cut, e.g. "Paragraph".
              (0, import_i18n31.__)('Moved "%s" to clipboard.'),
              title
            );
          }
        } else if (eventType === "copy") {
          notice = (0, import_i18n31.sprintf)(
            // Translators: %d: Number of blocks being copied.
            (0, import_i18n31._n)(
              "Copied %d block to clipboard.",
              "Copied %d blocks to clipboard.",
              selectedBlockClientIds.length
            ),
            selectedBlockClientIds.length
          );
        } else {
          notice = (0, import_i18n31.sprintf)(
            // Translators: %d: Number of blocks being moved.
            (0, import_i18n31._n)(
              "Moved %d block to clipboard.",
              "Moved %d blocks to clipboard.",
              selectedBlockClientIds.length
            ),
            selectedBlockClientIds.length
          );
        }
        createSuccessNotice(notice, {
          type: "snackbar"
        });
      },
      [createSuccessNotice, getBlockName2, getBlockType21]
    );
  }

  // packages/block-editor/build-module/components/writing-flow/utils.js
  var import_dom17 = __toESM(require_dom());
  var import_blocks22 = __toESM(require_blocks());

  // packages/block-editor/build-module/utils/pasting.js
  var import_dom16 = __toESM(require_dom());
  function removeWindowsFragments(html) {
    const startStr = "<!--StartFragment-->";
    const startIdx = html.indexOf(startStr);
    if (startIdx > -1) {
      html = html.substring(startIdx + startStr.length);
    } else {
      return html;
    }
    const endStr = "<!--EndFragment-->";
    const endIdx = html.indexOf(endStr);
    if (endIdx > -1) {
      html = html.substring(0, endIdx);
    }
    return html;
  }
  function removeCharsetMetaTag(html) {
    const metaTag = `<meta charset='utf-8'>`;
    if (html.startsWith(metaTag)) {
      return html.slice(metaTag.length);
    }
    return html;
  }
  function getPasteEventData({ clipboardData }) {
    let plainText = "";
    let html = "";
    try {
      plainText = clipboardData.getData("text/plain");
      html = clipboardData.getData("text/html");
    } catch (error) {
      return;
    }
    html = removeWindowsFragments(html);
    html = removeCharsetMetaTag(html);
    const files = (0, import_dom16.getFilesFromDataTransfer)(clipboardData);
    if (files.length && !shouldDismissPastedFiles(files, html)) {
      return { files };
    }
    return { html, plainText, files: [] };
  }
  function shouldDismissPastedFiles(files, html) {
    if (html && files?.length === 1 && files[0].type.indexOf("image/") === 0) {
      const IMAGE_TAG = /<\s*img\b/gi;
      if (html.match(IMAGE_TAG)?.length !== 1) {
        return true;
      }
      const IMG_WITH_LOCAL_SRC = /<\s*img\b[^>]*\bsrc="file:\/\//i;
      if (html.match(IMG_WITH_LOCAL_SRC)) {
        return true;
      }
    }
    return false;
  }

  // packages/block-editor/build-module/components/writing-flow/utils.js
  var requiresWrapperOnCopy = Symbol("requiresWrapperOnCopy");
  function setClipboardBlocks(event, blocks2, registry) {
    let _blocks = blocks2;
    const [firstBlock] = blocks2;
    if (firstBlock) {
      const firstBlockType = registry.select(import_blocks22.store).getBlockType(firstBlock.name);
      if (firstBlockType[requiresWrapperOnCopy]) {
        const { getBlockRootClientId: getBlockRootClientId2, getBlockName: getBlockName2, getBlockAttributes: getBlockAttributes3 } = registry.select(store);
        const wrapperBlockClientId = getBlockRootClientId2(
          firstBlock.clientId
        );
        const wrapperBlockName = getBlockName2(wrapperBlockClientId);
        if (wrapperBlockName) {
          _blocks = (0, import_blocks22.createBlock)(
            wrapperBlockName,
            getBlockAttributes3(wrapperBlockClientId),
            _blocks
          );
        }
      }
    }
    const serialized = (0, import_blocks22.serialize)(_blocks);
    event.clipboardData.setData("text/plain", toPlainText(serialized));
    event.clipboardData.setData("text/html", serialized);
  }
  function getPasteBlocks(event, canUserUseUnfilteredHTML) {
    const { plainText, html, files } = getPasteEventData(event);
    let blocks2 = [];
    if (files.length) {
      const fromTransforms = (0, import_blocks22.getBlockTransforms)("from");
      blocks2 = files.reduce((accumulator, file) => {
        const transformation = (0, import_blocks22.findTransform)(
          fromTransforms,
          (transform) => transform.type === "files" && transform.isMatch([file])
        );
        if (transformation) {
          accumulator.push(transformation.transform([file]));
        }
        return accumulator;
      }, []).flat();
    } else {
      blocks2 = (0, import_blocks22.pasteHandler)({
        HTML: html,
        plainText,
        mode: "BLOCKS",
        canUserUseUnfilteredHTML
      });
    }
    return blocks2;
  }
  function toPlainText(html) {
    html = html.replace(/<br>/g, "\n");
    const plainText = (0, import_dom17.__unstableStripHTML)(html).trim();
    return plainText.replace(/\n\n+/g, "\n\n");
  }

  // packages/block-editor/build-module/components/writing-flow/use-clipboard-handler.js
  function useClipboardHandler() {
    const registry = (0, import_data42.useRegistry)();
    const {
      getBlocksByClientId: getBlocksByClientId2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      hasMultiSelection: hasMultiSelection2,
      getSettings: getSettings4,
      getBlockName: getBlockName2,
      __unstableIsFullySelected: __unstableIsFullySelected2,
      __unstableIsSelectionCollapsed: __unstableIsSelectionCollapsed2,
      __unstableIsSelectionMergeable: __unstableIsSelectionMergeable2,
      __unstableGetSelectedBlocksWithPartialSelection: __unstableGetSelectedBlocksWithPartialSelection2,
      canInsertBlockType: canInsertBlockType2,
      getBlockRootClientId: getBlockRootClientId2
    } = (0, import_data42.useSelect)(store);
    const {
      flashBlock: flashBlock2,
      removeBlocks: removeBlocks2,
      replaceBlocks: replaceBlocks2,
      __unstableDeleteSelection: __unstableDeleteSelection2,
      __unstableExpandSelection: __unstableExpandSelection2,
      __unstableSplitSelection: __unstableSplitSelection2
    } = (0, import_data42.useDispatch)(store);
    const notifyCopy = useNotifyCopy();
    return (0, import_compose26.useRefEffect)((node2) => {
      function handler(event) {
        if (event.defaultPrevented) {
          return;
        }
        const selectedBlockClientIds = getSelectedBlockClientIds2();
        if (selectedBlockClientIds.length === 0) {
          return;
        }
        if (!hasMultiSelection2()) {
          const { target } = event;
          const { ownerDocument } = target;
          const hasSelection = event.type === "copy" || event.type === "cut" ? (0, import_dom18.documentHasUncollapsedSelection)(ownerDocument) : (0, import_dom18.documentHasSelection)(ownerDocument) && !ownerDocument.activeElement.isContentEditable;
          if (hasSelection) {
            return;
          }
        }
        const { activeElement } = event.target.ownerDocument;
        if (!node2.contains(activeElement)) {
          return;
        }
        const isSelectionMergeable = __unstableIsSelectionMergeable2();
        const shouldHandleWholeBlocks = __unstableIsSelectionCollapsed2() || __unstableIsFullySelected2();
        const expandSelectionIsNeeded = !shouldHandleWholeBlocks && !isSelectionMergeable;
        if (event.type === "copy" || event.type === "cut") {
          event.preventDefault();
          if (selectedBlockClientIds.length === 1) {
            flashBlock2(selectedBlockClientIds[0]);
          }
          if (expandSelectionIsNeeded) {
            __unstableExpandSelection2();
          } else {
            notifyCopy(event.type, selectedBlockClientIds);
            let blocks2;
            if (shouldHandleWholeBlocks) {
              blocks2 = getBlocksByClientId2(selectedBlockClientIds);
            } else {
              const [head, tail] = __unstableGetSelectedBlocksWithPartialSelection2();
              const inBetweenBlocks = getBlocksByClientId2(
                selectedBlockClientIds.slice(
                  1,
                  selectedBlockClientIds.length - 1
                )
              );
              blocks2 = [head, ...inBetweenBlocks, tail];
            }
            setClipboardBlocks(event, blocks2, registry);
          }
        }
        if (event.type === "cut") {
          if (shouldHandleWholeBlocks && !expandSelectionIsNeeded) {
            removeBlocks2(selectedBlockClientIds);
          } else {
            event.target.ownerDocument.activeElement.contentEditable = false;
            __unstableDeleteSelection2();
          }
        } else if (event.type === "paste") {
          const {
            __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML,
            mediaUpload: mediaUpload2
          } = getSettings4();
          const isInternal = event.clipboardData.getData("rich-text") === "true";
          if (isInternal) {
            return;
          }
          const { plainText, html, files } = getPasteEventData(event);
          const isFullySelected = __unstableIsFullySelected2();
          let blocks2 = [];
          if (files.length) {
            if (!mediaUpload2) {
              event.preventDefault();
              return;
            }
            const fromTransforms = (0, import_blocks23.getBlockTransforms)("from");
            blocks2 = files.reduce((accumulator, file) => {
              const transformation = (0, import_blocks23.findTransform)(
                fromTransforms,
                (transform) => transform.type === "files" && transform.isMatch([file])
              );
              if (transformation) {
                accumulator.push(
                  transformation.transform([file])
                );
              }
              return accumulator;
            }, []).flat();
          } else {
            blocks2 = (0, import_blocks23.pasteHandler)({
              HTML: html,
              plainText,
              mode: isFullySelected ? "BLOCKS" : "AUTO",
              canUserUseUnfilteredHTML
            });
          }
          if (typeof blocks2 === "string") {
            return;
          }
          if (isFullySelected) {
            replaceBlocks2(
              selectedBlockClientIds,
              blocks2,
              blocks2.length - 1,
              -1
            );
            event.preventDefault();
            return;
          }
          if (!hasMultiSelection2() && !(0, import_blocks23.hasBlockSupport)(
            getBlockName2(selectedBlockClientIds[0]),
            "splitting",
            false
          ) && !event.__deprecatedOnSplit) {
            return;
          }
          const [firstSelectedClientId] = selectedBlockClientIds;
          const rootClientId = getBlockRootClientId2(
            firstSelectedClientId
          );
          const newBlocks = [];
          for (const block of blocks2) {
            if (canInsertBlockType2(block.name, rootClientId)) {
              newBlocks.push(block);
            } else {
              const rootBlockName = getBlockName2(rootClientId);
              const switchedBlocks = block.name !== rootBlockName ? (0, import_blocks23.switchToBlockType)(block, rootBlockName) : [block];
              if (!switchedBlocks) {
                return;
              }
              for (const switchedBlock of switchedBlocks) {
                for (const innerBlock of switchedBlock.innerBlocks) {
                  newBlocks.push(innerBlock);
                }
              }
            }
          }
          __unstableSplitSelection2(newBlocks);
          event.preventDefault();
        }
      }
      node2.ownerDocument.addEventListener("copy", handler);
      node2.ownerDocument.addEventListener("cut", handler);
      node2.ownerDocument.addEventListener("paste", handler);
      return () => {
        node2.ownerDocument.removeEventListener("copy", handler);
        node2.ownerDocument.removeEventListener("cut", handler);
        node2.ownerDocument.removeEventListener("paste", handler);
      };
    }, []);
  }

  // packages/block-editor/build-module/components/writing-flow/index.js
  function useWritingFlow() {
    const [before, ref, after] = useTabNav();
    const hasMultiSelection2 = (0, import_data43.useSelect)(
      (select2) => select2(store).hasMultiSelection(),
      []
    );
    return [
      before,
      (0, import_compose27.useMergeRefs)([
        ref,
        useClipboardHandler(),
        useInput(),
        useDragSelection(),
        useSelectionObserver(),
        useClickSelection(),
        useMultiSelection(),
        useSelectAll(),
        useArrowNav(),
        (0, import_compose27.useRefEffect)(
          (node2) => {
            node2.tabIndex = 0;
            node2.dataset.hasMultiSelection = hasMultiSelection2;
            if (!hasMultiSelection2) {
              return () => {
                delete node2.dataset.hasMultiSelection;
              };
            }
            node2.setAttribute(
              "aria-label",
              (0, import_i18n32.__)("Multiple selected blocks")
            );
            return () => {
              delete node2.dataset.hasMultiSelection;
              node2.removeAttribute("aria-label");
            };
          },
          [hasMultiSelection2]
        )
      ]),
      after
    ];
  }
  function WritingFlow({ children, ...props }, forwardedRef) {
    const [before, ref, after] = useWritingFlow();
    return /* @__PURE__ */ (0, import_jsx_runtime147.jsxs)(import_jsx_runtime147.Fragment, { children: [
      before,
      /* @__PURE__ */ (0, import_jsx_runtime147.jsx)(
        "div",
        {
          ...props,
          ref: (0, import_compose27.useMergeRefs)([ref, forwardedRef]),
          className: clsx_default(
            props.className,
            "block-editor-writing-flow"
          ),
          children
        }
      ),
      after
    ] });
  }
  var writing_flow_default = (0, import_element40.forwardRef)(WritingFlow);

  // packages/block-editor/build-module/components/iframe/get-compatibility-styles.js
  var compatibilityStyles = null;
  function getCompatibilityStyles() {
    if (compatibilityStyles) {
      return compatibilityStyles;
    }
    compatibilityStyles = Array.from(document.styleSheets).reduce(
      (accumulator, styleSheet) => {
        try {
          styleSheet.cssRules;
        } catch (e2) {
          return accumulator;
        }
        const { ownerNode, cssRules } = styleSheet;
        if (ownerNode === null) {
          return accumulator;
        }
        if (!cssRules) {
          return accumulator;
        }
        if (ownerNode.id.startsWith("wp-")) {
          return accumulator;
        }
        if (!ownerNode.id) {
          return accumulator;
        }
        function matchFromRules(_cssRules) {
          return Array.from(_cssRules).find(
            ({
              selectorText,
              conditionText,
              cssRules: __cssRules
            }) => {
              if (conditionText) {
                return matchFromRules(__cssRules);
              }
              return selectorText && (selectorText.includes(
                ".editor-styles-wrapper"
              ) || selectorText.includes(".wp-block"));
            }
          );
        }
        if (matchFromRules(cssRules)) {
          const isInline = ownerNode.tagName === "STYLE";
          if (isInline) {
            const mainStylesCssId = ownerNode.id.replace(
              "-inline-css",
              "-css"
            );
            const mainStylesElement = document.getElementById(mainStylesCssId);
            if (mainStylesElement) {
              accumulator.push(mainStylesElement.cloneNode(true));
            }
          }
          accumulator.push(ownerNode.cloneNode(true));
          if (!isInline) {
            const inlineStylesCssId = ownerNode.id.replace(
              "-css",
              "-inline-css"
            );
            const inlineStylesElement = document.getElementById(inlineStylesCssId);
            if (inlineStylesElement) {
              accumulator.push(
                inlineStylesElement.cloneNode(true)
              );
            }
          }
        }
        return accumulator;
      },
      []
    );
    return compatibilityStyles;
  }

  // packages/block-editor/build-module/components/iframe/use-scale-canvas.js
  var import_element41 = __toESM(require_element());
  var import_compose28 = __toESM(require_compose());
  function calculateScale({
    frameSize,
    containerWidth,
    maxContainerWidth,
    scaleContainerWidth
  }) {
    return (Math.min(containerWidth, maxContainerWidth) - frameSize * 2) / scaleContainerWidth;
  }
  function computeScrollHeightNext(transitionFrom, transitionTo) {
    const { scaleValue: prevScale, scrollHeight: prevScrollHeight } = transitionFrom;
    const { frameSize, scaleValue } = transitionTo;
    return prevScrollHeight * (scaleValue / prevScale) + frameSize * 2;
  }
  function computeScrollTopNext(transitionFrom, transitionTo) {
    const {
      containerHeight: prevContainerHeight,
      frameSize: prevFrameSize,
      scaleValue: prevScale,
      scrollTop: prevScrollTop
    } = transitionFrom;
    const { containerHeight, frameSize, scaleValue, scrollHeight } = transitionTo;
    let scrollTopNext = prevScrollTop;
    scrollTopNext = (scrollTopNext + prevContainerHeight / 2 - prevFrameSize) / prevScale - prevContainerHeight / 2;
    scrollTopNext = (scrollTopNext + containerHeight / 2) * scaleValue + frameSize - containerHeight / 2;
    scrollTopNext = prevScrollTop <= prevFrameSize ? 0 : scrollTopNext;
    const maxScrollTop = scrollHeight - containerHeight;
    return Math.round(
      Math.min(Math.max(0, scrollTopNext), Math.max(0, maxScrollTop))
    );
  }
  function getAnimationKeyframes(transitionFrom, transitionTo) {
    const {
      scaleValue: prevScale,
      frameSize: prevFrameSize,
      scrollTop
    } = transitionFrom;
    const { scaleValue, frameSize, scrollTop: scrollTopNext } = transitionTo;
    return [
      {
        translate: `0 0`,
        scale: prevScale,
        paddingTop: `${prevFrameSize / prevScale}px`,
        paddingBottom: `${prevFrameSize / prevScale}px`
      },
      {
        translate: `0 ${scrollTop - scrollTopNext}px`,
        scale: scaleValue,
        paddingTop: `${frameSize / scaleValue}px`,
        paddingBottom: `${frameSize / scaleValue}px`
      }
    ];
  }
  function useScaleCanvas({
    frameSize,
    iframeDocument,
    maxContainerWidth = 750,
    scale
  }) {
    const [contentResizeListener, { height: contentHeight }] = (0, import_compose28.useResizeObserver)();
    const [
      containerResizeListener,
      { width: containerWidth, height: containerHeight }
    ] = (0, import_compose28.useResizeObserver)();
    const initialContainerWidthRef = (0, import_element41.useRef)(0);
    const isZoomedOut = scale !== 1;
    const prefersReducedMotion = (0, import_compose28.useReducedMotion)();
    const isAutoScaled = scale === "auto-scaled";
    const startAnimationRef = (0, import_element41.useRef)(false);
    const animationRef = (0, import_element41.useRef)(null);
    (0, import_element41.useEffect)(() => {
      if (!isZoomedOut) {
        initialContainerWidthRef.current = containerWidth;
      }
    }, [containerWidth, isZoomedOut]);
    const scaleContainerWidth = Math.max(
      initialContainerWidthRef.current,
      containerWidth
    );
    const scaleValue = isAutoScaled ? calculateScale({
      frameSize,
      containerWidth,
      maxContainerWidth,
      scaleContainerWidth
    }) : scale;
    const transitionFromRef = (0, import_element41.useRef)({
      scaleValue,
      frameSize,
      containerHeight: 0,
      scrollTop: 0,
      scrollHeight: 0
    });
    const transitionToRef = (0, import_element41.useRef)({
      scaleValue,
      frameSize,
      containerHeight: 0,
      scrollTop: 0,
      scrollHeight: 0
    });
    const startZoomOutAnimation = (0, import_element41.useCallback)(() => {
      const { scrollTop } = transitionFromRef.current;
      const { scrollTop: scrollTopNext } = transitionToRef.current;
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-scroll-top",
        `${scrollTop}px`
      );
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-scroll-top-next",
        `${scrollTopNext}px`
      );
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-overflow-behavior",
        transitionFromRef.current.scrollHeight === transitionFromRef.current.containerHeight ? "auto" : "scroll"
      );
      iframeDocument.documentElement.classList.add("zoom-out-animation");
      return iframeDocument.documentElement.animate(
        getAnimationKeyframes(
          transitionFromRef.current,
          transitionToRef.current
        ),
        {
          easing: "cubic-bezier(0.46, 0.03, 0.52, 0.96)",
          duration: 400
        }
      );
    }, [iframeDocument]);
    const finishZoomOutAnimation = (0, import_element41.useCallback)(() => {
      startAnimationRef.current = false;
      animationRef.current = null;
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-scale",
        transitionToRef.current.scaleValue
      );
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-frame-size",
        `${transitionToRef.current.frameSize}px`
      );
      iframeDocument.documentElement.classList.remove("zoom-out-animation");
      iframeDocument.documentElement.scrollTop = transitionToRef.current.scrollTop;
      iframeDocument.documentElement.style.removeProperty(
        "--wp-block-editor-iframe-zoom-out-scroll-top"
      );
      iframeDocument.documentElement.style.removeProperty(
        "--wp-block-editor-iframe-zoom-out-scroll-top-next"
      );
      iframeDocument.documentElement.style.removeProperty(
        "--wp-block-editor-iframe-zoom-out-overflow-behavior"
      );
      transitionFromRef.current = transitionToRef.current;
    }, [iframeDocument]);
    const previousIsZoomedOut = (0, import_element41.useRef)(false);
    (0, import_element41.useEffect)(() => {
      const trigger = iframeDocument && previousIsZoomedOut.current !== isZoomedOut;
      previousIsZoomedOut.current = isZoomedOut;
      if (!trigger) {
        return;
      }
      startAnimationRef.current = true;
      if (!isZoomedOut) {
        return;
      }
      iframeDocument.documentElement.classList.add("is-zoomed-out");
      return () => {
        iframeDocument.documentElement.classList.remove("is-zoomed-out");
      };
    }, [iframeDocument, isZoomedOut]);
    (0, import_element41.useEffect)(() => {
      if (!iframeDocument) {
        return;
      }
      if (isAutoScaled && transitionFromRef.current.scaleValue !== 1) {
        transitionFromRef.current.scaleValue = calculateScale({
          frameSize: transitionFromRef.current.frameSize,
          containerWidth,
          maxContainerWidth,
          scaleContainerWidth: containerWidth
        });
      }
      if (scaleValue < 1) {
        if (!startAnimationRef.current) {
          iframeDocument.documentElement.style.setProperty(
            "--wp-block-editor-iframe-zoom-out-scale",
            scaleValue
          );
          iframeDocument.documentElement.style.setProperty(
            "--wp-block-editor-iframe-zoom-out-frame-size",
            `${frameSize}px`
          );
        }
        iframeDocument.documentElement.style.setProperty(
          "--wp-block-editor-iframe-zoom-out-content-height",
          `${contentHeight}px`
        );
        iframeDocument.documentElement.style.setProperty(
          "--wp-block-editor-iframe-zoom-out-inner-height",
          `${containerHeight}px`
        );
        iframeDocument.documentElement.style.setProperty(
          "--wp-block-editor-iframe-zoom-out-container-width",
          `${containerWidth}px`
        );
        iframeDocument.documentElement.style.setProperty(
          "--wp-block-editor-iframe-zoom-out-scale-container-width",
          `${scaleContainerWidth}px`
        );
      }
      if (startAnimationRef.current) {
        startAnimationRef.current = false;
        if (animationRef.current) {
          animationRef.current.reverse();
          const tempTransitionFrom = transitionFromRef.current;
          const tempTransitionTo = transitionToRef.current;
          transitionFromRef.current = tempTransitionTo;
          transitionToRef.current = tempTransitionFrom;
        } else {
          transitionFromRef.current.scrollTop = iframeDocument.documentElement.scrollTop;
          transitionFromRef.current.scrollHeight = iframeDocument.documentElement.scrollHeight;
          transitionFromRef.current.containerHeight = containerHeight;
          transitionToRef.current = {
            scaleValue,
            frameSize,
            containerHeight: iframeDocument.documentElement.clientHeight
            // use clientHeight to get the actual height of the new container after zoom state changes have rendered, as it will be the most up-to-date.
          };
          transitionToRef.current.scrollHeight = computeScrollHeightNext(
            transitionFromRef.current,
            transitionToRef.current
          );
          transitionToRef.current.scrollTop = computeScrollTopNext(
            transitionFromRef.current,
            transitionToRef.current
          );
          animationRef.current = startZoomOutAnimation();
          if (prefersReducedMotion) {
            finishZoomOutAnimation();
          } else {
            animationRef.current.onfinish = finishZoomOutAnimation;
          }
        }
      }
    }, [
      startZoomOutAnimation,
      finishZoomOutAnimation,
      prefersReducedMotion,
      isAutoScaled,
      scaleValue,
      frameSize,
      iframeDocument,
      contentHeight,
      containerWidth,
      containerHeight,
      maxContainerWidth,
      scaleContainerWidth
    ]);
    return {
      isZoomedOut,
      scaleContainerWidth,
      contentResizeListener,
      containerResizeListener
    };
  }

  // packages/block-editor/build-module/components/iframe/index.js
  function bubbleEvent(event, Constructor, frame) {
    const init = {};
    for (const key in event) {
      init[key] = event[key];
    }
    if (event instanceof frame.contentDocument.defaultView.MouseEvent) {
      const rect = frame.getBoundingClientRect();
      init.clientX += rect.left;
      init.clientY += rect.top;
    }
    const newEvent = new Constructor(event.type, init);
    if (init.defaultPrevented) {
      newEvent.preventDefault();
    }
    const cancelled = !frame.dispatchEvent(newEvent);
    if (cancelled) {
      event.preventDefault();
    }
  }
  function useBubbleEvents(iframeDocument) {
    return (0, import_compose29.useRefEffect)(() => {
      const { defaultView } = iframeDocument;
      if (!defaultView) {
        return;
      }
      const { frameElement } = defaultView;
      const html = iframeDocument.documentElement;
      const eventTypes = ["dragover", "mousemove"];
      const handlers = {};
      for (const name of eventTypes) {
        handlers[name] = (event) => {
          const prototype = Object.getPrototypeOf(event);
          const constructorName = prototype.constructor.name;
          const Constructor = window[constructorName];
          bubbleEvent(event, Constructor, frameElement);
        };
        html.addEventListener(name, handlers[name]);
      }
      return () => {
        for (const name of eventTypes) {
          html.removeEventListener(name, handlers[name]);
        }
      };
    });
  }
  function Iframe({
    contentRef,
    children,
    tabIndex = 0,
    scale = 1,
    frameSize = 0,
    readonly,
    forwardedRef: ref,
    title = (0, import_i18n33.__)("Editor canvas"),
    ...props
  }) {
    const { resolvedAssets, isPreviewMode } = (0, import_data44.useSelect)((select2) => {
      const { getSettings: getSettings4 } = select2(store);
      const settings2 = getSettings4();
      return {
        resolvedAssets: settings2.__unstableResolvedAssets,
        isPreviewMode: settings2.isPreviewMode
      };
    }, []);
    const { styles = "", scripts = "" } = resolvedAssets;
    const [iframeDocument, setIframeDocument] = (0, import_element42.useState)();
    const [bodyClasses, setBodyClasses] = (0, import_element42.useState)([]);
    const clearerRef = useBlockSelectionClearer();
    const [before, writingFlowRef, after] = useWritingFlow();
    const setRef = (0, import_compose29.useRefEffect)((node2) => {
      node2._load = () => {
        setIframeDocument(node2.contentDocument);
      };
      let iFrameDocument;
      function preventFileDropDefault(event) {
        event.preventDefault();
      }
      function interceptLinkClicks(event) {
        if (event.target.tagName === "A" && event.target.getAttribute("href")?.startsWith("#")) {
          event.preventDefault();
          iFrameDocument.defaultView.location.hash = event.target.getAttribute("href").slice(1);
        }
      }
      const { ownerDocument } = node2;
      setBodyClasses(
        Array.from(ownerDocument.body.classList).filter(
          (name) => name.startsWith("admin-color-") || name.startsWith("post-type-") || name === "wp-embed-responsive"
        )
      );
      function onLoad() {
        const { contentDocument } = node2;
        const { documentElement } = contentDocument;
        iFrameDocument = contentDocument;
        documentElement.classList.add("block-editor-iframe__html");
        clearerRef(documentElement);
        contentDocument.dir = ownerDocument.dir;
        for (const compatStyle of getCompatibilityStyles()) {
          if (contentDocument.getElementById(compatStyle.id)) {
            continue;
          }
          contentDocument.head.appendChild(
            compatStyle.cloneNode(true)
          );
          if (!isPreviewMode) {
            console.warn(
              `${compatStyle.id} was added to the iframe incorrectly. Please use block.json or enqueue_block_assets to add styles to the iframe.`,
              compatStyle
            );
          }
        }
        iFrameDocument.addEventListener(
          "dragover",
          preventFileDropDefault,
          false
        );
        iFrameDocument.addEventListener(
          "drop",
          preventFileDropDefault,
          false
        );
        iFrameDocument.addEventListener("click", interceptLinkClicks);
      }
      node2.addEventListener("load", onLoad);
      return () => {
        delete node2._load;
        node2.removeEventListener("load", onLoad);
        iFrameDocument?.removeEventListener(
          "dragover",
          preventFileDropDefault
        );
        iFrameDocument?.removeEventListener(
          "drop",
          preventFileDropDefault
        );
        iFrameDocument?.removeEventListener("click", interceptLinkClicks);
      };
    }, []);
    const {
      contentResizeListener,
      containerResizeListener,
      isZoomedOut,
      scaleContainerWidth
    } = useScaleCanvas({
      scale,
      frameSize: parseInt(frameSize),
      iframeDocument
    });
    const disabledRef = (0, import_compose29.useDisabled)({ isDisabled: !readonly });
    const bodyRef = (0, import_compose29.useMergeRefs)([
      useBubbleEvents(iframeDocument),
      contentRef,
      clearerRef,
      writingFlowRef,
      disabledRef
    ]);
    const html = `<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<base href="${window.location.origin}">
		<script>window.frameElement._load()<\/script>
		<style>
			html{
				height: auto !important;
				min-height: 100%;
			}
			/* Lowest specificity to not override global styles */
			:where(body) {
				margin: 0;
				/* Default background color in case zoom out mode background
				colors the html element */
				background-color: white;
			}
		</style>
		${styles}
		${scripts}
	</head>
	<body>
		<script>document.currentScript.parentElement.remove()<\/script>
	</body>
</html>`;
    const [src, cleanup] = (0, import_element42.useMemo)(() => {
      const _src = URL.createObjectURL(
        new window.Blob([html], { type: "text/html" })
      );
      return [_src, () => URL.revokeObjectURL(_src)];
    }, [html]);
    (0, import_element42.useEffect)(() => cleanup, [cleanup]);
    const shouldRenderFocusCaptureElements = tabIndex >= 0 && !isPreviewMode;
    const iframe = /* @__PURE__ */ (0, import_jsx_runtime148.jsxs)(import_jsx_runtime148.Fragment, { children: [
      shouldRenderFocusCaptureElements && before,
      /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
        "iframe",
        {
          ...props,
          style: {
            ...props.style,
            height: props.style?.height,
            border: 0
          },
          ref: (0, import_compose29.useMergeRefs)([ref, setRef]),
          tabIndex,
          src,
          title,
          onKeyDown: (event) => {
            if (props.onKeyDown) {
              props.onKeyDown(event);
            }
            if (event.currentTarget.ownerDocument !== event.target.ownerDocument) {
              const { stopPropagation } = event.nativeEvent;
              event.nativeEvent.stopPropagation = () => {
              };
              event.stopPropagation();
              event.nativeEvent.stopPropagation = stopPropagation;
              bubbleEvent(
                event,
                window.KeyboardEvent,
                event.currentTarget
              );
            }
          },
          children: iframeDocument && (0, import_element42.createPortal)(
            // We want to prevent React events from bubbling through the iframe
            // we bubble these manually.
            /* eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions */
            /* @__PURE__ */ (0, import_jsx_runtime148.jsxs)(
              "body",
              {
                ref: bodyRef,
                className: clsx_default(
                  "block-editor-iframe__body",
                  "editor-styles-wrapper",
                  ...bodyClasses
                ),
                children: [
                  contentResizeListener,
                  /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(import_components26.__experimentalStyleProvider, { document: iframeDocument, children })
                ]
              }
            ),
            iframeDocument.documentElement
          )
        }
      ),
      shouldRenderFocusCaptureElements && after
    ] });
    return /* @__PURE__ */ (0, import_jsx_runtime148.jsxs)("div", { className: "block-editor-iframe__container", children: [
      containerResizeListener,
      /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
        "div",
        {
          className: clsx_default(
            "block-editor-iframe__scale-container",
            isZoomedOut && "is-zoomed-out"
          ),
          style: {
            "--wp-block-editor-iframe-zoom-out-scale-container-width": isZoomedOut && `${scaleContainerWidth}px`
          },
          children: iframe
        }
      )
    ] });
  }
  function IframeIfReady(props, ref) {
    const isInitialised = (0, import_data44.useSelect)(
      (select2) => select2(store).getSettings().__internalIsInitialized,
      []
    );
    if (!isInitialised) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(Iframe, { ...props, forwardedRef: ref });
  }
  var iframe_default = (0, import_element42.forwardRef)(IframeIfReady);

  // packages/block-editor/build-module/components/editor-styles/index.js
  var import_jsx_runtime149 = __toESM(require_jsx_runtime());
  var import_components27 = __toESM(require_components());
  var import_element43 = __toESM(require_element());
  var import_data45 = __toESM(require_data());

  // node_modules/parsel-js/dist/parsel.js
  var TOKENS = {
    attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
    id: /#(?<name>[-\w\P{ASCII}]+)/gu,
    class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
    comma: /\s*,\s*/g,
    combinator: /\s*[\s>+~]\s*/g,
    "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,
    "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,
    universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
    type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
    // this must be last
  };
  var TRIM_TOKENS = /* @__PURE__ */ new Set(["combinator", "comma"]);
  var getArgumentPatternByType = (type) => {
    switch (type) {
      case "pseudo-element":
      case "pseudo-class":
        return new RegExp(TOKENS[type].source.replace("(?<argument>\xB6*)", "(?<argument>.*)"), "gu");
      default:
        return TOKENS[type];
    }
  };
  function gobbleParens(text, offset) {
    let nesting = 0;
    let result = "";
    for (; offset < text.length; offset++) {
      const char2 = text[offset];
      switch (char2) {
        case "(":
          ++nesting;
          break;
        case ")":
          --nesting;
          break;
      }
      result += char2;
      if (nesting === 0) {
        return result;
      }
    }
    return result;
  }
  function tokenizeBy(text, grammar = TOKENS) {
    if (!text) {
      return [];
    }
    const tokens = [text];
    for (const [type, pattern] of Object.entries(grammar)) {
      for (let i2 = 0; i2 < tokens.length; i2++) {
        const token2 = tokens[i2];
        if (typeof token2 !== "string") {
          continue;
        }
        pattern.lastIndex = 0;
        const match2 = pattern.exec(token2);
        if (!match2) {
          continue;
        }
        const from2 = match2.index - 1;
        const args = [];
        const content = match2[0];
        const before = token2.slice(0, from2 + 1);
        if (before) {
          args.push(before);
        }
        args.push({
          ...match2.groups,
          type,
          content
        });
        const after = token2.slice(from2 + content.length + 1);
        if (after) {
          args.push(after);
        }
        tokens.splice(i2, 1, ...args);
      }
    }
    let offset = 0;
    for (const token2 of tokens) {
      switch (typeof token2) {
        case "string":
          throw new Error(`Unexpected sequence ${token2} found at index ${offset}`);
        case "object":
          offset += token2.content.length;
          token2.pos = [offset - token2.content.length, offset];
          if (TRIM_TOKENS.has(token2.type)) {
            token2.content = token2.content.trim() || " ";
          }
          break;
      }
    }
    return tokens;
  }
  var STRING_PATTERN = /(['"])([^\\\n]+?)\1/g;
  var ESCAPE_PATTERN = /\\./g;
  function tokenize(selector3, grammar = TOKENS) {
    selector3 = selector3.trim();
    if (selector3 === "") {
      return [];
    }
    const replacements = [];
    selector3 = selector3.replace(ESCAPE_PATTERN, (value, offset) => {
      replacements.push({ value, offset });
      return "\uE000".repeat(value.length);
    });
    selector3 = selector3.replace(STRING_PATTERN, (value, quote, content, offset) => {
      replacements.push({ value, offset });
      return `${quote}${"\uE001".repeat(content.length)}${quote}`;
    });
    {
      let pos = 0;
      let offset;
      while ((offset = selector3.indexOf("(", pos)) > -1) {
        const value = gobbleParens(selector3, offset);
        replacements.push({ value, offset });
        selector3 = `${selector3.substring(0, offset)}(${"\xB6".repeat(value.length - 2)})${selector3.substring(offset + value.length)}`;
        pos = offset + value.length;
      }
    }
    const tokens = tokenizeBy(selector3, grammar);
    const changedTokens = /* @__PURE__ */ new Set();
    for (const replacement of replacements.reverse()) {
      for (const token2 of tokens) {
        const { offset, value } = replacement;
        if (!(token2.pos[0] <= offset && offset + value.length <= token2.pos[1])) {
          continue;
        }
        const { content } = token2;
        const tokenOffset = offset - token2.pos[0];
        token2.content = content.slice(0, tokenOffset) + value + content.slice(tokenOffset + value.length);
        if (token2.content !== content) {
          changedTokens.add(token2);
        }
      }
    }
    for (const token2 of changedTokens) {
      const pattern = getArgumentPatternByType(token2.type);
      if (!pattern) {
        throw new Error(`Unknown token type: ${token2.type}`);
      }
      pattern.lastIndex = 0;
      const match2 = pattern.exec(token2.content);
      if (!match2) {
        throw new Error(`Unable to parse content for ${token2.type}: ${token2.content}`);
      }
      Object.assign(token2, match2.groups);
    }
    return tokens;
  }
  function* flatten(node2, parent) {
    switch (node2.type) {
      case "list":
        for (let child of node2.list) {
          yield* flatten(child, node2);
        }
        break;
      case "complex":
        yield* flatten(node2.left, node2);
        yield* flatten(node2.right, node2);
        break;
      case "compound":
        yield* node2.list.map((token2) => [token2, node2]);
        break;
      default:
        yield [node2, parent];
    }
  }
  function stringify(listOrNode) {
    let tokens;
    if (Array.isArray(listOrNode)) {
      tokens = listOrNode;
    } else {
      tokens = [...flatten(listOrNode)].map(([token2]) => token2);
    }
    return tokens.map((token2) => token2.content).join("");
  }

  // packages/block-editor/build-module/utils/transform-styles/index.js
  var import_processor = __toESM(require_processor());
  var import_css_syntax_error = __toESM(require_css_syntax_error());
  var import_postcss_prefix_selector = __toESM(require_postcss_prefix_selector());
  var import_postcss_urlrebase = __toESM(require_postcss_urlrebase());
  var cacheByWrapperSelector = /* @__PURE__ */ new Map();
  var ROOT_SELECTOR_TOKENS = [
    { type: "type", content: "body" },
    { type: "type", content: "html" },
    { type: "pseudo-class", content: ":root" },
    { type: "pseudo-class", content: ":where(body)" },
    { type: "pseudo-class", content: ":where(:root)" },
    { type: "pseudo-class", content: ":where(html)" }
  ];
  function prefixRootSelector(prefix3, selector3) {
    const tokenized = tokenize(selector3);
    const lastRootIndex = tokenized.findLastIndex(({ content, type }) => {
      return ROOT_SELECTOR_TOKENS.some(
        (rootSelector) => content === rootSelector.content && type === rootSelector.type
      );
    });
    let insertionPoint2 = -1;
    for (let i2 = lastRootIndex + 1; i2 < tokenized.length; i2++) {
      if (tokenized[i2].type === "combinator") {
        insertionPoint2 = i2;
        break;
      }
    }
    const tokenizedPrefix = tokenize(prefix3);
    tokenized.splice(
      // Insert at the insertion point, or the end.
      insertionPoint2 === -1 ? tokenized.length : insertionPoint2,
      0,
      {
        type: "combinator",
        content: " "
      },
      ...tokenizedPrefix
    );
    return stringify(tokenized);
  }
  function transformStyle({ css, ignoredSelectors = [], baseURL }, wrapperSelector = "", transformOptions) {
    if (!wrapperSelector && !baseURL) {
      return css;
    }
    try {
      const excludedSelectors = [
        ...ignoredSelectors,
        ...transformOptions?.ignoredSelectors ?? [],
        wrapperSelector
      ];
      return new import_processor.default(
        [
          wrapperSelector && (0, import_postcss_prefix_selector.default)({
            prefix: wrapperSelector,
            transform(prefix3, selector3, prefixedSelector) {
              if (excludedSelectors.some(
                (excludedSelector) => excludedSelector instanceof RegExp ? selector3.match(excludedSelector) : selector3.includes(excludedSelector)
              )) {
                return selector3;
              }
              const hasRootSelector = ROOT_SELECTOR_TOKENS.some(
                (rootSelector) => selector3.startsWith(rootSelector.content)
              );
              if (hasRootSelector) {
                return prefixRootSelector(prefix3, selector3);
              }
              return prefixedSelector;
            }
          }),
          baseURL && (0, import_postcss_urlrebase.default)({ rootUrl: baseURL })
        ].filter(Boolean)
      ).process(css, {}).css;
    } catch (error) {
      if (error instanceof import_css_syntax_error.default) {
        console.warn(
          "wp.blockEditor.transformStyles Failed to transform CSS.",
          error.message + "\n" + error.showSourceCode(false)
        );
      } else {
        console.warn(
          "wp.blockEditor.transformStyles Failed to transform CSS.",
          error
        );
      }
      return null;
    }
  }
  var transformStyles = (styles, wrapperSelector = "", transformOptions) => {
    let cache = cacheByWrapperSelector.get(wrapperSelector);
    if (!cache) {
      cache = /* @__PURE__ */ new WeakMap();
      cacheByWrapperSelector.set(wrapperSelector, cache);
    }
    return styles.map((style) => {
      let css = cache.get(style);
      if (!css) {
        css = transformStyle(style, wrapperSelector, transformOptions);
        cache.set(style, css);
      }
      return css;
    });
  };
  var transform_styles_default = transformStyles;

  // packages/block-editor/build-module/components/editor-styles/index.js
  k([names_default, a11y_default]);
  function useDarkThemeBodyClassName(styles, scope) {
    return (0, import_element43.useCallback)(
      (node2) => {
        if (!node2) {
          return;
        }
        const { ownerDocument } = node2;
        const { defaultView, body } = ownerDocument;
        const canvas = scope ? ownerDocument.querySelector(scope) : body;
        let backgroundColor;
        if (!canvas) {
          const tempCanvas = ownerDocument.createElement("div");
          tempCanvas.classList.add("editor-styles-wrapper");
          body.appendChild(tempCanvas);
          backgroundColor = defaultView?.getComputedStyle(tempCanvas, null).getPropertyValue("background-color");
          body.removeChild(tempCanvas);
        } else {
          backgroundColor = defaultView?.getComputedStyle(canvas, null).getPropertyValue("background-color");
        }
        const colordBackgroundColor = w(backgroundColor);
        if (colordBackgroundColor.luminance() > 0.5 || colordBackgroundColor.alpha() === 0) {
          body.classList.remove("is-dark-theme");
        } else {
          body.classList.add("is-dark-theme");
        }
      },
      [styles, scope]
    );
  }
  function EditorStyles({ styles, scope, transformOptions }) {
    const overrides = (0, import_data45.useSelect)(
      (select2) => unlock(select2(store)).getStyleOverrides(),
      []
    );
    const [transformedStyles, transformedSvgs] = (0, import_element43.useMemo)(() => {
      const _styles = Object.values(styles ?? []);
      for (const [id, override] of overrides) {
        const index = _styles.findIndex(({ id: _id }) => id === _id);
        const overrideWithId = { ...override, id };
        if (index === -1) {
          _styles.push(overrideWithId);
        } else {
          _styles[index] = overrideWithId;
        }
      }
      return [
        transform_styles_default(
          _styles.filter((style) => style?.css),
          scope,
          transformOptions
        ),
        _styles.filter((style) => style.__unstableType === "svgs").map((style) => style.assets).join("")
      ];
    }, [styles, overrides, scope, transformOptions]);
    return /* @__PURE__ */ (0, import_jsx_runtime149.jsxs)(import_jsx_runtime149.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(
        "style",
        {
          ref: useDarkThemeBodyClassName(transformedStyles, scope)
        }
      ),
      transformedStyles.map((css, index) => /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("style", { children: css }, index)),
      /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(
        import_components27.SVG,
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 0 0",
          width: "0",
          height: "0",
          role: "none",
          style: {
            visibility: "hidden",
            position: "absolute",
            left: "-9999px",
            overflow: "hidden"
          },
          dangerouslySetInnerHTML: { __html: transformedSvgs }
        }
      )
    ] });
  }
  var editor_styles_default = (0, import_element43.memo)(EditorStyles);

  // packages/block-editor/build-module/components/block-preview/auto.js
  var MemoizedBlockList = (0, import_element44.memo)(BlockList);
  var MAX_HEIGHT = 2e3;
  var EMPTY_ADDITIONAL_STYLES = [];
  function ScaledBlockPreview({
    viewportWidth,
    containerWidth,
    minHeight,
    additionalStyles = EMPTY_ADDITIONAL_STYLES
  }) {
    if (!viewportWidth) {
      viewportWidth = containerWidth;
    }
    const [contentResizeListener, { height: contentHeight }] = (0, import_compose30.useResizeObserver)();
    const { styles } = (0, import_data46.useSelect)((select2) => {
      const settings2 = select2(store).getSettings();
      return {
        styles: settings2.styles
      };
    }, []);
    const editorStyles = (0, import_element44.useMemo)(() => {
      if (styles) {
        return [
          ...styles,
          {
            css: "body{height:auto;overflow:hidden;border:none;padding:0;}",
            __unstableType: "presets"
          },
          ...additionalStyles
        ];
      }
      return styles;
    }, [styles, additionalStyles]);
    const scale = containerWidth / viewportWidth;
    const aspectRatio = contentHeight ? containerWidth / (contentHeight * scale) : 0;
    return /* @__PURE__ */ (0, import_jsx_runtime150.jsx)(
      import_components28.Disabled,
      {
        className: "block-editor-block-preview__content",
        style: {
          transform: `scale(${scale})`,
          // Using width + aspect-ratio instead of height here triggers browsers' native
          // handling of scrollbar's visibility. It prevents the flickering issue seen
          // in https://github.com/WordPress/gutenberg/issues/52027.
          // See https://github.com/WordPress/gutenberg/pull/52921 for more info.
          aspectRatio,
          maxHeight: contentHeight > MAX_HEIGHT ? MAX_HEIGHT * scale : void 0,
          minHeight
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime150.jsxs)(
          iframe_default,
          {
            contentRef: (0, import_compose30.useRefEffect)((bodyElement) => {
              const {
                ownerDocument: { documentElement }
              } = bodyElement;
              documentElement.classList.add(
                "block-editor-block-preview__content-iframe"
              );
              documentElement.style.position = "absolute";
              documentElement.style.width = "100%";
              bodyElement.style.boxSizing = "border-box";
              bodyElement.style.position = "absolute";
              bodyElement.style.width = "100%";
            }, []),
            "aria-hidden": true,
            tabIndex: -1,
            style: {
              position: "absolute",
              width: viewportWidth,
              height: contentHeight,
              pointerEvents: "none",
              // This is a catch-all max-height for patterns.
              // See: https://github.com/WordPress/gutenberg/pull/38175.
              maxHeight: MAX_HEIGHT,
              minHeight: scale !== 0 && scale < 1 && minHeight ? minHeight / scale : minHeight
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime150.jsx)(editor_styles_default, { styles: editorStyles }),
              contentResizeListener,
              /* @__PURE__ */ (0, import_jsx_runtime150.jsx)(MemoizedBlockList, { renderAppender: false })
            ]
          }
        )
      }
    );
  }
  function AutoBlockPreview(props) {
    const [containerResizeListener, { width: containerWidth }] = (0, import_compose30.useResizeObserver)();
    return /* @__PURE__ */ (0, import_jsx_runtime150.jsxs)(import_jsx_runtime150.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime150.jsx)("div", { style: { position: "relative", width: "100%", height: 0 }, children: containerResizeListener }),
      /* @__PURE__ */ (0, import_jsx_runtime150.jsx)("div", { className: "block-editor-block-preview__container", children: !!containerWidth && /* @__PURE__ */ (0, import_jsx_runtime150.jsx)(
        ScaledBlockPreview,
        {
          ...props,
          containerWidth
        }
      ) })
    ] });
  }

  // packages/block-editor/build-module/components/block-preview/async.js
  var import_element45 = __toESM(require_element());
  var import_priority_queue = __toESM(require_priority_queue());
  var blockPreviewQueue = (0, import_priority_queue.createQueue)();
  function Async({ children, placeholder }) {
    const [shouldRender, setShouldRender] = (0, import_element45.useState)(false);
    (0, import_element45.useEffect)(() => {
      const context = {};
      blockPreviewQueue.add(context, () => {
        (0, import_element45.flushSync)(() => {
          setShouldRender(true);
        });
      });
      return () => {
        blockPreviewQueue.cancel(context);
      };
    }, []);
    if (!shouldRender) {
      return placeholder;
    }
    return children;
  }

  // packages/block-editor/build-module/components/block-preview/index.js
  var EMPTY_ADDITIONAL_STYLES2 = [];
  function BlockPreview({
    blocks: blocks2,
    viewportWidth = 1200,
    minHeight,
    additionalStyles = EMPTY_ADDITIONAL_STYLES2,
    // Deprecated props:
    __experimentalMinHeight,
    __experimentalPadding
  }) {
    if (__experimentalMinHeight) {
      minHeight = __experimentalMinHeight;
      (0, import_deprecated7.default)("The __experimentalMinHeight prop", {
        since: "6.2",
        version: "6.4",
        alternative: "minHeight"
      });
    }
    if (__experimentalPadding) {
      additionalStyles = [
        ...additionalStyles,
        { css: `body { padding: ${__experimentalPadding}px; }` }
      ];
      (0, import_deprecated7.default)("The __experimentalPadding prop of BlockPreview", {
        since: "6.2",
        version: "6.4",
        alternative: "additionalStyles"
      });
    }
    const originalSettings = (0, import_data47.useSelect)(
      (select2) => select2(store).getSettings(),
      []
    );
    const settings2 = (0, import_element46.useMemo)(
      () => ({
        ...originalSettings,
        focusMode: false,
        // Disable "Spotlight mode".
        isPreviewMode: true
      }),
      [originalSettings]
    );
    const renderedBlocks = (0, import_element46.useMemo)(
      () => Array.isArray(blocks2) ? blocks2 : [blocks2],
      [blocks2]
    );
    if (!blocks2 || blocks2.length === 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(
      ExperimentalBlockEditorProvider,
      {
        value: renderedBlocks,
        settings: settings2,
        children: /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(
          AutoBlockPreview,
          {
            viewportWidth,
            minHeight,
            additionalStyles
          }
        )
      }
    );
  }
  var MemoizedBlockPreview = (0, import_element46.memo)(BlockPreview);
  MemoizedBlockPreview.Async = Async;
  var block_preview_default = MemoizedBlockPreview;
  function useBlockPreview({ blocks: blocks2, props = {}, layout }) {
    const originalSettings = (0, import_data47.useSelect)(
      (select2) => select2(store).getSettings(),
      []
    );
    const settings2 = (0, import_element46.useMemo)(
      () => ({
        ...originalSettings,
        styles: void 0,
        // Clear styles included by the parent settings, as they are already output by the parent's EditorStyles.
        focusMode: false,
        // Disable "Spotlight mode".
        isPreviewMode: true
      }),
      [originalSettings]
    );
    const disabledRef = (0, import_compose31.useDisabled)();
    const ref = (0, import_compose31.useMergeRefs)([props.ref, disabledRef]);
    const renderedBlocks = (0, import_element46.useMemo)(
      () => Array.isArray(blocks2) ? blocks2 : [blocks2],
      [blocks2]
    );
    const children = /* @__PURE__ */ (0, import_jsx_runtime151.jsxs)(
      ExperimentalBlockEditorProvider,
      {
        value: renderedBlocks,
        settings: settings2,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(editor_styles_default, {}),
          /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(BlockListItems, { renderAppender: false, layout })
        ]
      }
    );
    return {
      ...props,
      ref,
      className: clsx_default(
        props.className,
        "block-editor-block-preview__live-content",
        "components-disabled"
      ),
      children: blocks2?.length ? children : null
    };
  }

  // packages/block-editor/build-module/components/inserter/preview-panel.js
  function InserterPreviewPanel({ item }) {
    const { name, title, icon, description, initialAttributes, example } = item;
    const isReusable = (0, import_blocks24.isReusableBlock)(item);
    const blocks2 = (0, import_element47.useMemo)(() => {
      if (!example) {
        return (0, import_blocks24.createBlock)(name, initialAttributes);
      }
      return (0, import_blocks24.getBlockFromExample)(name, {
        attributes: {
          ...example.attributes,
          ...initialAttributes
        },
        innerBlocks: example.innerBlocks
      });
    }, [name, example, initialAttributes]);
    const previewHeight = 144;
    const sidebarWidth = 280;
    const viewportWidth = example?.viewportWidth ?? 500;
    const scale = sidebarWidth / viewportWidth;
    const minHeight = scale !== 0 && scale < 1 && previewHeight ? previewHeight / scale : previewHeight;
    return /* @__PURE__ */ (0, import_jsx_runtime152.jsxs)("div", { className: "block-editor-inserter__preview-container", children: [
      /* @__PURE__ */ (0, import_jsx_runtime152.jsx)("div", { className: "block-editor-inserter__preview", children: isReusable || example ? /* @__PURE__ */ (0, import_jsx_runtime152.jsx)("div", { className: "block-editor-inserter__preview-content", children: /* @__PURE__ */ (0, import_jsx_runtime152.jsx)(
        block_preview_default,
        {
          blocks: blocks2,
          viewportWidth,
          minHeight: previewHeight,
          additionalStyles: (
            //We want this CSS to be in sync with the one in BlockPreviewPanel.
            [
              {
                css: `
										body { 
											padding: 24px;
											min-height:${Math.round(minHeight)}px;
											display:flex;
											align-items:center;
										}
										.is-root-container { width: 100%; }
									`
              }
            ]
          )
        }
      ) }) : /* @__PURE__ */ (0, import_jsx_runtime152.jsx)("div", { className: "block-editor-inserter__preview-content-missing", children: (0, import_i18n34.__)("No preview available.") }) }),
      !isReusable && /* @__PURE__ */ (0, import_jsx_runtime152.jsx)(
        block_card_default,
        {
          title,
          icon,
          description
        }
      )
    ] });
  }
  var preview_panel_default = InserterPreviewPanel;

  // packages/block-editor/build-module/components/inserter/block-types-tab.js
  var import_jsx_runtime163 = __toESM(require_jsx_runtime());
  var import_i18n38 = __toESM(require_i18n());
  var import_element54 = __toESM(require_element());
  var import_compose33 = __toESM(require_compose());

  // packages/block-editor/build-module/components/block-types-list/index.js
  var import_jsx_runtime160 = __toESM(require_jsx_runtime());
  var import_blocks27 = __toESM(require_blocks());
  var import_compose32 = __toESM(require_compose());

  // packages/block-editor/build-module/components/inserter-list-item/index.js
  var import_jsx_runtime159 = __toESM(require_jsx_runtime());
  var import_element53 = __toESM(require_element());
  var import_blocks26 = __toESM(require_blocks());
  var import_components34 = __toESM(require_components());
  var import_keycodes6 = __toESM(require_keycodes());

  // packages/block-editor/build-module/components/inserter-listbox/index.js
  var import_jsx_runtime156 = __toESM(require_jsx_runtime());
  var import_components31 = __toESM(require_components());
  var import_element51 = __toESM(require_element());

  // packages/block-editor/build-module/components/inserter-listbox/group.js
  var import_jsx_runtime153 = __toESM(require_jsx_runtime());
  var import_element48 = __toESM(require_element());
  var import_i18n35 = __toESM(require_i18n());
  var import_a11y5 = __toESM(require_a11y());
  function InserterListboxGroup(props, ref) {
    const [shouldSpeak, setShouldSpeak] = (0, import_element48.useState)(false);
    (0, import_element48.useEffect)(() => {
      if (shouldSpeak) {
        (0, import_a11y5.speak)(
          (0, import_i18n35.__)("Use left and right arrow keys to move through blocks")
        );
      }
    }, [shouldSpeak]);
    return /* @__PURE__ */ (0, import_jsx_runtime153.jsx)(
      "div",
      {
        ref,
        role: "listbox",
        "aria-orientation": "horizontal",
        onFocus: () => {
          setShouldSpeak(true);
        },
        onBlur: (event) => {
          const focusingOutsideGroup = !event.currentTarget.contains(
            event.relatedTarget
          );
          if (focusingOutsideGroup) {
            setShouldSpeak(false);
          }
        },
        ...props
      }
    );
  }
  var group_default2 = (0, import_element48.forwardRef)(InserterListboxGroup);

  // packages/block-editor/build-module/components/inserter-listbox/row.js
  var import_jsx_runtime154 = __toESM(require_jsx_runtime());
  var import_element49 = __toESM(require_element());
  var import_components29 = __toESM(require_components());
  function InserterListboxRow(props, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime154.jsx)(import_components29.Composite.Group, { role: "presentation", ref, ...props });
  }
  var row_default2 = (0, import_element49.forwardRef)(InserterListboxRow);

  // packages/block-editor/build-module/components/inserter-listbox/item.js
  var import_jsx_runtime155 = __toESM(require_jsx_runtime());
  var import_components30 = __toESM(require_components());
  var import_element50 = __toESM(require_element());
  function InserterListboxItem({ isFirst, as: Component7, children, ...props }, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime155.jsx)(
      import_components30.Composite.Item,
      {
        ref,
        role: "option",
        accessibleWhenDisabled: true,
        ...props,
        render: (htmlProps) => {
          const propsWithTabIndex = {
            ...htmlProps,
            tabIndex: isFirst ? 0 : htmlProps.tabIndex
          };
          if (Component7) {
            return /* @__PURE__ */ (0, import_jsx_runtime155.jsx)(Component7, { ...propsWithTabIndex, children });
          }
          if (typeof children === "function") {
            return children(propsWithTabIndex);
          }
          return /* @__PURE__ */ (0, import_jsx_runtime155.jsx)(import_components30.Button, { __next40pxDefaultSize: true, ...propsWithTabIndex, children });
        }
      }
    );
  }
  var item_default = (0, import_element50.forwardRef)(InserterListboxItem);

  // packages/block-editor/build-module/components/inserter-listbox/index.js
  function InserterListBoxWrapper({ key, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime156.jsx)(import_element51.Fragment, { children }, key);
  }
  function InserterListbox({ children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime156.jsx)(
      import_components31.Composite,
      {
        focusShift: true,
        focusWrap: "horizontal",
        render: InserterListBoxWrapper,
        children
      }
    );
  }
  var inserter_listbox_default = InserterListbox;

  // packages/block-editor/build-module/components/inserter-draggable-blocks/index.js
  var import_jsx_runtime158 = __toESM(require_jsx_runtime());
  var import_components33 = __toESM(require_components());
  var import_blocks25 = __toESM(require_blocks());
  var import_data48 = __toESM(require_data());
  var import_element52 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-draggable/draggable-chip.js
  var import_jsx_runtime157 = __toESM(require_jsx_runtime());
  var import_i18n36 = __toESM(require_i18n());
  var import_components32 = __toESM(require_components());
  function BlockDraggableChip({
    count,
    icon,
    isPattern,
    fadeWhenDisabled
  }) {
    const patternLabel = isPattern && (0, import_i18n36.__)("Pattern");
    return /* @__PURE__ */ (0, import_jsx_runtime157.jsx)("div", { className: "block-editor-block-draggable-chip-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime157.jsx)(
      "div",
      {
        className: "block-editor-block-draggable-chip",
        "data-testid": "block-draggable-chip",
        children: /* @__PURE__ */ (0, import_jsx_runtime157.jsxs)(
          import_components32.Flex,
          {
            justify: "center",
            className: "block-editor-block-draggable-chip__content",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime157.jsx)(import_components32.FlexItem, { children: icon ? /* @__PURE__ */ (0, import_jsx_runtime157.jsx)(block_icon_default, { icon }) : patternLabel || (0, import_i18n36.sprintf)(
                /* translators: %d: Number of blocks. */
                (0, import_i18n36._n)("%d block", "%d blocks", count),
                count
              ) }),
              /* @__PURE__ */ (0, import_jsx_runtime157.jsx)(import_components32.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime157.jsx)(block_icon_default, { icon: drag_handle_default }) }),
              fadeWhenDisabled && /* @__PURE__ */ (0, import_jsx_runtime157.jsx)(import_components32.FlexItem, { className: "block-editor-block-draggable-chip__disabled", children: /* @__PURE__ */ (0, import_jsx_runtime157.jsx)("span", { className: "block-editor-block-draggable-chip__disabled-icon" }) })
            ]
          }
        )
      }
    ) });
  }

  // packages/block-editor/build-module/components/inserter-draggable-blocks/index.js
  var InserterDraggableBlocks = ({
    isEnabled,
    blocks: blocks2,
    icon,
    children,
    pattern
  }) => {
    const blockTypeIcon = (0, import_data48.useSelect)(
      (select2) => {
        const { getBlockType: getBlockType21 } = select2(import_blocks25.store);
        return blocks2.length === 1 && getBlockType21(blocks2[0].name)?.icon;
      },
      [blocks2]
    );
    const { startDragging: startDragging2, stopDragging: stopDragging2 } = unlock(
      (0, import_data48.useDispatch)(store)
    );
    const patternBlock = (0, import_element52.useMemo)(() => {
      return pattern?.type === INSERTER_PATTERN_TYPES.user && pattern?.syncStatus !== "unsynced" ? [(0, import_blocks25.createBlock)("core/block", { ref: pattern.id })] : void 0;
    }, [pattern?.type, pattern?.syncStatus, pattern?.id]);
    if (!isEnabled) {
      return children({
        draggable: false,
        onDragStart: void 0,
        onDragEnd: void 0
      });
    }
    const draggableBlocks = patternBlock ?? blocks2;
    return /* @__PURE__ */ (0, import_jsx_runtime158.jsx)(
      import_components33.Draggable,
      {
        __experimentalTransferDataType: "wp-blocks",
        transferData: { type: "inserter", blocks: draggableBlocks },
        onDragStart: (event) => {
          startDragging2();
          for (const block of draggableBlocks) {
            const type = `wp-block:${block.name}`;
            event.dataTransfer.items.add("", type);
          }
        },
        onDragEnd: () => {
          stopDragging2();
        },
        __experimentalDragComponent: /* @__PURE__ */ (0, import_jsx_runtime158.jsx)(
          BlockDraggableChip,
          {
            count: blocks2.length,
            icon: icon || !pattern && blockTypeIcon,
            isPattern: !!pattern
          }
        ),
        children: ({ onDraggableStart, onDraggableEnd }) => {
          return children({
            draggable: true,
            onDragStart: onDraggableStart,
            onDragEnd: onDraggableEnd
          });
        }
      }
    );
  };
  var inserter_draggable_blocks_default = InserterDraggableBlocks;

  // packages/block-editor/build-module/components/inserter-list-item/index.js
  function InserterListItem({
    className,
    isFirst,
    item,
    onSelect,
    onHover,
    isDraggable,
    ...props
  }) {
    const isDraggingRef = (0, import_element53.useRef)(false);
    const itemIconStyle = item.icon ? {
      backgroundColor: item.icon.background,
      color: item.icon.foreground
    } : {};
    const blocks2 = (0, import_element53.useMemo)(
      () => [
        (0, import_blocks26.createBlock)(
          item.name,
          item.initialAttributes,
          (0, import_blocks26.createBlocksFromInnerBlocksTemplate)(item.innerBlocks)
        )
      ],
      [item.name, item.initialAttributes, item.innerBlocks]
    );
    const isSynced = (0, import_blocks26.isReusableBlock)(item) && item.syncStatus !== "unsynced" || (0, import_blocks26.isTemplatePart)(item);
    return /* @__PURE__ */ (0, import_jsx_runtime159.jsx)(
      inserter_draggable_blocks_default,
      {
        isEnabled: isDraggable && !item.isDisabled,
        blocks: blocks2,
        icon: item.icon,
        children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0, import_jsx_runtime159.jsx)(
          "div",
          {
            className: clsx_default(
              "block-editor-block-types-list__list-item",
              {
                "is-synced": isSynced
              }
            ),
            draggable,
            onDragStart: (event) => {
              isDraggingRef.current = true;
              if (onDragStart) {
                onHover(null);
                onDragStart(event);
              }
            },
            onDragEnd: (event) => {
              isDraggingRef.current = false;
              if (onDragEnd) {
                onDragEnd(event);
              }
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime159.jsxs)(
              item_default,
              {
                isFirst,
                className: clsx_default(
                  "block-editor-block-types-list__item",
                  className
                ),
                disabled: item.isDisabled,
                onClick: (event) => {
                  event.preventDefault();
                  onSelect(
                    item,
                    (0, import_keycodes6.isAppleOS)() ? event.metaKey : event.ctrlKey
                  );
                  onHover(null);
                },
                onKeyDown: (event) => {
                  const { keyCode } = event;
                  if (keyCode === import_keycodes6.ENTER) {
                    event.preventDefault();
                    onSelect(
                      item,
                      (0, import_keycodes6.isAppleOS)() ? event.metaKey : event.ctrlKey
                    );
                    onHover(null);
                  }
                },
                onMouseEnter: () => {
                  if (isDraggingRef.current) {
                    return;
                  }
                  onHover(item);
                },
                onMouseLeave: () => onHover(null),
                ...props,
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime159.jsx)(
                    "span",
                    {
                      className: "block-editor-block-types-list__item-icon",
                      style: itemIconStyle,
                      children: /* @__PURE__ */ (0, import_jsx_runtime159.jsx)(block_icon_default, { icon: item.icon, showColors: true })
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime159.jsx)("span", { className: "block-editor-block-types-list__item-title", children: /* @__PURE__ */ (0, import_jsx_runtime159.jsx)(import_components34.__experimentalTruncate, { numberOfLines: 3, children: item.title }) })
                ]
              }
            )
          }
        )
      }
    );
  }
  var inserter_list_item_default = (0, import_element53.memo)(InserterListItem);

  // packages/block-editor/build-module/components/block-types-list/index.js
  function chunk(array, size) {
    const chunks = [];
    for (let i2 = 0, j2 = array.length; i2 < j2; i2 += size) {
      chunks.push(array.slice(i2, i2 + size));
    }
    return chunks;
  }
  function BlockTypesList({
    items = [],
    onSelect,
    onHover = () => {
    },
    children,
    label,
    isDraggable = true
  }) {
    const className = "block-editor-block-types-list";
    const listId = (0, import_compose32.useInstanceId)(BlockTypesList, className);
    return /* @__PURE__ */ (0, import_jsx_runtime160.jsxs)(group_default2, { className, "aria-label": label, children: [
      chunk(items, 3).map((row, i2) => /* @__PURE__ */ (0, import_jsx_runtime160.jsx)(row_default2, { children: row.map((item, j2) => /* @__PURE__ */ (0, import_jsx_runtime160.jsx)(
        inserter_list_item_default,
        {
          item,
          className: (0, import_blocks27.getBlockMenuDefaultClassName)(
            item.id
          ),
          onSelect,
          onHover,
          isDraggable: isDraggable && !item.isDisabled,
          isFirst: i2 === 0 && j2 === 0,
          rowId: `${listId}-${i2}`
        },
        item.id
      )) }, i2)),
      children
    ] });
  }
  var block_types_list_default = BlockTypesList;

  // packages/block-editor/build-module/components/inserter/panel.js
  var import_jsx_runtime161 = __toESM(require_jsx_runtime());
  var import_components35 = __toESM(require_components());
  function InserterPanel({ title, icon, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime161.jsxs)(import_jsx_runtime161.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime161.jsxs)("div", { className: "block-editor-inserter__panel-header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime161.jsx)("h2", { className: "block-editor-inserter__panel-title", children: title }),
        /* @__PURE__ */ (0, import_jsx_runtime161.jsx)(import_components35.Icon, { icon })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime161.jsx)("div", { className: "block-editor-inserter__panel-content", children })
    ] });
  }
  var panel_default = InserterPanel;

  // packages/block-editor/build-module/components/inserter/no-results.js
  var import_jsx_runtime162 = __toESM(require_jsx_runtime());
  var import_i18n37 = __toESM(require_i18n());
  function InserterNoResults() {
    return /* @__PURE__ */ (0, import_jsx_runtime162.jsx)("div", { className: "block-editor-inserter__no-results", children: /* @__PURE__ */ (0, import_jsx_runtime162.jsx)("p", { children: (0, import_i18n37.__)("No results found.") }) });
  }
  var no_results_default = InserterNoResults;

  // packages/block-editor/build-module/components/inserter/block-types-tab.js
  var getBlockNamespace = (item) => item.name.split("/")[0];
  var MAX_SUGGESTED_ITEMS = 6;
  var EMPTY_ARRAY5 = [];
  function BlockTypesTabPanel({
    items,
    collections,
    categories,
    onSelectItem,
    onHover,
    showMostUsedBlocks,
    className
  }) {
    const suggestedItems = (0, import_element54.useMemo)(() => {
      return orderBy(items, "frecency", "desc").slice(
        0,
        MAX_SUGGESTED_ITEMS
      );
    }, [items]);
    const uncategorizedItems = (0, import_element54.useMemo)(() => {
      return items.filter((item) => !item.category);
    }, [items]);
    const itemsPerCollection = (0, import_element54.useMemo)(() => {
      const result = { ...collections };
      Object.keys(collections).forEach((namespace) => {
        result[namespace] = items.filter(
          (item) => getBlockNamespace(item) === namespace
        );
        if (result[namespace].length === 0) {
          delete result[namespace];
        }
      });
      return result;
    }, [items, collections]);
    (0, import_element54.useEffect)(() => () => onHover(null), []);
    const currentlyRenderedCategories = (0, import_compose33.useAsyncList)(categories);
    const didRenderAllCategories = categories.length === currentlyRenderedCategories.length;
    const collectionEntries = (0, import_element54.useMemo)(() => {
      return Object.entries(collections);
    }, [collections]);
    const currentlyRenderedCollections = (0, import_compose33.useAsyncList)(
      didRenderAllCategories ? collectionEntries : EMPTY_ARRAY5
    );
    return /* @__PURE__ */ (0, import_jsx_runtime163.jsxs)("div", { className, children: [
      showMostUsedBlocks && // Only show the most used blocks if the total amount of block
      // is larger than 1 row, otherwise it is not so useful.
      items.length > 3 && !!suggestedItems.length && /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(panel_default, { title: (0, import_i18n38._x)("Most used", "blocks"), children: /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
        block_types_list_default,
        {
          items: suggestedItems,
          onSelect: onSelectItem,
          onHover,
          label: (0, import_i18n38._x)("Most used", "blocks")
        }
      ) }),
      currentlyRenderedCategories.map((category) => {
        const categoryItems = items.filter(
          (item) => item.category === category.slug
        );
        if (!categoryItems || !categoryItems.length) {
          return null;
        }
        return /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
          panel_default,
          {
            title: category.title,
            icon: category.icon,
            children: /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
              block_types_list_default,
              {
                items: categoryItems,
                onSelect: onSelectItem,
                onHover,
                label: category.title
              }
            )
          },
          category.slug
        );
      }),
      didRenderAllCategories && uncategorizedItems.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
        panel_default,
        {
          className: "block-editor-inserter__uncategorized-blocks-panel",
          title: (0, import_i18n38.__)("Uncategorized"),
          children: /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
            block_types_list_default,
            {
              items: uncategorizedItems,
              onSelect: onSelectItem,
              onHover,
              label: (0, import_i18n38.__)("Uncategorized")
            }
          )
        }
      ),
      currentlyRenderedCollections.map(
        ([namespace, collection]) => {
          const collectionItems = itemsPerCollection[namespace];
          if (!collectionItems || !collectionItems.length) {
            return null;
          }
          return /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
            panel_default,
            {
              title: collection.title,
              icon: collection.icon,
              children: /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
                block_types_list_default,
                {
                  items: collectionItems,
                  onSelect: onSelectItem,
                  onHover,
                  label: collection.title
                }
              )
            },
            namespace
          );
        }
      )
    ] });
  }
  function BlockTypesTab({ rootClientId, onInsert, onHover, showMostUsedBlocks }, ref) {
    const [items, categories, collections, onSelectItem] = use_block_types_state_default(
      rootClientId,
      onInsert
    );
    if (!items.length) {
      return /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(no_results_default, {});
    }
    const itemsForCurrentRoot = [];
    const itemsRemaining = [];
    for (const item of items) {
      if (item.category === "reusable") {
        continue;
      }
      if (item.isAllowedInCurrentRoot) {
        itemsForCurrentRoot.push(item);
      } else {
        itemsRemaining.push(item);
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(inserter_listbox_default, { children: /* @__PURE__ */ (0, import_jsx_runtime163.jsxs)("div", { ref, children: [
      !!itemsForCurrentRoot.length && /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(import_jsx_runtime163.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
        BlockTypesTabPanel,
        {
          items: itemsForCurrentRoot,
          categories,
          collections,
          onSelectItem,
          onHover,
          showMostUsedBlocks,
          className: "block-editor-inserter__insertable-blocks-at-selection"
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime163.jsx)(
        BlockTypesTabPanel,
        {
          items: itemsRemaining,
          categories,
          collections,
          onSelectItem,
          onHover,
          showMostUsedBlocks,
          className: "block-editor-inserter__all-blocks"
        }
      )
    ] }) });
  }
  var block_types_tab_default = (0, import_element54.forwardRef)(BlockTypesTab);

  // packages/block-editor/build-module/components/inserter/block-patterns-tab/index.js
  var import_jsx_runtime173 = __toESM(require_jsx_runtime());
  var import_element65 = __toESM(require_element());
  var import_compose38 = __toESM(require_compose());
  var import_components45 = __toESM(require_components());
  var import_i18n50 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/inserter/block-patterns-explorer/index.js
  var import_jsx_runtime168 = __toESM(require_jsx_runtime());
  var import_components40 = __toESM(require_components());
  var import_element61 = __toESM(require_element());
  var import_i18n46 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/inserter/block-patterns-explorer/pattern-explorer-sidebar.js
  var import_jsx_runtime164 = __toESM(require_jsx_runtime());
  var import_components36 = __toESM(require_components());
  var import_i18n39 = __toESM(require_i18n());
  function PatternCategoriesList({
    selectedCategory,
    patternCategories,
    onClickCategory
  }) {
    const baseClassName = "block-editor-block-patterns-explorer__sidebar";
    return /* @__PURE__ */ (0, import_jsx_runtime164.jsx)("div", { className: `${baseClassName}__categories-list`, children: patternCategories.map(({ name, label }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime164.jsx)(
        import_components36.Button,
        {
          __next40pxDefaultSize: true,
          label,
          className: `${baseClassName}__categories-list__item`,
          isPressed: selectedCategory === name,
          onClick: () => {
            onClickCategory(name);
          },
          children: label
        },
        name
      );
    }) });
  }
  function PatternsExplorerSearch({ searchValue, setSearchValue }) {
    const baseClassName = "block-editor-block-patterns-explorer__search";
    return /* @__PURE__ */ (0, import_jsx_runtime164.jsx)("div", { className: baseClassName, children: /* @__PURE__ */ (0, import_jsx_runtime164.jsx)(
      import_components36.SearchControl,
      {
        __nextHasNoMarginBottom: true,
        onChange: setSearchValue,
        value: searchValue,
        label: (0, import_i18n39.__)("Search"),
        placeholder: (0, import_i18n39.__)("Search")
      }
    ) });
  }
  function PatternExplorerSidebar({
    selectedCategory,
    patternCategories,
    onClickCategory,
    searchValue,
    setSearchValue
  }) {
    const baseClassName = "block-editor-block-patterns-explorer__sidebar";
    return /* @__PURE__ */ (0, import_jsx_runtime164.jsxs)("div", { className: baseClassName, children: [
      /* @__PURE__ */ (0, import_jsx_runtime164.jsx)(
        PatternsExplorerSearch,
        {
          searchValue,
          setSearchValue
        }
      ),
      !searchValue && /* @__PURE__ */ (0, import_jsx_runtime164.jsx)(
        PatternCategoriesList,
        {
          selectedCategory,
          patternCategories,
          onClickCategory
        }
      )
    ] });
  }
  var pattern_explorer_sidebar_default = PatternExplorerSidebar;

  // packages/block-editor/build-module/components/inserter/block-patterns-explorer/pattern-list.js
  var import_jsx_runtime167 = __toESM(require_jsx_runtime());
  var import_element59 = __toESM(require_element());
  var import_i18n44 = __toESM(require_i18n());
  var import_compose36 = __toESM(require_compose());
  var import_components39 = __toESM(require_components());
  var import_a11y7 = __toESM(require_a11y());

  // packages/block-editor/build-module/components/block-patterns-list/index.js
  var import_jsx_runtime166 = __toESM(require_jsx_runtime());
  var import_blocks28 = __toESM(require_blocks());
  var import_element55 = __toESM(require_element());
  var import_components38 = __toESM(require_components());
  var import_compose34 = __toESM(require_compose());
  var import_i18n41 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-patterns-paging/index.js
  var import_jsx_runtime165 = __toESM(require_jsx_runtime());
  var import_components37 = __toESM(require_components());
  var import_i18n40 = __toESM(require_i18n());
  function Pagination({
    currentPage,
    numPages,
    changePage,
    totalItems
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime165.jsxs)(import_components37.__experimentalVStack, { className: "block-editor-patterns__grid-pagination-wrapper", children: [
      /* @__PURE__ */ (0, import_jsx_runtime165.jsx)(import_components37.__experimentalText, { variant: "muted", children: (0, import_i18n40.sprintf)(
        // translators: %s: Total number of patterns.
        (0, import_i18n40._n)("%s item", "%s items", totalItems),
        totalItems
      ) }),
      numPages > 1 && /* @__PURE__ */ (0, import_jsx_runtime165.jsxs)(
        import_components37.__experimentalHStack,
        {
          expanded: false,
          spacing: 3,
          justify: "flex-start",
          className: "block-editor-patterns__grid-pagination",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime165.jsxs)(
              import_components37.__experimentalHStack,
              {
                expanded: false,
                spacing: 1,
                className: "block-editor-patterns__grid-pagination-previous",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime165.jsx)(
                    import_components37.Button,
                    {
                      variant: "tertiary",
                      onClick: () => changePage(1),
                      disabled: currentPage === 1,
                      "aria-label": (0, import_i18n40.__)("First page"),
                      size: "compact",
                      accessibleWhenDisabled: true,
                      className: "block-editor-patterns__grid-pagination-button",
                      children: /* @__PURE__ */ (0, import_jsx_runtime165.jsx)("span", { children: "\xAB" })
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime165.jsx)(
                    import_components37.Button,
                    {
                      variant: "tertiary",
                      onClick: () => changePage(currentPage - 1),
                      disabled: currentPage === 1,
                      "aria-label": (0, import_i18n40.__)("Previous page"),
                      size: "compact",
                      accessibleWhenDisabled: true,
                      className: "block-editor-patterns__grid-pagination-button",
                      children: /* @__PURE__ */ (0, import_jsx_runtime165.jsx)("span", { children: "\u2039" })
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime165.jsx)(import_components37.__experimentalText, { variant: "muted", children: (0, import_i18n40.sprintf)(
              // translators: 1: Current page number. 2: Total number of pages.
              (0, import_i18n40._x)("%1$s of %2$s", "paging"),
              currentPage,
              numPages
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime165.jsxs)(
              import_components37.__experimentalHStack,
              {
                expanded: false,
                spacing: 1,
                className: "block-editor-patterns__grid-pagination-next",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime165.jsx)(
                    import_components37.Button,
                    {
                      variant: "tertiary",
                      onClick: () => changePage(currentPage + 1),
                      disabled: currentPage === numPages,
                      "aria-label": (0, import_i18n40.__)("Next page"),
                      size: "compact",
                      accessibleWhenDisabled: true,
                      className: "block-editor-patterns__grid-pagination-button",
                      children: /* @__PURE__ */ (0, import_jsx_runtime165.jsx)("span", { children: "\u203A" })
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime165.jsx)(
                    import_components37.Button,
                    {
                      variant: "tertiary",
                      onClick: () => changePage(numPages),
                      disabled: currentPage === numPages,
                      "aria-label": (0, import_i18n40.__)("Last page"),
                      size: "compact",
                      accessibleWhenDisabled: true,
                      className: "block-editor-patterns__grid-pagination-button",
                      children: /* @__PURE__ */ (0, import_jsx_runtime165.jsx)("span", { children: "\xBB" })
                    }
                  )
                ]
              }
            )
          ]
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/block-patterns-list/index.js
  var WithToolTip = ({ showTooltip, title, children }) => {
    if (showTooltip) {
      return /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(import_components38.Tooltip, { text: title, children });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(import_jsx_runtime166.Fragment, { children });
  };
  function BlockPattern({
    id,
    isDraggable,
    pattern,
    onClick,
    onHover,
    showTitlesAsTooltip,
    category,
    isSelected
  }) {
    const [isDragging3, setIsDragging] = (0, import_element55.useState)(false);
    const { blocks: blocks2, viewportWidth } = pattern;
    const instanceId = (0, import_compose34.useInstanceId)(BlockPattern);
    const descriptionId = `block-editor-block-patterns-list__item-description-${instanceId}`;
    const isUserPattern = pattern.type === INSERTER_PATTERN_TYPES.user;
    const patternBlocks = (0, import_element55.useMemo)(() => {
      if (!category || !isDraggable) {
        return blocks2;
      }
      return (blocks2 ?? []).map((block) => {
        const clonedBlock = (0, import_blocks28.cloneBlock)(block);
        if (clonedBlock.attributes.metadata?.categories?.includes(
          category
        )) {
          clonedBlock.attributes.metadata.categories = [category];
        }
        return clonedBlock;
      });
    }, [blocks2, isDraggable, category]);
    return /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
      inserter_draggable_blocks_default,
      {
        isEnabled: isDraggable,
        blocks: patternBlocks,
        pattern,
        children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
          "div",
          {
            className: "block-editor-block-patterns-list__list-item",
            draggable,
            onDragStart: (event) => {
              setIsDragging(true);
              if (onDragStart) {
                onHover?.(null);
                onDragStart(event);
              }
            },
            onDragEnd: (event) => {
              setIsDragging(false);
              if (onDragEnd) {
                onDragEnd(event);
              }
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
              WithToolTip,
              {
                showTooltip: showTitlesAsTooltip && !isUserPattern,
                title: pattern.title,
                children: /* @__PURE__ */ (0, import_jsx_runtime166.jsxs)(
                  import_components38.Composite.Item,
                  {
                    render: /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
                      "div",
                      {
                        role: "option",
                        "aria-label": pattern.title,
                        "aria-describedby": pattern.description ? descriptionId : void 0,
                        className: clsx_default(
                          "block-editor-block-patterns-list__item",
                          {
                            "block-editor-block-patterns-list__list-item-synced": pattern.type === INSERTER_PATTERN_TYPES.user && !pattern.syncStatus,
                            "is-selected": isSelected
                          }
                        )
                      }
                    ),
                    id,
                    onClick: () => {
                      onClick(pattern, blocks2);
                      onHover?.(null);
                    },
                    onMouseEnter: () => {
                      if (isDragging3) {
                        return;
                      }
                      onHover?.(pattern);
                    },
                    onMouseLeave: () => onHover?.(null),
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
                        block_preview_default.Async,
                        {
                          placeholder: /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(BlockPatternPlaceholder, {}),
                          children: /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
                            block_preview_default,
                            {
                              blocks: blocks2,
                              viewportWidth
                            }
                          )
                        }
                      ),
                      (!showTitlesAsTooltip || isUserPattern) && /* @__PURE__ */ (0, import_jsx_runtime166.jsxs)(
                        import_components38.__experimentalHStack,
                        {
                          className: "block-editor-patterns__pattern-details",
                          spacing: 2,
                          children: [
                            isUserPattern && !pattern.syncStatus && /* @__PURE__ */ (0, import_jsx_runtime166.jsx)("div", { className: "block-editor-patterns__pattern-icon-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
                              icon_default,
                              {
                                className: "block-editor-patterns__pattern-icon",
                                icon: symbol_default
                              }
                            ) }),
                            /* @__PURE__ */ (0, import_jsx_runtime166.jsx)("div", { className: "block-editor-block-patterns-list__item-title", children: pattern.title })
                          ]
                        }
                      ),
                      !!pattern.description && /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(import_components38.VisuallyHidden, { id: descriptionId, children: pattern.description })
                    ]
                  }
                )
              }
            )
          }
        )
      }
    );
  }
  function BlockPatternPlaceholder() {
    return /* @__PURE__ */ (0, import_jsx_runtime166.jsx)("div", { className: "block-editor-block-patterns-list__item is-placeholder" });
  }
  function BlockPatternsList({
    isDraggable,
    blockPatterns,
    onHover,
    onClickPattern,
    orientation,
    label = (0, import_i18n41.__)("Block patterns"),
    category,
    showTitlesAsTooltip,
    pagingProps
  }, ref) {
    const [activeCompositeId, setActiveCompositeId] = (0, import_element55.useState)(void 0);
    const [activePattern, setActivePattern] = (0, import_element55.useState)(null);
    (0, import_element55.useEffect)(() => {
      const firstCompositeItemId = blockPatterns[0]?.name;
      setActiveCompositeId(firstCompositeItemId);
    }, [blockPatterns]);
    const handleClickPattern = (pattern, blocks2) => {
      setActivePattern(pattern.name);
      onClickPattern(pattern, blocks2);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime166.jsxs)(
      import_components38.Composite,
      {
        orientation,
        activeId: activeCompositeId,
        setActiveId: setActiveCompositeId,
        role: "listbox",
        className: "block-editor-block-patterns-list",
        "aria-label": label,
        ref,
        children: [
          blockPatterns.map((pattern) => /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(
            BlockPattern,
            {
              id: pattern.name,
              pattern,
              onClick: handleClickPattern,
              onHover,
              isDraggable,
              showTitlesAsTooltip,
              category,
              isSelected: !!activePattern && activePattern === pattern.name
            },
            pattern.name
          )),
          pagingProps && /* @__PURE__ */ (0, import_jsx_runtime166.jsx)(Pagination, { ...pagingProps })
        ]
      }
    );
  }
  var block_patterns_list_default = (0, import_element55.forwardRef)(BlockPatternsList);

  // packages/block-editor/build-module/components/inserter/hooks/use-insertion-point.js
  var import_data49 = __toESM(require_data());
  var import_blocks29 = __toESM(require_blocks());
  var import_i18n42 = __toESM(require_i18n());
  var import_a11y6 = __toESM(require_a11y());
  var import_element56 = __toESM(require_element());
  function getIndex({
    destinationRootClientId,
    destinationIndex,
    rootClientId,
    registry
  }) {
    if (rootClientId === destinationRootClientId) {
      return destinationIndex;
    }
    const parents = [
      "",
      ...registry.select(store).getBlockParents(destinationRootClientId),
      destinationRootClientId
    ];
    const parentIndex = parents.indexOf(rootClientId);
    if (parentIndex !== -1) {
      return registry.select(store).getBlockIndex(parents[parentIndex + 1]) + 1;
    }
    return registry.select(store).getBlockOrder(rootClientId).length;
  }
  function useInsertionPoint({
    rootClientId = "",
    insertionIndex,
    clientId,
    isAppender,
    onSelect,
    shouldFocusBlock = true,
    selectBlockOnInsert = true
  }) {
    const registry = (0, import_data49.useRegistry)();
    const {
      getSelectedBlock: getSelectedBlock2,
      getClosestAllowedInsertionPoint: getClosestAllowedInsertionPoint2,
      isBlockInsertionPointVisible: isBlockInsertionPointVisible2
    } = unlock((0, import_data49.useSelect)(store));
    const { destinationRootClientId, destinationIndex } = (0, import_data49.useSelect)(
      (select2) => {
        const {
          getSelectedBlockClientId: getSelectedBlockClientId2,
          getBlockRootClientId: getBlockRootClientId2,
          getBlockIndex: getBlockIndex2,
          getBlockOrder: getBlockOrder2,
          getInsertionPoint: getInsertionPoint2
        } = unlock(select2(store));
        const selectedBlockClientId = getSelectedBlockClientId2();
        let _destinationRootClientId = rootClientId;
        let _destinationIndex;
        const insertionPoint2 = getInsertionPoint2();
        if (insertionIndex !== void 0) {
          _destinationIndex = insertionIndex;
        } else if (insertionPoint2 && insertionPoint2.hasOwnProperty("index")) {
          _destinationRootClientId = insertionPoint2?.rootClientId ? insertionPoint2.rootClientId : rootClientId;
          _destinationIndex = insertionPoint2.index;
        } else if (clientId) {
          _destinationIndex = getBlockIndex2(clientId);
        } else if (!isAppender && selectedBlockClientId) {
          _destinationRootClientId = getBlockRootClientId2(
            selectedBlockClientId
          );
          _destinationIndex = getBlockIndex2(selectedBlockClientId) + 1;
        } else {
          _destinationIndex = getBlockOrder2(
            _destinationRootClientId
          ).length;
        }
        return {
          destinationRootClientId: _destinationRootClientId,
          destinationIndex: _destinationIndex
        };
      },
      [rootClientId, insertionIndex, clientId, isAppender]
    );
    const {
      replaceBlocks: replaceBlocks2,
      insertBlocks: insertBlocks2,
      showInsertionPoint: showInsertionPoint2,
      hideInsertionPoint: hideInsertionPoint2,
      setLastFocus: setLastFocus2
    } = unlock((0, import_data49.useDispatch)(store));
    const onInsertBlocks = (0, import_element56.useCallback)(
      (blocks2, meta, shouldForceFocusBlock = false, _rootClientId) => {
        if (shouldForceFocusBlock || shouldFocusBlock || selectBlockOnInsert) {
          setLastFocus2(null);
        }
        const selectedBlock = getSelectedBlock2();
        if (!isAppender && selectedBlock && (0, import_blocks29.isUnmodifiedDefaultBlock)(selectedBlock, "content")) {
          replaceBlocks2(
            selectedBlock.clientId,
            blocks2,
            null,
            shouldFocusBlock || shouldForceFocusBlock ? 0 : null,
            meta
          );
        } else {
          insertBlocks2(
            blocks2,
            isAppender || _rootClientId === void 0 ? destinationIndex : getIndex({
              destinationRootClientId,
              destinationIndex,
              rootClientId: _rootClientId,
              registry
            }),
            isAppender || _rootClientId === void 0 ? destinationRootClientId : _rootClientId,
            selectBlockOnInsert,
            shouldFocusBlock || shouldForceFocusBlock ? 0 : null,
            meta
          );
        }
        const blockLength = Array.isArray(blocks2) ? blocks2.length : 1;
        const message = (0, import_i18n42.sprintf)(
          // translators: %d: the name of the block that has been added
          (0, import_i18n42._n)("%d block added.", "%d blocks added.", blockLength),
          blockLength
        );
        (0, import_a11y6.speak)(message);
        if (onSelect) {
          onSelect(blocks2);
        }
      },
      [
        isAppender,
        getSelectedBlock2,
        replaceBlocks2,
        insertBlocks2,
        destinationRootClientId,
        destinationIndex,
        onSelect,
        shouldFocusBlock,
        selectBlockOnInsert
      ]
    );
    const onToggleInsertionPoint = (0, import_element56.useCallback)(
      (item) => {
        if (item && !isBlockInsertionPointVisible2()) {
          const allowedDestinationRootClientId = getClosestAllowedInsertionPoint2(
            item.name,
            destinationRootClientId
          );
          if (allowedDestinationRootClientId !== null) {
            showInsertionPoint2(
              allowedDestinationRootClientId,
              getIndex({
                destinationRootClientId,
                destinationIndex,
                rootClientId: allowedDestinationRootClientId,
                registry
              })
            );
          }
        } else {
          hideInsertionPoint2();
        }
      },
      [
        getClosestAllowedInsertionPoint2,
        isBlockInsertionPointVisible2,
        showInsertionPoint2,
        hideInsertionPoint2,
        destinationRootClientId,
        destinationIndex
      ]
    );
    return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
  }
  var use_insertion_point_default = useInsertionPoint;

  // packages/block-editor/build-module/components/inserter/hooks/use-patterns-state.js
  var import_element57 = __toESM(require_element());
  var import_blocks30 = __toESM(require_blocks());
  var import_data50 = __toESM(require_data());
  var import_i18n43 = __toESM(require_i18n());
  var import_notices4 = __toESM(require_notices());
  var usePatternsState = (onInsert, rootClientId, selectedCategory, isQuick) => {
    const options = (0, import_element57.useMemo)(
      () => ({ [isFiltered]: !!isQuick }),
      [isQuick]
    );
    const { patternCategories, patterns, userPatternCategories } = (0, import_data50.useSelect)(
      (select2) => {
        const { getSettings: getSettings4, __experimentalGetAllowedPatterns: __experimentalGetAllowedPatterns2 } = unlock(
          select2(store)
        );
        const {
          __experimentalUserPatternCategories,
          __experimentalBlockPatternCategories
        } = getSettings4();
        return {
          patterns: __experimentalGetAllowedPatterns2(
            rootClientId,
            options
          ),
          userPatternCategories: __experimentalUserPatternCategories,
          patternCategories: __experimentalBlockPatternCategories
        };
      },
      [rootClientId, options]
    );
    const { getClosestAllowedInsertionPointForPattern: getClosestAllowedInsertionPointForPattern2 } = unlock(
      (0, import_data50.useSelect)(store)
    );
    const allCategories = (0, import_element57.useMemo)(() => {
      const categories = [...patternCategories];
      userPatternCategories?.forEach((userCategory) => {
        if (!categories.find(
          (existingCategory) => existingCategory.name === userCategory.name
        )) {
          categories.push(userCategory);
        }
      });
      return categories;
    }, [patternCategories, userPatternCategories]);
    const { createSuccessNotice } = (0, import_data50.useDispatch)(import_notices4.store);
    const onClickPattern = (0, import_element57.useCallback)(
      (pattern, blocks2) => {
        const destinationRootClientId = isQuick ? rootClientId : getClosestAllowedInsertionPointForPattern2(
          pattern,
          rootClientId
        );
        if (destinationRootClientId === null) {
          return;
        }
        const patternBlocks = pattern.type === INSERTER_PATTERN_TYPES.user && pattern.syncStatus !== "unsynced" ? [(0, import_blocks30.createBlock)("core/block", { ref: pattern.id })] : blocks2;
        onInsert(
          (patternBlocks ?? []).map((block) => {
            const clonedBlock = (0, import_blocks30.cloneBlock)(block);
            if (clonedBlock.attributes.metadata?.categories?.includes(
              selectedCategory
            )) {
              clonedBlock.attributes.metadata.categories = [
                selectedCategory
              ];
            }
            return clonedBlock;
          }),
          pattern.name,
          false,
          destinationRootClientId
        );
        createSuccessNotice(
          (0, import_i18n43.sprintf)(
            /* translators: %s: block pattern title. */
            (0, import_i18n43.__)('Block pattern "%s" inserted.'),
            pattern.title
          ),
          {
            type: "snackbar",
            id: "inserter-notice"
          }
        );
      },
      [
        createSuccessNotice,
        onInsert,
        selectedCategory,
        rootClientId,
        getClosestAllowedInsertionPointForPattern2,
        isQuick
      ]
    );
    return [patterns, allCategories, onClickPattern];
  };
  var use_patterns_state_default = usePatternsState;

  // packages/block-editor/build-module/components/inserter/hooks/use-patterns-paging.js
  var import_element58 = __toESM(require_element());
  var import_compose35 = __toESM(require_compose());
  var import_dom19 = __toESM(require_dom());
  var PAGE_SIZE = 20;
  function usePatternsPaging(currentCategoryPatterns, currentCategory, scrollContainerRef, currentFilter = "") {
    const [currentPage, setCurrentPage] = (0, import_element58.useState)(1);
    const previousCategory = (0, import_compose35.usePrevious)(currentCategory);
    const previousFilter = (0, import_compose35.usePrevious)(currentFilter);
    if ((previousCategory !== currentCategory || previousFilter !== currentFilter) && currentPage !== 1) {
      setCurrentPage(1);
    }
    const totalItems = currentCategoryPatterns.length;
    const pageIndex = currentPage - 1;
    const categoryPatterns = (0, import_element58.useMemo)(() => {
      return currentCategoryPatterns.slice(
        pageIndex * PAGE_SIZE,
        pageIndex * PAGE_SIZE + PAGE_SIZE
      );
    }, [pageIndex, currentCategoryPatterns]);
    const numPages = Math.ceil(currentCategoryPatterns.length / PAGE_SIZE);
    const changePage = (page) => {
      const scrollContainer = (0, import_dom19.getScrollContainer)(
        scrollContainerRef?.current
      );
      scrollContainer?.scrollTo(0, 0);
      setCurrentPage(page);
    };
    (0, import_element58.useEffect)(
      function scrollToTopOnCategoryChange() {
        const scrollContainer = (0, import_dom19.getScrollContainer)(
          scrollContainerRef?.current
        );
        scrollContainer?.scrollTo(0, 0);
      },
      [currentCategory, scrollContainerRef]
    );
    return {
      totalItems,
      categoryPatterns,
      numPages,
      changePage,
      currentPage
    };
  }

  // packages/block-editor/build-module/components/inserter/block-patterns-explorer/pattern-list.js
  function PatternsListHeader({ filterValue, filteredBlockPatternsLength }) {
    if (!filterValue) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime167.jsx)(
      import_components39.__experimentalHeading,
      {
        level: 2,
        lineHeight: "48px",
        className: "block-editor-block-patterns-explorer__search-results-count",
        children: (0, import_i18n44.sprintf)(
          /* translators: %d: number of patterns. */
          (0, import_i18n44._n)(
            "%d pattern found",
            "%d patterns found",
            filteredBlockPatternsLength
          ),
          filteredBlockPatternsLength
        )
      }
    );
  }
  function PatternList({
    searchValue,
    selectedCategory,
    patternCategories,
    rootClientId,
    onModalClose
  }) {
    const container = (0, import_element59.useRef)();
    const debouncedSpeak = (0, import_compose36.useDebounce)(import_a11y7.speak, 500);
    const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
      rootClientId,
      shouldFocusBlock: true
    });
    const [patterns, , onClickPattern] = use_patterns_state_default(
      onInsertBlocks,
      destinationRootClientId,
      selectedCategory
    );
    const registeredPatternCategories = (0, import_element59.useMemo)(
      () => patternCategories.map(
        (patternCategory) => patternCategory.name
      ),
      [patternCategories]
    );
    const filteredBlockPatterns = (0, import_element59.useMemo)(() => {
      const filteredPatterns = patterns.filter((pattern) => {
        if (selectedCategory === allPatternsCategory.name) {
          return true;
        }
        if (selectedCategory === myPatternsCategory.name && pattern.type === INSERTER_PATTERN_TYPES.user) {
          return true;
        }
        if (selectedCategory === starterPatternsCategory.name && pattern.blockTypes?.includes("core/post-content")) {
          return true;
        }
        if (selectedCategory === "uncategorized") {
          const hasKnownCategory = pattern.categories?.some(
            (category) => registeredPatternCategories.includes(category)
          ) ?? false;
          return !pattern.categories?.length || !hasKnownCategory;
        }
        return pattern.categories?.includes(selectedCategory);
      });
      if (!searchValue) {
        return filteredPatterns;
      }
      return searchItems(filteredPatterns, searchValue);
    }, [
      searchValue,
      patterns,
      selectedCategory,
      registeredPatternCategories
    ]);
    (0, import_element59.useEffect)(() => {
      if (!searchValue) {
        return;
      }
      const count = filteredBlockPatterns.length;
      const resultsFoundMessage = (0, import_i18n44.sprintf)(
        /* translators: %d: number of results. */
        (0, import_i18n44._n)("%d result found.", "%d results found.", count),
        count
      );
      debouncedSpeak(resultsFoundMessage);
    }, [searchValue, debouncedSpeak, filteredBlockPatterns.length]);
    const pagingProps = usePatternsPaging(
      filteredBlockPatterns,
      selectedCategory,
      container
    );
    const [previousSearchValue, setPreviousSearchValue] = (0, import_element59.useState)(searchValue);
    if (searchValue !== previousSearchValue) {
      setPreviousSearchValue(searchValue);
      pagingProps.changePage(1);
    }
    const hasItems = !!filteredBlockPatterns?.length;
    return /* @__PURE__ */ (0, import_jsx_runtime167.jsxs)(
      "div",
      {
        className: "block-editor-block-patterns-explorer__list",
        ref: container,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime167.jsx)(
            PatternsListHeader,
            {
              filterValue: searchValue,
              filteredBlockPatternsLength: filteredBlockPatterns.length
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime167.jsx)(inserter_listbox_default, { children: hasItems && /* @__PURE__ */ (0, import_jsx_runtime167.jsxs)(import_jsx_runtime167.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime167.jsx)(
              block_patterns_list_default,
              {
                blockPatterns: pagingProps.categoryPatterns,
                onClickPattern: (pattern, blocks2) => {
                  onClickPattern(pattern, blocks2);
                  onModalClose();
                },
                isDraggable: false
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime167.jsx)(Pagination, { ...pagingProps })
          ] }) })
        ]
      }
    );
  }
  var pattern_list_default = PatternList;

  // packages/block-editor/build-module/components/inserter/block-patterns-tab/use-pattern-categories.js
  var import_element60 = __toESM(require_element());
  var import_i18n45 = __toESM(require_i18n());
  var import_a11y8 = __toESM(require_a11y());
  function hasRegisteredCategory(pattern, allCategories) {
    if (!pattern.categories || !pattern.categories.length) {
      return false;
    }
    return pattern.categories.some(
      (cat) => allCategories.some((category) => category.name === cat)
    );
  }
  function usePatternCategories(rootClientId, sourceFilter = "all") {
    const [patterns, allCategories] = use_patterns_state_default(
      void 0,
      rootClientId
    );
    const filteredPatterns = (0, import_element60.useMemo)(
      () => sourceFilter === "all" ? patterns : patterns.filter(
        (pattern) => !isPatternFiltered(pattern, sourceFilter)
      ),
      [sourceFilter, patterns]
    );
    const populatedCategories = (0, import_element60.useMemo)(() => {
      const categories = allCategories.filter(
        (category) => filteredPatterns.some(
          (pattern) => pattern.categories?.includes(category.name)
        )
      ).sort((a2, b2) => a2.label.localeCompare(b2.label));
      if (filteredPatterns.some(
        (pattern) => !hasRegisteredCategory(pattern, allCategories)
      ) && !categories.find(
        (category) => category.name === "uncategorized"
      )) {
        categories.push({
          name: "uncategorized",
          label: (0, import_i18n45._x)("Uncategorized")
        });
      }
      if (filteredPatterns.some(
        (pattern) => pattern.blockTypes?.includes("core/post-content")
      )) {
        categories.unshift(starterPatternsCategory);
      }
      if (filteredPatterns.some(
        (pattern) => pattern.type === INSERTER_PATTERN_TYPES.user
      )) {
        categories.unshift(myPatternsCategory);
      }
      if (filteredPatterns.length > 0) {
        categories.unshift({
          name: allPatternsCategory.name,
          label: allPatternsCategory.label
        });
      }
      (0, import_a11y8.speak)(
        (0, import_i18n45.sprintf)(
          /* translators: %d: number of categories . */
          (0, import_i18n45._n)(
            "%d category button displayed.",
            "%d category buttons displayed.",
            categories.length
          ),
          categories.length
        )
      );
      return categories;
    }, [allCategories, filteredPatterns]);
    return populatedCategories;
  }

  // packages/block-editor/build-module/components/inserter/block-patterns-explorer/index.js
  function PatternsExplorer({ initialCategory, rootClientId, onModalClose }) {
    const [searchValue, setSearchValue] = (0, import_element61.useState)("");
    const [selectedCategory, setSelectedCategory] = (0, import_element61.useState)(
      initialCategory?.name
    );
    const patternCategories = usePatternCategories(rootClientId);
    return /* @__PURE__ */ (0, import_jsx_runtime168.jsxs)("div", { className: "block-editor-block-patterns-explorer", children: [
      /* @__PURE__ */ (0, import_jsx_runtime168.jsx)(
        pattern_explorer_sidebar_default,
        {
          selectedCategory,
          patternCategories,
          onClickCategory: setSelectedCategory,
          searchValue,
          setSearchValue
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime168.jsx)(
        pattern_list_default,
        {
          searchValue,
          selectedCategory,
          patternCategories,
          rootClientId,
          onModalClose
        }
      )
    ] });
  }
  function PatternsExplorerModal({ onModalClose, ...restProps }) {
    return /* @__PURE__ */ (0, import_jsx_runtime168.jsx)(
      import_components40.Modal,
      {
        title: (0, import_i18n46.__)("Patterns"),
        onRequestClose: onModalClose,
        isFullScreen: true,
        children: /* @__PURE__ */ (0, import_jsx_runtime168.jsx)(PatternsExplorer, { onModalClose, ...restProps })
      }
    );
  }
  var block_patterns_explorer_default = PatternsExplorerModal;

  // packages/block-editor/build-module/components/inserter/mobile-tab-navigation.js
  var import_jsx_runtime169 = __toESM(require_jsx_runtime());
  var import_i18n47 = __toESM(require_i18n());
  var import_components41 = __toESM(require_components());
  function ScreenHeader({ title }) {
    return /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.__experimentalVStack, { spacing: 0, children: /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.__experimentalView, { children: /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.__experimentalSpacer, { marginBottom: 0, paddingX: 4, paddingY: 3, children: /* @__PURE__ */ (0, import_jsx_runtime169.jsxs)(import_components41.__experimentalHStack, { spacing: 2, children: [
      /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(
        import_components41.Navigator.BackButton,
        {
          style: (
            // TODO: This style override is also used in ToolsPanelHeader.
            // It should be supported out-of-the-box by Button.
            { minWidth: 24, padding: 0 }
          ),
          icon: (0, import_i18n47.isRTL)() ? chevron_right_default : chevron_left_default,
          size: "small",
          label: (0, import_i18n47.__)("Back")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.__experimentalSpacer, { children: /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.__experimentalHeading, { level: 5, children: title }) })
    ] }) }) }) });
  }
  function MobileTabNavigation({ categories, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime169.jsxs)(
      import_components41.Navigator,
      {
        initialPath: "/",
        className: "block-editor-inserter__mobile-tab-navigation",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.Navigator.Screen, { path: "/", children: /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.__experimentalItemGroup, { children: categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(
            import_components41.Navigator.Button,
            {
              path: `/category/${category.name}`,
              as: import_components41.__experimentalItem,
              isAction: true,
              children: /* @__PURE__ */ (0, import_jsx_runtime169.jsxs)(import_components41.__experimentalHStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(import_components41.FlexBlock, { children: category.label }),
                /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(
                  icon_default,
                  {
                    icon: (0, import_i18n47.isRTL)() ? chevron_left_default : chevron_right_default
                  }
                )
              ] })
            },
            category.name
          )) }) }),
          categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime169.jsxs)(
            import_components41.Navigator.Screen,
            {
              path: `/category/${category.name}`,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime169.jsx)(ScreenHeader, { title: (0, import_i18n47.__)("Back") }),
                children(category)
              ]
            },
            category.name
          ))
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/inserter/block-patterns-tab/pattern-category-previews.js
  var import_jsx_runtime171 = __toESM(require_jsx_runtime());
  var import_element63 = __toESM(require_element());
  var import_i18n49 = __toESM(require_i18n());
  var import_components43 = __toESM(require_components());

  // packages/block-editor/build-module/components/inserter/block-patterns-tab/patterns-filter.js
  var import_jsx_runtime170 = __toESM(require_jsx_runtime());
  var import_components42 = __toESM(require_components());
  var import_i18n48 = __toESM(require_i18n());
  var import_element62 = __toESM(require_element());
  var getShouldDisableSyncFilter = (sourceFilter) => sourceFilter !== "all" && sourceFilter !== "user";
  var getShouldHideSourcesFilter = (category) => {
    return category.name === myPatternsCategory.name;
  };
  var PATTERN_SOURCE_MENU_OPTIONS = [
    {
      value: "all",
      label: (0, import_i18n48._x)("All", "patterns")
    },
    {
      value: INSERTER_PATTERN_TYPES.directory,
      label: (0, import_i18n48.__)("Pattern Directory")
    },
    {
      value: INSERTER_PATTERN_TYPES.theme,
      label: (0, import_i18n48.__)("Theme & Plugins")
    },
    {
      value: INSERTER_PATTERN_TYPES.user,
      label: (0, import_i18n48.__)("User")
    }
  ];
  function PatternsFilter({
    setPatternSyncFilter,
    setPatternSourceFilter,
    patternSyncFilter,
    patternSourceFilter,
    scrollContainerRef,
    category
  }) {
    const currentPatternSourceFilter = category.name === myPatternsCategory.name ? INSERTER_PATTERN_TYPES.user : patternSourceFilter;
    const shouldDisableSyncFilter = getShouldDisableSyncFilter(
      currentPatternSourceFilter
    );
    const shouldHideSourcesFilter = getShouldHideSourcesFilter(category);
    const patternSyncMenuOptions = (0, import_element62.useMemo)(
      () => [
        {
          value: "all",
          label: (0, import_i18n48._x)("All", "patterns")
        },
        {
          value: INSERTER_SYNC_TYPES.full,
          label: (0, import_i18n48._x)("Synced", "patterns"),
          disabled: shouldDisableSyncFilter
        },
        {
          value: INSERTER_SYNC_TYPES.unsynced,
          label: (0, import_i18n48._x)("Not synced", "patterns"),
          disabled: shouldDisableSyncFilter
        }
      ],
      [shouldDisableSyncFilter]
    );
    function handleSetSourceFilterChange(newSourceFilter) {
      setPatternSourceFilter(newSourceFilter);
      if (getShouldDisableSyncFilter(newSourceFilter)) {
        setPatternSyncFilter("all");
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(import_jsx_runtime170.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(
      import_components42.DropdownMenu,
      {
        popoverProps: {
          placement: "right-end"
        },
        label: (0, import_i18n48.__)("Filter patterns"),
        toggleProps: { size: "compact" },
        icon: /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(
          icon_default,
          {
            icon: /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(
              import_components42.SVG,
              {
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                children: /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(
                  import_components42.Path,
                  {
                    d: "M10 17.5H14V16H10V17.5ZM6 6V7.5H18V6H6ZM8 12.5H16V11H8V12.5Z",
                    fill: "currentColor"
                  }
                )
              }
            )
          }
        ),
        children: () => /* @__PURE__ */ (0, import_jsx_runtime170.jsxs)(import_jsx_runtime170.Fragment, { children: [
          !shouldHideSourcesFilter && /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(import_components42.MenuGroup, { label: (0, import_i18n48.__)("Source"), children: /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(
            import_components42.MenuItemsChoice,
            {
              choices: PATTERN_SOURCE_MENU_OPTIONS,
              onSelect: (value) => {
                handleSetSourceFilterChange(value);
                scrollContainerRef.current?.scrollTo(
                  0,
                  0
                );
              },
              value: currentPatternSourceFilter
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(import_components42.MenuGroup, { label: (0, import_i18n48.__)("Type"), children: /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(
            import_components42.MenuItemsChoice,
            {
              choices: patternSyncMenuOptions,
              onSelect: (value) => {
                setPatternSyncFilter(value);
                scrollContainerRef.current?.scrollTo(
                  0,
                  0
                );
              },
              value: patternSyncFilter
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime170.jsx)("div", { className: "block-editor-inserter__patterns-filter-help", children: (0, import_element62.createInterpolateElement)(
            (0, import_i18n48.__)(
              "Patterns are available from the <Link>WordPress.org Pattern Directory</Link>, bundled in the active theme, or created by users on this site. Only patterns created on this site can be synced."
            ),
            {
              Link: /* @__PURE__ */ (0, import_jsx_runtime170.jsx)(
                import_components42.ExternalLink,
                {
                  href: (0, import_i18n48.__)(
                    "https://wordpress.org/patterns/"
                  )
                }
              )
            }
          ) })
        ] })
      }
    ) });
  }

  // packages/block-editor/build-module/components/inserter/block-patterns-tab/pattern-category-previews.js
  var noop7 = () => {
  };
  function PatternCategoryPreviews({
    rootClientId,
    onInsert,
    onHover = noop7,
    category,
    showTitlesAsTooltip
  }) {
    const [allPatterns, , onClickPattern] = use_patterns_state_default(
      onInsert,
      rootClientId,
      category?.name
    );
    const [patternSyncFilter, setPatternSyncFilter] = (0, import_element63.useState)("all");
    const [patternSourceFilter, setPatternSourceFilter] = (0, import_element63.useState)("all");
    const availableCategories = usePatternCategories(
      rootClientId,
      patternSourceFilter
    );
    const scrollContainerRef = (0, import_element63.useRef)();
    const currentCategoryPatterns = (0, import_element63.useMemo)(
      () => allPatterns.filter((pattern) => {
        if (isPatternFiltered(
          pattern,
          patternSourceFilter,
          patternSyncFilter
        )) {
          return false;
        }
        if (category.name === allPatternsCategory.name) {
          return true;
        }
        if (category.name === myPatternsCategory.name && pattern.type === INSERTER_PATTERN_TYPES.user) {
          return true;
        }
        if (category.name === starterPatternsCategory.name && pattern.blockTypes?.includes("core/post-content")) {
          return true;
        }
        if (category.name === "uncategorized") {
          if (!pattern.categories) {
            return true;
          }
          return !pattern.categories.some(
            (catName) => availableCategories.some((c6) => c6.name === catName)
          );
        }
        return pattern.categories?.includes(category.name);
      }),
      [
        allPatterns,
        availableCategories,
        category.name,
        patternSourceFilter,
        patternSyncFilter
      ]
    );
    const pagingProps = usePatternsPaging(
      currentCategoryPatterns,
      category,
      scrollContainerRef
    );
    const { changePage } = pagingProps;
    (0, import_element63.useEffect)(() => () => onHover(null), []);
    const onSetPatternSyncFilter = (0, import_element63.useCallback)(
      (value) => {
        setPatternSyncFilter(value);
        changePage(1);
      },
      [setPatternSyncFilter, changePage]
    );
    const onSetPatternSourceFilter = (0, import_element63.useCallback)(
      (value) => {
        setPatternSourceFilter(value);
        changePage(1);
      },
      [setPatternSourceFilter, changePage]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime171.jsxs)(import_jsx_runtime171.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime171.jsxs)(
        import_components43.__experimentalVStack,
        {
          spacing: 2,
          className: "block-editor-inserter__patterns-category-panel-header",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime171.jsxs)(import_components43.__experimentalHStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime171.jsx)(import_components43.FlexBlock, { children: /* @__PURE__ */ (0, import_jsx_runtime171.jsx)(
                import_components43.__experimentalHeading,
                {
                  className: "block-editor-inserter__patterns-category-panel-title",
                  size: 13,
                  level: 4,
                  as: "div",
                  children: category.label
                }
              ) }),
              /* @__PURE__ */ (0, import_jsx_runtime171.jsx)(
                PatternsFilter,
                {
                  patternSyncFilter,
                  patternSourceFilter,
                  setPatternSyncFilter: onSetPatternSyncFilter,
                  setPatternSourceFilter: onSetPatternSourceFilter,
                  scrollContainerRef,
                  category
                }
              )
            ] }),
            !currentCategoryPatterns.length && /* @__PURE__ */ (0, import_jsx_runtime171.jsx)(
              import_components43.__experimentalText,
              {
                variant: "muted",
                className: "block-editor-inserter__patterns-category-no-results",
                children: (0, import_i18n49.__)("No results found")
              }
            )
          ]
        }
      ),
      currentCategoryPatterns.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime171.jsxs)(import_jsx_runtime171.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime171.jsx)(
          import_components43.__experimentalText,
          {
            size: "12",
            as: "p",
            className: "block-editor-inserter__help-text",
            children: (0, import_i18n49.__)("Drag and drop patterns into the canvas.")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime171.jsx)(
          block_patterns_list_default,
          {
            ref: scrollContainerRef,
            blockPatterns: pagingProps.categoryPatterns,
            onClickPattern,
            onHover,
            label: category.label,
            orientation: "vertical",
            category: category.name,
            isDraggable: true,
            showTitlesAsTooltip,
            patternFilter: patternSourceFilter,
            pagingProps
          }
        )
      ] })
    ] });
  }

  // packages/block-editor/build-module/components/inserter/category-tabs/index.js
  var import_jsx_runtime172 = __toESM(require_jsx_runtime());
  var import_compose37 = __toESM(require_compose());
  var import_components44 = __toESM(require_components());
  var import_element64 = __toESM(require_element());
  var { Tabs } = unlock(import_components44.privateApis);
  function CategoryTabs({
    categories,
    selectedCategory,
    onSelectCategory,
    children
  }) {
    const ANIMATION_DURATION = 0.25;
    const disableMotion = (0, import_compose37.useReducedMotion)();
    const defaultTransition = {
      type: "tween",
      duration: disableMotion ? 0 : ANIMATION_DURATION,
      ease: [0.6, 0, 0.4, 1]
    };
    const previousSelectedCategory = (0, import_compose37.usePrevious)(selectedCategory);
    const selectedTabId = selectedCategory ? selectedCategory.name : null;
    const [activeTabId, setActiveId] = (0, import_element64.useState)();
    const firstTabId = categories?.[0]?.name;
    if (selectedTabId === null && !activeTabId && firstTabId) {
      setActiveId(firstTabId);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime172.jsxs)(
      Tabs,
      {
        selectOnMove: false,
        selectedTabId,
        orientation: "vertical",
        onSelect: (categoryId) => {
          onSelectCategory(
            categories.find(
              (category) => category.name === categoryId
            )
          );
        },
        activeTabId,
        onActiveTabIdChange: setActiveId,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime172.jsx)(Tabs.TabList, { className: "block-editor-inserter__category-tablist", children: categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime172.jsx)(
            Tabs.Tab,
            {
              tabId: category.name,
              "aria-current": category === selectedCategory ? "true" : void 0,
              children: category.label
            },
            category.name
          )) }),
          categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime172.jsx)(
            Tabs.TabPanel,
            {
              tabId: category.name,
              focusable: false,
              children: /* @__PURE__ */ (0, import_jsx_runtime172.jsx)(
                import_components44.__unstableMotion.div,
                {
                  className: "block-editor-inserter__category-panel",
                  initial: !previousSelectedCategory ? "closed" : "open",
                  animate: "open",
                  variants: {
                    open: {
                      transform: "translateX( 0 )",
                      transitionEnd: {
                        zIndex: "1"
                      }
                    },
                    closed: {
                      transform: "translateX( -100% )",
                      zIndex: "-1"
                    }
                  },
                  transition: defaultTransition,
                  children
                }
              )
            },
            category.name
          ))
        ]
      }
    );
  }
  var category_tabs_default = CategoryTabs;

  // packages/block-editor/build-module/components/inserter/block-patterns-tab/index.js
  function BlockPatternsTab({
    onSelectCategory,
    selectedCategory,
    onInsert,
    rootClientId,
    children
  }) {
    const [showPatternsExplorer, setShowPatternsExplorer] = (0, import_element65.useState)(false);
    const categories = usePatternCategories(rootClientId);
    const isMobile = (0, import_compose38.useViewportMatch)("medium", "<");
    if (!categories.length) {
      return /* @__PURE__ */ (0, import_jsx_runtime173.jsx)(no_results_default, {});
    }
    return /* @__PURE__ */ (0, import_jsx_runtime173.jsxs)(import_jsx_runtime173.Fragment, { children: [
      !isMobile && /* @__PURE__ */ (0, import_jsx_runtime173.jsxs)("div", { className: "block-editor-inserter__block-patterns-tabs-container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime173.jsx)(
          category_tabs_default,
          {
            categories,
            selectedCategory,
            onSelectCategory,
            children
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime173.jsx)(
          import_components45.Button,
          {
            __next40pxDefaultSize: true,
            className: "block-editor-inserter__patterns-explore-button",
            onClick: () => setShowPatternsExplorer(true),
            variant: "secondary",
            children: (0, import_i18n50.__)("Explore all patterns")
          }
        )
      ] }),
      isMobile && /* @__PURE__ */ (0, import_jsx_runtime173.jsx)(MobileTabNavigation, { categories, children: (category) => /* @__PURE__ */ (0, import_jsx_runtime173.jsx)("div", { className: "block-editor-inserter__category-panel", children: /* @__PURE__ */ (0, import_jsx_runtime173.jsx)(
        PatternCategoryPreviews,
        {
          onInsert,
          rootClientId,
          category
        },
        category.name
      ) }) }),
      showPatternsExplorer && /* @__PURE__ */ (0, import_jsx_runtime173.jsx)(
        block_patterns_explorer_default,
        {
          initialCategory: selectedCategory || categories[0],
          patternCategories: categories,
          onModalClose: () => setShowPatternsExplorer(false),
          rootClientId
        }
      )
    ] });
  }
  var block_patterns_tab_default = BlockPatternsTab;

  // packages/block-editor/build-module/components/inserter/media-tab/media-tab.js
  var import_jsx_runtime178 = __toESM(require_jsx_runtime());
  var import_i18n54 = __toESM(require_i18n());
  var import_compose40 = __toESM(require_compose());
  var import_components50 = __toESM(require_components());
  var import_element68 = __toESM(require_element());

  // packages/block-editor/build-module/components/inserter/media-tab/media-panel.js
  var import_jsx_runtime177 = __toESM(require_jsx_runtime());
  var import_components48 = __toESM(require_components());
  var import_i18n53 = __toESM(require_i18n());
  var import_compose39 = __toESM(require_compose());

  // packages/block-editor/build-module/components/inserter/media-tab/media-list.js
  var import_jsx_runtime176 = __toESM(require_jsx_runtime());
  var import_components47 = __toESM(require_components());
  var import_i18n52 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/inserter/media-tab/media-preview.js
  var import_jsx_runtime175 = __toESM(require_jsx_runtime());
  var import_components46 = __toESM(require_components());
  var import_i18n51 = __toESM(require_i18n());
  var import_element66 = __toESM(require_element());
  var import_blocks32 = __toESM(require_blocks());
  var import_data51 = __toESM(require_data());
  var import_notices5 = __toESM(require_notices());
  var import_blob2 = __toESM(require_blob());
  var import_url4 = __toESM(require_url());

  // packages/block-editor/build-module/components/inserter/media-tab/utils.js
  var import_jsx_runtime174 = __toESM(require_jsx_runtime());
  var import_blocks31 = __toESM(require_blocks());
  var mediaTypeTag = { image: "img", video: "video", audio: "audio" };
  function getBlockAndPreviewFromMedia(media, mediaType) {
    const attributes = {
      id: media.id || void 0,
      caption: media.caption || void 0
    };
    const mediaSrc = media.url;
    const alt = media.alt || void 0;
    if (mediaType === "image") {
      attributes.url = mediaSrc;
      attributes.alt = alt;
    } else if (["video", "audio"].includes(mediaType)) {
      attributes.src = mediaSrc;
    }
    const PreviewTag = mediaTypeTag[mediaType];
    const preview = /* @__PURE__ */ (0, import_jsx_runtime174.jsx)(
      PreviewTag,
      {
        src: media.previewUrl || mediaSrc,
        alt,
        controls: mediaType === "audio" ? true : void 0,
        inert: "true",
        onError: ({ currentTarget }) => {
          if (currentTarget.src === media.previewUrl) {
            currentTarget.src = mediaSrc;
          }
        }
      }
    );
    return [(0, import_blocks31.createBlock)(`core/${mediaType}`, attributes), preview];
  }

  // packages/block-editor/build-module/components/inserter/media-tab/media-preview.js
  var ALLOWED_MEDIA_TYPES = ["image"];
  var MEDIA_OPTIONS_POPOVER_PROPS = {
    placement: "bottom-end",
    className: "block-editor-inserter__media-list__item-preview-options__popover"
  };
  function MediaPreviewOptions({ category, media }) {
    if (!category.getReportUrl) {
      return null;
    }
    const reportUrl = category.getReportUrl(media);
    return /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
      import_components46.DropdownMenu,
      {
        className: "block-editor-inserter__media-list__item-preview-options",
        label: (0, import_i18n51.__)("Options"),
        popoverProps: MEDIA_OPTIONS_POPOVER_PROPS,
        icon: more_vertical_default,
        children: () => /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(import_components46.MenuGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
          import_components46.MenuItem,
          {
            onClick: () => window.open(reportUrl, "_blank").focus(),
            icon: external_default,
            children: (0, import_i18n51.sprintf)(
              /* translators: %s: The media type to report e.g: "image", "video", "audio" */
              (0, import_i18n51.__)("Report %s"),
              category.mediaType
            )
          }
        ) })
      }
    );
  }
  function InsertExternalImageModal({ onClose, onSubmit }) {
    return /* @__PURE__ */ (0, import_jsx_runtime175.jsxs)(
      import_components46.Modal,
      {
        title: (0, import_i18n51.__)("Insert external image"),
        onRequestClose: onClose,
        className: "block-editor-inserter-media-tab-media-preview-inserter-external-image-modal",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime175.jsxs)(import_components46.__experimentalVStack, { spacing: 3, children: [
            /* @__PURE__ */ (0, import_jsx_runtime175.jsx)("p", { children: (0, import_i18n51.__)(
              "This image cannot be uploaded to your Media Library, but it can still be inserted as an external image."
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime175.jsx)("p", { children: (0, import_i18n51.__)(
              "External images can be removed by the external provider without warning and could even have legal compliance issues related to privacy legislation."
            ) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime175.jsxs)(
            import_components46.Flex,
            {
              className: "block-editor-block-lock-modal__actions",
              justify: "flex-end",
              expanded: false,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(import_components46.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
                  import_components46.Button,
                  {
                    __next40pxDefaultSize: true,
                    variant: "tertiary",
                    onClick: onClose,
                    children: (0, import_i18n51.__)("Cancel")
                  }
                ) }),
                /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(import_components46.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
                  import_components46.Button,
                  {
                    __next40pxDefaultSize: true,
                    variant: "primary",
                    onClick: onSubmit,
                    children: (0, import_i18n51.__)("Insert")
                  }
                ) })
              ]
            }
          )
        ]
      }
    );
  }
  function MediaPreview({ media, onClick, category }) {
    const [showExternalUploadModal, setShowExternalUploadModal] = (0, import_element66.useState)(false);
    const [isHovered, setIsHovered] = (0, import_element66.useState)(false);
    const [isInserting, setIsInserting] = (0, import_element66.useState)(false);
    const [block, preview] = (0, import_element66.useMemo)(
      () => getBlockAndPreviewFromMedia(media, category.mediaType),
      [media, category.mediaType]
    );
    const { createErrorNotice, createSuccessNotice } = (0, import_data51.useDispatch)(import_notices5.store);
    const { getSettings: getSettings4, getBlock: getBlock2 } = (0, import_data51.useSelect)(store);
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data51.useDispatch)(store);
    const onMediaInsert = (0, import_element66.useCallback)(
      (previewBlock) => {
        if (isInserting) {
          return;
        }
        const settings2 = getSettings4();
        const clonedBlock = (0, import_blocks32.cloneBlock)(previewBlock);
        const { id, url, caption } = clonedBlock.attributes;
        if (!id && !settings2.mediaUpload) {
          setShowExternalUploadModal(true);
          return;
        }
        if (!!id) {
          onClick(clonedBlock);
          return;
        }
        setIsInserting(true);
        window.fetch(url).then((response) => response.blob()).then((blob) => {
          const fileName = (0, import_url4.getFilename)(url) || "image.jpg";
          const file = new File([blob], fileName, {
            type: blob.type
          });
          settings2.mediaUpload({
            filesList: [file],
            additionalData: { caption },
            onFileChange([img]) {
              if ((0, import_blob2.isBlobURL)(img.url)) {
                return;
              }
              if (!getBlock2(clonedBlock.clientId)) {
                onClick({
                  ...clonedBlock,
                  attributes: {
                    ...clonedBlock.attributes,
                    id: img.id,
                    url: img.url
                  }
                });
                createSuccessNotice(
                  (0, import_i18n51.__)("Image uploaded and inserted."),
                  { type: "snackbar", id: "inserter-notice" }
                );
              } else {
                updateBlockAttributes2(clonedBlock.clientId, {
                  ...clonedBlock.attributes,
                  id: img.id,
                  url: img.url
                });
              }
              setIsInserting(false);
            },
            allowedTypes: ALLOWED_MEDIA_TYPES,
            onError(message) {
              createErrorNotice(message, {
                type: "snackbar",
                id: "inserter-notice"
              });
              setIsInserting(false);
            }
          });
        }).catch(() => {
          setShowExternalUploadModal(true);
          setIsInserting(false);
        });
      },
      [
        isInserting,
        getSettings4,
        onClick,
        createSuccessNotice,
        updateBlockAttributes2,
        createErrorNotice,
        getBlock2
      ]
    );
    const title = typeof media.title === "string" ? media.title : media.title?.rendered || (0, import_i18n51.__)("no title");
    const onMouseEnter = (0, import_element66.useCallback)(() => setIsHovered(true), []);
    const onMouseLeave = (0, import_element66.useCallback)(() => setIsHovered(false), []);
    return /* @__PURE__ */ (0, import_jsx_runtime175.jsxs)(import_jsx_runtime175.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(inserter_draggable_blocks_default, { isEnabled: true, blocks: [block], children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
        "div",
        {
          className: clsx_default(
            "block-editor-inserter__media-list__list-item",
            {
              "is-hovered": isHovered
            }
          ),
          draggable,
          onDragStart,
          onDragEnd,
          children: /* @__PURE__ */ (0, import_jsx_runtime175.jsxs)(
            "div",
            {
              onMouseEnter,
              onMouseLeave,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(import_components46.Tooltip, { text: title, children: /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
                  import_components46.Composite.Item,
                  {
                    render: /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
                      "div",
                      {
                        "aria-label": title,
                        role: "option",
                        className: "block-editor-inserter__media-list__item"
                      }
                    ),
                    onClick: () => onMediaInsert(block),
                    children: /* @__PURE__ */ (0, import_jsx_runtime175.jsxs)("div", { className: "block-editor-inserter__media-list__item-preview", children: [
                      preview,
                      isInserting && /* @__PURE__ */ (0, import_jsx_runtime175.jsx)("div", { className: "block-editor-inserter__media-list__item-preview-spinner", children: /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(import_components46.Spinner, {}) })
                    ] })
                  }
                ) }),
                !isInserting && /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
                  MediaPreviewOptions,
                  {
                    category,
                    media
                  }
                )
              ]
            }
          )
        }
      ) }),
      showExternalUploadModal && /* @__PURE__ */ (0, import_jsx_runtime175.jsx)(
        InsertExternalImageModal,
        {
          onClose: () => setShowExternalUploadModal(false),
          onSubmit: () => {
            onClick((0, import_blocks32.cloneBlock)(block));
            createSuccessNotice((0, import_i18n51.__)("Image inserted."), {
              type: "snackbar",
              id: "inserter-notice"
            });
            setShowExternalUploadModal(false);
          }
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/inserter/media-tab/media-list.js
  function MediaList({
    mediaList,
    category,
    onClick,
    label = (0, import_i18n52.__)("Media List")
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime176.jsx)(
      import_components47.Composite,
      {
        role: "listbox",
        className: "block-editor-inserter__media-list",
        "aria-label": label,
        children: mediaList.map((media, index) => /* @__PURE__ */ (0, import_jsx_runtime176.jsx)(
          MediaPreview,
          {
            media,
            category,
            onClick
          },
          media.id || media.sourceId || index
        ))
      }
    );
  }
  var media_list_default = MediaList;

  // packages/block-editor/build-module/components/inserter/media-tab/hooks.js
  var import_element67 = __toESM(require_element());
  var import_data52 = __toESM(require_data());
  function useMediaResults(category, query = {}) {
    const [mediaList, setMediaList] = (0, import_element67.useState)();
    const [isLoading, setIsLoading] = (0, import_element67.useState)(false);
    const lastRequestRef = (0, import_element67.useRef)();
    (0, import_element67.useEffect)(() => {
      (async () => {
        const key = JSON.stringify({
          category: category.name,
          ...query
        });
        lastRequestRef.current = key;
        setIsLoading(true);
        setMediaList([]);
        const _media = await category.fetch?.(query);
        if (key === lastRequestRef.current) {
          setMediaList(_media);
          setIsLoading(false);
        }
      })();
    }, [category.name, ...Object.values(query)]);
    return { mediaList, isLoading };
  }
  function useMediaCategories(rootClientId) {
    const [categories, setCategories] = (0, import_element67.useState)([]);
    const inserterMediaCategories = (0, import_data52.useSelect)(
      (select2) => unlock(select2(store)).getInserterMediaCategories(),
      []
    );
    const { canInsertImage, canInsertVideo, canInsertAudio } = (0, import_data52.useSelect)(
      (select2) => {
        const { canInsertBlockType: canInsertBlockType2 } = select2(store);
        return {
          canInsertImage: canInsertBlockType2(
            "core/image",
            rootClientId
          ),
          canInsertVideo: canInsertBlockType2(
            "core/video",
            rootClientId
          ),
          canInsertAudio: canInsertBlockType2(
            "core/audio",
            rootClientId
          )
        };
      },
      [rootClientId]
    );
    (0, import_element67.useEffect)(() => {
      (async () => {
        const _categories = [];
        if (!inserterMediaCategories) {
          return;
        }
        const categoriesHaveMedia = new Map(
          await Promise.all(
            inserterMediaCategories.map(async (category) => {
              if (category.isExternalResource) {
                return [category.name, true];
              }
              let results = [];
              try {
                results = await category.fetch({
                  per_page: 1
                });
              } catch (e2) {
              }
              return [category.name, !!results.length];
            })
          )
        );
        const canInsertMediaType = {
          image: canInsertImage,
          video: canInsertVideo,
          audio: canInsertAudio
        };
        inserterMediaCategories.forEach((category) => {
          if (canInsertMediaType[category.mediaType] && categoriesHaveMedia.get(category.name)) {
            _categories.push(category);
          }
        });
        if (!!_categories.length) {
          setCategories(_categories);
        }
      })();
    }, [
      canInsertImage,
      canInsertVideo,
      canInsertAudio,
      inserterMediaCategories
    ]);
    return categories;
  }

  // packages/block-editor/build-module/components/inserter/media-tab/media-panel.js
  var INITIAL_MEDIA_ITEMS_PER_PAGE = 10;
  function MediaCategoryPanel({ rootClientId, onInsert, category }) {
    const [search, setSearch, debouncedSearch] = (0, import_compose39.useDebouncedInput)();
    const { mediaList, isLoading } = useMediaResults(category, {
      per_page: !!debouncedSearch ? 20 : INITIAL_MEDIA_ITEMS_PER_PAGE,
      search: debouncedSearch
    });
    const baseCssClass = "block-editor-inserter__media-panel";
    const searchLabel = category.labels.search_items || (0, import_i18n53.__)("Search");
    return /* @__PURE__ */ (0, import_jsx_runtime177.jsxs)("div", { className: baseCssClass, children: [
      /* @__PURE__ */ (0, import_jsx_runtime177.jsx)(
        import_components48.SearchControl,
        {
          __nextHasNoMarginBottom: true,
          className: `${baseCssClass}-search`,
          onChange: setSearch,
          value: search,
          label: searchLabel,
          placeholder: searchLabel
        }
      ),
      isLoading && /* @__PURE__ */ (0, import_jsx_runtime177.jsx)("div", { className: `${baseCssClass}-spinner`, children: /* @__PURE__ */ (0, import_jsx_runtime177.jsx)(import_components48.Spinner, {}) }),
      !isLoading && !mediaList?.length && /* @__PURE__ */ (0, import_jsx_runtime177.jsx)(no_results_default, {}),
      !isLoading && !!mediaList?.length && /* @__PURE__ */ (0, import_jsx_runtime177.jsx)(
        media_list_default,
        {
          rootClientId,
          onClick: onInsert,
          mediaList,
          category
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/media-upload/check.js
  var import_data53 = __toESM(require_data());
  function MediaUploadCheck({ fallback = null, children }) {
    const hasUploadPermissions = (0, import_data53.useSelect)((select2) => {
      const { getSettings: getSettings4 } = select2(store);
      return !!getSettings4().mediaUpload;
    }, []);
    return hasUploadPermissions ? children : fallback;
  }
  var check_default2 = MediaUploadCheck;

  // packages/block-editor/build-module/components/media-upload/index.js
  var import_components49 = __toESM(require_components());
  var MediaUpload = () => null;
  var media_upload_default = (0, import_components49.withFilters)("editor.MediaUpload")(MediaUpload);

  // packages/block-editor/build-module/components/inserter/media-tab/media-tab.js
  var ALLOWED_MEDIA_TYPES2 = ["image", "video", "audio"];
  function MediaTab({
    rootClientId,
    selectedCategory,
    onSelectCategory,
    onInsert,
    children
  }) {
    const mediaCategories = useMediaCategories(rootClientId);
    const isMobile = (0, import_compose40.useViewportMatch)("medium", "<");
    const baseCssClass = "block-editor-inserter__media-tabs";
    const onSelectMedia = (0, import_element68.useCallback)(
      (media) => {
        if (!media?.url) {
          return;
        }
        const [block] = getBlockAndPreviewFromMedia(media, media.type);
        onInsert(block);
      },
      [onInsert]
    );
    const categories = (0, import_element68.useMemo)(
      () => mediaCategories.map((mediaCategory) => ({
        ...mediaCategory,
        label: mediaCategory.labels.name
      })),
      [mediaCategories]
    );
    if (!categories.length) {
      return /* @__PURE__ */ (0, import_jsx_runtime178.jsx)(no_results_default, {});
    }
    return /* @__PURE__ */ (0, import_jsx_runtime178.jsxs)(import_jsx_runtime178.Fragment, { children: [
      !isMobile && /* @__PURE__ */ (0, import_jsx_runtime178.jsxs)("div", { className: `${baseCssClass}-container`, children: [
        /* @__PURE__ */ (0, import_jsx_runtime178.jsx)(
          category_tabs_default,
          {
            categories,
            selectedCategory,
            onSelectCategory,
            children
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime178.jsx)(check_default2, { children: /* @__PURE__ */ (0, import_jsx_runtime178.jsx)(
          media_upload_default,
          {
            multiple: false,
            onSelect: onSelectMedia,
            allowedTypes: ALLOWED_MEDIA_TYPES2,
            render: ({ open }) => /* @__PURE__ */ (0, import_jsx_runtime178.jsx)(
              import_components50.Button,
              {
                __next40pxDefaultSize: true,
                onClick: (event) => {
                  event.target.focus();
                  open();
                },
                className: "block-editor-inserter__media-library-button",
                variant: "secondary",
                "data-unstable-ignore-focus-outside-for-relatedtarget": ".media-modal",
                children: (0, import_i18n54.__)("Open Media Library")
              }
            )
          }
        ) })
      ] }),
      isMobile && /* @__PURE__ */ (0, import_jsx_runtime178.jsx)(MobileTabNavigation, { categories, children: (category) => /* @__PURE__ */ (0, import_jsx_runtime178.jsx)(
        MediaCategoryPanel,
        {
          onInsert,
          rootClientId,
          category
        }
      ) })
    ] });
  }
  var media_tab_default = MediaTab;

  // packages/block-editor/build-module/components/inserter/search-results.js
  var import_jsx_runtime179 = __toESM(require_jsx_runtime());
  var import_element69 = __toESM(require_element());
  var import_i18n55 = __toESM(require_i18n());
  var import_components52 = __toESM(require_components());
  var import_compose41 = __toESM(require_compose());
  var import_a11y9 = __toESM(require_a11y());
  var import_data54 = __toESM(require_data());

  // packages/block-editor/build-module/components/inserter-menu-extension/index.js
  var import_components51 = __toESM(require_components());
  var { Fill: __unstableInserterMenuExtension, Slot } = (0, import_components51.createSlotFill)(
    "__unstableInserterMenuExtension"
  );
  __unstableInserterMenuExtension.Slot = Slot;
  var inserter_menu_extension_default = __unstableInserterMenuExtension;

  // packages/block-editor/build-module/components/inserter/search-results.js
  var INITIAL_INSERTER_RESULTS = 9;
  var EMPTY_ARRAY6 = [];
  function InserterSearchResults({
    filterValue,
    onSelect,
    onHover,
    onHoverPattern,
    rootClientId,
    clientId,
    isAppender,
    __experimentalInsertionIndex,
    maxBlockPatterns,
    maxBlockTypes,
    showBlockDirectory = false,
    isDraggable = true,
    shouldFocusBlock = true,
    prioritizePatterns,
    selectBlockOnInsert,
    isQuick
  }) {
    const debouncedSpeak = (0, import_compose41.useDebounce)(import_a11y9.speak, 500);
    const { prioritizedBlocks } = (0, import_data54.useSelect)(
      (select2) => {
        const blockListSettings2 = select2(store).getBlockListSettings(rootClientId);
        return {
          prioritizedBlocks: blockListSettings2?.prioritizedInserterBlocks || EMPTY_ARRAY6
        };
      },
      [rootClientId]
    );
    const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
      onSelect,
      rootClientId,
      clientId,
      isAppender,
      insertionIndex: __experimentalInsertionIndex,
      shouldFocusBlock,
      selectBlockOnInsert
    });
    const [
      blockTypes,
      blockTypeCategories,
      blockTypeCollections,
      onSelectBlockType
    ] = use_block_types_state_default(destinationRootClientId, onInsertBlocks, isQuick);
    const [patterns, , onClickPattern] = use_patterns_state_default(
      onInsertBlocks,
      destinationRootClientId,
      void 0,
      isQuick
    );
    const filteredBlockPatterns = (0, import_element69.useMemo)(() => {
      if (maxBlockPatterns === 0) {
        return [];
      }
      const results = searchItems(patterns, filterValue);
      return maxBlockPatterns !== void 0 ? results.slice(0, maxBlockPatterns) : results;
    }, [filterValue, patterns, maxBlockPatterns]);
    let maxBlockTypesToShow = maxBlockTypes;
    if (prioritizePatterns && filteredBlockPatterns.length > 2) {
      maxBlockTypesToShow = 0;
    }
    const filteredBlockTypes = (0, import_element69.useMemo)(() => {
      if (maxBlockTypesToShow === 0) {
        return [];
      }
      const nonPatternBlockTypes = blockTypes.filter(
        (blockType) => blockType.name !== "core/block"
      );
      let orderedItems = orderBy(nonPatternBlockTypes, "frecency", "desc");
      if (!filterValue && prioritizedBlocks.length) {
        orderedItems = orderInserterBlockItems(
          orderedItems,
          prioritizedBlocks
        );
      }
      const results = searchBlockItems(
        orderedItems,
        blockTypeCategories,
        blockTypeCollections,
        filterValue
      );
      return maxBlockTypesToShow !== void 0 ? results.slice(0, maxBlockTypesToShow) : results;
    }, [
      filterValue,
      blockTypes,
      blockTypeCategories,
      blockTypeCollections,
      maxBlockTypesToShow,
      prioritizedBlocks
    ]);
    (0, import_element69.useEffect)(() => {
      if (!filterValue) {
        return;
      }
      const count = filteredBlockTypes.length + filteredBlockPatterns.length;
      const resultsFoundMessage = (0, import_i18n55.sprintf)(
        /* translators: %d: number of results. */
        (0, import_i18n55._n)("%d result found.", "%d results found.", count),
        count
      );
      debouncedSpeak(resultsFoundMessage);
    }, [
      filterValue,
      debouncedSpeak,
      filteredBlockTypes,
      filteredBlockPatterns
    ]);
    const currentShownBlockTypes = (0, import_compose41.useAsyncList)(filteredBlockTypes, {
      step: INITIAL_INSERTER_RESULTS
    });
    const hasItems = filteredBlockTypes.length > 0 || filteredBlockPatterns.length > 0;
    const blocksUI = !!filteredBlockTypes.length && /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(
      panel_default,
      {
        title: /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(import_components52.VisuallyHidden, { children: (0, import_i18n55.__)("Blocks") }),
        children: /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(
          block_types_list_default,
          {
            items: currentShownBlockTypes,
            onSelect: onSelectBlockType,
            onHover,
            label: (0, import_i18n55.__)("Blocks"),
            isDraggable
          }
        )
      }
    );
    const patternsUI = !!filteredBlockPatterns.length && /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(
      panel_default,
      {
        title: /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(import_components52.VisuallyHidden, { children: (0, import_i18n55.__)("Block patterns") }),
        children: /* @__PURE__ */ (0, import_jsx_runtime179.jsx)("div", { className: "block-editor-inserter__quick-inserter-patterns", children: /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(
          block_patterns_list_default,
          {
            blockPatterns: filteredBlockPatterns,
            onClickPattern,
            onHover: onHoverPattern,
            isDraggable
          }
        ) })
      }
    );
    return /* @__PURE__ */ (0, import_jsx_runtime179.jsxs)(inserter_listbox_default, { children: [
      !showBlockDirectory && !hasItems && /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(no_results_default, {}),
      prioritizePatterns ? patternsUI : blocksUI,
      !!filteredBlockTypes.length && !!filteredBlockPatterns.length && /* @__PURE__ */ (0, import_jsx_runtime179.jsx)("div", { className: "block-editor-inserter__quick-inserter-separator" }),
      prioritizePatterns ? blocksUI : patternsUI,
      showBlockDirectory && /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(
        inserter_menu_extension_default.Slot,
        {
          fillProps: {
            onSelect: onSelectBlockType,
            onHover,
            filterValue,
            hasItems,
            rootClientId: destinationRootClientId
          },
          children: (fills) => {
            if (fills.length) {
              return fills;
            }
            if (!hasItems) {
              return /* @__PURE__ */ (0, import_jsx_runtime179.jsx)(no_results_default, {});
            }
            return null;
          }
        }
      )
    ] });
  }
  var search_results_default = InserterSearchResults;

  // packages/block-editor/build-module/components/tabbed-sidebar/index.js
  var import_jsx_runtime180 = __toESM(require_jsx_runtime());
  var import_components53 = __toESM(require_components());
  var import_element70 = __toESM(require_element());
  var { Tabs: Tabs2 } = unlock(import_components53.privateApis);
  function TabbedSidebar({ defaultTabId, onClose, onSelect, selectedTab, tabs, closeButtonLabel }, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime180.jsx)("div", { className: "block-editor-tabbed-sidebar", children: /* @__PURE__ */ (0, import_jsx_runtime180.jsxs)(
      Tabs2,
      {
        selectOnMove: false,
        defaultTabId,
        onSelect,
        selectedTabId: selectedTab,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime180.jsxs)("div", { className: "block-editor-tabbed-sidebar__tablist-and-close-button", children: [
            /* @__PURE__ */ (0, import_jsx_runtime180.jsx)(
              import_components53.Button,
              {
                className: "block-editor-tabbed-sidebar__close-button",
                icon: close_small_default,
                label: closeButtonLabel,
                onClick: () => onClose(),
                size: "compact"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime180.jsx)(
              Tabs2.TabList,
              {
                className: "block-editor-tabbed-sidebar__tablist",
                ref,
                children: tabs.map((tab) => /* @__PURE__ */ (0, import_jsx_runtime180.jsx)(
                  Tabs2.Tab,
                  {
                    tabId: tab.name,
                    className: "block-editor-tabbed-sidebar__tab",
                    children: tab.title
                  },
                  tab.name
                ))
              }
            )
          ] }),
          tabs.map((tab) => /* @__PURE__ */ (0, import_jsx_runtime180.jsx)(
            Tabs2.TabPanel,
            {
              tabId: tab.name,
              focusable: false,
              className: "block-editor-tabbed-sidebar__tabpanel",
              ref: tab.panelRef,
              children: tab.panel
            },
            tab.name
          ))
        ]
      }
    ) });
  }
  var tabbed_sidebar_default = (0, import_element70.forwardRef)(TabbedSidebar);

  // packages/block-editor/build-module/hooks/use-zoom-out.js
  var import_data55 = __toESM(require_data());
  var import_element71 = __toESM(require_element());
  function useZoomOut(enabled = true) {
    const { setZoomLevel: setZoomLevel2, resetZoomLevel: resetZoomLevel2 } = unlock(
      (0, import_data55.useDispatch)(store)
    );
    const { isZoomedOut, isZoomOut: isZoomOut2 } = (0, import_data55.useSelect)((select2) => {
      const { isZoomOut: _isZoomOut } = unlock(select2(store));
      return {
        isZoomedOut: _isZoomOut(),
        isZoomOut: _isZoomOut
      };
    }, []);
    const controlZoomLevelRef = (0, import_element71.useRef)(false);
    const isEnabledRef = (0, import_element71.useRef)(enabled);
    (0, import_element71.useEffect)(() => {
      if (isZoomedOut !== isEnabledRef.current) {
        controlZoomLevelRef.current = false;
      }
    }, [isZoomedOut]);
    (0, import_element71.useEffect)(() => {
      isEnabledRef.current = enabled;
      if (enabled !== isZoomOut2()) {
        controlZoomLevelRef.current = true;
        if (enabled) {
          setZoomLevel2("auto-scaled");
        } else {
          resetZoomLevel2();
        }
      }
      return () => {
        if (controlZoomLevelRef.current && isZoomOut2()) {
          resetZoomLevel2();
        }
      };
    }, [enabled, isZoomOut2, resetZoomLevel2, setZoomLevel2]);
  }

  // packages/block-editor/build-module/components/inserter/menu.js
  var NOOP = () => {
  };
  function InserterMenu({
    rootClientId,
    clientId,
    isAppender,
    __experimentalInsertionIndex,
    onSelect,
    showInserterHelpPanel,
    showMostUsedBlocks,
    __experimentalFilterValue = "",
    shouldFocusBlock = true,
    onPatternCategorySelection,
    onClose,
    __experimentalInitialTab,
    __experimentalInitialCategory
  }, ref) {
    const { isZoomOutMode, hasSectionRootClientId } = (0, import_data56.useSelect)((select2) => {
      const { isZoomOut: isZoomOut2, getSectionRootClientId: getSectionRootClientId2 } = unlock(
        select2(store)
      );
      return {
        isZoomOutMode: isZoomOut2(),
        hasSectionRootClientId: !!getSectionRootClientId2()
      };
    }, []);
    const [filterValue, setFilterValue, delayedFilterValue] = (0, import_compose42.useDebouncedInput)(__experimentalFilterValue);
    const [hoveredItem, setHoveredItem] = (0, import_element72.useState)(null);
    const [selectedPatternCategory, setSelectedPatternCategory] = (0, import_element72.useState)(
      __experimentalInitialCategory
    );
    const [patternFilter, setPatternFilter] = (0, import_element72.useState)("all");
    const [selectedMediaCategory, setSelectedMediaCategory] = (0, import_element72.useState)(null);
    const isLargeViewport = (0, import_compose42.useViewportMatch)("large");
    function getInitialTab() {
      if (__experimentalInitialTab) {
        return __experimentalInitialTab;
      }
      if (isZoomOutMode) {
        return "patterns";
      }
      return "blocks";
    }
    const [selectedTab, setSelectedTab] = (0, import_element72.useState)(getInitialTab());
    const shouldUseZoomOut = hasSectionRootClientId && (selectedTab === "patterns" || selectedTab === "media");
    useZoomOut(shouldUseZoomOut && isLargeViewport);
    const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = use_insertion_point_default({
      rootClientId,
      clientId,
      isAppender,
      insertionIndex: __experimentalInsertionIndex,
      shouldFocusBlock
    });
    const blockTypesTabRef = (0, import_element72.useRef)();
    const onInsert = (0, import_element72.useCallback)(
      (blocks2, meta, shouldForceFocusBlock, _rootClientId) => {
        onInsertBlocks(
          blocks2,
          meta,
          shouldForceFocusBlock,
          _rootClientId
        );
        onSelect(blocks2);
        window.requestAnimationFrame(() => {
          if (!shouldFocusBlock && !blockTypesTabRef.current?.contains(
            ref.current.ownerDocument.activeElement
          )) {
            blockTypesTabRef.current?.querySelector("button").focus();
          }
        });
      },
      [onInsertBlocks, onSelect, shouldFocusBlock]
    );
    const onInsertPattern = (0, import_element72.useCallback)(
      (blocks2, patternName, ...args) => {
        onToggleInsertionPoint(false);
        onInsertBlocks(blocks2, { patternName }, ...args);
        onSelect();
      },
      [onInsertBlocks, onSelect]
    );
    const onHover = (0, import_element72.useCallback)(
      (item) => {
        onToggleInsertionPoint(item);
        setHoveredItem(item);
      },
      [onToggleInsertionPoint, setHoveredItem]
    );
    const onClickPatternCategory = (0, import_element72.useCallback)(
      (patternCategory, filter) => {
        setSelectedPatternCategory(patternCategory);
        setPatternFilter(filter);
        onPatternCategorySelection?.();
      },
      [setSelectedPatternCategory, onPatternCategorySelection]
    );
    const showPatternPanel = selectedTab === "patterns" && !delayedFilterValue && !!selectedPatternCategory;
    const showMediaPanel = selectedTab === "media" && !!selectedMediaCategory;
    const inserterSearch = (0, import_element72.useMemo)(() => {
      if (selectedTab === "media") {
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime181.jsxs)(import_jsx_runtime181.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
          import_components54.SearchControl,
          {
            __nextHasNoMarginBottom: true,
            className: "block-editor-inserter__search",
            onChange: (value) => {
              if (hoveredItem) {
                setHoveredItem(null);
              }
              setFilterValue(value);
            },
            value: filterValue,
            label: (0, import_i18n56.__)("Search"),
            placeholder: (0, import_i18n56.__)("Search")
          }
        ),
        !!delayedFilterValue && /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
          search_results_default,
          {
            filterValue: delayedFilterValue,
            onSelect,
            onHover,
            rootClientId,
            clientId,
            isAppender,
            __experimentalInsertionIndex,
            showBlockDirectory: true,
            shouldFocusBlock,
            prioritizePatterns: selectedTab === "patterns"
          }
        )
      ] });
    }, [
      selectedTab,
      hoveredItem,
      setHoveredItem,
      setFilterValue,
      filterValue,
      delayedFilterValue,
      onSelect,
      onHover,
      shouldFocusBlock,
      clientId,
      rootClientId,
      __experimentalInsertionIndex,
      isAppender
    ]);
    const blocksTab = (0, import_element72.useMemo)(() => {
      return /* @__PURE__ */ (0, import_jsx_runtime181.jsxs)(import_jsx_runtime181.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime181.jsx)("div", { className: "block-editor-inserter__block-list", children: /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
          block_types_tab_default,
          {
            ref: blockTypesTabRef,
            rootClientId: destinationRootClientId,
            onInsert,
            onHover,
            showMostUsedBlocks
          }
        ) }),
        showInserterHelpPanel && /* @__PURE__ */ (0, import_jsx_runtime181.jsxs)("div", { className: "block-editor-inserter__tips", children: [
          /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(import_components54.VisuallyHidden, { as: "h2", children: (0, import_i18n56.__)("A tip for using the block editor") }),
          /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(tips_default, {})
        ] })
      ] });
    }, [
      destinationRootClientId,
      onInsert,
      onHover,
      showMostUsedBlocks,
      showInserterHelpPanel
    ]);
    const patternsTab = (0, import_element72.useMemo)(() => {
      return /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
        block_patterns_tab_default,
        {
          rootClientId: destinationRootClientId,
          onInsert: onInsertPattern,
          onSelectCategory: onClickPatternCategory,
          selectedCategory: selectedPatternCategory,
          children: showPatternPanel && /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
            PatternCategoryPreviews,
            {
              rootClientId: destinationRootClientId,
              onInsert: onInsertPattern,
              category: selectedPatternCategory,
              patternFilter,
              showTitlesAsTooltip: true
            }
          )
        }
      );
    }, [
      destinationRootClientId,
      onInsertPattern,
      onClickPatternCategory,
      patternFilter,
      selectedPatternCategory,
      showPatternPanel
    ]);
    const mediaTab = (0, import_element72.useMemo)(() => {
      return /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
        media_tab_default,
        {
          rootClientId: destinationRootClientId,
          selectedCategory: selectedMediaCategory,
          onSelectCategory: setSelectedMediaCategory,
          onInsert,
          children: showMediaPanel && /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
            MediaCategoryPanel,
            {
              rootClientId: destinationRootClientId,
              onInsert,
              category: selectedMediaCategory
            }
          )
        }
      );
    }, [
      destinationRootClientId,
      onInsert,
      selectedMediaCategory,
      setSelectedMediaCategory,
      showMediaPanel
    ]);
    const handleSetSelectedTab = (value) => {
      if (value !== "patterns") {
        setSelectedPatternCategory(null);
      }
      setSelectedTab(value);
    };
    const tabsRef = (0, import_element72.useRef)();
    (0, import_element72.useLayoutEffect)(() => {
      if (tabsRef.current) {
        window.requestAnimationFrame(() => {
          tabsRef.current.querySelector('[role="tab"][aria-selected="true"]')?.focus();
        });
      }
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime181.jsxs)(
      "div",
      {
        className: clsx_default("block-editor-inserter__menu", {
          "show-panel": showPatternPanel || showMediaPanel,
          "is-zoom-out": isZoomOutMode
        }),
        ref,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime181.jsx)("div", { className: "block-editor-inserter__main-area", children: /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
            tabbed_sidebar_default,
            {
              ref: tabsRef,
              onSelect: handleSetSelectedTab,
              onClose,
              selectedTab,
              closeButtonLabel: (0, import_i18n56.__)("Close Block Inserter"),
              tabs: [
                {
                  name: "blocks",
                  title: (0, import_i18n56.__)("Blocks"),
                  panel: /* @__PURE__ */ (0, import_jsx_runtime181.jsxs)(import_jsx_runtime181.Fragment, { children: [
                    inserterSearch,
                    selectedTab === "blocks" && !delayedFilterValue && blocksTab
                  ] })
                },
                {
                  name: "patterns",
                  title: (0, import_i18n56.__)("Patterns"),
                  panel: /* @__PURE__ */ (0, import_jsx_runtime181.jsxs)(import_jsx_runtime181.Fragment, { children: [
                    inserterSearch,
                    selectedTab === "patterns" && !delayedFilterValue && patternsTab
                  ] })
                },
                {
                  name: "media",
                  title: (0, import_i18n56.__)("Media"),
                  panel: /* @__PURE__ */ (0, import_jsx_runtime181.jsxs)(import_jsx_runtime181.Fragment, { children: [
                    inserterSearch,
                    mediaTab
                  ] })
                }
              ]
            }
          ) }),
          showInserterHelpPanel && hoveredItem && /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
            import_components54.Popover,
            {
              className: "block-editor-inserter__preview-container__popover",
              placement: "right-start",
              offset: 16,
              focusOnMount: false,
              animate: false,
              children: /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(preview_panel_default, { item: hoveredItem })
            }
          )
        ]
      }
    );
  }
  var PrivateInserterMenu = (0, import_element72.forwardRef)(InserterMenu);
  function PublicInserterMenu(props, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime181.jsx)(
      PrivateInserterMenu,
      {
        ...props,
        onPatternCategorySelection: NOOP,
        ref
      }
    );
  }
  var menu_default = (0, import_element72.forwardRef)(PublicInserterMenu);

  // packages/block-editor/build-module/components/inserter/quick-inserter.js
  var import_jsx_runtime182 = __toESM(require_jsx_runtime());
  var import_element73 = __toESM(require_element());
  var import_i18n57 = __toESM(require_i18n());
  var import_components55 = __toESM(require_components());
  var import_data57 = __toESM(require_data());
  var SEARCH_THRESHOLD = 6;
  var SHOWN_BLOCK_TYPES2 = 6;
  var SHOWN_BLOCK_PATTERNS = 2;
  function QuickInserter({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    selectBlockOnInsert,
    hasSearch = true
  }) {
    const [filterValue, setFilterValue] = (0, import_element73.useState)("");
    const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
      onSelect,
      rootClientId,
      clientId,
      isAppender,
      selectBlockOnInsert
    });
    const [blockTypes] = use_block_types_state_default(
      destinationRootClientId,
      onInsertBlocks,
      true
    );
    const { setInserterIsOpened, insertionIndex } = (0, import_data57.useSelect)(
      (select2) => {
        const { getSettings: getSettings4, getBlockIndex: getBlockIndex2, getBlockCount: getBlockCount2 } = select2(store);
        const settings2 = getSettings4();
        const index = getBlockIndex2(clientId);
        const blockCount = getBlockCount2();
        return {
          setInserterIsOpened: settings2.__experimentalSetIsInserterOpened,
          insertionIndex: index === -1 ? blockCount : index
        };
      },
      [clientId]
    );
    const showSearch = hasSearch && blockTypes.length > SEARCH_THRESHOLD;
    (0, import_element73.useEffect)(() => {
      if (setInserterIsOpened) {
        setInserterIsOpened(false);
      }
    }, [setInserterIsOpened]);
    const onBrowseAll = () => {
      setInserterIsOpened({
        filterValue,
        onSelect,
        rootClientId,
        insertionIndex
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime182.jsxs)(
      "div",
      {
        className: clsx_default("block-editor-inserter__quick-inserter", {
          "has-search": showSearch,
          "has-expand": setInserterIsOpened
        }),
        children: [
          showSearch && /* @__PURE__ */ (0, import_jsx_runtime182.jsx)(
            import_components55.SearchControl,
            {
              __nextHasNoMarginBottom: true,
              className: "block-editor-inserter__search",
              value: filterValue,
              onChange: (value) => {
                setFilterValue(value);
              },
              label: (0, import_i18n57.__)("Search"),
              placeholder: (0, import_i18n57.__)("Search")
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime182.jsx)("div", { className: "block-editor-inserter__quick-inserter-results", children: /* @__PURE__ */ (0, import_jsx_runtime182.jsx)(
            search_results_default,
            {
              filterValue,
              onSelect,
              rootClientId,
              clientId,
              isAppender,
              maxBlockPatterns: !!filterValue ? SHOWN_BLOCK_PATTERNS : 0,
              maxBlockTypes: SHOWN_BLOCK_TYPES2,
              isDraggable: false,
              selectBlockOnInsert,
              isQuick: true
            }
          ) }),
          setInserterIsOpened && /* @__PURE__ */ (0, import_jsx_runtime182.jsx)(
            import_components55.Button,
            {
              __next40pxDefaultSize: true,
              className: "block-editor-inserter__quick-inserter-expand",
              onClick: onBrowseAll,
              "aria-label": (0, import_i18n57.__)(
                "Browse all. This will open the main inserter panel in the editor toolbar."
              ),
              children: (0, import_i18n57.__)("Browse all")
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/inserter/index.js
  var defaultRenderToggle = ({
    onToggle,
    disabled,
    isOpen,
    blockTitle,
    hasSingleBlockType,
    toggleProps = {}
  }) => {
    const {
      as: Wrapper = import_components56.Button,
      label: labelProp,
      onClick,
      ...rest
    } = toggleProps;
    let label = labelProp;
    if (!label && hasSingleBlockType) {
      label = (0, import_i18n58.sprintf)(
        // translators: %s: the name of the block when there is only one
        (0, import_i18n58._x)("Add %s", "directly add the only allowed block"),
        blockTitle
      );
    } else if (!label) {
      label = (0, import_i18n58._x)("Add block", "Generic label for block inserter button");
    }
    function handleClick(event) {
      if (onToggle) {
        onToggle(event);
      }
      if (onClick) {
        onClick(event);
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime183.jsx)(
      Wrapper,
      {
        __next40pxDefaultSize: toggleProps.as ? void 0 : true,
        icon: plus_default,
        label,
        tooltipPosition: "bottom",
        onClick: handleClick,
        className: "block-editor-inserter__toggle",
        "aria-haspopup": !hasSingleBlockType ? "true" : false,
        "aria-expanded": !hasSingleBlockType ? isOpen : false,
        disabled,
        ...rest
      }
    );
  };
  var Inserter = class extends import_element74.Component {
    constructor() {
      super(...arguments);
      this.onToggle = this.onToggle.bind(this);
      this.renderToggle = this.renderToggle.bind(this);
      this.renderContent = this.renderContent.bind(this);
    }
    onToggle(isOpen) {
      const { onToggle } = this.props;
      if (onToggle) {
        onToggle(isOpen);
      }
    }
    /**
     * Render callback to display Dropdown toggle element.
     *
     * @param {Object}   options
     * @param {Function} options.onToggle Callback to invoke when toggle is
     *                                    pressed.
     * @param {boolean}  options.isOpen   Whether dropdown is currently open.
     *
     * @return {Element} Dropdown toggle element.
     */
    renderToggle({ onToggle, isOpen }) {
      const {
        disabled,
        blockTitle,
        hasSingleBlockType,
        directInsertBlock,
        toggleProps,
        hasItems,
        renderToggle: renderToggle3 = defaultRenderToggle
      } = this.props;
      return renderToggle3({
        onToggle,
        isOpen,
        disabled: disabled || !hasItems,
        blockTitle,
        hasSingleBlockType,
        directInsertBlock,
        toggleProps
      });
    }
    /**
     * Render callback to display Dropdown content element.
     *
     * @param {Object}   options
     * @param {Function} options.onClose Callback to invoke when dropdown is
     *                                   closed.
     *
     * @return {Element} Dropdown content element.
     */
    renderContent({ onClose }) {
      const {
        rootClientId,
        clientId,
        isAppender,
        showInserterHelpPanel,
        // This prop is experimental to give some time for the quick inserter to mature
        // Feel free to make them stable after a few releases.
        __experimentalIsQuick: isQuick,
        onSelectOrClose,
        selectBlockOnInsert
      } = this.props;
      if (isQuick) {
        return /* @__PURE__ */ (0, import_jsx_runtime183.jsx)(
          QuickInserter,
          {
            onSelect: (blocks2) => {
              const firstBlock = Array.isArray(blocks2) && blocks2?.length ? blocks2[0] : blocks2;
              if (onSelectOrClose && typeof onSelectOrClose === "function") {
                onSelectOrClose(firstBlock);
              }
              onClose();
            },
            rootClientId,
            clientId,
            isAppender,
            selectBlockOnInsert
          }
        );
      }
      return /* @__PURE__ */ (0, import_jsx_runtime183.jsx)(
        menu_default,
        {
          onSelect: () => {
            onClose();
          },
          rootClientId,
          clientId,
          isAppender,
          showInserterHelpPanel
        }
      );
    }
    render() {
      const {
        position: position2,
        hasSingleBlockType,
        directInsertBlock,
        insertOnlyAllowedBlock,
        __experimentalIsQuick: isQuick,
        onSelectOrClose
      } = this.props;
      if (hasSingleBlockType || directInsertBlock) {
        return this.renderToggle({ onToggle: insertOnlyAllowedBlock });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime183.jsx)(
        import_components56.Dropdown,
        {
          className: "block-editor-inserter",
          contentClassName: clsx_default("block-editor-inserter__popover", {
            "is-quick": isQuick
          }),
          popoverProps: { position: position2, shift: true },
          onToggle: this.onToggle,
          expandOnMobile: true,
          headerTitle: (0, import_i18n58.__)("Add a block"),
          renderToggle: this.renderToggle,
          renderContent: this.renderContent,
          onClose: onSelectOrClose
        }
      );
    }
  };
  var inserter_default = (0, import_compose43.compose)([
    (0, import_data58.withSelect)(
      (select2, { clientId, rootClientId, shouldDirectInsert = true }) => {
        const {
          getBlockRootClientId: getBlockRootClientId2,
          hasInserterItems: hasInserterItems2,
          getAllowedBlocks: getAllowedBlocks2,
          getDirectInsertBlock: getDirectInsertBlock2
        } = select2(store);
        const { getBlockVariations: getBlockVariations2 } = select2(import_blocks33.store);
        rootClientId = rootClientId || getBlockRootClientId2(clientId) || void 0;
        const allowedBlocks = getAllowedBlocks2(rootClientId);
        const directInsertBlock = shouldDirectInsert && getDirectInsertBlock2(rootClientId);
        const hasSingleBlockType = allowedBlocks?.length === 1 && getBlockVariations2(allowedBlocks[0].name, "inserter")?.length === 0;
        let allowedBlockType = false;
        if (hasSingleBlockType) {
          allowedBlockType = allowedBlocks[0];
        }
        return {
          hasItems: hasInserterItems2(rootClientId),
          hasSingleBlockType,
          blockTitle: allowedBlockType ? allowedBlockType.title : "",
          allowedBlockType,
          directInsertBlock,
          rootClientId
        };
      }
    ),
    (0, import_data58.withDispatch)((dispatch, ownProps, { select: select2 }) => {
      return {
        insertOnlyAllowedBlock() {
          const {
            rootClientId,
            clientId,
            isAppender,
            hasSingleBlockType,
            allowedBlockType,
            directInsertBlock,
            onSelectOrClose,
            selectBlockOnInsert
          } = ownProps;
          if (!hasSingleBlockType && !directInsertBlock) {
            return;
          }
          function getAdjacentBlockAttributes(attributesToCopy) {
            const { getBlock: getBlock2, getPreviousBlockClientId: getPreviousBlockClientId2 } = select2(store);
            if (!attributesToCopy || !clientId && !rootClientId) {
              return {};
            }
            const result = {};
            let adjacentAttributes = {};
            if (!clientId) {
              const parentBlock = getBlock2(rootClientId);
              if (parentBlock?.innerBlocks?.length) {
                const lastInnerBlock = parentBlock.innerBlocks[parentBlock.innerBlocks.length - 1];
                if (directInsertBlock && directInsertBlock?.name === lastInnerBlock.name) {
                  adjacentAttributes = lastInnerBlock.attributes;
                }
              }
            } else {
              const currentBlock = getBlock2(clientId);
              const previousBlock = getBlock2(
                getPreviousBlockClientId2(clientId)
              );
              if (currentBlock?.name === previousBlock?.name) {
                adjacentAttributes = previousBlock?.attributes || {};
              }
            }
            attributesToCopy.forEach((attribute) => {
              if (adjacentAttributes.hasOwnProperty(attribute)) {
                result[attribute] = adjacentAttributes[attribute];
              }
            });
            return result;
          }
          function getInsertionIndex() {
            const {
              getBlockIndex: getBlockIndex2,
              getBlockSelectionEnd: getBlockSelectionEnd2,
              getBlockOrder: getBlockOrder2,
              getBlockRootClientId: getBlockRootClientId2
            } = select2(store);
            if (clientId) {
              return getBlockIndex2(clientId);
            }
            const end = getBlockSelectionEnd2();
            if (!isAppender && end && getBlockRootClientId2(end) === rootClientId) {
              return getBlockIndex2(end) + 1;
            }
            return getBlockOrder2(rootClientId).length;
          }
          const { insertBlock: insertBlock2 } = dispatch(store);
          let blockToInsert;
          if (directInsertBlock) {
            const newAttributes = getAdjacentBlockAttributes(
              directInsertBlock.attributesToCopy
            );
            blockToInsert = (0, import_blocks33.createBlock)(directInsertBlock.name, {
              ...directInsertBlock.attributes || {},
              ...newAttributes
            });
          } else {
            blockToInsert = (0, import_blocks33.createBlock)(allowedBlockType.name);
          }
          insertBlock2(
            blockToInsert,
            getInsertionIndex(),
            rootClientId,
            selectBlockOnInsert
          );
          if (onSelectOrClose) {
            onSelectOrClose(blockToInsert);
          }
          const message = (0, import_i18n58.sprintf)(
            // translators: %s: the name of the block that has been added
            (0, import_i18n58.__)("%s block added"),
            allowedBlockType.title
          );
          (0, import_a11y10.speak)(message);
        }
      };
    }),
    // The global inserter should always be visible, we are using ( ! isAppender && ! rootClientId && ! clientId ) as
    // a way to detect the global Inserter.
    (0, import_compose43.ifCondition)(
      ({ hasItems, isAppender, rootClientId, clientId }) => hasItems || !isAppender && !rootClientId && !clientId
    )
  ])(Inserter);

  // packages/block-editor/build-module/components/default-block-appender/index.js
  var ZWNBSP = "\uFEFF";
  function DefaultBlockAppender({ rootClientId }) {
    const { showPrompt, isLocked, placeholder, isManualGrid } = (0, import_data59.useSelect)(
      (select2) => {
        const {
          getBlockCount: getBlockCount2,
          getSettings: getSettings4,
          getTemplateLock: getTemplateLock2,
          getBlockAttributes: getBlockAttributes3
        } = select2(store);
        const isEmpty3 = !getBlockCount2(rootClientId);
        const { bodyPlaceholder } = getSettings4();
        return {
          showPrompt: isEmpty3,
          isLocked: !!getTemplateLock2(rootClientId),
          placeholder: bodyPlaceholder,
          isManualGrid: getBlockAttributes3(rootClientId)?.layout?.isManualPlacement
        };
      },
      [rootClientId]
    );
    const { insertDefaultBlock: insertDefaultBlock2, startTyping: startTyping2 } = (0, import_data59.useDispatch)(store);
    if (isLocked || isManualGrid) {
      return null;
    }
    const value = (0, import_html_entities2.decodeEntities)(placeholder) || (0, import_i18n59.__)("Type / to choose a block");
    const onAppend = () => {
      insertDefaultBlock2(void 0, rootClientId);
      startTyping2();
    };
    return /* @__PURE__ */ (0, import_jsx_runtime184.jsxs)(
      "div",
      {
        "data-root-client-id": rootClientId || "",
        className: clsx_default("block-editor-default-block-appender", {
          "has-visible-prompt": showPrompt
        }),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime184.jsx)(
            "p",
            {
              tabIndex: "0",
              role: "button",
              "aria-label": (0, import_i18n59.__)("Add default block"),
              className: "block-editor-default-block-appender__content",
              onKeyDown: (event) => {
                if (import_keycodes7.ENTER === event.keyCode || import_keycodes7.SPACE === event.keyCode) {
                  onAppend();
                }
              },
              onClick: () => onAppend(),
              onFocus: () => {
                if (showPrompt) {
                  onAppend();
                }
              },
              children: showPrompt ? value : ZWNBSP
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime184.jsx)(
            inserter_default,
            {
              rootClientId,
              position: "bottom right",
              isAppender: true,
              __experimentalIsQuick: true
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/button-block-appender/index.js
  var import_jsx_runtime185 = __toESM(require_jsx_runtime());
  var import_components57 = __toESM(require_components());
  var import_element75 = __toESM(require_element());
  var import_i18n60 = __toESM(require_i18n());
  var import_deprecated8 = __toESM(require_deprecated());
  function ButtonBlockAppender({ rootClientId, className, onFocus, tabIndex, onSelect }, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime185.jsx)(
      inserter_default,
      {
        position: "bottom center",
        rootClientId,
        __experimentalIsQuick: true,
        onSelectOrClose: (...args) => {
          if (onSelect && typeof onSelect === "function") {
            onSelect(...args);
          }
        },
        renderToggle: ({
          onToggle,
          disabled,
          isOpen,
          blockTitle,
          hasSingleBlockType
        }) => {
          const isToggleButton = !hasSingleBlockType;
          const label = hasSingleBlockType ? (0, import_i18n60.sprintf)(
            // translators: %s: the name of the block when there is only one
            (0, import_i18n60._x)(
              "Add %s",
              "directly add the only allowed block"
            ),
            blockTitle
          ) : (0, import_i18n60._x)(
            "Add block",
            "Generic label for block inserter button"
          );
          return /* @__PURE__ */ (0, import_jsx_runtime185.jsx)(
            import_components57.Button,
            {
              __next40pxDefaultSize: true,
              ref,
              onFocus,
              tabIndex,
              className: clsx_default(
                className,
                "block-editor-button-block-appender"
              ),
              onClick: onToggle,
              "aria-haspopup": isToggleButton ? "true" : void 0,
              "aria-expanded": isToggleButton ? isOpen : void 0,
              disabled,
              label,
              showTooltip: true,
              children: /* @__PURE__ */ (0, import_jsx_runtime185.jsx)(icon_default, { icon: plus_default })
            }
          );
        },
        isAppender: true
      }
    );
  }
  var ButtonBlockerAppender = (0, import_element75.forwardRef)((props, ref) => {
    (0, import_deprecated8.default)(`wp.blockEditor.ButtonBlockerAppender`, {
      alternative: "wp.blockEditor.ButtonBlockAppender",
      since: "5.9"
    });
    return ButtonBlockAppender(props, ref);
  });
  var button_block_appender_default = (0, import_element75.forwardRef)(ButtonBlockAppender);

  // packages/block-editor/build-module/components/block-list-appender/index.js
  function DefaultAppender({ rootClientId }) {
    const canInsertDefaultBlock = (0, import_data60.useSelect)(
      (select2) => select2(store).canInsertBlockType(
        (0, import_blocks34.getDefaultBlockName)(),
        rootClientId
      )
    );
    if (canInsertDefaultBlock) {
      return /* @__PURE__ */ (0, import_jsx_runtime186.jsx)(DefaultBlockAppender, { rootClientId });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime186.jsx)(
      button_block_appender_default,
      {
        rootClientId,
        className: "block-list-appender__toggle"
      }
    );
  }
  function BlockListAppender({
    rootClientId,
    CustomAppender,
    className,
    tagName: TagName = "div"
  }) {
    const isDragOver = (0, import_data60.useSelect)(
      (select2) => {
        const {
          getBlockInsertionPoint: getBlockInsertionPoint2,
          isBlockInsertionPointVisible: isBlockInsertionPointVisible2,
          getBlockCount: getBlockCount2
        } = select2(store);
        const insertionPoint2 = getBlockInsertionPoint2();
        return isBlockInsertionPointVisible2() && rootClientId === insertionPoint2?.rootClientId && getBlockCount2(rootClientId) === 0;
      },
      [rootClientId]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime186.jsx)(
      TagName,
      {
        tabIndex: -1,
        className: clsx_default("block-list-appender wp-block", className, {
          "is-drag-over": isDragOver
        }),
        contentEditable: false,
        "data-block": true,
        children: CustomAppender ? /* @__PURE__ */ (0, import_jsx_runtime186.jsx)(CustomAppender, {}) : /* @__PURE__ */ (0, import_jsx_runtime186.jsx)(DefaultAppender, { rootClientId })
      }
    );
  }

  // packages/block-editor/build-module/components/block-list/use-in-between-inserter.js
  var import_compose48 = __toESM(require_compose());
  var import_data64 = __toESM(require_data());
  var import_element80 = __toESM(require_element());
  var import_i18n62 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-tools/insertion-point.js
  var import_jsx_runtime191 = __toESM(require_jsx_runtime());
  var import_data63 = __toESM(require_data());
  var import_element79 = __toESM(require_element());
  var import_components61 = __toESM(require_components());
  var import_compose47 = __toESM(require_compose());

  // packages/block-editor/build-module/components/block-popover/inbetween.js
  var import_jsx_runtime187 = __toESM(require_jsx_runtime());
  var import_data61 = __toESM(require_data());
  var import_element76 = __toESM(require_element());
  var import_components58 = __toESM(require_components());
  var import_i18n61 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-popover/use-popover-scroll.js
  var import_compose44 = __toESM(require_compose());
  var import_dom20 = __toESM(require_dom());
  var scrollContainerCache = /* @__PURE__ */ new WeakMap();
  function usePopoverScroll(contentRef) {
    const effect = (0, import_compose44.useRefEffect)(
      (node2) => {
        function onWheel(event) {
          const { deltaX, deltaY, target } = event;
          const contentEl = contentRef.current;
          let scrollContainer = scrollContainerCache.get(contentEl);
          if (!scrollContainer) {
            scrollContainer = (0, import_dom20.getScrollContainer)(contentEl);
            scrollContainerCache.set(contentEl, scrollContainer);
          }
          const eventScrollContainer = (0, import_dom20.getScrollContainer)(target);
          if (!node2.contains(eventScrollContainer)) {
            scrollContainer.scrollBy(deltaX, deltaY);
          }
        }
        const options = { passive: true };
        node2.addEventListener("wheel", onWheel, options);
        return () => {
          node2.removeEventListener("wheel", onWheel, options);
        };
      },
      [contentRef]
    );
    return contentRef ? effect : null;
  }
  var use_popover_scroll_default = usePopoverScroll;

  // packages/block-editor/build-module/components/block-popover/inbetween.js
  var MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
  function BlockPopoverInbetween({
    previousClientId,
    nextClientId,
    children,
    __unstablePopoverSlot,
    __unstableContentRef,
    operation = "insert",
    nearestSide = "right",
    ...props
  }) {
    const [popoverRecomputeCounter, forcePopoverRecompute] = (0, import_element76.useReducer)(
      // Module is there to make sure that the counter doesn't overflow.
      (s2) => (s2 + 1) % MAX_POPOVER_RECOMPUTE_COUNTER,
      0
    );
    const { orientation, rootClientId, isVisible } = (0, import_data61.useSelect)(
      (select2) => {
        const {
          getBlockListSettings: getBlockListSettings2,
          getBlockRootClientId: getBlockRootClientId2,
          isBlockVisible: isBlockVisible2
        } = select2(store);
        const _rootClientId = getBlockRootClientId2(
          previousClientId ?? nextClientId
        );
        return {
          orientation: getBlockListSettings2(_rootClientId)?.orientation || "vertical",
          rootClientId: _rootClientId,
          isVisible: isBlockVisible2(previousClientId) && isBlockVisible2(nextClientId)
        };
      },
      [previousClientId, nextClientId]
    );
    const previousElement = useBlockElement(previousClientId);
    const nextElement = useBlockElement(nextClientId);
    const isVertical = orientation === "vertical";
    const popoverAnchor = (0, import_element76.useMemo)(() => {
      if (
        // popoverRecomputeCounter is by definition always equal or greater than 0.
        // This check is only there to satisfy the correctness of the
        // exhaustive-deps rule for the `useMemo` hook.
        popoverRecomputeCounter < 0 || !previousElement && !nextElement || !isVisible
      ) {
        return void 0;
      }
      const contextElement = operation === "group" ? nextElement || previousElement : previousElement || nextElement;
      return {
        contextElement,
        getBoundingClientRect() {
          const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
          const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;
          let left = 0;
          let top = 0;
          let width = 0;
          let height = 0;
          if (operation === "group") {
            const targetRect = nextRect || previousRect;
            top = targetRect.top;
            width = 0;
            height = targetRect.bottom - targetRect.top;
            left = nearestSide === "left" ? targetRect.left - 2 : targetRect.right - 2;
          } else if (isVertical) {
            top = previousRect ? previousRect.bottom : nextRect.top;
            width = previousRect ? previousRect.width : nextRect.width;
            height = nextRect && previousRect ? nextRect.top - previousRect.bottom : 0;
            left = previousRect ? previousRect.left : nextRect.left;
          } else {
            top = previousRect ? previousRect.top : nextRect.top;
            height = previousRect ? previousRect.height : nextRect.height;
            if ((0, import_i18n61.isRTL)()) {
              left = nextRect ? nextRect.right : previousRect.left;
              width = previousRect && nextRect ? previousRect.left - nextRect.right : 0;
            } else {
              left = previousRect ? previousRect.right : nextRect.left;
              width = previousRect && nextRect ? nextRect.left - previousRect.right : 0;
            }
            width = Math.max(width, 0);
          }
          return new window.DOMRect(left, top, width, height);
        }
      };
    }, [
      previousElement,
      nextElement,
      popoverRecomputeCounter,
      isVertical,
      isVisible,
      operation,
      nearestSide
    ]);
    const popoverScrollRef = use_popover_scroll_default(__unstableContentRef);
    (0, import_element76.useLayoutEffect)(() => {
      if (!previousElement) {
        return;
      }
      const observer = new window.MutationObserver(forcePopoverRecompute);
      observer.observe(previousElement, { attributes: true });
      return () => {
        observer.disconnect();
      };
    }, [previousElement]);
    (0, import_element76.useLayoutEffect)(() => {
      if (!nextElement) {
        return;
      }
      const observer = new window.MutationObserver(forcePopoverRecompute);
      observer.observe(nextElement, { attributes: true });
      return () => {
        observer.disconnect();
      };
    }, [nextElement]);
    (0, import_element76.useLayoutEffect)(() => {
      if (!previousElement) {
        return;
      }
      previousElement.ownerDocument.defaultView.addEventListener(
        "resize",
        forcePopoverRecompute
      );
      return () => {
        previousElement.ownerDocument.defaultView?.removeEventListener(
          "resize",
          forcePopoverRecompute
        );
      };
    }, [previousElement]);
    if (!previousElement && !nextElement || !isVisible) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime187.jsx)(
      import_components58.Popover,
      {
        ref: popoverScrollRef,
        animate: false,
        anchor: popoverAnchor,
        focusOnMount: false,
        __unstableSlotName: __unstablePopoverSlot,
        inline: !__unstablePopoverSlot,
        ...props,
        className: clsx_default(
          "block-editor-block-popover",
          "block-editor-block-popover__inbetween",
          props.className
        ),
        resize: false,
        flip: false,
        placement: "overlay",
        variant: "unstyled",
        children: /* @__PURE__ */ (0, import_jsx_runtime187.jsx)("div", { className: "block-editor-block-popover__inbetween-container", children })
      },
      nextClientId + "--" + rootClientId
    );
  }
  var inbetween_default = BlockPopoverInbetween;

  // packages/block-editor/build-module/components/block-popover/drop-zone.js
  var import_jsx_runtime190 = __toESM(require_jsx_runtime());
  var import_data62 = __toESM(require_data());
  var import_compose46 = __toESM(require_compose());
  var import_components60 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-popover/cover.js
  var import_jsx_runtime189 = __toESM(require_jsx_runtime());
  var import_element78 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-popover/index.js
  var import_jsx_runtime188 = __toESM(require_jsx_runtime());
  var import_compose45 = __toESM(require_compose());
  var import_components59 = __toESM(require_components());
  var import_element77 = __toESM(require_element());
  var MAX_POPOVER_RECOMPUTE_COUNTER2 = Number.MAX_SAFE_INTEGER;
  function BlockPopover({
    clientId,
    bottomClientId,
    children,
    __unstablePopoverSlot,
    __unstableContentRef,
    shift = true,
    ...props
  }, ref) {
    const selectedElement = useBlockElement(clientId);
    const lastSelectedElement = useBlockElement(bottomClientId ?? clientId);
    const mergedRefs = (0, import_compose45.useMergeRefs)([
      ref,
      use_popover_scroll_default(__unstableContentRef)
    ]);
    const [
      popoverDimensionsRecomputeCounter,
      forceRecomputePopoverDimensions
    ] = (0, import_element77.useReducer)(
      // Module is there to make sure that the counter doesn't overflow.
      (s2) => (s2 + 1) % MAX_POPOVER_RECOMPUTE_COUNTER2,
      0
    );
    (0, import_element77.useLayoutEffect)(() => {
      if (!selectedElement) {
        return;
      }
      const observer = new window.MutationObserver(
        forceRecomputePopoverDimensions
      );
      observer.observe(selectedElement, { attributes: true });
      return () => {
        observer.disconnect();
      };
    }, [selectedElement]);
    const popoverAnchor = (0, import_element77.useMemo)(() => {
      if (
        // popoverDimensionsRecomputeCounter is by definition always equal or greater
        // than 0. This check is only there to satisfy the correctness of the
        // exhaustive-deps rule for the `useMemo` hook.
        popoverDimensionsRecomputeCounter < 0 || !selectedElement || bottomClientId && !lastSelectedElement
      ) {
        return void 0;
      }
      return {
        getBoundingClientRect() {
          return lastSelectedElement ? rectUnion(
            getElementBounds(selectedElement),
            getElementBounds(lastSelectedElement)
          ) : getElementBounds(selectedElement);
        },
        contextElement: selectedElement
      };
    }, [
      popoverDimensionsRecomputeCounter,
      selectedElement,
      bottomClientId,
      lastSelectedElement
    ]);
    if (!selectedElement || bottomClientId && !lastSelectedElement) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime188.jsx)(
      import_components59.Popover,
      {
        ref: mergedRefs,
        animate: false,
        focusOnMount: false,
        anchor: popoverAnchor,
        __unstableSlotName: __unstablePopoverSlot,
        inline: !__unstablePopoverSlot,
        placement: "top-start",
        resize: false,
        flip: false,
        shift,
        ...props,
        className: clsx_default("block-editor-block-popover", props.className),
        variant: "unstyled",
        children
      }
    );
  }
  var PrivateBlockPopover = (0, import_element77.forwardRef)(BlockPopover);
  var PublicBlockPopover = ({ clientId, bottomClientId, children, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime188.jsx)(
    PrivateBlockPopover,
    {
      ...props,
      bottomClientId,
      clientId,
      __unstableContentRef: void 0,
      __unstablePopoverSlot: void 0,
      ref,
      children
    }
  );
  var block_popover_default = (0, import_element77.forwardRef)(PublicBlockPopover);

  // packages/block-editor/build-module/components/block-popover/cover.js
  function BlockPopoverCover({
    clientId,
    bottomClientId,
    children,
    shift = false,
    additionalStyles,
    ...props
  }, ref) {
    bottomClientId ??= clientId;
    const selectedElement = useBlockElement(clientId);
    return /* @__PURE__ */ (0, import_jsx_runtime189.jsx)(
      PrivateBlockPopover,
      {
        ref,
        clientId,
        bottomClientId,
        shift,
        ...props,
        children: selectedElement && clientId === bottomClientId ? /* @__PURE__ */ (0, import_jsx_runtime189.jsx)(
          CoverContainer,
          {
            selectedElement,
            additionalStyles,
            children
          }
        ) : children
      }
    );
  }
  function CoverContainer({
    selectedElement,
    additionalStyles = {},
    children
  }) {
    const [width, setWidth] = (0, import_element78.useState)(selectedElement.offsetWidth);
    const [height, setHeight] = (0, import_element78.useState)(selectedElement.offsetHeight);
    (0, import_element78.useEffect)(() => {
      const observer = new window.ResizeObserver(() => {
        setWidth(selectedElement.offsetWidth);
        setHeight(selectedElement.offsetHeight);
      });
      observer.observe(selectedElement, { box: "border-box" });
      return () => observer.disconnect();
    }, [selectedElement]);
    const style = (0, import_element78.useMemo)(() => {
      return {
        position: "absolute",
        width,
        height,
        ...additionalStyles
      };
    }, [width, height, additionalStyles]);
    return /* @__PURE__ */ (0, import_jsx_runtime189.jsx)("div", { style, children });
  }
  var cover_default = (0, import_element78.forwardRef)(BlockPopoverCover);

  // packages/block-editor/build-module/components/block-popover/drop-zone.js
  var animateVariants = {
    hide: { opacity: 0, scaleY: 0.75 },
    show: { opacity: 1, scaleY: 1 },
    exit: { opacity: 0, scaleY: 0.9 }
  };
  function BlockDropZonePopover({
    __unstablePopoverSlot,
    __unstableContentRef
  }) {
    const { clientId } = (0, import_data62.useSelect)((select2) => {
      const { getBlockOrder: getBlockOrder2, getBlockInsertionPoint: getBlockInsertionPoint2 } = select2(store);
      const insertionPoint2 = getBlockInsertionPoint2();
      const order = getBlockOrder2(insertionPoint2.rootClientId);
      if (!order.length) {
        return {};
      }
      return {
        clientId: order[insertionPoint2.index]
      };
    }, []);
    const reducedMotion = (0, import_compose46.useReducedMotion)();
    return /* @__PURE__ */ (0, import_jsx_runtime190.jsx)(
      cover_default,
      {
        clientId,
        __unstablePopoverSlot,
        __unstableContentRef,
        className: "block-editor-block-popover__drop-zone",
        children: /* @__PURE__ */ (0, import_jsx_runtime190.jsx)(
          import_components60.__unstableMotion.div,
          {
            "data-testid": "block-popover-drop-zone",
            initial: reducedMotion ? animateVariants.show : animateVariants.hide,
            animate: animateVariants.show,
            exit: reducedMotion ? animateVariants.show : animateVariants.exit,
            className: "block-editor-block-popover__drop-zone-foreground"
          }
        )
      }
    );
  }
  var drop_zone_default = BlockDropZonePopover;

  // packages/block-editor/build-module/components/block-tools/insertion-point.js
  var InsertionPointOpenRef = (0, import_element79.createContext)();
  InsertionPointOpenRef.displayName = "InsertionPointOpenRefContext";
  function InbetweenInsertionPointPopover({
    __unstablePopoverSlot,
    __unstableContentRef,
    operation = "insert",
    nearestSide = "right"
  }) {
    const { selectBlock: selectBlock2, hideInsertionPoint: hideInsertionPoint2 } = (0, import_data63.useDispatch)(store);
    const openRef = (0, import_element79.useContext)(InsertionPointOpenRef);
    const ref = (0, import_element79.useRef)();
    const {
      orientation,
      previousClientId,
      nextClientId,
      rootClientId,
      isInserterShown,
      isDistractionFree,
      isZoomOutMode
    } = (0, import_data63.useSelect)((select2) => {
      const {
        getBlockOrder: getBlockOrder2,
        getBlockListSettings: getBlockListSettings2,
        getBlockInsertionPoint: getBlockInsertionPoint2,
        isBlockBeingDragged: isBlockBeingDragged2,
        getPreviousBlockClientId: getPreviousBlockClientId2,
        getNextBlockClientId: getNextBlockClientId2,
        getSettings: getSettings4,
        isZoomOut: isZoomOut2
      } = unlock(select2(store));
      const insertionPoint2 = getBlockInsertionPoint2();
      const order = getBlockOrder2(insertionPoint2.rootClientId);
      if (!order.length) {
        return {};
      }
      let _previousClientId = order[insertionPoint2.index - 1];
      let _nextClientId = order[insertionPoint2.index];
      while (isBlockBeingDragged2(_previousClientId)) {
        _previousClientId = getPreviousBlockClientId2(_previousClientId);
      }
      while (isBlockBeingDragged2(_nextClientId)) {
        _nextClientId = getNextBlockClientId2(_nextClientId);
      }
      const settings2 = getSettings4();
      return {
        previousClientId: _previousClientId,
        nextClientId: _nextClientId,
        orientation: getBlockListSettings2(insertionPoint2.rootClientId)?.orientation || "vertical",
        rootClientId: insertionPoint2.rootClientId,
        isDistractionFree: settings2.isDistractionFree,
        isInserterShown: insertionPoint2?.__unstableWithInserter,
        isZoomOutMode: isZoomOut2()
      };
    }, []);
    const { getBlockEditingMode: getBlockEditingMode2 } = (0, import_data63.useSelect)(store);
    const disableMotion = (0, import_compose47.useReducedMotion)();
    function onClick(event) {
      if (event.target === ref.current && nextClientId && getBlockEditingMode2(nextClientId) !== "disabled") {
        selectBlock2(nextClientId, -1);
      }
    }
    function maybeHideInserterPoint(event) {
      if (event.target === ref.current && !openRef.current) {
        hideInsertionPoint2();
      }
    }
    function onFocus(event) {
      if (event.target !== ref.current) {
        openRef.current = true;
      }
    }
    const maybeResetOpenRef = (0, import_element79.useCallback)(
      (node2) => {
        if (!node2 && openRef.current) {
          openRef.current = false;
        }
      },
      [openRef]
    );
    const lineVariants = {
      // Initial position starts from the center and invisible.
      start: {
        opacity: 0,
        scale: 0
      },
      // The line expands to fill the container. If the inserter is visible it
      // is delayed so it appears orchestrated.
      rest: {
        opacity: 1,
        scale: 1,
        transition: { delay: isInserterShown ? 0.5 : 0, type: "tween" }
      },
      hover: {
        opacity: 1,
        scale: 1,
        transition: { delay: 0.5, type: "tween" }
      }
    };
    const inserterVariants = {
      start: {
        scale: disableMotion ? 1 : 0
      },
      rest: {
        scale: 1,
        transition: { delay: 0.4, type: "tween" }
      }
    };
    if (isDistractionFree) {
      return null;
    }
    if (isZoomOutMode && operation !== "insert") {
      return null;
    }
    const orientationClassname = orientation === "horizontal" || operation === "group" ? "is-horizontal" : "is-vertical";
    const className = clsx_default(
      "block-editor-block-list__insertion-point",
      orientationClassname
    );
    return /* @__PURE__ */ (0, import_jsx_runtime191.jsx)(
      inbetween_default,
      {
        previousClientId,
        nextClientId,
        __unstablePopoverSlot,
        __unstableContentRef,
        operation,
        nearestSide,
        children: /* @__PURE__ */ (0, import_jsx_runtime191.jsxs)(
          import_components61.__unstableMotion.div,
          {
            layout: !disableMotion,
            initial: disableMotion ? "rest" : "start",
            animate: "rest",
            whileHover: "hover",
            whileTap: "pressed",
            exit: "start",
            ref,
            tabIndex: -1,
            onClick,
            onFocus,
            className: clsx_default(className, {
              "is-with-inserter": isInserterShown
            }),
            onHoverEnd: maybeHideInserterPoint,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime191.jsx)(
                import_components61.__unstableMotion.div,
                {
                  variants: lineVariants,
                  className: "block-editor-block-list__insertion-point-indicator",
                  "data-testid": "block-list-insertion-point-indicator"
                }
              ),
              isInserterShown && /* @__PURE__ */ (0, import_jsx_runtime191.jsx)(
                import_components61.__unstableMotion.div,
                {
                  variants: inserterVariants,
                  className: clsx_default(
                    "block-editor-block-list__insertion-point-inserter"
                  ),
                  children: /* @__PURE__ */ (0, import_jsx_runtime191.jsx)(
                    inserter_default,
                    {
                      ref: maybeResetOpenRef,
                      position: "bottom center",
                      clientId: nextClientId,
                      rootClientId,
                      __experimentalIsQuick: true,
                      onToggle: (isOpen) => {
                        openRef.current = isOpen;
                      },
                      onSelectOrClose: () => {
                        openRef.current = false;
                      }
                    }
                  )
                }
              )
            ]
          }
        )
      }
    );
  }
  function InsertionPoint(props) {
    const { insertionPoint: insertionPoint2, isVisible, isBlockListEmpty } = (0, import_data63.useSelect)(
      (select2) => {
        const {
          getBlockInsertionPoint: getBlockInsertionPoint2,
          isBlockInsertionPointVisible: isBlockInsertionPointVisible2,
          getBlockCount: getBlockCount2
        } = select2(store);
        const blockInsertionPoint = getBlockInsertionPoint2();
        return {
          insertionPoint: blockInsertionPoint,
          isVisible: isBlockInsertionPointVisible2(),
          isBlockListEmpty: getBlockCount2(blockInsertionPoint?.rootClientId) === 0
        };
      },
      []
    );
    if (!isVisible || // Don't render the insertion point if the block list is empty.
    // The insertion point will be represented by the appender instead.
    isBlockListEmpty) {
      return null;
    }
    return insertionPoint2.operation === "replace" ? /* @__PURE__ */ (0, import_jsx_runtime191.jsx)(
      drop_zone_default,
      {
        ...props
      },
      `${insertionPoint2.rootClientId}-${insertionPoint2.index}`
    ) : /* @__PURE__ */ (0, import_jsx_runtime191.jsx)(
      InbetweenInsertionPointPopover,
      {
        operation: insertionPoint2.operation,
        nearestSide: insertionPoint2.nearestSide,
        ...props
      }
    );
  }

  // packages/block-editor/build-module/components/block-list/use-in-between-inserter.js
  function useInBetweenInserter() {
    const openRef = (0, import_element80.useContext)(InsertionPointOpenRef);
    const isInBetweenInserterDisabled = (0, import_data64.useSelect)(
      (select2) => select2(store).getSettings().isDistractionFree || unlock(select2(store)).isZoomOut(),
      []
    );
    const {
      getBlockListSettings: getBlockListSettings2,
      getBlockIndex: getBlockIndex2,
      isMultiSelecting: isMultiSelecting3,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      getSettings: getSettings4,
      getTemplateLock: getTemplateLock2,
      __unstableIsWithinBlockOverlay: __unstableIsWithinBlockOverlay2,
      getBlockEditingMode: getBlockEditingMode2,
      getBlockName: getBlockName2,
      getBlockAttributes: getBlockAttributes3,
      getParentSectionBlock: getParentSectionBlock2
    } = unlock((0, import_data64.useSelect)(store));
    const { showInsertionPoint: showInsertionPoint2, hideInsertionPoint: hideInsertionPoint2 } = (0, import_data64.useDispatch)(store);
    return (0, import_compose48.useRefEffect)(
      (node2) => {
        if (isInBetweenInserterDisabled) {
          return;
        }
        function onMouseMove(event) {
          if (openRef === void 0 || openRef.current) {
            return;
          }
          if (event.target.nodeType === event.target.TEXT_NODE) {
            return;
          }
          if (isMultiSelecting3()) {
            return;
          }
          if (!event.target.classList.contains(
            "block-editor-block-list__layout"
          )) {
            hideInsertionPoint2();
            return;
          }
          let rootClientId;
          if (!event.target.classList.contains("is-root-container")) {
            const blockElement = !!event.target.getAttribute(
              "data-block"
            ) ? event.target : event.target.closest("[data-block]");
            rootClientId = blockElement.getAttribute("data-block");
          }
          if (getTemplateLock2(rootClientId) || getBlockEditingMode2(rootClientId) === "disabled" || getBlockName2(rootClientId) === "core/block" || rootClientId && getBlockAttributes3(rootClientId).layout?.isManualPlacement) {
            return;
          }
          const blockListSettings2 = getBlockListSettings2(rootClientId);
          const orientation = blockListSettings2?.orientation || "vertical";
          const captureToolbars = !!blockListSettings2?.__experimentalCaptureToolbars;
          const offsetTop = event.clientY;
          const offsetLeft = event.clientX;
          const children = Array.from(event.target.children);
          let element = children.find((blockEl) => {
            const blockElRect = blockEl.getBoundingClientRect();
            return blockEl.classList.contains("wp-block") && orientation === "vertical" && blockElRect.top > offsetTop || blockEl.classList.contains("wp-block") && orientation === "horizontal" && ((0, import_i18n62.isRTL)() ? blockElRect.right < offsetLeft : blockElRect.left > offsetLeft);
          });
          if (!element) {
            hideInsertionPoint2();
            return;
          }
          if (!element.id) {
            element = element.firstElementChild;
            if (!element) {
              hideInsertionPoint2();
              return;
            }
          }
          const clientId = element.id.slice("block-".length);
          if (!clientId || __unstableIsWithinBlockOverlay2(clientId) || !!getParentSectionBlock2(clientId)) {
            return;
          }
          if (getSelectedBlockClientIds2().includes(clientId) && orientation === "vertical" && !captureToolbars && !getSettings4().hasFixedToolbar) {
            return;
          }
          const elementRect = element.getBoundingClientRect();
          if (orientation === "horizontal" && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === "vertical" && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
            hideInsertionPoint2();
            return;
          }
          const index = getBlockIndex2(clientId);
          if (index === 0) {
            hideInsertionPoint2();
            return;
          }
          showInsertionPoint2(rootClientId, index, {
            __unstableWithInserter: true
          });
        }
        node2.addEventListener("mousemove", onMouseMove);
        return () => {
          node2.removeEventListener("mousemove", onMouseMove);
        };
      },
      [
        openRef,
        getBlockListSettings2,
        getBlockIndex2,
        isMultiSelecting3,
        showInsertionPoint2,
        hideInsertionPoint2,
        getSelectedBlockClientIds2,
        isInBetweenInserterDisabled
      ]
    );
  }

  // packages/block-editor/build-module/components/inner-blocks/index.js
  var import_jsx_runtime194 = __toESM(require_jsx_runtime());
  var import_compose50 = __toESM(require_compose());
  var import_element85 = __toESM(require_element());
  var import_data70 = __toESM(require_data());
  var import_blocks39 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/inner-blocks/button-block-appender.js
  var import_jsx_runtime192 = __toESM(require_jsx_runtime());
  function ButtonBlockAppender2({
    showSeparator,
    isFloating,
    onAddBlock,
    isToggle
  }) {
    const { clientId } = useBlockEditContext();
    return /* @__PURE__ */ (0, import_jsx_runtime192.jsx)(
      button_block_appender_default,
      {
        className: clsx_default({
          "block-list-appender__toggle": isToggle
        }),
        rootClientId: clientId,
        showSeparator,
        isFloating,
        onAddBlock
      }
    );
  }

  // packages/block-editor/build-module/components/inner-blocks/default-block-appender.js
  var import_jsx_runtime193 = __toESM(require_jsx_runtime());
  function DefaultBlockAppender2() {
    const { clientId } = useBlockEditContext();
    return /* @__PURE__ */ (0, import_jsx_runtime193.jsx)(DefaultBlockAppender, { rootClientId: clientId });
  }

  // packages/block-editor/build-module/components/inner-blocks/use-nested-settings-update.js
  var import_element81 = __toESM(require_element());
  var import_data65 = __toESM(require_data());
  var import_deprecated9 = __toESM(require_deprecated());
  var import_is_shallow_equal = __toESM(require_is_shallow_equal());
  var pendingSettingsUpdates = /* @__PURE__ */ new WeakMap();
  function createShallowMemo() {
    let value;
    return (newValue) => {
      if (value === void 0 || !(0, import_is_shallow_equal.default)(value, newValue)) {
        value = newValue;
      }
      return value;
    };
  }
  function useShallowMemo(value) {
    const [memo11] = (0, import_element81.useState)(createShallowMemo);
    return memo11(value);
  }
  function useNestedSettingsUpdate(clientId, parentLock, allowedBlocks, prioritizedInserterBlocks, defaultBlock, directInsert, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout) {
    const registry = (0, import_data65.useRegistry)();
    const _allowedBlocks = useShallowMemo(allowedBlocks);
    const _prioritizedInserterBlocks = useShallowMemo(
      prioritizedInserterBlocks
    );
    const _templateLock = templateLock === void 0 || parentLock === "contentOnly" ? parentLock : templateLock;
    (0, import_element81.useLayoutEffect)(() => {
      const newSettings = {
        allowedBlocks: _allowedBlocks,
        prioritizedInserterBlocks: _prioritizedInserterBlocks,
        templateLock: _templateLock
      };
      if (captureToolbars !== void 0) {
        newSettings.__experimentalCaptureToolbars = captureToolbars;
      }
      if (orientation !== void 0) {
        newSettings.orientation = orientation;
      } else {
        const layoutType = getLayoutType(layout?.type);
        newSettings.orientation = layoutType.getOrientation(layout);
      }
      if (__experimentalDefaultBlock !== void 0) {
        (0, import_deprecated9.default)("__experimentalDefaultBlock", {
          alternative: "defaultBlock",
          since: "6.3",
          version: "6.4"
        });
        newSettings.defaultBlock = __experimentalDefaultBlock;
      }
      if (defaultBlock !== void 0) {
        newSettings.defaultBlock = defaultBlock;
      }
      if (__experimentalDirectInsert !== void 0) {
        (0, import_deprecated9.default)("__experimentalDirectInsert", {
          alternative: "directInsert",
          since: "6.3",
          version: "6.4"
        });
        newSettings.directInsert = __experimentalDirectInsert;
      }
      if (directInsert !== void 0) {
        newSettings.directInsert = directInsert;
      }
      if (newSettings.directInsert !== void 0 && typeof newSettings.directInsert !== "boolean") {
        (0, import_deprecated9.default)("Using `Function` as a `directInsert` argument", {
          alternative: "`boolean` values",
          since: "6.5"
        });
      }
      if (!pendingSettingsUpdates.get(registry)) {
        pendingSettingsUpdates.set(registry, {});
      }
      pendingSettingsUpdates.get(registry)[clientId] = newSettings;
      window.queueMicrotask(() => {
        const settings2 = pendingSettingsUpdates.get(registry);
        if (Object.keys(settings2).length) {
          const { updateBlockListSettings: updateBlockListSettings2 } = registry.dispatch(store);
          updateBlockListSettings2(settings2);
          pendingSettingsUpdates.set(registry, {});
        }
      });
    }, [
      clientId,
      _allowedBlocks,
      _prioritizedInserterBlocks,
      _templateLock,
      defaultBlock,
      directInsert,
      __experimentalDefaultBlock,
      __experimentalDirectInsert,
      captureToolbars,
      orientation,
      layout,
      registry
    ]);
  }

  // packages/block-editor/build-module/components/inner-blocks/use-inner-block-template-sync.js
  var import_es62 = __toESM(require_es6());
  var import_element82 = __toESM(require_element());
  var import_data66 = __toESM(require_data());
  var import_blocks35 = __toESM(require_blocks());
  function useInnerBlockTemplateSync(clientId, template2, templateLock, templateInsertUpdatesSelection) {
    const registry = (0, import_data66.useRegistry)();
    const existingTemplateRef = (0, import_element82.useRef)(null);
    (0, import_element82.useLayoutEffect)(() => {
      let isCancelled = false;
      const {
        getBlocks: getBlocks2,
        getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2,
        isBlockSelected: isBlockSelected2
      } = registry.select(store);
      const { replaceInnerBlocks: replaceInnerBlocks2, __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2 } = registry.dispatch(store);
      window.queueMicrotask(() => {
        if (isCancelled) {
          return;
        }
        const currentInnerBlocks = getBlocks2(clientId);
        const shouldApplyTemplate = currentInnerBlocks.length === 0 || templateLock === "all" || templateLock === "contentOnly";
        const hasTemplateChanged = !(0, import_es62.default)(
          template2,
          existingTemplateRef.current
        );
        if (!shouldApplyTemplate || !hasTemplateChanged) {
          return;
        }
        existingTemplateRef.current = template2;
        const nextBlocks = (0, import_blocks35.synchronizeBlocksWithTemplate)(
          currentInnerBlocks,
          template2
        );
        if (!(0, import_es62.default)(nextBlocks, currentInnerBlocks)) {
          __unstableMarkNextChangeAsNotPersistent2();
          replaceInnerBlocks2(
            clientId,
            nextBlocks,
            currentInnerBlocks.length === 0 && templateInsertUpdatesSelection && nextBlocks.length !== 0 && isBlockSelected2(clientId),
            // This ensures the "initialPosition" doesn't change when applying the template
            // If we're supposed to focus the block, we'll focus the first inner block
            // otherwise, we won't apply any auto-focus.
            // This ensures for instance that the focus stays in the inserter when inserting the "buttons" block.
            getSelectedBlocksInitialCaretPosition2()
          );
        }
      });
      return () => {
        isCancelled = true;
      };
    }, [
      template2,
      templateLock,
      clientId,
      registry,
      templateInsertUpdatesSelection
    ]);
  }

  // packages/block-editor/build-module/components/inner-blocks/use-block-context.js
  var import_blocks36 = __toESM(require_blocks());
  var import_data67 = __toESM(require_data());
  function useBlockContext(clientId) {
    return (0, import_data67.useSelect)(
      (select2) => {
        const block = select2(store).getBlock(clientId);
        if (!block) {
          return void 0;
        }
        const blockType = select2(import_blocks36.store).getBlockType(block.name);
        if (!blockType) {
          return void 0;
        }
        if (Object.keys(blockType.providesContext).length === 0) {
          return void 0;
        }
        return Object.fromEntries(
          Object.entries(blockType.providesContext).map(
            ([contextName, attributeName]) => [
              contextName,
              block.attributes[attributeName]
            ]
          )
        );
      },
      [clientId]
    );
  }

  // packages/block-editor/build-module/components/use-block-drop-zone/index.js
  var import_data69 = __toESM(require_data());
  var import_element84 = __toESM(require_element());
  var import_compose49 = __toESM(require_compose());
  var import_i18n63 = __toESM(require_i18n());
  var import_blocks38 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/use-on-block-drop/index.js
  var import_element83 = __toESM(require_element());
  var import_blocks37 = __toESM(require_blocks());
  var import_data68 = __toESM(require_data());
  var import_dom22 = __toESM(require_dom());
  function parseDropEvent(event) {
    let result = {
      srcRootClientId: null,
      srcClientIds: null,
      srcIndex: null,
      type: null,
      blocks: null
    };
    if (!event.dataTransfer) {
      return result;
    }
    try {
      result = Object.assign(
        result,
        JSON.parse(event.dataTransfer.getData("wp-blocks"))
      );
    } catch (err) {
      return result;
    }
    return result;
  }
  function onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex2, getClientIdsOfDescendants2, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock2, operation, getBlock2) {
    return (event) => {
      const {
        srcRootClientId: sourceRootClientId,
        srcClientIds: sourceClientIds,
        type: dropType,
        blocks: blocks2
      } = parseDropEvent(event);
      if (dropType === "inserter") {
        clearSelectedBlock2();
        const blocksToInsert = blocks2.map(
          (block) => (0, import_blocks37.cloneBlock)(block)
        );
        insertOrReplaceBlocks(blocksToInsert, true, null);
      }
      if (dropType === "block") {
        const sourceBlockIndex = getBlockIndex2(sourceClientIds[0]);
        if (sourceRootClientId === targetRootClientId && sourceBlockIndex === targetBlockIndex) {
          return;
        }
        if (sourceClientIds.includes(targetRootClientId) || getClientIdsOfDescendants2(sourceClientIds).some(
          (id) => id === targetRootClientId
        )) {
          return;
        }
        if (operation === "group") {
          const blocksToInsert = sourceClientIds.map(
            (clientId) => getBlock2(clientId)
          );
          insertOrReplaceBlocks(
            blocksToInsert,
            true,
            null,
            sourceClientIds
          );
          return;
        }
        const isAtSameLevel = sourceRootClientId === targetRootClientId;
        const draggedBlockCount = sourceClientIds.length;
        const insertIndex = isAtSameLevel && sourceBlockIndex < targetBlockIndex ? targetBlockIndex - draggedBlockCount : targetBlockIndex;
        moveBlocks(sourceClientIds, sourceRootClientId, insertIndex);
      }
    };
  }
  function onFilesDrop(targetRootClientId, getSettings4, updateBlockAttributes2, canInsertBlockType2, insertOrReplaceBlocks) {
    return (files) => {
      if (!getSettings4().mediaUpload) {
        return;
      }
      const transformation = (0, import_blocks37.findTransform)(
        (0, import_blocks37.getBlockTransforms)("from"),
        (transform) => transform.type === "files" && canInsertBlockType2(transform.blockName, targetRootClientId) && transform.isMatch(files)
      );
      if (transformation) {
        const blocks2 = transformation.transform(
          files,
          updateBlockAttributes2
        );
        insertOrReplaceBlocks(blocks2);
      }
    };
  }
  function onHTMLDrop(insertOrReplaceBlocks) {
    return (HTML) => {
      const blocks2 = (0, import_blocks37.pasteHandler)({ HTML, mode: "BLOCKS" });
      if (blocks2.length) {
        insertOrReplaceBlocks(blocks2);
      }
    };
  }
  function useOnBlockDrop(targetRootClientId, targetBlockIndex, options = {}) {
    const { operation = "insert", nearestSide = "right" } = options;
    const {
      canInsertBlockType: canInsertBlockType2,
      getBlockIndex: getBlockIndex2,
      getClientIdsOfDescendants: getClientIdsOfDescendants2,
      getBlockOrder: getBlockOrder2,
      getBlocksByClientId: getBlocksByClientId2,
      getSettings: getSettings4,
      getBlock: getBlock2
    } = (0, import_data68.useSelect)(store);
    const { getGroupingBlockName } = (0, import_data68.useSelect)(import_blocks37.store);
    const {
      insertBlocks: insertBlocks2,
      moveBlocksToPosition: moveBlocksToPosition2,
      updateBlockAttributes: updateBlockAttributes2,
      clearSelectedBlock: clearSelectedBlock2,
      replaceBlocks: replaceBlocks2,
      removeBlocks: removeBlocks2
    } = (0, import_data68.useDispatch)(store);
    const registry = (0, import_data68.useRegistry)();
    const insertOrReplaceBlocks = (0, import_element83.useCallback)(
      (blocks2, updateSelection = true, initialPosition2 = 0, clientIdsToReplace = []) => {
        if (!Array.isArray(blocks2)) {
          blocks2 = [blocks2];
        }
        const clientIds = getBlockOrder2(targetRootClientId);
        const clientId = clientIds[targetBlockIndex];
        if (operation === "replace") {
          replaceBlocks2(clientId, blocks2, void 0, initialPosition2);
        } else if (operation === "group") {
          const targetBlock = getBlock2(clientId);
          if (nearestSide === "left") {
            blocks2.push(targetBlock);
          } else {
            blocks2.unshift(targetBlock);
          }
          const groupInnerBlocks = blocks2.map((block) => {
            return (0, import_blocks37.createBlock)(
              block.name,
              block.attributes,
              block.innerBlocks
            );
          });
          const areAllImages = blocks2.every((block) => {
            return block.name === "core/image";
          });
          const galleryBlock = canInsertBlockType2(
            "core/gallery",
            targetRootClientId
          );
          const wrappedBlocks = (0, import_blocks37.createBlock)(
            areAllImages && galleryBlock ? "core/gallery" : getGroupingBlockName(),
            {
              layout: {
                type: "flex",
                flexWrap: areAllImages && galleryBlock ? null : "nowrap"
              }
            },
            groupInnerBlocks
          );
          replaceBlocks2(
            [clientId, ...clientIdsToReplace],
            wrappedBlocks,
            void 0,
            initialPosition2
          );
        } else {
          insertBlocks2(
            blocks2,
            targetBlockIndex,
            targetRootClientId,
            updateSelection,
            initialPosition2
          );
        }
      },
      [
        getBlockOrder2,
        targetRootClientId,
        targetBlockIndex,
        operation,
        replaceBlocks2,
        getBlock2,
        nearestSide,
        canInsertBlockType2,
        getGroupingBlockName,
        insertBlocks2
      ]
    );
    const moveBlocks = (0, import_element83.useCallback)(
      (sourceClientIds, sourceRootClientId, insertIndex) => {
        if (operation === "replace") {
          const sourceBlocks = getBlocksByClientId2(sourceClientIds);
          const targetBlockClientIds = getBlockOrder2(targetRootClientId);
          const targetBlockClientId = targetBlockClientIds[targetBlockIndex];
          registry.batch(() => {
            removeBlocks2(sourceClientIds, false);
            replaceBlocks2(
              targetBlockClientId,
              sourceBlocks,
              void 0,
              0
            );
          });
        } else {
          moveBlocksToPosition2(
            sourceClientIds,
            sourceRootClientId,
            targetRootClientId,
            insertIndex
          );
        }
      },
      [
        operation,
        getBlockOrder2,
        getBlocksByClientId2,
        moveBlocksToPosition2,
        registry,
        removeBlocks2,
        replaceBlocks2,
        targetBlockIndex,
        targetRootClientId
      ]
    );
    const _onDrop = onBlockDrop(
      targetRootClientId,
      targetBlockIndex,
      getBlockIndex2,
      getClientIdsOfDescendants2,
      moveBlocks,
      insertOrReplaceBlocks,
      clearSelectedBlock2,
      operation,
      getBlock2
    );
    const _onFilesDrop = onFilesDrop(
      targetRootClientId,
      getSettings4,
      updateBlockAttributes2,
      canInsertBlockType2,
      insertOrReplaceBlocks
    );
    const _onHTMLDrop = onHTMLDrop(insertOrReplaceBlocks);
    return (event) => {
      const files = (0, import_dom22.getFilesFromDataTransfer)(event.dataTransfer);
      const html = event.dataTransfer.getData("text/html");
      if (html) {
        _onHTMLDrop(html);
      } else if (files.length) {
        _onFilesDrop(files);
      } else {
        _onDrop(event);
      }
    };
  }

  // packages/block-editor/build-module/utils/math.js
  function getDistanceFromPointToEdge(point, rect, edge) {
    const isHorizontal = edge === "top" || edge === "bottom";
    const { x: x2, y: y2 } = point;
    const pointLateralPosition = isHorizontal ? x2 : y2;
    const pointForwardPosition = isHorizontal ? y2 : x2;
    const edgeStart = isHorizontal ? rect.left : rect.top;
    const edgeEnd = isHorizontal ? rect.right : rect.bottom;
    const edgeForwardPosition = rect[edge];
    let edgeLateralPosition;
    if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
      edgeLateralPosition = pointLateralPosition;
    } else if (pointLateralPosition < edgeEnd) {
      edgeLateralPosition = edgeStart;
    } else {
      edgeLateralPosition = edgeEnd;
    }
    return Math.sqrt(
      (pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2
    );
  }
  function getDistanceToNearestEdge(point, rect, allowedEdges = ["top", "bottom", "left", "right"]) {
    let candidateDistance;
    let candidateEdge;
    allowedEdges.forEach((edge) => {
      const distance = getDistanceFromPointToEdge(point, rect, edge);
      if (candidateDistance === void 0 || distance < candidateDistance) {
        candidateDistance = distance;
        candidateEdge = edge;
      }
    });
    return [candidateDistance, candidateEdge];
  }
  function isPointContainedByRect(point, rect) {
    return rect.left <= point.x && rect.right >= point.x && rect.top <= point.y && rect.bottom >= point.y;
  }
  function isPointWithinTopAndBottomBoundariesOfRect(point, rect) {
    return rect.top <= point.y && rect.bottom >= point.y;
  }

  // packages/block-editor/build-module/components/use-block-drop-zone/index.js
  var THRESHOLD_DISTANCE = 30;
  var MINIMUM_HEIGHT_FOR_THRESHOLD = 120;
  var MINIMUM_WIDTH_FOR_THRESHOLD = 120;
  function getDropTargetPosition(blocksData, position2, orientation = "vertical", options = {}) {
    const allowedEdges = orientation === "horizontal" ? ["left", "right"] : ["top", "bottom"];
    let nearestIndex = 0;
    let insertPosition = "before";
    let minDistance = Infinity;
    let targetBlockIndex = null;
    let nearestSide = "right";
    const {
      dropZoneElement,
      parentBlockOrientation,
      rootBlockIndex = 0
    } = options;
    if (dropZoneElement && parentBlockOrientation !== "horizontal") {
      const rect = dropZoneElement.getBoundingClientRect();
      const [distance, edge] = getDistanceToNearestEdge(position2, rect, [
        "top",
        "bottom"
      ]);
      if (rect.height > MINIMUM_HEIGHT_FOR_THRESHOLD && distance < THRESHOLD_DISTANCE) {
        if (edge === "top") {
          return [rootBlockIndex, "before"];
        }
        if (edge === "bottom") {
          return [rootBlockIndex + 1, "after"];
        }
      }
    }
    const isRightToLeft = (0, import_i18n63.isRTL)();
    if (dropZoneElement && parentBlockOrientation === "horizontal") {
      const rect = dropZoneElement.getBoundingClientRect();
      const [distance, edge] = getDistanceToNearestEdge(position2, rect, [
        "left",
        "right"
      ]);
      if (rect.width > MINIMUM_WIDTH_FOR_THRESHOLD && distance < THRESHOLD_DISTANCE) {
        if (isRightToLeft && edge === "right" || !isRightToLeft && edge === "left") {
          return [rootBlockIndex, "before"];
        }
        if (isRightToLeft && edge === "left" || !isRightToLeft && edge === "right") {
          return [rootBlockIndex + 1, "after"];
        }
      }
    }
    blocksData.forEach(
      ({
        isUnmodifiedDefaultBlock: isUnmodifiedDefaultBlock5,
        getBoundingClientRect,
        blockIndex,
        blockOrientation
      }) => {
        const rect = getBoundingClientRect();
        if (!rect) {
          return;
        }
        let [distance, edge] = getDistanceToNearestEdge(
          position2,
          rect,
          allowedEdges
        );
        const [sideDistance, sideEdge] = getDistanceToNearestEdge(
          position2,
          rect,
          ["left", "right"]
        );
        const isPointInsideRect = isPointContainedByRect(position2, rect);
        if (isUnmodifiedDefaultBlock5 && isPointInsideRect) {
          distance = 0;
        } else if (orientation === "vertical" && blockOrientation !== "horizontal" && (isPointInsideRect && sideDistance < THRESHOLD_DISTANCE || !isPointInsideRect && isPointWithinTopAndBottomBoundariesOfRect(
          position2,
          rect
        ))) {
          targetBlockIndex = blockIndex;
          nearestSide = sideEdge;
        }
        if (distance < minDistance) {
          insertPosition = edge === "bottom" || !isRightToLeft && edge === "right" || isRightToLeft && edge === "left" ? "after" : "before";
          minDistance = distance;
          nearestIndex = blockIndex;
        }
      }
    );
    const adjacentIndex = nearestIndex + (insertPosition === "after" ? 1 : -1);
    const isNearestBlockUnmodifiedDefaultBlock = !!blocksData[nearestIndex]?.isUnmodifiedDefaultBlock;
    const isAdjacentBlockUnmodifiedDefaultBlock = !!blocksData[adjacentIndex]?.isUnmodifiedDefaultBlock;
    if (targetBlockIndex !== null) {
      return [targetBlockIndex, "group", nearestSide];
    }
    if (!isNearestBlockUnmodifiedDefaultBlock && !isAdjacentBlockUnmodifiedDefaultBlock) {
      const insertionIndex = insertPosition === "after" ? nearestIndex + 1 : nearestIndex;
      return [insertionIndex, "insert"];
    }
    return [
      isNearestBlockUnmodifiedDefaultBlock ? nearestIndex : adjacentIndex,
      "replace"
    ];
  }
  function isDropTargetValid(getBlockType21, allowedBlocks, draggedBlockNames, targetBlockName) {
    let areBlocksAllowed = true;
    if (allowedBlocks) {
      const allowedBlockNames = allowedBlocks?.map(({ name }) => name);
      areBlocksAllowed = draggedBlockNames.every(
        (name) => allowedBlockNames?.includes(name)
      );
    }
    const draggedBlockTypes = draggedBlockNames.map(
      (name) => getBlockType21(name)
    );
    const targetMatchesDraggedBlockParents = draggedBlockTypes.every(
      (block) => {
        const [allowedParentName] = block?.parent || [];
        if (!allowedParentName) {
          return true;
        }
        return allowedParentName === targetBlockName;
      }
    );
    return areBlocksAllowed && targetMatchesDraggedBlockParents;
  }
  function isInsertionPoint(targetToCheck, ownerDocument) {
    const { defaultView } = ownerDocument;
    return !!(defaultView && targetToCheck instanceof defaultView.HTMLElement && targetToCheck.closest("[data-is-insertion-point]"));
  }
  function useBlockDropZone({
    dropZoneElement,
    // An undefined value represents a top-level block. Default to an empty
    // string for this so that `targetRootClientId` can be easily compared to
    // values returned by the `getRootBlockClientId` selector, which also uses
    // an empty string to represent top-level blocks.
    rootClientId: targetRootClientId = "",
    parentClientId: parentBlockClientId = "",
    isDisabled = false
  } = {}) {
    const registry = (0, import_data69.useRegistry)();
    const [dropTarget, setDropTarget] = (0, import_element84.useState)({
      index: null,
      operation: "insert"
    });
    const { getBlockType: getBlockType21, getBlockVariations: getBlockVariations2, getGroupingBlockName } = (0, import_data69.useSelect)(import_blocks38.store);
    const {
      canInsertBlockType: canInsertBlockType2,
      getBlockListSettings: getBlockListSettings2,
      getBlocks: getBlocks2,
      getBlockIndex: getBlockIndex2,
      getDraggedBlockClientIds: getDraggedBlockClientIds2,
      getBlockNamesByClientId: getBlockNamesByClientId2,
      getAllowedBlocks: getAllowedBlocks2,
      isDragging: isDragging3,
      isGroupable: isGroupable2,
      isZoomOut: isZoomOut2,
      getSectionRootClientId: getSectionRootClientId2,
      getBlockParents: getBlockParents2
    } = unlock((0, import_data69.useSelect)(store));
    const {
      showInsertionPoint: showInsertionPoint2,
      hideInsertionPoint: hideInsertionPoint2,
      startDragging: startDragging2,
      stopDragging: stopDragging2
    } = unlock((0, import_data69.useDispatch)(store));
    const onBlockDrop2 = useOnBlockDrop(
      dropTarget.operation === "before" || dropTarget.operation === "after" ? parentBlockClientId : targetRootClientId,
      dropTarget.index,
      {
        operation: dropTarget.operation,
        nearestSide: dropTarget.nearestSide
      }
    );
    const throttled = (0, import_compose49.useThrottle)(
      (0, import_element84.useCallback)(
        (event, ownerDocument) => {
          if (!isDragging3()) {
            startDragging2();
          }
          const draggedBlockClientIds = getDraggedBlockClientIds2();
          const targetParents = [
            targetRootClientId,
            ...getBlockParents2(targetRootClientId, true)
          ];
          const isTargetWithinDraggedBlocks = draggedBlockClientIds.some(
            (clientId) => targetParents.includes(clientId)
          );
          if (isTargetWithinDraggedBlocks) {
            return;
          }
          const allowedBlocks = getAllowedBlocks2(targetRootClientId);
          const targetBlockName = getBlockNamesByClientId2([
            targetRootClientId
          ])[0];
          const draggedBlockNames = getBlockNamesByClientId2(
            draggedBlockClientIds
          );
          const isBlockDroppingAllowed = isDropTargetValid(
            getBlockType21,
            allowedBlocks,
            draggedBlockNames,
            targetBlockName
          );
          if (!isBlockDroppingAllowed) {
            return;
          }
          const sectionRootClientId = getSectionRootClientId2();
          if (isZoomOut2() && sectionRootClientId !== targetRootClientId) {
            return;
          }
          const blocks2 = getBlocks2(targetRootClientId).filter((block) => {
            return !((0, import_blocks38.hasBlockSupport)(
              block.name,
              "blockVisibility",
              true
            ) && block.attributes?.metadata?.blockVisibility === false);
          });
          if (blocks2.length === 0) {
            registry.batch(() => {
              setDropTarget({
                index: 0,
                operation: "insert"
              });
              showInsertionPoint2(targetRootClientId, 0, {
                operation: "insert"
              });
            });
            return;
          }
          const blocksData = blocks2.map((block) => {
            const clientId = block.clientId;
            return {
              isUnmodifiedDefaultBlock: (0, import_blocks38.isUnmodifiedDefaultBlock)(block),
              getBoundingClientRect: () => {
                const blockElement = ownerDocument.getElementById(
                  `block-${clientId}`
                );
                return blockElement ? blockElement.getBoundingClientRect() : null;
              },
              blockIndex: getBlockIndex2(clientId),
              blockOrientation: getBlockListSettings2(clientId)?.orientation
            };
          });
          const dropTargetPosition = getDropTargetPosition(
            blocksData,
            { x: event.clientX, y: event.clientY },
            getBlockListSettings2(targetRootClientId)?.orientation,
            {
              dropZoneElement,
              parentBlockClientId,
              parentBlockOrientation: parentBlockClientId ? getBlockListSettings2(parentBlockClientId)?.orientation : void 0,
              rootBlockIndex: getBlockIndex2(targetRootClientId)
            }
          );
          const [targetIndex, operation, nearestSide] = dropTargetPosition;
          const isTargetIndexEmptyDefaultBlock = blocksData[targetIndex]?.isUnmodifiedDefaultBlock;
          if (isZoomOut2() && !isTargetIndexEmptyDefaultBlock && operation !== "insert") {
            return;
          }
          if (operation === "group") {
            const targetBlock = blocks2[targetIndex];
            const areAllImages = [
              targetBlock.name,
              ...draggedBlockNames
            ].every((name) => name === "core/image");
            const canInsertGalleryBlock = canInsertBlockType2(
              "core/gallery",
              targetRootClientId
            );
            const areGroupableBlocks = isGroupable2([
              targetBlock.clientId,
              getDraggedBlockClientIds2()
            ]);
            const groupBlockVariations = getBlockVariations2(
              getGroupingBlockName(),
              "block"
            );
            const canInsertRow = groupBlockVariations && groupBlockVariations.find(
              ({ name }) => name === "group-row"
            );
            if (areAllImages && !canInsertGalleryBlock && (!areGroupableBlocks || !canInsertRow)) {
              return;
            }
            if (!areAllImages && (!areGroupableBlocks || !canInsertRow)) {
              return;
            }
          }
          registry.batch(() => {
            setDropTarget({
              index: targetIndex,
              operation,
              nearestSide
            });
            const insertionPointClientId = [
              "before",
              "after"
            ].includes(operation) ? parentBlockClientId : targetRootClientId;
            showInsertionPoint2(insertionPointClientId, targetIndex, {
              operation,
              nearestSide
            });
          });
        },
        [
          isDragging3,
          getAllowedBlocks2,
          targetRootClientId,
          getBlockNamesByClientId2,
          getDraggedBlockClientIds2,
          getBlockType21,
          getSectionRootClientId2,
          isZoomOut2,
          getBlocks2,
          getBlockListSettings2,
          dropZoneElement,
          parentBlockClientId,
          getBlockIndex2,
          registry,
          startDragging2,
          showInsertionPoint2,
          canInsertBlockType2,
          isGroupable2,
          getBlockVariations2,
          getGroupingBlockName
        ]
      ),
      200
    );
    return (0, import_compose49.__experimentalUseDropZone)({
      dropZoneElement,
      isDisabled,
      onDrop: onBlockDrop2,
      onDragOver(event) {
        throttled(event, event.currentTarget.ownerDocument);
      },
      onDragLeave(event) {
        const { ownerDocument } = event.currentTarget;
        if (isInsertionPoint(event.relatedTarget, ownerDocument) || isInsertionPoint(event.target, ownerDocument)) {
          return;
        }
        throttled.cancel();
        hideInsertionPoint2();
      },
      onDragEnd() {
        throttled.cancel();
        stopDragging2();
        hideInsertionPoint2();
      }
    });
  }

  // packages/block-editor/build-module/components/inner-blocks/index.js
  var EMPTY_OBJECT = {};
  function BlockContext({ children, clientId }) {
    const context = useBlockContext(clientId);
    return /* @__PURE__ */ (0, import_jsx_runtime194.jsx)(BlockContextProvider, { value: context, children });
  }
  var BlockListItemsMemo = (0, import_element85.memo)(BlockListItems);
  function UncontrolledInnerBlocks(props) {
    const {
      clientId,
      allowedBlocks,
      prioritizedInserterBlocks,
      defaultBlock,
      directInsert,
      __experimentalDefaultBlock,
      __experimentalDirectInsert,
      template: template2,
      templateLock,
      wrapperRef,
      templateInsertUpdatesSelection,
      __experimentalCaptureToolbars: captureToolbars,
      __experimentalAppenderTagName,
      renderAppender,
      orientation,
      placeholder,
      layout,
      name,
      blockType,
      parentLock,
      defaultLayout: defaultLayout2
    } = props;
    useNestedSettingsUpdate(
      clientId,
      parentLock,
      allowedBlocks,
      prioritizedInserterBlocks,
      defaultBlock,
      directInsert,
      __experimentalDefaultBlock,
      __experimentalDirectInsert,
      templateLock,
      captureToolbars,
      orientation,
      layout
    );
    useInnerBlockTemplateSync(
      clientId,
      template2,
      templateLock,
      templateInsertUpdatesSelection
    );
    const defaultLayoutBlockSupport = (0, import_blocks39.getBlockSupport)(name, "layout") || (0, import_blocks39.getBlockSupport)(name, "__experimentalLayout") || EMPTY_OBJECT;
    const { allowSizingOnChildren = false } = defaultLayoutBlockSupport;
    const usedLayout = layout || defaultLayoutBlockSupport;
    const memoedLayout = (0, import_element85.useMemo)(
      () => ({
        // Default layout will know about any content/wide size defined by the theme.
        ...defaultLayout2,
        ...usedLayout,
        ...allowSizingOnChildren && {
          allowSizingOnChildren: true
        }
      }),
      [defaultLayout2, usedLayout, allowSizingOnChildren]
    );
    const items = /* @__PURE__ */ (0, import_jsx_runtime194.jsx)(
      BlockListItemsMemo,
      {
        rootClientId: clientId,
        renderAppender,
        __experimentalAppenderTagName,
        layout: memoedLayout,
        wrapperRef,
        placeholder
      }
    );
    if (!blockType?.providesContext || Object.keys(blockType.providesContext).length === 0) {
      return items;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime194.jsx)(BlockContext, { clientId, children: items });
  }
  function ControlledInnerBlocks(props) {
    useBlockSync(props);
    return /* @__PURE__ */ (0, import_jsx_runtime194.jsx)(UncontrolledInnerBlocks, { ...props });
  }
  var ForwardedInnerBlocks = (0, import_element85.forwardRef)((props, ref) => {
    const innerBlocksProps = useInnerBlocksProps({ ref }, props);
    return /* @__PURE__ */ (0, import_jsx_runtime194.jsx)("div", { className: "block-editor-inner-blocks", children: /* @__PURE__ */ (0, import_jsx_runtime194.jsx)("div", { ...innerBlocksProps }) });
  });
  function useInnerBlocksProps(props = {}, options = {}) {
    const {
      __unstableDisableLayoutClassNames,
      __unstableDisableDropZone,
      dropZoneElement
    } = options;
    const {
      clientId,
      layout = null,
      __unstableLayoutClassNames: layoutClassNames = ""
    } = useBlockEditContext();
    const selected = (0, import_data70.useSelect)(
      (select2) => {
        const {
          getBlockName: getBlockName2,
          isZoomOut: isZoomOut2,
          getTemplateLock: getTemplateLock2,
          getBlockRootClientId: getBlockRootClientId2,
          getBlockEditingMode: getBlockEditingMode2,
          getBlockSettings: getBlockSettings2,
          getSectionRootClientId: getSectionRootClientId2
        } = unlock(select2(store));
        if (!clientId) {
          const sectionRootClientId = getSectionRootClientId2();
          return {
            isDropZoneDisabled: isZoomOut2() && sectionRootClientId !== ""
          };
        }
        const { hasBlockSupport: hasBlockSupport43, getBlockType: getBlockType21 } = select2(import_blocks39.store);
        const blockName = getBlockName2(clientId);
        const blockEditingMode = getBlockEditingMode2(clientId);
        const parentClientId2 = getBlockRootClientId2(clientId);
        const [defaultLayout22] = getBlockSettings2(clientId, "layout");
        let _isDropZoneDisabled = blockEditingMode === "disabled";
        if (isZoomOut2()) {
          const sectionRootClientId = getSectionRootClientId2();
          _isDropZoneDisabled = clientId !== sectionRootClientId;
        }
        return {
          __experimentalCaptureToolbars: hasBlockSupport43(
            blockName,
            "__experimentalExposeControlsToChildren",
            false
          ),
          name: blockName,
          blockType: getBlockType21(blockName),
          parentLock: getTemplateLock2(parentClientId2),
          parentClientId: parentClientId2,
          isDropZoneDisabled: _isDropZoneDisabled,
          defaultLayout: defaultLayout22
        };
      },
      [clientId]
    );
    const {
      __experimentalCaptureToolbars,
      name,
      blockType,
      parentLock,
      parentClientId,
      isDropZoneDisabled,
      defaultLayout: defaultLayout2
    } = selected;
    const blockDropZoneRef = useBlockDropZone({
      dropZoneElement,
      rootClientId: clientId,
      parentClientId
    });
    const ref = (0, import_compose50.useMergeRefs)([
      props.ref,
      __unstableDisableDropZone || isDropZoneDisabled || layout?.isManualPlacement && window.__experimentalEnableGridInteractivity ? null : blockDropZoneRef
    ]);
    const innerBlocksProps = {
      __experimentalCaptureToolbars,
      layout,
      name,
      blockType,
      parentLock,
      defaultLayout: defaultLayout2,
      ...options
    };
    const InnerBlocks = innerBlocksProps.value && innerBlocksProps.onChange ? ControlledInnerBlocks : UncontrolledInnerBlocks;
    return {
      ...props,
      ref,
      className: clsx_default(
        props.className,
        "block-editor-block-list__layout",
        __unstableDisableLayoutClassNames ? "" : layoutClassNames
      ),
      children: clientId ? /* @__PURE__ */ (0, import_jsx_runtime194.jsx)(InnerBlocks, { ...innerBlocksProps, clientId }) : /* @__PURE__ */ (0, import_jsx_runtime194.jsx)(BlockListItems, { ...options })
    };
  }
  useInnerBlocksProps.save = import_blocks39.__unstableGetInnerBlocksProps;
  ForwardedInnerBlocks.DefaultBlockAppender = DefaultBlockAppender2;
  ForwardedInnerBlocks.ButtonBlockAppender = ButtonBlockAppender2;
  ForwardedInnerBlocks.Content = () => useInnerBlocksProps.save().children;
  var inner_blocks_default = ForwardedInnerBlocks;

  // packages/block-editor/build-module/components/observe-typing/index.js
  var import_jsx_runtime195 = __toESM(require_jsx_runtime());
  var import_compose51 = __toESM(require_compose());
  var import_data71 = __toESM(require_data());
  var import_dom23 = __toESM(require_dom());
  var import_keycodes8 = __toESM(require_keycodes());
  var KEY_DOWN_ELIGIBLE_KEY_CODES = /* @__PURE__ */ new Set([
    import_keycodes8.UP,
    import_keycodes8.RIGHT,
    import_keycodes8.DOWN,
    import_keycodes8.LEFT,
    import_keycodes8.ENTER,
    import_keycodes8.BACKSPACE
  ]);
  function isKeyDownEligibleForStartTyping(event) {
    const { keyCode, shiftKey } = event;
    return !shiftKey && KEY_DOWN_ELIGIBLE_KEY_CODES.has(keyCode);
  }
  function useMouseMoveTypingReset() {
    const isTyping3 = (0, import_data71.useSelect)(
      (select2) => select2(store).isTyping(),
      []
    );
    const { stopTyping: stopTyping2 } = (0, import_data71.useDispatch)(store);
    return (0, import_compose51.useRefEffect)(
      (node2) => {
        if (!isTyping3) {
          return;
        }
        const { ownerDocument } = node2;
        let lastClientX;
        let lastClientY;
        function stopTypingOnMouseMove(event) {
          const { clientX, clientY } = event;
          if (lastClientX && lastClientY && (lastClientX !== clientX || lastClientY !== clientY)) {
            stopTyping2();
          }
          lastClientX = clientX;
          lastClientY = clientY;
        }
        ownerDocument.addEventListener(
          "mousemove",
          stopTypingOnMouseMove
        );
        return () => {
          ownerDocument.removeEventListener(
            "mousemove",
            stopTypingOnMouseMove
          );
        };
      },
      [isTyping3, stopTyping2]
    );
  }
  function useTypingObserver() {
    const { isTyping: isTyping3 } = (0, import_data71.useSelect)((select2) => {
      const { isTyping: _isTyping } = select2(store);
      return {
        isTyping: _isTyping()
      };
    }, []);
    const { startTyping: startTyping2, stopTyping: stopTyping2 } = (0, import_data71.useDispatch)(store);
    const ref1 = useMouseMoveTypingReset();
    const ref2 = (0, import_compose51.useRefEffect)(
      (node2) => {
        const { ownerDocument } = node2;
        const { defaultView } = ownerDocument;
        const selection2 = defaultView.getSelection();
        if (isTyping3) {
          let stopTypingOnNonTextField2 = function(event) {
            const { target } = event;
            timerId = defaultView.setTimeout(() => {
              if (!(0, import_dom23.isTextField)(target)) {
                stopTyping2();
              }
            });
          }, stopTypingOnEscapeKey2 = function(event) {
            const { keyCode } = event;
            if (keyCode === import_keycodes8.ESCAPE || keyCode === import_keycodes8.TAB) {
              stopTyping2();
            }
          }, stopTypingOnSelectionUncollapse2 = function() {
            if (!selection2.isCollapsed) {
              stopTyping2();
            }
          };
          var stopTypingOnNonTextField = stopTypingOnNonTextField2, stopTypingOnEscapeKey = stopTypingOnEscapeKey2, stopTypingOnSelectionUncollapse = stopTypingOnSelectionUncollapse2;
          let timerId;
          node2.addEventListener("focus", stopTypingOnNonTextField2);
          node2.addEventListener("keydown", stopTypingOnEscapeKey2);
          ownerDocument.addEventListener(
            "selectionchange",
            stopTypingOnSelectionUncollapse2
          );
          return () => {
            defaultView.clearTimeout(timerId);
            node2.removeEventListener(
              "focus",
              stopTypingOnNonTextField2
            );
            node2.removeEventListener(
              "keydown",
              stopTypingOnEscapeKey2
            );
            ownerDocument.removeEventListener(
              "selectionchange",
              stopTypingOnSelectionUncollapse2
            );
          };
        }
        function startTypingInTextField(event) {
          const { type, target } = event;
          if (!(0, import_dom23.isTextField)(target) || !node2.contains(target)) {
            return;
          }
          if (type === "keydown" && !isKeyDownEligibleForStartTyping(event)) {
            return;
          }
          startTyping2();
        }
        node2.addEventListener("keypress", startTypingInTextField);
        node2.addEventListener("keydown", startTypingInTextField);
        return () => {
          node2.removeEventListener("keypress", startTypingInTextField);
          node2.removeEventListener("keydown", startTypingInTextField);
        };
      },
      [isTyping3, startTyping2, stopTyping2]
    );
    return (0, import_compose51.useMergeRefs)([ref1, ref2]);
  }
  function ObserveTyping({ children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime195.jsx)("div", { ref: useTypingObserver(), children });
  }
  var observe_typing_default = ObserveTyping;

  // packages/block-editor/build-module/components/block-list/zoom-out-separator.js
  var import_jsx_runtime196 = __toESM(require_jsx_runtime());
  var import_components62 = __toESM(require_components());
  var import_compose52 = __toESM(require_compose());
  var import_data72 = __toESM(require_data());
  var import_element86 = __toESM(require_element());
  var import_i18n64 = __toESM(require_i18n());
  function ZoomOutSeparator({
    clientId,
    rootClientId = "",
    position: position2 = "top"
  }) {
    const [isDraggedOver, setIsDraggedOver] = (0, import_element86.useState)(false);
    const {
      sectionRootClientId,
      sectionClientIds,
      insertionPoint: insertionPoint2,
      blockInsertionPointVisible,
      blockInsertionPoint,
      blocksBeingDragged
    } = (0, import_data72.useSelect)((select2) => {
      const {
        getInsertionPoint: getInsertionPoint2,
        getBlockOrder: getBlockOrder2,
        getSectionRootClientId: getSectionRootClientId2,
        isBlockInsertionPointVisible: isBlockInsertionPointVisible2,
        getBlockInsertionPoint: getBlockInsertionPoint2,
        getDraggedBlockClientIds: getDraggedBlockClientIds2
      } = unlock(select2(store));
      const root = getSectionRootClientId2();
      const sectionRootClientIds = getBlockOrder2(root);
      return {
        sectionRootClientId: root,
        sectionClientIds: sectionRootClientIds,
        insertionPoint: getInsertionPoint2(),
        blockInsertionPoint: getBlockInsertionPoint2(),
        blockInsertionPointVisible: isBlockInsertionPointVisible2(),
        blocksBeingDragged: getDraggedBlockClientIds2()
      };
    }, []);
    const isReducedMotion = (0, import_compose52.useReducedMotion)();
    if (!clientId) {
      return;
    }
    let isVisible = false;
    const isSectionBlock2 = rootClientId === sectionRootClientId && sectionClientIds && sectionClientIds.includes(clientId);
    if (!isSectionBlock2) {
      return null;
    }
    const hasTopInsertionPoint = insertionPoint2?.index === 0 && clientId === sectionClientIds[insertionPoint2.index];
    const hasBottomInsertionPoint = insertionPoint2 && insertionPoint2.hasOwnProperty("index") && clientId === sectionClientIds[insertionPoint2.index - 1];
    if (position2 === "top") {
      isVisible = hasTopInsertionPoint || blockInsertionPointVisible && blockInsertionPoint.index === 0 && clientId === sectionClientIds[blockInsertionPoint.index];
    }
    if (position2 === "bottom") {
      isVisible = hasBottomInsertionPoint || blockInsertionPointVisible && clientId === sectionClientIds[blockInsertionPoint.index - 1];
    }
    const blockBeingDraggedClientId = blocksBeingDragged[0];
    const isCurrentBlockBeingDragged = blocksBeingDragged.includes(clientId);
    const blockBeingDraggedIndex = sectionClientIds.indexOf(
      blockBeingDraggedClientId
    );
    const blockBeingDraggedPreviousSiblingClientId = blockBeingDraggedIndex > 0 ? sectionClientIds[blockBeingDraggedIndex - 1] : null;
    const isCurrentBlockPreviousSiblingOfBlockBeingDragged = blockBeingDraggedPreviousSiblingClientId === clientId;
    if (isCurrentBlockBeingDragged || isCurrentBlockPreviousSiblingOfBlockBeingDragged) {
      isVisible = false;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime196.jsx)(import_components62.__unstableAnimatePresence, { children: isVisible && /* @__PURE__ */ (0, import_jsx_runtime196.jsx)(
      import_components62.__unstableMotion.div,
      {
        initial: { height: 0 },
        animate: {
          // Use a height equal to that of the zoom out frame size.
          height: "calc(1 * var(--wp-block-editor-iframe-zoom-out-frame-size) / var(--wp-block-editor-iframe-zoom-out-scale)"
        },
        exit: { height: 0 },
        transition: {
          type: "tween",
          duration: isReducedMotion ? 0 : 0.2,
          ease: [0.6, 0, 0.4, 1]
        },
        className: clsx_default(
          "block-editor-block-list__zoom-out-separator",
          {
            "is-dragged-over": isDraggedOver
          }
        ),
        "data-is-insertion-point": "true",
        onDragOver: () => setIsDraggedOver(true),
        onDragLeave: () => setIsDraggedOver(false),
        children: /* @__PURE__ */ (0, import_jsx_runtime196.jsx)(
          import_components62.__unstableMotion.div,
          {
            initial: { opacity: 0 },
            animate: { opacity: 1 },
            exit: { opacity: 0, transition: { delay: -0.125 } },
            transition: {
              ease: "linear",
              duration: 0.1,
              delay: 0.125
            },
            children: (0, import_i18n64.__)("Drop pattern.")
          }
        )
      }
    ) });
  }

  // packages/block-editor/build-module/components/block-list/index.js
  var IntersectionObserver = (0, import_element87.createContext)();
  IntersectionObserver.displayName = "IntersectionObserverContext";
  var pendingBlockVisibilityUpdatesPerRegistry = /* @__PURE__ */ new WeakMap();
  var delayedBlockVisibilityDebounceOptions = {
    trailing: true
  };
  function Root({ className, ...settings2 }) {
    const { isOutlineMode, isFocusMode, temporarilyEditingAsBlocks: temporarilyEditingAsBlocks2 } = (0, import_data73.useSelect)((select2) => {
      const {
        getSettings: getSettings4,
        getTemporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks2,
        isTyping: isTyping3,
        hasBlockSpotlight: hasBlockSpotlight3
      } = unlock(select2(store));
      const { outlineMode, focusMode } = getSettings4();
      return {
        isOutlineMode: outlineMode && !isTyping3(),
        isFocusMode: focusMode || hasBlockSpotlight3(),
        temporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks2()
      };
    }, []);
    const registry = (0, import_data73.useRegistry)();
    const { setBlockVisibility: setBlockVisibility2 } = (0, import_data73.useDispatch)(store);
    const delayedBlockVisibilityUpdates = (0, import_compose53.useDebounce)(
      (0, import_element87.useCallback)(() => {
        const updates = {};
        pendingBlockVisibilityUpdatesPerRegistry.get(registry).forEach(([id, isIntersecting]) => {
          updates[id] = isIntersecting;
        });
        setBlockVisibility2(updates);
      }, [registry]),
      300,
      delayedBlockVisibilityDebounceOptions
    );
    const intersectionObserver = (0, import_element87.useMemo)(() => {
      const { IntersectionObserver: Observer } = window;
      if (!Observer) {
        return;
      }
      return new Observer((entries) => {
        if (!pendingBlockVisibilityUpdatesPerRegistry.get(registry)) {
          pendingBlockVisibilityUpdatesPerRegistry.set(registry, []);
        }
        for (const entry of entries) {
          const clientId = entry.target.getAttribute("data-block");
          pendingBlockVisibilityUpdatesPerRegistry.get(registry).push([clientId, entry.isIntersecting]);
        }
        delayedBlockVisibilityUpdates();
      });
    }, []);
    const innerBlocksProps = useInnerBlocksProps(
      {
        ref: (0, import_compose53.useMergeRefs)([
          useBlockSelectionClearer(),
          useInBetweenInserter(),
          useTypingObserver()
        ]),
        className: clsx_default("is-root-container", className, {
          "is-outline-mode": isOutlineMode,
          "is-focus-mode": isFocusMode
        })
      },
      settings2
    );
    return /* @__PURE__ */ (0, import_jsx_runtime197.jsxs)(IntersectionObserver.Provider, { value: intersectionObserver, children: [
      /* @__PURE__ */ (0, import_jsx_runtime197.jsx)("div", { ...innerBlocksProps }),
      !!temporarilyEditingAsBlocks2 && /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(
        StopEditingAsBlocksOnOutsideSelect,
        {
          clientId: temporarilyEditingAsBlocks2
        }
      )
    ] });
  }
  function StopEditingAsBlocksOnOutsideSelect({ clientId }) {
    const { stopEditingAsBlocks: stopEditingAsBlocks2 } = unlock((0, import_data73.useDispatch)(store));
    const isBlockOrDescendantSelected = (0, import_data73.useSelect)(
      (select2) => {
        const { isBlockSelected: isBlockSelected2, hasSelectedInnerBlock: hasSelectedInnerBlock2 } = select2(store);
        return isBlockSelected2(clientId) || hasSelectedInnerBlock2(clientId, true);
      },
      [clientId]
    );
    (0, import_element87.useEffect)(() => {
      if (!isBlockOrDescendantSelected) {
        stopEditingAsBlocks2(clientId);
      }
    }, [isBlockOrDescendantSelected, clientId, stopEditingAsBlocks2]);
    return null;
  }
  function BlockList(settings2) {
    return /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(Provider, { value: DEFAULT_BLOCK_EDIT_CONTEXT, children: /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(Root, { ...settings2 }) });
  }
  var EMPTY_ARRAY7 = [];
  var EMPTY_SET2 = /* @__PURE__ */ new Set();
  function Items({
    placeholder,
    rootClientId,
    renderAppender: CustomAppender,
    __experimentalAppenderTagName,
    layout = defaultLayout
  }) {
    const hasAppender = CustomAppender !== false;
    const hasCustomAppender = !!CustomAppender;
    const {
      order,
      isZoomOut: isZoomOut2,
      selectedBlocks,
      visibleBlocks,
      shouldRenderAppender
    } = (0, import_data73.useSelect)(
      (select2) => {
        const {
          getSettings: getSettings4,
          getBlockOrder: getBlockOrder2,
          getSelectedBlockClientIds: getSelectedBlockClientIds2,
          __unstableGetVisibleBlocks: __unstableGetVisibleBlocks2,
          getTemplateLock: getTemplateLock2,
          getBlockEditingMode: getBlockEditingMode2,
          isSectionBlock: isSectionBlock2,
          isContainerInsertableToInWriteMode: isContainerInsertableToInWriteMode2,
          getBlockName: getBlockName2,
          isZoomOut: _isZoomOut,
          canInsertBlockType: canInsertBlockType2
        } = unlock(select2(store));
        const _order = getBlockOrder2(rootClientId);
        if (getSettings4().isPreviewMode) {
          return {
            order: _order,
            selectedBlocks: EMPTY_ARRAY7,
            visibleBlocks: EMPTY_SET2
          };
        }
        const selectedBlockClientIds = getSelectedBlockClientIds2();
        const selectedBlockClientId = selectedBlockClientIds[0];
        const showRootAppender = !rootClientId && !selectedBlockClientId && (!_order.length || !canInsertBlockType2(
          (0, import_blocks40.getDefaultBlockName)(),
          rootClientId
        ));
        const hasSelectedRoot = !!(rootClientId && selectedBlockClientId && rootClientId === selectedBlockClientId);
        return {
          order: _order,
          selectedBlocks: selectedBlockClientIds,
          visibleBlocks: __unstableGetVisibleBlocks2(),
          isZoomOut: _isZoomOut(),
          shouldRenderAppender: (!isSectionBlock2(rootClientId) || isContainerInsertableToInWriteMode2(
            getBlockName2(selectedBlockClientId),
            rootClientId
          )) && getBlockEditingMode2(rootClientId) !== "disabled" && !getTemplateLock2(rootClientId) && hasAppender && !_isZoomOut() && (hasCustomAppender || hasSelectedRoot || showRootAppender)
        };
      },
      [rootClientId, hasAppender, hasCustomAppender]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime197.jsxs)(LayoutProvider, { value: layout, children: [
      order.map((clientId) => /* @__PURE__ */ (0, import_jsx_runtime197.jsxs)(
        import_data73.AsyncModeProvider,
        {
          value: (
            // Only provide data asynchronously if the block is
            // not visible and not selected.
            !visibleBlocks.has(clientId) && !selectedBlocks.includes(clientId)
          ),
          children: [
            isZoomOut2 && /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(
              ZoomOutSeparator,
              {
                clientId,
                rootClientId,
                position: "top"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(
              block_default2,
              {
                rootClientId,
                clientId
              }
            ),
            isZoomOut2 && /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(
              ZoomOutSeparator,
              {
                clientId,
                rootClientId,
                position: "bottom"
              }
            )
          ]
        },
        clientId
      )),
      order.length < 1 && placeholder,
      shouldRenderAppender && /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(
        BlockListAppender,
        {
          tagName: __experimentalAppenderTagName,
          rootClientId,
          CustomAppender
        }
      )
    ] });
  }
  function BlockListItems(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(import_data73.AsyncModeProvider, { value: false, children: /* @__PURE__ */ (0, import_jsx_runtime197.jsx)(Items, { ...props }) });
  }

  // packages/block-editor/build-module/components/block-tools/index.js
  var import_jsx_runtime286 = __toESM(require_jsx_runtime());
  var import_data126 = __toESM(require_data());
  var import_dom33 = __toESM(require_dom());
  var import_components149 = __toESM(require_components());
  var import_keyboard_shortcuts8 = __toESM(require_keyboard_shortcuts());
  var import_element154 = __toESM(require_element());
  var import_blocks74 = __toESM(require_blocks());
  var import_a11y13 = __toESM(require_a11y());
  var import_i18n145 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-tools/empty-block-inserter.js
  var import_jsx_runtime204 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/block-tools/use-block-toolbar-popover-props.js
  var import_compose56 = __toESM(require_compose());
  var import_data77 = __toESM(require_data());
  var import_dom24 = __toESM(require_dom());
  var import_element92 = __toESM(require_element());

  // packages/block-editor/build-module/hooks/position.js
  var import_jsx_runtime203 = __toESM(require_jsx_runtime());
  var import_i18n69 = __toESM(require_i18n());
  var import_blocks42 = __toESM(require_blocks());
  var import_components68 = __toESM(require_components());
  var import_compose55 = __toESM(require_compose());
  var import_data76 = __toESM(require_data());
  var import_element91 = __toESM(require_element());

  // packages/block-editor/build-module/components/inspector-controls/index.js
  var import_jsx_runtime202 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/inspector-controls/fill.js
  var import_jsx_runtime198 = __toESM(require_jsx_runtime());
  var import_components64 = __toESM(require_components());
  var import_warning5 = __toESM(require_warning());
  var import_deprecated10 = __toESM(require_deprecated());
  var import_element88 = __toESM(require_element());

  // packages/block-editor/build-module/components/inspector-controls/groups.js
  var import_components63 = __toESM(require_components());
  var InspectorControlsDefault = (0, import_components63.createSlotFill)("InspectorControls");
  var InspectorControlsAdvanced = (0, import_components63.createSlotFill)("InspectorAdvancedControls");
  var InspectorControlsBindings = (0, import_components63.createSlotFill)("InspectorControlsBindings");
  var InspectorControlsBackground = (0, import_components63.createSlotFill)(
    "InspectorControlsBackground"
  );
  var InspectorControlsBorder = (0, import_components63.createSlotFill)("InspectorControlsBorder");
  var InspectorControlsColor = (0, import_components63.createSlotFill)("InspectorControlsColor");
  var InspectorControlsFilter = (0, import_components63.createSlotFill)("InspectorControlsFilter");
  var InspectorControlsDimensions = (0, import_components63.createSlotFill)(
    "InspectorControlsDimensions"
  );
  var InspectorControlsPosition = (0, import_components63.createSlotFill)("InspectorControlsPosition");
  var InspectorControlsTypography = (0, import_components63.createSlotFill)(
    "InspectorControlsTypography"
  );
  var InspectorControlsListView = (0, import_components63.createSlotFill)("InspectorControlsListView");
  var InspectorControlsStyles = (0, import_components63.createSlotFill)("InspectorControlsStyles");
  var InspectorControlsEffects = (0, import_components63.createSlotFill)("InspectorControlsEffects");
  var groups = {
    default: InspectorControlsDefault,
    advanced: InspectorControlsAdvanced,
    background: InspectorControlsBackground,
    bindings: InspectorControlsBindings,
    border: InspectorControlsBorder,
    color: InspectorControlsColor,
    dimensions: InspectorControlsDimensions,
    effects: InspectorControlsEffects,
    filter: InspectorControlsFilter,
    list: InspectorControlsListView,
    position: InspectorControlsPosition,
    settings: InspectorControlsDefault,
    // Alias for default.
    styles: InspectorControlsStyles,
    typography: InspectorControlsTypography
  };
  var groups_default = groups;
  var PrivateInspectorControlsAllowedBlocks = (0, import_components63.createSlotFill)(
    Symbol("PrivateInspectorControlsAllowedBlocks")
  );

  // packages/block-editor/build-module/components/inspector-controls/fill.js
  function InspectorControlsFill({
    children,
    group = "default",
    __experimentalGroup,
    resetAllFilter
  }) {
    if (__experimentalGroup) {
      (0, import_deprecated10.default)(
        "`__experimentalGroup` property in `InspectorControlsFill`",
        {
          since: "6.2",
          version: "6.4",
          alternative: "`group`"
        }
      );
      group = __experimentalGroup;
    }
    const context = useBlockEditContext();
    const Fill3 = groups_default[group]?.Fill;
    if (!Fill3) {
      (0, import_warning5.default)(`Unknown InspectorControls group "${group}" provided.`);
      return null;
    }
    if (!context[mayDisplayControlsKey]) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime198.jsx)(import_components64.__experimentalStyleProvider, { document, children: /* @__PURE__ */ (0, import_jsx_runtime198.jsx)(Fill3, { children: (fillProps) => {
      return /* @__PURE__ */ (0, import_jsx_runtime198.jsx)(
        ToolsPanelInspectorControl,
        {
          fillProps,
          children,
          resetAllFilter
        }
      );
    } }) });
  }
  function RegisterResetAll({ resetAllFilter, children }) {
    const { registerResetAllFilter, deregisterResetAllFilter } = (0, import_element88.useContext)(import_components64.__experimentalToolsPanelContext);
    (0, import_element88.useEffect)(() => {
      if (resetAllFilter && registerResetAllFilter && deregisterResetAllFilter) {
        registerResetAllFilter(resetAllFilter);
        return () => {
          deregisterResetAllFilter(resetAllFilter);
        };
      }
    }, [resetAllFilter, registerResetAllFilter, deregisterResetAllFilter]);
    return children;
  }
  function ToolsPanelInspectorControl({ children, resetAllFilter, fillProps }) {
    const { forwardedContext = [] } = fillProps;
    const innerMarkup = /* @__PURE__ */ (0, import_jsx_runtime198.jsx)(RegisterResetAll, { resetAllFilter, children });
    return forwardedContext.reduce(
      (inner, [Provider2, props]) => /* @__PURE__ */ (0, import_jsx_runtime198.jsx)(Provider2, { ...props, children: inner }),
      innerMarkup
    );
  }

  // packages/block-editor/build-module/components/inspector-controls/slot.js
  var import_jsx_runtime201 = __toESM(require_jsx_runtime());
  var import_components67 = __toESM(require_components());
  var import_warning6 = __toESM(require_warning());
  var import_deprecated11 = __toESM(require_deprecated());

  // packages/block-editor/build-module/components/inspector-controls/block-support-tools-panel.js
  var import_jsx_runtime199 = __toESM(require_jsx_runtime());
  var import_components65 = __toESM(require_components());
  var import_data74 = __toESM(require_data());
  var import_element89 = __toESM(require_element());

  // packages/block-editor/build-module/components/global-styles/utils.js
  var import_es63 = __toESM(require_es6());
  var import_compose54 = __toESM(require_compose());
  var import_style_engine2 = __toESM(require_style_engine());

  // packages/block-editor/build-module/utils/get-font-styles-and-weights.js
  var import_i18n67 = __toESM(require_i18n());

  // packages/block-editor/build-module/utils/format-font-style.js
  var import_i18n65 = __toESM(require_i18n());
  function formatFontStyle(fontStyle) {
    if (!fontStyle) {
      return {};
    }
    if (typeof fontStyle === "object") {
      return fontStyle;
    }
    let name;
    switch (fontStyle) {
      case "normal":
        name = (0, import_i18n65._x)("Regular", "font style");
        break;
      case "italic":
        name = (0, import_i18n65._x)("Italic", "font style");
        break;
      case "oblique":
        name = (0, import_i18n65._x)("Oblique", "font style");
        break;
      default:
        name = fontStyle;
        break;
    }
    return { name, value: fontStyle };
  }

  // packages/block-editor/build-module/utils/format-font-weight.js
  var import_i18n66 = __toESM(require_i18n());
  function formatFontWeight(fontWeight) {
    if (!fontWeight) {
      return {};
    }
    if (typeof fontWeight === "object") {
      return fontWeight;
    }
    let name;
    switch (fontWeight) {
      case "normal":
      case "400":
        name = (0, import_i18n66._x)("Regular", "font weight");
        break;
      case "bold":
      case "700":
        name = (0, import_i18n66._x)("Bold", "font weight");
        break;
      case "100":
        name = (0, import_i18n66._x)("Thin", "font weight");
        break;
      case "200":
        name = (0, import_i18n66._x)("Extra Light", "font weight");
        break;
      case "300":
        name = (0, import_i18n66._x)("Light", "font weight");
        break;
      case "500":
        name = (0, import_i18n66._x)("Medium", "font weight");
        break;
      case "600":
        name = (0, import_i18n66._x)("Semi Bold", "font weight");
        break;
      case "800":
        name = (0, import_i18n66._x)("Extra Bold", "font weight");
        break;
      case "900":
        name = (0, import_i18n66._x)("Black", "font weight");
        break;
      case "1000":
        name = (0, import_i18n66._x)("Extra Black", "font weight");
        break;
      default:
        name = fontWeight;
        break;
    }
    return { name, value: fontWeight };
  }

  // packages/block-editor/build-module/utils/get-font-styles-and-weights.js
  var FONT_STYLES = [
    {
      name: (0, import_i18n67._x)("Regular", "font style"),
      value: "normal"
    },
    {
      name: (0, import_i18n67._x)("Italic", "font style"),
      value: "italic"
    }
  ];
  var FONT_WEIGHTS = [
    {
      name: (0, import_i18n67._x)("Thin", "font weight"),
      value: "100"
    },
    {
      name: (0, import_i18n67._x)("Extra Light", "font weight"),
      value: "200"
    },
    {
      name: (0, import_i18n67._x)("Light", "font weight"),
      value: "300"
    },
    {
      name: (0, import_i18n67._x)("Regular", "font weight"),
      value: "400"
    },
    {
      name: (0, import_i18n67._x)("Medium", "font weight"),
      value: "500"
    },
    {
      name: (0, import_i18n67._x)("Semi Bold", "font weight"),
      value: "600"
    },
    {
      name: (0, import_i18n67._x)("Bold", "font weight"),
      value: "700"
    },
    {
      name: (0, import_i18n67._x)("Extra Bold", "font weight"),
      value: "800"
    },
    {
      name: (0, import_i18n67._x)("Black", "font weight"),
      value: "900"
    },
    {
      name: (0, import_i18n67._x)("Extra Black", "font weight"),
      value: "1000"
    }
  ];
  function getFontStylesAndWeights(fontFamilyFaces) {
    let fontStyles = [];
    let fontWeights = [];
    const combinedStyleAndWeightOptions = [];
    const isSystemFont = !fontFamilyFaces || fontFamilyFaces?.length === 0;
    let isVariableFont = false;
    fontFamilyFaces?.forEach((face) => {
      if ("string" === typeof face.fontWeight && /\s/.test(face.fontWeight.trim())) {
        isVariableFont = true;
        let [startValue, endValue] = face.fontWeight.split(" ");
        startValue = parseInt(startValue.slice(0, 1));
        if (endValue === "1000") {
          endValue = 10;
        } else {
          endValue = parseInt(endValue.slice(0, 1));
        }
        for (let i2 = startValue; i2 <= endValue; i2++) {
          const fontWeightValue = `${i2.toString()}00`;
          if (!fontWeights.some(
            (weight) => weight.value === fontWeightValue
          )) {
            fontWeights.push(formatFontWeight(fontWeightValue));
          }
        }
      }
      const fontWeight = formatFontWeight(
        "number" === typeof face.fontWeight ? face.fontWeight.toString() : face.fontWeight
      );
      const fontStyle = formatFontStyle(face.fontStyle);
      if (fontStyle && Object.keys(fontStyle).length) {
        if (!fontStyles.some(
          (style) => style.value === fontStyle.value
        )) {
          fontStyles.push(fontStyle);
        }
      }
      if (fontWeight && Object.keys(fontWeight).length) {
        if (!fontWeights.some(
          (weight) => weight.value === fontWeight.value
        )) {
          if (!isVariableFont) {
            fontWeights.push(fontWeight);
          }
        }
      }
    });
    if (!fontWeights.some((weight) => weight.value >= "600")) {
      fontWeights.push({
        name: (0, import_i18n67._x)("Bold", "font weight"),
        value: "700"
      });
    }
    if (!fontStyles.some((style) => style.value === "italic")) {
      fontStyles.push({
        name: (0, import_i18n67._x)("Italic", "font style"),
        value: "italic"
      });
    }
    if (isSystemFont) {
      fontStyles = FONT_STYLES;
      fontWeights = FONT_WEIGHTS;
    }
    fontStyles = fontStyles.length === 0 ? FONT_STYLES : fontStyles;
    fontWeights = fontWeights.length === 0 ? FONT_WEIGHTS : fontWeights;
    fontStyles.forEach(({ name: styleName, value: styleValue }) => {
      fontWeights.forEach(({ name: weightName, value: weightValue }) => {
        const optionName = styleValue === "normal" ? weightName : (0, import_i18n67.sprintf)(
          /* translators: 1: Font weight name. 2: Font style name. */
          (0, import_i18n67._x)("%1$s %2$s", "font"),
          weightName,
          styleName
        );
        combinedStyleAndWeightOptions.push({
          key: `${styleValue}-${weightValue}`,
          name: optionName,
          style: {
            fontStyle: styleValue,
            fontWeight: weightValue
          }
        });
      });
    });
    return {
      fontStyles,
      fontWeights,
      combinedStyleAndWeightOptions,
      isSystemFont,
      isVariableFont
    };
  }

  // packages/block-editor/build-module/components/global-styles/typography-utils.js
  function getTypographyFontSizeValue(preset, settings2) {
    const { size: defaultSize } = preset;
    if (!defaultSize || "0" === defaultSize || false === preset?.fluid) {
      return defaultSize;
    }
    if (!isFluidTypographyEnabled(settings2?.typography) && !isFluidTypographyEnabled(preset)) {
      return defaultSize;
    }
    let fluidTypographySettings = getFluidTypographyOptionsFromSettings(settings2);
    fluidTypographySettings = typeof fluidTypographySettings?.fluid === "object" ? fluidTypographySettings?.fluid : {};
    const fluidFontSizeValue = getComputedFluidTypographyValue({
      minimumFontSize: preset?.fluid?.min,
      maximumFontSize: preset?.fluid?.max,
      fontSize: defaultSize,
      minimumFontSizeLimit: fluidTypographySettings?.minFontSize,
      maximumViewportWidth: fluidTypographySettings?.maxViewportWidth,
      minimumViewportWidth: fluidTypographySettings?.minViewportWidth
    });
    if (!!fluidFontSizeValue) {
      return fluidFontSizeValue;
    }
    return defaultSize;
  }
  function isFluidTypographyEnabled(typographySettings) {
    const fluidSettings = typographySettings?.fluid;
    return true === fluidSettings || fluidSettings && typeof fluidSettings === "object" && Object.keys(fluidSettings).length > 0;
  }
  function getFluidTypographyOptionsFromSettings(settings2) {
    const typographySettings = settings2?.typography;
    const layoutSettings = settings2?.layout;
    const defaultMaxViewportWidth = getTypographyValueAndUnit(
      layoutSettings?.wideSize
    ) ? layoutSettings?.wideSize : null;
    return isFluidTypographyEnabled(typographySettings) && defaultMaxViewportWidth ? {
      fluid: {
        maxViewportWidth: defaultMaxViewportWidth,
        ...typographySettings.fluid
      }
    } : {
      fluid: typographySettings?.fluid
    };
  }
  function getMergedFontFamiliesAndFontFamilyFaces(settings2, selectedFontFamily) {
    const fontFamiliesFromSettings = settings2?.typography?.fontFamilies;
    const fontFamilies = ["default", "theme", "custom"].flatMap(
      (key) => fontFamiliesFromSettings?.[key] ?? []
    );
    const fontFamilyFaces = fontFamilies.find(
      (family) => family.fontFamily === selectedFontFamily
    )?.fontFace ?? [];
    return { fontFamilies, fontFamilyFaces };
  }
  function findNearestFontWeight(availableFontWeights, newFontWeightValue) {
    newFontWeightValue = "number" === typeof newFontWeightValue ? newFontWeightValue.toString() : newFontWeightValue;
    if (!newFontWeightValue || typeof newFontWeightValue !== "string") {
      return "";
    }
    if (!availableFontWeights || availableFontWeights.length === 0) {
      return newFontWeightValue;
    }
    const nearestFontWeight = availableFontWeights?.reduce(
      (nearest, { value: fw }) => {
        const currentDiff = Math.abs(
          parseInt(fw) - parseInt(newFontWeightValue)
        );
        const nearestDiff = Math.abs(
          parseInt(nearest) - parseInt(newFontWeightValue)
        );
        return currentDiff < nearestDiff ? fw : nearest;
      },
      availableFontWeights[0]?.value
    );
    return nearestFontWeight;
  }
  function findNearestFontStyle(availableFontStyles, newFontStyleValue) {
    if (typeof newFontStyleValue !== "string" || !newFontStyleValue) {
      return "";
    }
    const validStyles = ["normal", "italic", "oblique"];
    if (!validStyles.includes(newFontStyleValue)) {
      return "";
    }
    if (!availableFontStyles || availableFontStyles.length === 0 || availableFontStyles.find(
      (style) => style.value === newFontStyleValue
    )) {
      return newFontStyleValue;
    }
    if (newFontStyleValue === "oblique" && !availableFontStyles.find((style) => style.value === "oblique")) {
      return "italic";
    }
    return "";
  }
  function findNearestStyleAndWeight(fontFamilyFaces, fontStyle, fontWeight) {
    let nearestFontStyle = fontStyle;
    let nearestFontWeight = fontWeight;
    const { fontStyles, fontWeights, combinedStyleAndWeightOptions } = getFontStylesAndWeights(fontFamilyFaces);
    const hasFontStyle = fontStyles?.some(
      ({ value: fs }) => fs === fontStyle
    );
    const hasFontWeight = fontWeights?.some(
      ({ value: fw }) => fw?.toString() === fontWeight?.toString()
    );
    if (!hasFontStyle) {
      nearestFontStyle = fontStyle ? findNearestFontStyle(fontStyles, fontStyle) : combinedStyleAndWeightOptions?.find(
        (option) => option.style.fontWeight === findNearestFontWeight(fontWeights, fontWeight)
      )?.style?.fontStyle;
    }
    if (!hasFontWeight) {
      nearestFontWeight = fontWeight ? findNearestFontWeight(fontWeights, fontWeight) : combinedStyleAndWeightOptions?.find(
        (option) => option.style.fontStyle === (nearestFontStyle || fontStyle)
      )?.style?.fontWeight;
    }
    return { nearestFontStyle, nearestFontWeight };
  }

  // packages/block-editor/build-module/components/global-styles/utils.js
  var ROOT_BLOCK_SELECTOR = "body";
  var ROOT_CSS_PROPERTIES_SELECTOR = ":root";
  var PRESET_METADATA = [
    {
      path: ["color", "palette"],
      valueKey: "color",
      cssVarInfix: "color",
      classes: [
        { classSuffix: "color", propertyName: "color" },
        {
          classSuffix: "background-color",
          propertyName: "background-color"
        },
        {
          classSuffix: "border-color",
          propertyName: "border-color"
        }
      ]
    },
    {
      path: ["color", "gradients"],
      valueKey: "gradient",
      cssVarInfix: "gradient",
      classes: [
        {
          classSuffix: "gradient-background",
          propertyName: "background"
        }
      ]
    },
    {
      path: ["color", "duotone"],
      valueKey: "colors",
      cssVarInfix: "duotone",
      valueFunc: ({ slug }) => `url( '#wp-duotone-${slug}' )`,
      classes: []
    },
    {
      path: ["shadow", "presets"],
      valueKey: "shadow",
      cssVarInfix: "shadow",
      classes: []
    },
    {
      path: ["typography", "fontSizes"],
      valueFunc: (preset, settings2) => getTypographyFontSizeValue(preset, settings2),
      valueKey: "size",
      cssVarInfix: "font-size",
      classes: [{ classSuffix: "font-size", propertyName: "font-size" }]
    },
    {
      path: ["typography", "fontFamilies"],
      valueKey: "fontFamily",
      cssVarInfix: "font-family",
      classes: [
        { classSuffix: "font-family", propertyName: "font-family" }
      ]
    },
    {
      path: ["spacing", "spacingSizes"],
      valueKey: "size",
      cssVarInfix: "spacing",
      classes: []
    },
    {
      path: ["border", "radiusSizes"],
      valueKey: "size",
      cssVarInfix: "border-radius",
      classes: []
    }
  ];
  var STYLE_PATH_TO_CSS_VAR_INFIX = {
    "color.background": "color",
    "color.text": "color",
    "filter.duotone": "duotone",
    "elements.link.color.text": "color",
    "elements.link.:hover.color.text": "color",
    "elements.link.typography.fontFamily": "font-family",
    "elements.link.typography.fontSize": "font-size",
    "elements.button.color.text": "color",
    "elements.button.color.background": "color",
    "elements.caption.color.text": "color",
    "elements.button.typography.fontFamily": "font-family",
    "elements.button.typography.fontSize": "font-size",
    "elements.heading.color": "color",
    "elements.heading.color.background": "color",
    "elements.heading.typography.fontFamily": "font-family",
    "elements.heading.gradient": "gradient",
    "elements.heading.color.gradient": "gradient",
    "elements.h1.color": "color",
    "elements.h1.color.background": "color",
    "elements.h1.typography.fontFamily": "font-family",
    "elements.h1.color.gradient": "gradient",
    "elements.h2.color": "color",
    "elements.h2.color.background": "color",
    "elements.h2.typography.fontFamily": "font-family",
    "elements.h2.color.gradient": "gradient",
    "elements.h3.color": "color",
    "elements.h3.color.background": "color",
    "elements.h3.typography.fontFamily": "font-family",
    "elements.h3.color.gradient": "gradient",
    "elements.h4.color": "color",
    "elements.h4.color.background": "color",
    "elements.h4.typography.fontFamily": "font-family",
    "elements.h4.color.gradient": "gradient",
    "elements.h5.color": "color",
    "elements.h5.color.background": "color",
    "elements.h5.typography.fontFamily": "font-family",
    "elements.h5.color.gradient": "gradient",
    "elements.h6.color": "color",
    "elements.h6.color.background": "color",
    "elements.h6.typography.fontFamily": "font-family",
    "elements.h6.color.gradient": "gradient",
    "color.gradient": "gradient",
    shadow: "shadow",
    "typography.fontSize": "font-size",
    "typography.fontFamily": "font-family"
  };
  function useToolsPanelDropdownMenuProps() {
    const isMobile = (0, import_compose54.useViewportMatch)("medium", "<");
    return !isMobile ? {
      popoverProps: {
        placement: "left-start",
        // For non-mobile, inner sidebar width (248px) - button width (24px) - border (1px) + padding (16px) + spacing (20px)
        offset: 259
      }
    } : {};
  }
  function findInPresetsBy(features, blockName, presetPath, presetProperty, presetValueValue) {
    const orderedPresetsByOrigin = [
      getValueFromObjectPath(features, [
        "blocks",
        blockName,
        ...presetPath
      ]),
      getValueFromObjectPath(features, presetPath)
    ];
    for (const presetByOrigin of orderedPresetsByOrigin) {
      if (presetByOrigin) {
        const origins = ["custom", "theme", "default"];
        for (const origin of origins) {
          const presets = presetByOrigin[origin];
          if (presets) {
            const presetObject = presets.find(
              (preset) => preset[presetProperty] === presetValueValue
            );
            if (presetObject) {
              if (presetProperty === "slug") {
                return presetObject;
              }
              const highestPresetObjectWithSameSlug = findInPresetsBy(
                features,
                blockName,
                presetPath,
                "slug",
                presetObject.slug
              );
              if (highestPresetObjectWithSameSlug[presetProperty] === presetObject[presetProperty]) {
                return presetObject;
              }
              return void 0;
            }
          }
        }
      }
    }
  }
  function getPresetVariableFromValue(features, blockName, variableStylePath, presetPropertyValue) {
    if (!presetPropertyValue) {
      return presetPropertyValue;
    }
    const cssVarInfix = STYLE_PATH_TO_CSS_VAR_INFIX[variableStylePath];
    const metadata = PRESET_METADATA.find(
      (data) => data.cssVarInfix === cssVarInfix
    );
    if (!metadata) {
      return presetPropertyValue;
    }
    const { valueKey, path } = metadata;
    const presetObject = findInPresetsBy(
      features,
      blockName,
      path,
      valueKey,
      presetPropertyValue
    );
    if (!presetObject) {
      return presetPropertyValue;
    }
    return `var:preset|${cssVarInfix}|${presetObject.slug}`;
  }
  function getValueFromPresetVariable(features, blockName, variable, [presetType, slug]) {
    const metadata = PRESET_METADATA.find(
      (data) => data.cssVarInfix === presetType
    );
    if (!metadata) {
      return variable;
    }
    const presetObject = findInPresetsBy(
      features.settings,
      blockName,
      metadata.path,
      "slug",
      slug
    );
    if (presetObject) {
      const { valueKey } = metadata;
      const result = presetObject[valueKey];
      return getValueFromVariable(features, blockName, result);
    }
    return variable;
  }
  function getValueFromCustomVariable(features, blockName, variable, path) {
    const result = getValueFromObjectPath(features.settings, [
      "blocks",
      blockName,
      "custom",
      ...path
    ]) ?? getValueFromObjectPath(features.settings, ["custom", ...path]);
    if (!result) {
      return variable;
    }
    return getValueFromVariable(features, blockName, result);
  }
  function getValueFromVariable(features, blockName, variable) {
    if (!variable || typeof variable !== "string") {
      if (typeof variable?.ref === "string") {
        variable = getValueFromObjectPath(features, variable.ref);
        if (!variable || !!variable?.ref) {
          return variable;
        }
      } else {
        return variable;
      }
    }
    const USER_VALUE_PREFIX = "var:";
    const THEME_VALUE_PREFIX = "var(--wp--";
    const THEME_VALUE_SUFFIX = ")";
    let parsedVar;
    if (variable.startsWith(USER_VALUE_PREFIX)) {
      parsedVar = variable.slice(USER_VALUE_PREFIX.length).split("|");
    } else if (variable.startsWith(THEME_VALUE_PREFIX) && variable.endsWith(THEME_VALUE_SUFFIX)) {
      parsedVar = variable.slice(THEME_VALUE_PREFIX.length, -THEME_VALUE_SUFFIX.length).split("--");
    } else {
      return variable;
    }
    const [type, ...path] = parsedVar;
    if (type === "preset") {
      return getValueFromPresetVariable(
        features,
        blockName,
        variable,
        path
      );
    }
    if (type === "custom") {
      return getValueFromCustomVariable(
        features,
        blockName,
        variable,
        path
      );
    }
    return variable;
  }
  function scopeSelector(scope, selector3) {
    if (!scope || !selector3) {
      return selector3;
    }
    const scopes = scope.split(",");
    const selectors = selector3.split(",");
    const selectorsScoped = [];
    scopes.forEach((outer) => {
      selectors.forEach((inner) => {
        selectorsScoped.push(`${outer.trim()} ${inner.trim()}`);
      });
    });
    return selectorsScoped.join(", ");
  }
  function scopeFeatureSelectors(scope, selectors) {
    if (!scope || !selectors) {
      return;
    }
    const featureSelectors = {};
    Object.entries(selectors).forEach(([feature, selector3]) => {
      if (typeof selector3 === "string") {
        featureSelectors[feature] = scopeSelector(scope, selector3);
      }
      if (typeof selector3 === "object") {
        featureSelectors[feature] = {};
        Object.entries(selector3).forEach(
          ([subfeature, subfeatureSelector]) => {
            featureSelectors[feature][subfeature] = scopeSelector(
              scope,
              subfeatureSelector
            );
          }
        );
      }
    });
    return featureSelectors;
  }
  function appendToSelector(selector3, toAppend) {
    if (!selector3.includes(",")) {
      return selector3 + toAppend;
    }
    const selectors = selector3.split(",");
    const newSelectors = selectors.map((sel) => sel + toAppend);
    return newSelectors.join(",");
  }
  function areGlobalStyleConfigsEqual(original, variation) {
    if (typeof original !== "object" || typeof variation !== "object") {
      return original === variation;
    }
    return (0, import_es63.default)(original?.styles, variation?.styles) && (0, import_es63.default)(original?.settings, variation?.settings);
  }
  function getBlockStyleVariationSelector(variation, blockSelector) {
    const variationClass = `.is-style-${variation}`;
    if (!blockSelector) {
      return variationClass;
    }
    const ancestorRegex = /((?::\([^)]+\))?\s*)([^\s:]+)/;
    const addVariationClass = (_match, group1, group2) => {
      return group1 + group2 + variationClass;
    };
    const result = blockSelector.split(",").map((part) => part.replace(ancestorRegex, addVariationClass));
    return result.join(",");
  }
  function getResolvedThemeFilePath(file, themeFileURIs) {
    if (!file || !themeFileURIs || !Array.isArray(themeFileURIs)) {
      return file;
    }
    const uri = themeFileURIs.find(
      (themeFileUri) => themeFileUri?.name === file
    );
    if (!uri?.href) {
      return file;
    }
    return uri?.href;
  }
  function getResolvedRefValue(ruleValue, tree) {
    if (!ruleValue || !tree) {
      return ruleValue;
    }
    if (typeof ruleValue !== "string" && ruleValue?.ref) {
      const resolvedRuleValue = (0, import_style_engine2.getCSSValueFromRawStyle)(
        getValueFromObjectPath(tree, ruleValue.ref)
      );
      if (resolvedRuleValue?.ref) {
        return void 0;
      }
      if (resolvedRuleValue === void 0) {
        return ruleValue;
      }
      return resolvedRuleValue;
    }
    return ruleValue;
  }
  function getResolvedValue(ruleValue, tree) {
    if (!ruleValue || !tree) {
      return ruleValue;
    }
    const resolvedValue = getResolvedRefValue(ruleValue, tree);
    if (resolvedValue?.url) {
      resolvedValue.url = getResolvedThemeFilePath(
        resolvedValue.url,
        tree?._links?.["wp:theme-file"]
      );
    }
    return resolvedValue;
  }

  // packages/block-editor/build-module/components/inspector-controls/block-support-tools-panel.js
  function BlockSupportToolsPanel({ children, group, label }) {
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data74.useDispatch)(store);
    const {
      getBlockAttributes: getBlockAttributes3,
      getMultiSelectedBlockClientIds: getMultiSelectedBlockClientIds2,
      getSelectedBlockClientId: getSelectedBlockClientId2,
      hasMultiSelection: hasMultiSelection2
    } = (0, import_data74.useSelect)(store);
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const panelId = getSelectedBlockClientId2();
    const resetAll = (0, import_element89.useCallback)(
      (resetFilters = []) => {
        const newAttributes = {};
        const clientIds = hasMultiSelection2() ? getMultiSelectedBlockClientIds2() : [panelId];
        clientIds.forEach((clientId) => {
          const { style } = getBlockAttributes3(clientId);
          let newBlockAttributes = { style };
          resetFilters.forEach((resetFilter) => {
            newBlockAttributes = {
              ...newBlockAttributes,
              ...resetFilter(newBlockAttributes)
            };
          });
          newBlockAttributes = {
            ...newBlockAttributes,
            style: cleanEmptyObject(newBlockAttributes.style)
          };
          newAttributes[clientId] = newBlockAttributes;
        });
        updateBlockAttributes2(clientIds, newAttributes, true);
      },
      [
        getBlockAttributes3,
        getMultiSelectedBlockClientIds2,
        hasMultiSelection2,
        panelId,
        updateBlockAttributes2
      ]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime199.jsx)(
      import_components65.__experimentalToolsPanel,
      {
        className: `${group}-block-support-panel`,
        label,
        resetAll,
        panelId,
        hasInnerWrapper: true,
        shouldRenderPlaceholderItems: true,
        __experimentalFirstVisibleItemClass: "first",
        __experimentalLastVisibleItemClass: "last",
        dropdownMenuProps,
        children
      },
      panelId
    );
  }

  // packages/block-editor/build-module/components/inspector-controls/block-support-slot-container.js
  var import_jsx_runtime200 = __toESM(require_jsx_runtime());
  var import_components66 = __toESM(require_components());
  var import_element90 = __toESM(require_element());
  function BlockSupportSlotContainer({
    Slot: Slot6,
    fillProps,
    ...props
  }) {
    const toolsPanelContext = (0, import_element90.useContext)(import_components66.__experimentalToolsPanelContext);
    const computedFillProps = (0, import_element90.useMemo)(
      () => ({
        ...fillProps ?? {},
        forwardedContext: [
          ...fillProps?.forwardedContext ?? [],
          [import_components66.__experimentalToolsPanelContext.Provider, { value: toolsPanelContext }]
        ]
      }),
      [toolsPanelContext, fillProps]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime200.jsx)(Slot6, { ...props, fillProps: computedFillProps, bubblesVirtually: true });
  }

  // packages/block-editor/build-module/components/inspector-controls/slot.js
  function InspectorControlsSlot({
    __experimentalGroup,
    group = "default",
    label,
    fillProps,
    ...props
  }) {
    if (__experimentalGroup) {
      (0, import_deprecated11.default)(
        "`__experimentalGroup` property in `InspectorControlsSlot`",
        {
          since: "6.2",
          version: "6.4",
          alternative: "`group`"
        }
      );
      group = __experimentalGroup;
    }
    const slotFill = groups_default[group];
    const fills = (0, import_components67.__experimentalUseSlotFills)(slotFill?.name);
    if (!slotFill) {
      (0, import_warning6.default)(`Unknown InspectorControls group "${group}" provided.`);
      return null;
    }
    if (!fills?.length) {
      return null;
    }
    const { Slot: Slot6 } = slotFill;
    if (label) {
      return /* @__PURE__ */ (0, import_jsx_runtime201.jsx)(BlockSupportToolsPanel, { group, label, children: /* @__PURE__ */ (0, import_jsx_runtime201.jsx)(
        BlockSupportSlotContainer,
        {
          ...props,
          fillProps,
          Slot: Slot6
        }
      ) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime201.jsx)(Slot6, { ...props, fillProps, bubblesVirtually: true });
  }

  // packages/block-editor/build-module/components/inspector-controls/index.js
  var InspectorControls = InspectorControlsFill;
  InspectorControls.Slot = InspectorControlsSlot;
  var InspectorAdvancedControls = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime202.jsx)(InspectorControlsFill, { ...props, group: "advanced" });
  };
  InspectorAdvancedControls.Slot = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime202.jsx)(InspectorControlsSlot, { ...props, group: "advanced" });
  };
  InspectorAdvancedControls.slotName = "InspectorAdvancedControls";
  var inspector_controls_default = InspectorControls;

  // packages/block-editor/build-module/components/use-block-display-information/index.js
  var import_data75 = __toESM(require_data());
  var import_blocks41 = __toESM(require_blocks());
  var import_i18n68 = __toESM(require_i18n());
  function getPositionTypeLabel(attributes) {
    const positionType = attributes?.style?.position?.type;
    if (positionType === "sticky") {
      return (0, import_i18n68.__)("Sticky");
    }
    if (positionType === "fixed") {
      return (0, import_i18n68.__)("Fixed");
    }
    return null;
  }
  function useBlockDisplayInformation(clientId) {
    return (0, import_data75.useSelect)(
      (select2) => {
        if (!clientId) {
          return null;
        }
        const { getBlockName: getBlockName2, getBlockAttributes: getBlockAttributes3 } = select2(store);
        const { getBlockType: getBlockType21, getActiveBlockVariation } = select2(import_blocks41.store);
        const blockName = getBlockName2(clientId);
        const blockType = getBlockType21(blockName);
        if (!blockType) {
          return null;
        }
        const attributes = getBlockAttributes3(clientId);
        const match2 = getActiveBlockVariation(blockName, attributes);
        const isSynced = (0, import_blocks41.isReusableBlock)(blockType) || (0, import_blocks41.isTemplatePart)(blockType);
        const syncedTitle = isSynced ? (0, import_blocks41.__experimentalGetBlockLabel)(blockType, attributes) : void 0;
        const title = syncedTitle || blockType.title;
        const positionLabel = getPositionTypeLabel(attributes);
        const blockTypeInfo = {
          isSynced,
          title,
          icon: blockType.icon,
          description: blockType.description,
          anchor: attributes?.anchor,
          positionLabel,
          positionType: attributes?.style?.position?.type,
          name: attributes?.metadata?.name
        };
        if (!match2) {
          return blockTypeInfo;
        }
        return {
          isSynced,
          title: match2.title || blockType.title,
          icon: match2.icon || blockType.icon,
          description: match2.description || blockType.description,
          anchor: attributes?.anchor,
          positionLabel,
          positionType: attributes?.style?.position?.type,
          name: attributes?.metadata?.name
        };
      },
      [clientId]
    );
  }

  // packages/block-editor/build-module/hooks/position.js
  var POSITION_SUPPORT_KEY = "position";
  var DEFAULT_OPTION = {
    key: "default",
    value: "",
    name: (0, import_i18n69.__)("Default")
  };
  var STICKY_OPTION = {
    key: "sticky",
    value: "sticky",
    name: (0, import_i18n69._x)("Sticky", "Name for the value of the CSS position property"),
    hint: (0, import_i18n69.__)(
      "The block will stick to the top of the window instead of scrolling."
    )
  };
  var FIXED_OPTION = {
    key: "fixed",
    value: "fixed",
    name: (0, import_i18n69._x)("Fixed", "Name for the value of the CSS position property"),
    hint: (0, import_i18n69.__)("The block will not move when the page is scrolled.")
  };
  var POSITION_SIDES = ["top", "right", "bottom", "left"];
  var VALID_POSITION_TYPES = ["sticky", "fixed"];
  function getPositionCSS({ selector: selector3, style }) {
    let output = "";
    const { type: positionType } = style?.position || {};
    if (!VALID_POSITION_TYPES.includes(positionType)) {
      return output;
    }
    output += `${selector3} {`;
    output += `position: ${positionType};`;
    POSITION_SIDES.forEach((side) => {
      if (style?.position?.[side] !== void 0) {
        output += `${side}: ${style.position[side]};`;
      }
    });
    if (positionType === "sticky" || positionType === "fixed") {
      output += `z-index: 10`;
    }
    output += `}`;
    return output;
  }
  function hasStickyPositionSupport(blockType) {
    const support = (0, import_blocks42.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
    return !!(true === support || support?.sticky);
  }
  function hasFixedPositionSupport(blockType) {
    const support = (0, import_blocks42.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
    return !!(true === support || support?.fixed);
  }
  function hasPositionSupport(blockType) {
    const support = (0, import_blocks42.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
    return !!support;
  }
  function hasStickyOrFixedPositionValue(attributes) {
    const positionType = attributes?.style?.position?.type;
    return positionType === "sticky" || positionType === "fixed";
  }
  function useIsPositionDisabled({ name: blockName } = {}) {
    const [allowFixed, allowSticky] = useSettings(
      "position.fixed",
      "position.sticky"
    );
    const isDisabled = !allowFixed && !allowSticky;
    return !hasPositionSupport(blockName) || isDisabled;
  }
  function PositionPanelPure({
    style = {},
    clientId,
    name: blockName,
    setAttributes
  }) {
    const allowFixed = hasFixedPositionSupport(blockName);
    const allowSticky = hasStickyPositionSupport(blockName);
    const value = style?.position?.type;
    const { firstParentClientId } = (0, import_data76.useSelect)(
      (select2) => {
        const { getBlockParents: getBlockParents2 } = select2(store);
        const parents = getBlockParents2(clientId);
        return { firstParentClientId: parents[parents.length - 1] };
      },
      [clientId]
    );
    const blockInformation = useBlockDisplayInformation(firstParentClientId);
    const stickyHelpText = allowSticky && value === STICKY_OPTION.value && blockInformation ? (0, import_i18n69.sprintf)(
      /* translators: %s: the name of the parent block. */
      (0, import_i18n69.__)(
        "The block will stick to the scrollable area of the parent %s block."
      ),
      blockInformation.title
    ) : null;
    const options = (0, import_element91.useMemo)(() => {
      const availableOptions = [DEFAULT_OPTION];
      if (allowSticky || value === STICKY_OPTION.value) {
        availableOptions.push(STICKY_OPTION);
      }
      if (allowFixed || value === FIXED_OPTION.value) {
        availableOptions.push(FIXED_OPTION);
      }
      return availableOptions;
    }, [allowFixed, allowSticky, value]);
    const onChangeType = (next2) => {
      const placementValue = "0px";
      const newStyle = {
        ...style,
        position: {
          ...style?.position,
          type: next2,
          top: next2 === "sticky" || next2 === "fixed" ? placementValue : void 0
        }
      };
      setAttributes({
        style: cleanEmptyObject(newStyle)
      });
    };
    const selectedOption = value ? options.find((option) => option.value === value) || DEFAULT_OPTION : DEFAULT_OPTION;
    return import_element91.Platform.select({
      web: options.length > 1 ? /* @__PURE__ */ (0, import_jsx_runtime203.jsx)(inspector_controls_default, { group: "position", children: /* @__PURE__ */ (0, import_jsx_runtime203.jsx)(
        import_components68.BaseControl,
        {
          __nextHasNoMarginBottom: true,
          help: stickyHelpText,
          children: /* @__PURE__ */ (0, import_jsx_runtime203.jsx)(
            import_components68.CustomSelectControl,
            {
              __next40pxDefaultSize: true,
              label: (0, import_i18n69.__)("Position"),
              hideLabelFromVision: true,
              describedBy: (0, import_i18n69.sprintf)(
                // translators: %s: Currently selected position.
                (0, import_i18n69.__)("Currently selected position: %s"),
                selectedOption.name
              ),
              options,
              value: selectedOption,
              onChange: ({ selectedItem }) => {
                onChangeType(selectedItem.value);
              },
              size: "__unstable-large"
            }
          )
        }
      ) }) : null,
      native: null
    });
  }
  var position_default = {
    edit: function Edit2(props) {
      const isPositionDisabled = useIsPositionDisabled(props);
      if (isPositionDisabled) {
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime203.jsx)(PositionPanelPure, { ...props });
    },
    useBlockProps: useBlockProps2,
    attributeKeys: ["style"],
    hasSupport(name) {
      return (0, import_blocks42.hasBlockSupport)(name, POSITION_SUPPORT_KEY);
    }
  };
  var POSITION_BLOCK_PROPS_REFERENCE = {};
  function useBlockProps2({ name, style }) {
    const hasPositionBlockSupport = (0, import_blocks42.hasBlockSupport)(
      name,
      POSITION_SUPPORT_KEY
    );
    const isPositionDisabled = useIsPositionDisabled({ name });
    const allowPositionStyles = hasPositionBlockSupport && !isPositionDisabled;
    const id = (0, import_compose55.useInstanceId)(POSITION_BLOCK_PROPS_REFERENCE);
    const positionSelector = `.wp-container-${id}.wp-container-${id}`;
    let css;
    if (allowPositionStyles) {
      css = getPositionCSS({
        selector: positionSelector,
        style
      }) || "";
    }
    const className = clsx_default({
      [`wp-container-${id}`]: allowPositionStyles && !!css,
      // Only attach a container class if there is generated CSS to be attached.
      [`is-position-${style?.position?.type}`]: allowPositionStyles && !!css && !!style?.position?.type
    });
    useStyleOverride({ css });
    return { className };
  }

  // packages/block-editor/build-module/components/block-tools/use-block-toolbar-popover-props.js
  var COMMON_PROPS = {
    placement: "top-start"
  };
  var DEFAULT_PROPS2 = {
    ...COMMON_PROPS,
    flip: false,
    shift: true
  };
  var RESTRICTED_HEIGHT_PROPS = {
    ...COMMON_PROPS,
    flip: true,
    shift: false
  };
  function getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky) {
    if (!contentElement || !selectedBlockElement) {
      return DEFAULT_PROPS2;
    }
    const scrollTop = scrollContainer?.scrollTop || 0;
    const blockRect = getElementBounds(selectedBlockElement);
    const contentRect = contentElement.getBoundingClientRect();
    const topOfContentElementInViewport = scrollTop + contentRect.top;
    const viewportHeight = contentElement.ownerDocument.documentElement.clientHeight;
    const restrictedTopArea = topOfContentElementInViewport + toolbarHeight;
    const hasSpaceForToolbarAbove = blockRect.top > restrictedTopArea;
    const isBlockTallerThanViewport = blockRect.height > viewportHeight - toolbarHeight;
    if (!isSticky && (hasSpaceForToolbarAbove || isBlockTallerThanViewport)) {
      return DEFAULT_PROPS2;
    }
    return RESTRICTED_HEIGHT_PROPS;
  }
  function useBlockToolbarPopoverProps({
    contentElement,
    clientId
  }) {
    const selectedBlockElement = useBlockElement(clientId);
    const [toolbarHeight, setToolbarHeight] = (0, import_element92.useState)(0);
    const { blockIndex, isSticky } = (0, import_data77.useSelect)(
      (select2) => {
        const { getBlockIndex: getBlockIndex2, getBlockAttributes: getBlockAttributes3 } = select2(store);
        return {
          blockIndex: getBlockIndex2(clientId),
          isSticky: hasStickyOrFixedPositionValue(
            getBlockAttributes3(clientId)
          )
        };
      },
      [clientId]
    );
    const scrollContainer = (0, import_element92.useMemo)(() => {
      if (!contentElement) {
        return;
      }
      return (0, import_dom24.getScrollContainer)(contentElement);
    }, [contentElement]);
    const [props, setProps] = (0, import_element92.useState)(
      () => getProps(
        contentElement,
        selectedBlockElement,
        scrollContainer,
        toolbarHeight,
        isSticky
      )
    );
    const popoverRef = (0, import_compose56.useRefEffect)((popoverNode) => {
      setToolbarHeight(popoverNode.offsetHeight);
    }, []);
    const updateProps = (0, import_element92.useCallback)(
      () => setProps(
        getProps(
          contentElement,
          selectedBlockElement,
          scrollContainer,
          toolbarHeight,
          isSticky
        )
      ),
      [contentElement, selectedBlockElement, scrollContainer, toolbarHeight]
    );
    (0, import_element92.useLayoutEffect)(updateProps, [blockIndex, updateProps]);
    (0, import_element92.useLayoutEffect)(() => {
      if (!contentElement || !selectedBlockElement) {
        return;
      }
      const contentView = contentElement?.ownerDocument?.defaultView;
      contentView?.addEventHandler?.("resize", updateProps);
      let resizeObserver;
      const blockView = selectedBlockElement?.ownerDocument?.defaultView;
      if (blockView.ResizeObserver) {
        resizeObserver = new blockView.ResizeObserver(updateProps);
        resizeObserver.observe(selectedBlockElement);
      }
      return () => {
        contentView?.removeEventHandler?.("resize", updateProps);
        if (resizeObserver) {
          resizeObserver.disconnect();
        }
      };
    }, [updateProps, contentElement, selectedBlockElement]);
    return {
      ...props,
      ref: popoverRef
    };
  }

  // packages/block-editor/build-module/components/block-tools/use-selected-block-tool-props.js
  var import_data78 = __toESM(require_data());
  function useSelectedBlockToolProps(clientId) {
    const selectedBlockProps = (0, import_data78.useSelect)(
      (select2) => {
        const {
          getBlockRootClientId: getBlockRootClientId2,
          getBlockParents: getBlockParents2,
          __experimentalGetBlockListSettingsForBlocks: __experimentalGetBlockListSettingsForBlocks2,
          isBlockInsertionPointVisible: isBlockInsertionPointVisible2,
          getBlockInsertionPoint: getBlockInsertionPoint2,
          getBlockOrder: getBlockOrder2,
          hasMultiSelection: hasMultiSelection2,
          getLastMultiSelectedBlockClientId: getLastMultiSelectedBlockClientId2
        } = select2(store);
        const blockParentsClientIds = getBlockParents2(clientId);
        const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks2(
          blockParentsClientIds
        );
        const capturingClientId = blockParentsClientIds.find(
          (parentClientId) => parentBlockListSettings[parentClientId]?.__experimentalCaptureToolbars
        );
        let isInsertionPointVisible = false;
        if (isBlockInsertionPointVisible2()) {
          const insertionPoint2 = getBlockInsertionPoint2();
          const order = getBlockOrder2(insertionPoint2.rootClientId);
          isInsertionPointVisible = order[insertionPoint2.index] === clientId;
        }
        return {
          capturingClientId,
          isInsertionPointVisible,
          lastClientId: hasMultiSelection2() ? getLastMultiSelectedBlockClientId2() : null,
          rootClientId: getBlockRootClientId2(clientId)
        };
      },
      [clientId]
    );
    return selectedBlockProps;
  }

  // packages/block-editor/build-module/components/block-tools/empty-block-inserter.js
  function EmptyBlockInserter({
    clientId,
    __unstableContentRef
  }) {
    const {
      capturingClientId,
      isInsertionPointVisible,
      lastClientId,
      rootClientId
    } = useSelectedBlockToolProps(clientId);
    const popoverProps3 = useBlockToolbarPopoverProps({
      contentElement: __unstableContentRef?.current,
      clientId
    });
    return /* @__PURE__ */ (0, import_jsx_runtime204.jsx)(
      cover_default,
      {
        clientId: capturingClientId || clientId,
        bottomClientId: lastClientId,
        className: clsx_default(
          "block-editor-block-list__block-side-inserter-popover",
          {
            "is-insertion-point-visible": isInsertionPointVisible
          }
        ),
        __unstableContentRef,
        ...popoverProps3,
        children: /* @__PURE__ */ (0, import_jsx_runtime204.jsx)("div", { className: "block-editor-block-list__empty-block-inserter", children: /* @__PURE__ */ (0, import_jsx_runtime204.jsx)(
          inserter_default,
          {
            position: "bottom right",
            rootClientId,
            clientId,
            __experimentalIsQuick: true
          }
        ) })
      }
    );
  }

  // packages/block-editor/build-module/components/block-tools/block-toolbar-popover.js
  var import_jsx_runtime283 = __toESM(require_jsx_runtime());
  var import_data123 = __toESM(require_data());
  var import_element152 = __toESM(require_element());
  var import_keyboard_shortcuts7 = __toESM(require_keyboard_shortcuts());

  // packages/block-editor/build-module/components/block-toolbar/index.js
  var import_jsx_runtime282 = __toESM(require_jsx_runtime());
  var import_i18n143 = __toESM(require_i18n());
  var import_data122 = __toESM(require_data());
  var import_element151 = __toESM(require_element());
  var import_compose69 = __toESM(require_compose());
  var import_blocks72 = __toESM(require_blocks());
  var import_components147 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-mover/index.js
  var import_jsx_runtime207 = __toESM(require_jsx_runtime());
  var import_components71 = __toESM(require_components());
  var import_data81 = __toESM(require_data());
  var import_i18n72 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-draggable/index.js
  var import_jsx_runtime205 = __toESM(require_jsx_runtime());
  var import_blocks43 = __toESM(require_blocks());
  var import_components69 = __toESM(require_components());
  var import_data79 = __toESM(require_data());
  var import_element94 = __toESM(require_element());
  var import_compose57 = __toESM(require_compose());

  // packages/block-editor/build-module/components/block-draggable/use-scroll-when-dragging.js
  var import_dom26 = __toESM(require_dom());
  var import_element93 = __toESM(require_element());
  var SCROLL_INACTIVE_DISTANCE_PX = 50;
  var SCROLL_INTERVAL_MS = 25;
  var PIXELS_PER_SECOND_PER_PERCENTAGE = 1e3;
  var VELOCITY_MULTIPLIER = PIXELS_PER_SECOND_PER_PERCENTAGE * (SCROLL_INTERVAL_MS / 1e3);
  function useScrollWhenDragging() {
    const dragStartYRef = (0, import_element93.useRef)(null);
    const velocityYRef = (0, import_element93.useRef)(null);
    const scrollParentYRef = (0, import_element93.useRef)(null);
    const scrollEditorIntervalRef = (0, import_element93.useRef)(null);
    (0, import_element93.useEffect)(
      () => () => {
        if (scrollEditorIntervalRef.current) {
          clearInterval(scrollEditorIntervalRef.current);
          scrollEditorIntervalRef.current = null;
        }
      },
      []
    );
    const startScrolling = (0, import_element93.useCallback)((event) => {
      dragStartYRef.current = event.clientY;
      scrollParentYRef.current = (0, import_dom26.getScrollContainer)(event.target);
      scrollEditorIntervalRef.current = setInterval(() => {
        if (scrollParentYRef.current && velocityYRef.current) {
          const newTop = scrollParentYRef.current.scrollTop + velocityYRef.current;
          scrollParentYRef.current.scroll({
            top: newTop
          });
        }
      }, SCROLL_INTERVAL_MS);
    }, []);
    const scrollOnDragOver = (0, import_element93.useCallback)((event) => {
      if (!scrollParentYRef.current) {
        return;
      }
      const scrollParentHeight = scrollParentYRef.current.offsetHeight;
      const offsetDragStartPosition = dragStartYRef.current - scrollParentYRef.current.offsetTop;
      const offsetDragPosition = event.clientY - scrollParentYRef.current.offsetTop;
      if (event.clientY > offsetDragStartPosition) {
        const moveableDistance = Math.max(
          scrollParentHeight - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX,
          0
        );
        const dragDistance = Math.max(
          offsetDragPosition - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX,
          0
        );
        const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
        velocityYRef.current = VELOCITY_MULTIPLIER * distancePercentage;
      } else if (event.clientY < offsetDragStartPosition) {
        const moveableDistance = Math.max(
          offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX,
          0
        );
        const dragDistance = Math.max(
          offsetDragStartPosition - offsetDragPosition - SCROLL_INACTIVE_DISTANCE_PX,
          0
        );
        const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
        velocityYRef.current = -VELOCITY_MULTIPLIER * distancePercentage;
      } else {
        velocityYRef.current = 0;
      }
    }, []);
    const stopScrolling = () => {
      dragStartYRef.current = null;
      scrollParentYRef.current = null;
      if (scrollEditorIntervalRef.current) {
        clearInterval(scrollEditorIntervalRef.current);
        scrollEditorIntervalRef.current = null;
      }
    };
    return [startScrolling, scrollOnDragOver, stopScrolling];
  }

  // packages/block-editor/build-module/components/block-draggable/index.js
  var BlockDraggable = ({
    appendToOwnerDocument,
    children,
    clientIds,
    cloneClassname,
    elementId,
    onDragStart,
    onDragEnd,
    fadeWhenDisabled = false,
    dragComponent
  }) => {
    const {
      srcRootClientId,
      isDraggable,
      icon,
      visibleInserter,
      getBlockType: getBlockType21
    } = (0, import_data79.useSelect)(
      (select2) => {
        const {
          canMoveBlocks: canMoveBlocks2,
          getBlockRootClientId: getBlockRootClientId22,
          getBlockName: getBlockName2,
          getBlockAttributes: getBlockAttributes3,
          isBlockInsertionPointVisible: isBlockInsertionPointVisible2
        } = select2(store);
        const { getBlockType: _getBlockType, getActiveBlockVariation } = select2(import_blocks43.store);
        const rootClientId = getBlockRootClientId22(clientIds[0]);
        const blockName = getBlockName2(clientIds[0]);
        const variation = getActiveBlockVariation(
          blockName,
          getBlockAttributes3(clientIds[0])
        );
        return {
          srcRootClientId: rootClientId,
          isDraggable: canMoveBlocks2(clientIds),
          icon: variation?.icon || _getBlockType(blockName)?.icon,
          visibleInserter: isBlockInsertionPointVisible2(),
          getBlockType: _getBlockType
        };
      },
      [clientIds]
    );
    const isDraggingRef = (0, import_element94.useRef)(false);
    const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
    const { getAllowedBlocks: getAllowedBlocks2, getBlockNamesByClientId: getBlockNamesByClientId2, getBlockRootClientId: getBlockRootClientId2 } = (0, import_data79.useSelect)(store);
    const { startDraggingBlocks: startDraggingBlocks2, stopDraggingBlocks: stopDraggingBlocks2 } = (0, import_data79.useDispatch)(store);
    (0, import_element94.useEffect)(() => {
      return () => {
        if (isDraggingRef.current) {
          stopDraggingBlocks2();
        }
      };
    }, []);
    const blockEl = useBlockElement(clientIds[0]);
    const editorRoot = blockEl?.closest("body");
    (0, import_element94.useEffect)(() => {
      if (!editorRoot || !fadeWhenDisabled) {
        return;
      }
      const onDragOver = (event) => {
        if (!event.target.closest("[data-block]")) {
          return;
        }
        const draggedBlockNames = getBlockNamesByClientId2(clientIds);
        const targetClientId = event.target.closest("[data-block]").getAttribute("data-block");
        const allowedBlocks = getAllowedBlocks2(targetClientId);
        const targetBlockName = getBlockNamesByClientId2([
          targetClientId
        ])[0];
        let dropTargetValid;
        if (allowedBlocks?.length === 0) {
          const targetRootClientId = getBlockRootClientId2(targetClientId);
          const targetRootBlockName = getBlockNamesByClientId2([
            targetRootClientId
          ])[0];
          const rootAllowedBlocks = getAllowedBlocks2(targetRootClientId);
          dropTargetValid = isDropTargetValid(
            getBlockType21,
            rootAllowedBlocks,
            draggedBlockNames,
            targetRootBlockName
          );
        } else {
          dropTargetValid = isDropTargetValid(
            getBlockType21,
            allowedBlocks,
            draggedBlockNames,
            targetBlockName
          );
        }
        if (!dropTargetValid && !visibleInserter) {
          window?.document?.body?.classList?.add(
            "block-draggable-invalid-drag-token"
          );
        } else {
          window?.document?.body?.classList?.remove(
            "block-draggable-invalid-drag-token"
          );
        }
      };
      const throttledOnDragOver = (0, import_compose57.throttle)(onDragOver, 200);
      editorRoot.addEventListener("dragover", throttledOnDragOver);
      return () => {
        editorRoot.removeEventListener("dragover", throttledOnDragOver);
      };
    }, [
      clientIds,
      editorRoot,
      fadeWhenDisabled,
      getAllowedBlocks2,
      getBlockNamesByClientId2,
      getBlockRootClientId2,
      getBlockType21,
      visibleInserter
    ]);
    if (!isDraggable) {
      return children({ draggable: false });
    }
    const transferData = {
      type: "block",
      srcClientIds: clientIds,
      srcRootClientId
    };
    return /* @__PURE__ */ (0, import_jsx_runtime205.jsx)(
      import_components69.Draggable,
      {
        appendToOwnerDocument,
        cloneClassname,
        __experimentalTransferDataType: "wp-blocks",
        transferData,
        onDragStart: (event) => {
          window.requestAnimationFrame(() => {
            startDraggingBlocks2(clientIds);
            isDraggingRef.current = true;
            startScrolling(event);
            if (onDragStart) {
              onDragStart();
            }
          });
        },
        onDragOver: scrollOnDragOver,
        onDragEnd: () => {
          stopDraggingBlocks2();
          isDraggingRef.current = false;
          stopScrolling();
          if (onDragEnd) {
            onDragEnd();
          }
        },
        __experimentalDragComponent: (
          // Check against `undefined` so that `null` can be used to disable
          // the default drag component.
          dragComponent !== void 0 ? dragComponent : /* @__PURE__ */ (0, import_jsx_runtime205.jsx)(
            BlockDraggableChip,
            {
              count: clientIds.length,
              icon,
              fadeWhenDisabled: true
            }
          )
        ),
        elementId,
        children: ({ onDraggableStart, onDraggableEnd }) => {
          return children({
            draggable: true,
            onDragStart: onDraggableStart,
            onDragEnd: onDraggableEnd
          });
        }
      }
    );
  };
  var block_draggable_default = BlockDraggable;

  // packages/block-editor/build-module/components/block-mover/button.js
  var import_jsx_runtime206 = __toESM(require_jsx_runtime());
  var import_blocks44 = __toESM(require_blocks());
  var import_components70 = __toESM(require_components());
  var import_compose58 = __toESM(require_compose());
  var import_data80 = __toESM(require_data());
  var import_element95 = __toESM(require_element());
  var import_i18n71 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-mover/mover-description.js
  var import_i18n70 = __toESM(require_i18n());
  var getMovementDirection = (moveDirection, orientation) => {
    if (moveDirection === "up") {
      if (orientation === "horizontal") {
        return (0, import_i18n70.isRTL)() ? "right" : "left";
      }
      return "up";
    } else if (moveDirection === "down") {
      if (orientation === "horizontal") {
        return (0, import_i18n70.isRTL)() ? "left" : "right";
      }
      return "down";
    }
    return null;
  };
  function getBlockMoverDescription(selectedCount, type, firstIndex, isFirst, isLast, dir, orientation) {
    const position2 = firstIndex + 1;
    if (selectedCount > 1) {
      return getMultiBlockMoverDescription(
        selectedCount,
        firstIndex,
        isFirst,
        isLast,
        dir,
        orientation
      );
    }
    if (isFirst && isLast) {
      return (0, import_i18n70.sprintf)(
        // translators: %s: Type of block (i.e. Text, Image etc)
        (0, import_i18n70.__)("Block %s is the only block, and cannot be moved"),
        type
      );
    }
    if (dir > 0 && !isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
          (0, import_i18n70.__)(
            "Move %1$s block from position %2$d down to position %3$d"
          ),
          type,
          position2,
          position2 + 1
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
          (0, import_i18n70.__)(
            "Move %1$s block from position %2$d left to position %3$d"
          ),
          type,
          position2,
          position2 + 1
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
          (0, import_i18n70.__)(
            "Move %1$s block from position %2$d right to position %3$d"
          ),
          type,
          position2,
          position2 + 1
        );
      }
    }
    if (dir > 0 && isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc)
          (0, import_i18n70.__)(
            "Block %1$s is at the end of the content and can\u2019t be moved down"
          ),
          type
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc)
          (0, import_i18n70.__)(
            "Block %1$s is at the end of the content and can\u2019t be moved left"
          ),
          type
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc)
          (0, import_i18n70.__)(
            "Block %1$s is at the end of the content and can\u2019t be moved right"
          ),
          type
        );
      }
    }
    if (dir < 0 && !isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
          (0, import_i18n70.__)("Move %1$s block from position %2$d up to position %3$d"),
          type,
          position2,
          position2 - 1
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
          (0, import_i18n70.__)(
            "Move %1$s block from position %2$d left to position %3$d"
          ),
          type,
          position2,
          position2 - 1
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
          (0, import_i18n70.__)(
            "Move %1$s block from position %2$d right to position %3$d"
          ),
          type,
          position2,
          position2 - 1
        );
      }
    }
    if (dir < 0 && isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc)
          (0, import_i18n70.__)(
            "Block %1$s is at the beginning of the content and can\u2019t be moved up"
          ),
          type
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc)
          (0, import_i18n70.__)(
            "Block %1$s is at the beginning of the content and can\u2019t be moved left"
          ),
          type
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Type of block (i.e. Text, Image etc)
          (0, import_i18n70.__)(
            "Block %1$s is at the beginning of the content and can\u2019t be moved right"
          ),
          type
        );
      }
    }
  }
  function getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation) {
    const position2 = firstIndex + 1;
    if (isFirst && isLast) {
      return (0, import_i18n70.__)("All blocks are selected, and cannot be moved");
    }
    if (dir > 0 && !isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Number of selected blocks, 2: Position of selected blocks
          (0, import_i18n70.__)("Move %1$d blocks from position %2$d down by one place"),
          selectedCount,
          position2
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Number of selected blocks, 2: Position of selected blocks
          (0, import_i18n70.__)("Move %1$d blocks from position %2$d left by one place"),
          selectedCount,
          position2
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Number of selected blocks, 2: Position of selected blocks
          (0, import_i18n70.__)("Move %1$d blocks from position %2$d right by one place"),
          selectedCount,
          position2
        );
      }
    }
    if (dir > 0 && isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return (0, import_i18n70.__)(
          "Blocks cannot be moved down as they are already at the bottom"
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.__)(
          "Blocks cannot be moved left as they are already are at the leftmost position"
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.__)(
          "Blocks cannot be moved right as they are already are at the rightmost position"
        );
      }
    }
    if (dir < 0 && !isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Number of selected blocks, 2: Position of selected blocks
          (0, import_i18n70.__)("Move %1$d blocks from position %2$d up by one place"),
          selectedCount,
          position2
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Number of selected blocks, 2: Position of selected blocks
          (0, import_i18n70.__)("Move %1$d blocks from position %2$d left by one place"),
          selectedCount,
          position2
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.sprintf)(
          // translators: 1: Number of selected blocks, 2: Position of selected blocks
          (0, import_i18n70.__)("Move %1$d blocks from position %2$d right by one place"),
          selectedCount,
          position2
        );
      }
    }
    if (dir < 0 && isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return (0, import_i18n70.__)(
          "Blocks cannot be moved up as they are already at the top"
        );
      }
      if (movementDirection === "left") {
        return (0, import_i18n70.__)(
          "Blocks cannot be moved left as they are already are at the leftmost position"
        );
      }
      if (movementDirection === "right") {
        return (0, import_i18n70.__)(
          "Blocks cannot be moved right as they are already are at the rightmost position"
        );
      }
    }
  }

  // packages/block-editor/build-module/components/block-mover/button.js
  var getArrowIcon = (direction, orientation) => {
    if (direction === "up") {
      if (orientation === "horizontal") {
        return (0, import_i18n71.isRTL)() ? chevron_right_default : chevron_left_default;
      }
      return chevron_up_default;
    } else if (direction === "down") {
      if (orientation === "horizontal") {
        return (0, import_i18n71.isRTL)() ? chevron_left_default : chevron_right_default;
      }
      return chevron_down_default;
    }
    return null;
  };
  var getMovementDirectionLabel = (moveDirection, orientation) => {
    if (moveDirection === "up") {
      if (orientation === "horizontal") {
        return (0, import_i18n71.isRTL)() ? (0, import_i18n71.__)("Move right") : (0, import_i18n71.__)("Move left");
      }
      return (0, import_i18n71.__)("Move up");
    } else if (moveDirection === "down") {
      if (orientation === "horizontal") {
        return (0, import_i18n71.isRTL)() ? (0, import_i18n71.__)("Move left") : (0, import_i18n71.__)("Move right");
      }
      return (0, import_i18n71.__)("Move down");
    }
    return null;
  };
  var BlockMoverButton = (0, import_element95.forwardRef)(
    ({ clientIds, direction, orientation: moverOrientation, ...props }, ref) => {
      const instanceId = (0, import_compose58.useInstanceId)(BlockMoverButton);
      const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
      const blocksCount = normalizedClientIds.length;
      const { disabled } = props;
      const {
        blockType,
        isDisabled,
        rootClientId,
        isFirst,
        isLast,
        firstIndex,
        orientation = "vertical"
      } = (0, import_data80.useSelect)(
        (select2) => {
          const {
            getBlockIndex: getBlockIndex2,
            getBlockRootClientId: getBlockRootClientId2,
            getBlockOrder: getBlockOrder2,
            getBlock: getBlock2,
            getBlockListSettings: getBlockListSettings2
          } = select2(store);
          const firstClientId = normalizedClientIds[0];
          const blockRootClientId = getBlockRootClientId2(firstClientId);
          const firstBlockIndex = getBlockIndex2(firstClientId);
          const lastBlockIndex = getBlockIndex2(
            normalizedClientIds[normalizedClientIds.length - 1]
          );
          const blockOrder = getBlockOrder2(blockRootClientId);
          const block = getBlock2(firstClientId);
          const isFirstBlock = firstBlockIndex === 0;
          const isLastBlock = lastBlockIndex === blockOrder.length - 1;
          const { orientation: blockListOrientation } = getBlockListSettings2(blockRootClientId) || {};
          return {
            blockType: block ? (0, import_blocks44.getBlockType)(block.name) : null,
            isDisabled: disabled || (direction === "up" ? isFirstBlock : isLastBlock),
            rootClientId: blockRootClientId,
            firstIndex: firstBlockIndex,
            isFirst: isFirstBlock,
            isLast: isLastBlock,
            orientation: moverOrientation || blockListOrientation
          };
        },
        [clientIds, direction]
      );
      const { moveBlocksDown: moveBlocksDown2, moveBlocksUp: moveBlocksUp2 } = (0, import_data80.useDispatch)(store);
      const moverFunction = direction === "up" ? moveBlocksUp2 : moveBlocksDown2;
      const onClick = (event) => {
        moverFunction(clientIds, rootClientId);
        if (props.onClick) {
          props.onClick(event);
        }
      };
      const descriptionId = `block-editor-block-mover-button__description-${instanceId}`;
      return /* @__PURE__ */ (0, import_jsx_runtime206.jsxs)(import_jsx_runtime206.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime206.jsx)(
          import_components70.Button,
          {
            __next40pxDefaultSize: true,
            ref,
            className: clsx_default(
              "block-editor-block-mover-button",
              `is-${direction}-button`
            ),
            icon: getArrowIcon(direction, orientation),
            label: getMovementDirectionLabel(
              direction,
              orientation
            ),
            "aria-describedby": descriptionId,
            ...props,
            onClick: isDisabled ? null : onClick,
            disabled: isDisabled,
            accessibleWhenDisabled: true
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime206.jsx)(import_components70.VisuallyHidden, { id: descriptionId, children: getBlockMoverDescription(
          blocksCount,
          blockType && blockType.title,
          firstIndex,
          isFirst,
          isLast,
          direction === "up" ? -1 : 1,
          orientation
        ) })
      ] });
    }
  );
  var BlockMoverUpButton = (0, import_element95.forwardRef)((props, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime206.jsx)(BlockMoverButton, { direction: "up", ref, ...props });
  });
  var BlockMoverDownButton = (0, import_element95.forwardRef)((props, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime206.jsx)(BlockMoverButton, { direction: "down", ref, ...props });
  });

  // packages/block-editor/build-module/components/block-mover/index.js
  function BlockMover({
    clientIds,
    hideDragHandle,
    isBlockMoverUpButtonDisabled,
    isBlockMoverDownButtonDisabled
  }) {
    const {
      canMove,
      rootClientId,
      isFirst,
      isLast,
      orientation,
      isManualGrid
    } = (0, import_data81.useSelect)(
      (select2) => {
        const {
          getBlockIndex: getBlockIndex2,
          getBlockListSettings: getBlockListSettings2,
          canMoveBlocks: canMoveBlocks2,
          getBlockOrder: getBlockOrder2,
          getBlockRootClientId: getBlockRootClientId2,
          getBlockAttributes: getBlockAttributes3
        } = select2(store);
        const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
        const firstClientId = normalizedClientIds[0];
        const _rootClientId = getBlockRootClientId2(firstClientId);
        const firstIndex = getBlockIndex2(firstClientId);
        const lastIndex = getBlockIndex2(
          normalizedClientIds[normalizedClientIds.length - 1]
        );
        const blockOrder = getBlockOrder2(_rootClientId);
        const { layout = {} } = getBlockAttributes3(_rootClientId) ?? {};
        return {
          canMove: canMoveBlocks2(clientIds),
          rootClientId: _rootClientId,
          isFirst: firstIndex === 0,
          isLast: lastIndex === blockOrder.length - 1,
          orientation: getBlockListSettings2(_rootClientId)?.orientation,
          isManualGrid: layout.type === "grid" && layout.isManualPlacement && window.__experimentalEnableGridInteractivity
        };
      },
      [clientIds]
    );
    if (!canMove || isFirst && isLast && !rootClientId || hideDragHandle && isManualGrid) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime207.jsxs)(
      import_components71.ToolbarGroup,
      {
        className: clsx_default("block-editor-block-mover", {
          "is-horizontal": orientation === "horizontal"
        }),
        children: [
          !hideDragHandle && /* @__PURE__ */ (0, import_jsx_runtime207.jsx)(block_draggable_default, { clientIds, fadeWhenDisabled: true, children: (draggableProps) => /* @__PURE__ */ (0, import_jsx_runtime207.jsx)(
            import_components71.Button,
            {
              __next40pxDefaultSize: true,
              icon: drag_handle_default,
              className: "block-editor-block-mover__drag-handle",
              label: (0, import_i18n72.__)("Drag"),
              tabIndex: "-1",
              ...draggableProps
            }
          ) }),
          !isManualGrid && /* @__PURE__ */ (0, import_jsx_runtime207.jsxs)("div", { className: "block-editor-block-mover__move-button-container", children: [
            /* @__PURE__ */ (0, import_jsx_runtime207.jsx)(import_components71.ToolbarItem, { children: (itemProps) => /* @__PURE__ */ (0, import_jsx_runtime207.jsx)(
              BlockMoverUpButton,
              {
                disabled: isBlockMoverUpButtonDisabled,
                clientIds,
                ...itemProps
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime207.jsx)(import_components71.ToolbarItem, { children: (itemProps) => /* @__PURE__ */ (0, import_jsx_runtime207.jsx)(
              BlockMoverDownButton,
              {
                disabled: isBlockMoverDownButtonDisabled,
                clientIds,
                ...itemProps
              }
            ) })
          ] })
        ]
      }
    );
  }
  var block_mover_default = BlockMover;

  // packages/block-editor/build-module/components/block-parent-selector/index.js
  var import_jsx_runtime208 = __toESM(require_jsx_runtime());
  var import_components72 = __toESM(require_components());
  var import_data83 = __toESM(require_data());
  var import_i18n73 = __toESM(require_i18n());
  var import_element97 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-toolbar/utils.js
  var import_data82 = __toESM(require_data());
  var import_element96 = __toESM(require_element());
  var { clearTimeout: clearTimeout2, setTimeout: setTimeout2 } = window;
  var DEBOUNCE_TIMEOUT = 200;
  function useDebouncedShowGestures({
    ref,
    isFocused,
    highlightParent,
    debounceTimeout = DEBOUNCE_TIMEOUT
  }) {
    const { getSelectedBlockClientId: getSelectedBlockClientId2, getBlockRootClientId: getBlockRootClientId2 } = (0, import_data82.useSelect)(store);
    const { toggleBlockHighlight: toggleBlockHighlight2 } = (0, import_data82.useDispatch)(store);
    const timeoutRef = (0, import_element96.useRef)();
    const isDistractionFree = (0, import_data82.useSelect)(
      (select2) => select2(store).getSettings().isDistractionFree,
      []
    );
    const handleOnChange = (nextIsFocused) => {
      if (nextIsFocused && isDistractionFree) {
        return;
      }
      const selectedBlockClientId = getSelectedBlockClientId2();
      const clientId = highlightParent ? getBlockRootClientId2(selectedBlockClientId) : selectedBlockClientId;
      toggleBlockHighlight2(clientId, nextIsFocused);
    };
    const getIsHovered = () => {
      return ref?.current && ref.current.matches(":hover");
    };
    const shouldHideGestures = () => {
      const isHovered = getIsHovered();
      return !isFocused && !isHovered;
    };
    const clearTimeoutRef = () => {
      const timeout = timeoutRef.current;
      if (timeout && clearTimeout2) {
        clearTimeout2(timeout);
      }
    };
    const debouncedShowGestures = (event) => {
      if (event) {
        event.stopPropagation();
      }
      clearTimeoutRef();
      handleOnChange(true);
    };
    const debouncedHideGestures = (event) => {
      if (event) {
        event.stopPropagation();
      }
      clearTimeoutRef();
      timeoutRef.current = setTimeout2(() => {
        if (shouldHideGestures()) {
          handleOnChange(false);
        }
      }, debounceTimeout);
    };
    (0, import_element96.useEffect)(
      () => () => {
        handleOnChange(false);
        clearTimeoutRef();
      },
      []
    );
    return {
      debouncedShowGestures,
      debouncedHideGestures
    };
  }
  function useShowHoveredOrFocusedGestures({
    ref,
    highlightParent = false,
    debounceTimeout = DEBOUNCE_TIMEOUT
  }) {
    const [isFocused, setIsFocused] = (0, import_element96.useState)(false);
    const { debouncedShowGestures, debouncedHideGestures } = useDebouncedShowGestures({
      ref,
      debounceTimeout,
      isFocused,
      highlightParent
    });
    const registerRef = (0, import_element96.useRef)(false);
    const isFocusedWithin = () => {
      return ref?.current && ref.current.contains(ref.current.ownerDocument.activeElement);
    };
    (0, import_element96.useEffect)(() => {
      const node2 = ref.current;
      const handleOnFocus = () => {
        if (isFocusedWithin()) {
          setIsFocused(true);
          debouncedShowGestures();
        }
      };
      const handleOnBlur = () => {
        if (!isFocusedWithin()) {
          setIsFocused(false);
          debouncedHideGestures();
        }
      };
      if (node2 && !registerRef.current) {
        node2.addEventListener("focus", handleOnFocus, true);
        node2.addEventListener("blur", handleOnBlur, true);
        registerRef.current = true;
      }
      return () => {
        if (node2) {
          node2.removeEventListener("focus", handleOnFocus);
          node2.removeEventListener("blur", handleOnBlur);
        }
      };
    }, [
      ref,
      registerRef,
      setIsFocused,
      debouncedShowGestures,
      debouncedHideGestures
    ]);
    return {
      onMouseMove: debouncedShowGestures,
      onMouseLeave: debouncedHideGestures
    };
  }

  // packages/block-editor/build-module/components/block-parent-selector/index.js
  function BlockParentSelector() {
    const { selectBlock: selectBlock2 } = (0, import_data83.useDispatch)(store);
    const { parentClientId } = (0, import_data83.useSelect)((select2) => {
      const {
        getBlockParents: getBlockParents2,
        getSelectedBlockClientId: getSelectedBlockClientId2,
        getParentSectionBlock: getParentSectionBlock2
      } = unlock(select2(store));
      const selectedBlockClientId = getSelectedBlockClientId2();
      const parentSection = getParentSectionBlock2(selectedBlockClientId);
      const parents = getBlockParents2(selectedBlockClientId);
      const _parentClientId = parentSection ?? parents[parents.length - 1];
      return {
        parentClientId: _parentClientId
      };
    }, []);
    const blockInformation = useBlockDisplayInformation(parentClientId);
    const nodeRef = (0, import_element97.useRef)();
    const showHoveredOrFocusedGestures = useShowHoveredOrFocusedGestures({
      ref: nodeRef,
      highlightParent: true
    });
    return /* @__PURE__ */ (0, import_jsx_runtime208.jsx)(
      "div",
      {
        className: "block-editor-block-parent-selector",
        ref: nodeRef,
        ...showHoveredOrFocusedGestures,
        children: /* @__PURE__ */ (0, import_jsx_runtime208.jsx)(
          import_components72.ToolbarButton,
          {
            className: "block-editor-block-parent-selector__button",
            onClick: () => selectBlock2(parentClientId),
            label: (0, import_i18n73.sprintf)(
              /* translators: %s: Name of the block's parent. */
              (0, import_i18n73.__)("Select parent block: %s"),
              blockInformation?.title
            ),
            showTooltip: true,
            icon: /* @__PURE__ */ (0, import_jsx_runtime208.jsx)(block_icon_default, { icon: blockInformation?.icon })
          }
        )
      },
      parentClientId
    );
  }

  // packages/block-editor/build-module/components/block-switcher/index.js
  var import_jsx_runtime215 = __toESM(require_jsx_runtime());
  var import_i18n79 = __toESM(require_i18n());
  var import_components79 = __toESM(require_components());
  var import_blocks50 = __toESM(require_blocks());
  var import_data86 = __toESM(require_data());
  var import_preferences2 = __toESM(require_preferences());

  // packages/block-editor/build-module/components/block-switcher/block-transformations-menu.js
  var import_jsx_runtime211 = __toESM(require_jsx_runtime());
  var import_i18n75 = __toESM(require_i18n());
  var import_components75 = __toESM(require_components());
  var import_blocks46 = __toESM(require_blocks());
  var import_element99 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-switcher/preview-block-popover.js
  var import_jsx_runtime209 = __toESM(require_jsx_runtime());
  var import_i18n74 = __toESM(require_i18n());
  var import_components73 = __toESM(require_components());
  var import_compose59 = __toESM(require_compose());
  function PreviewBlockPopover({ blocks: blocks2 }) {
    const isMobile = (0, import_compose59.useViewportMatch)("medium", "<");
    if (isMobile) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime209.jsx)("div", { className: "block-editor-block-switcher__popover-preview-container", children: /* @__PURE__ */ (0, import_jsx_runtime209.jsx)(
      import_components73.Popover,
      {
        className: "block-editor-block-switcher__popover-preview",
        placement: "right-start",
        focusOnMount: false,
        offset: 16,
        children: /* @__PURE__ */ (0, import_jsx_runtime209.jsxs)("div", { className: "block-editor-block-switcher__preview", children: [
          /* @__PURE__ */ (0, import_jsx_runtime209.jsx)("div", { className: "block-editor-block-switcher__preview-title", children: (0, import_i18n74.__)("Preview") }),
          /* @__PURE__ */ (0, import_jsx_runtime209.jsx)(block_preview_default, { viewportWidth: 601, blocks: blocks2 })
        ] })
      }
    ) });
  }

  // packages/block-editor/build-module/components/block-switcher/block-variation-transformations.js
  var import_jsx_runtime210 = __toESM(require_jsx_runtime());
  var import_components74 = __toESM(require_components());
  var import_blocks45 = __toESM(require_blocks());
  var import_data84 = __toESM(require_data());
  var import_element98 = __toESM(require_element());
  var EMPTY_OBJECT2 = {};
  function useBlockVariationTransforms({ clientIds, blocks: blocks2 }) {
    const { activeBlockVariation, blockVariationTransformations } = (0, import_data84.useSelect)(
      (select2) => {
        const { getBlockAttributes: getBlockAttributes3, canRemoveBlocks: canRemoveBlocks2 } = select2(store);
        const { getActiveBlockVariation, getBlockVariations: getBlockVariations2 } = select2(import_blocks45.store);
        const canRemove = canRemoveBlocks2(clientIds);
        if (blocks2.length !== 1 || !canRemove) {
          return EMPTY_OBJECT2;
        }
        const [firstBlock] = blocks2;
        return {
          blockVariationTransformations: getBlockVariations2(
            firstBlock.name,
            "transform"
          ),
          activeBlockVariation: getActiveBlockVariation(
            firstBlock.name,
            getBlockAttributes3(firstBlock.clientId)
          )
        };
      },
      [clientIds, blocks2]
    );
    const transformations = (0, import_element98.useMemo)(() => {
      return blockVariationTransformations?.filter(
        ({ name }) => name !== activeBlockVariation?.name
      );
    }, [blockVariationTransformations, activeBlockVariation]);
    return transformations;
  }
  var BlockVariationTransformations = ({
    transformations,
    onSelect,
    blocks: blocks2
  }) => {
    const [hoveredTransformItemName, setHoveredTransformItemName] = (0, import_element98.useState)();
    return /* @__PURE__ */ (0, import_jsx_runtime210.jsxs)(import_jsx_runtime210.Fragment, { children: [
      hoveredTransformItemName && /* @__PURE__ */ (0, import_jsx_runtime210.jsx)(
        PreviewBlockPopover,
        {
          blocks: (0, import_blocks45.cloneBlock)(
            blocks2[0],
            transformations.find(
              ({ name }) => name === hoveredTransformItemName
            ).attributes
          )
        }
      ),
      transformations?.map((item) => /* @__PURE__ */ (0, import_jsx_runtime210.jsx)(
        BlockVariationTransformationItem,
        {
          item,
          onSelect,
          setHoveredTransformItemName
        },
        item.name
      ))
    ] });
  };
  function BlockVariationTransformationItem({
    item,
    onSelect,
    setHoveredTransformItemName
  }) {
    const { name, icon, title } = item;
    return /* @__PURE__ */ (0, import_jsx_runtime210.jsxs)(
      import_components74.MenuItem,
      {
        className: (0, import_blocks45.getBlockMenuDefaultClassName)(name),
        onClick: (event) => {
          event.preventDefault();
          onSelect(name);
        },
        onMouseLeave: () => setHoveredTransformItemName(null),
        onMouseEnter: () => setHoveredTransformItemName(name),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime210.jsx)(block_icon_default, { icon, showColors: true }),
          title
        ]
      }
    );
  }
  var block_variation_transformations_default = BlockVariationTransformations;

  // packages/block-editor/build-module/components/block-switcher/block-transformations-menu.js
  function useGroupedTransforms(possibleBlockTransformations) {
    const priorityContentTransformationBlocks = {
      "core/paragraph": 1,
      "core/heading": 2,
      "core/list": 3,
      "core/quote": 4
    };
    const transformations = (0, import_element99.useMemo)(() => {
      const priorityTextTransformsNames = Object.keys(
        priorityContentTransformationBlocks
      );
      const groupedPossibleTransforms = possibleBlockTransformations.reduce(
        (accumulator, item) => {
          const { name } = item;
          if (priorityTextTransformsNames.includes(name)) {
            accumulator.priorityTextTransformations.push(item);
          } else {
            accumulator.restTransformations.push(item);
          }
          return accumulator;
        },
        { priorityTextTransformations: [], restTransformations: [] }
      );
      if (groupedPossibleTransforms.priorityTextTransformations.length === 1 && groupedPossibleTransforms.priorityTextTransformations[0].name === "core/quote") {
        const singleQuote = groupedPossibleTransforms.priorityTextTransformations.pop();
        groupedPossibleTransforms.restTransformations.push(singleQuote);
      }
      return groupedPossibleTransforms;
    }, [possibleBlockTransformations]);
    transformations.priorityTextTransformations.sort(
      ({ name: currentName }, { name: nextName }) => {
        return priorityContentTransformationBlocks[currentName] < priorityContentTransformationBlocks[nextName] ? -1 : 1;
      }
    );
    return transformations;
  }
  var BlockTransformationsMenu = ({
    className,
    possibleBlockTransformations,
    possibleBlockVariationTransformations,
    onSelect,
    onSelectVariation,
    blocks: blocks2
  }) => {
    const [hoveredTransformItemName, setHoveredTransformItemName] = (0, import_element99.useState)();
    const { priorityTextTransformations, restTransformations } = useGroupedTransforms(possibleBlockTransformations);
    const hasBothContentTransformations = priorityTextTransformations.length && restTransformations.length;
    const restTransformItems = !!restTransformations.length && /* @__PURE__ */ (0, import_jsx_runtime211.jsx)(
      RestTransformationItems,
      {
        restTransformations,
        onSelect,
        setHoveredTransformItemName
      }
    );
    return /* @__PURE__ */ (0, import_jsx_runtime211.jsxs)(import_jsx_runtime211.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime211.jsxs)(import_components75.MenuGroup, { label: (0, import_i18n75.__)("Transform to"), className, children: [
        hoveredTransformItemName && /* @__PURE__ */ (0, import_jsx_runtime211.jsx)(
          PreviewBlockPopover,
          {
            blocks: (0, import_blocks46.switchToBlockType)(
              blocks2,
              hoveredTransformItemName
            )
          }
        ),
        !!possibleBlockVariationTransformations?.length && /* @__PURE__ */ (0, import_jsx_runtime211.jsx)(
          block_variation_transformations_default,
          {
            transformations: possibleBlockVariationTransformations,
            blocks: blocks2,
            onSelect: onSelectVariation
          }
        ),
        priorityTextTransformations.map((item) => /* @__PURE__ */ (0, import_jsx_runtime211.jsx)(
          BlockTransformationItem,
          {
            item,
            onSelect,
            setHoveredTransformItemName
          },
          item.name
        )),
        !hasBothContentTransformations && restTransformItems
      ] }),
      !!hasBothContentTransformations && /* @__PURE__ */ (0, import_jsx_runtime211.jsx)(import_components75.MenuGroup, { className, children: restTransformItems })
    ] });
  };
  function RestTransformationItems({
    restTransformations,
    onSelect,
    setHoveredTransformItemName
  }) {
    return restTransformations.map((item) => /* @__PURE__ */ (0, import_jsx_runtime211.jsx)(
      BlockTransformationItem,
      {
        item,
        onSelect,
        setHoveredTransformItemName
      },
      item.name
    ));
  }
  function BlockTransformationItem({
    item,
    onSelect,
    setHoveredTransformItemName
  }) {
    const { name, icon, title, isDisabled } = item;
    return /* @__PURE__ */ (0, import_jsx_runtime211.jsxs)(
      import_components75.MenuItem,
      {
        className: (0, import_blocks46.getBlockMenuDefaultClassName)(name),
        onClick: (event) => {
          event.preventDefault();
          onSelect(name);
        },
        disabled: isDisabled,
        onMouseLeave: () => setHoveredTransformItemName(null),
        onMouseEnter: () => setHoveredTransformItemName(name),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime211.jsx)(block_icon_default, { icon, showColors: true }),
          title
        ]
      }
    );
  }
  var block_transformations_menu_default = BlockTransformationsMenu;

  // packages/block-editor/build-module/components/block-switcher/block-styles-menu.js
  var import_jsx_runtime213 = __toESM(require_jsx_runtime());
  var import_i18n77 = __toESM(require_i18n());
  var import_components77 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-styles/menu-items.js
  var import_jsx_runtime212 = __toESM(require_jsx_runtime());
  var import_components76 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-styles/use-styles-for-block.js
  var import_data85 = __toESM(require_data());
  var import_blocks47 = __toESM(require_blocks());
  var import_element100 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-styles/utils.js
  var import_token_list = __toESM(require_token_list());
  var import_i18n76 = __toESM(require_i18n());
  function getActiveStyle(styles, className) {
    for (const style of new import_token_list.default(className).values()) {
      if (style.indexOf("is-style-") === -1) {
        continue;
      }
      const potentialStyleName = style.substring(9);
      const activeStyle = styles?.find(
        ({ name }) => name === potentialStyleName
      );
      if (activeStyle) {
        return activeStyle;
      }
    }
    return getDefaultStyle(styles);
  }
  function replaceActiveStyle(className, activeStyle, newStyle) {
    const list = new import_token_list.default(className);
    if (activeStyle) {
      list.remove("is-style-" + activeStyle.name);
    }
    list.add("is-style-" + newStyle.name);
    return list.value;
  }
  function getRenderedStyles(styles) {
    if (!styles || styles.length === 0) {
      return [];
    }
    return getDefaultStyle(styles) ? styles : [
      {
        name: "default",
        label: (0, import_i18n76._x)("Default", "block style"),
        isDefault: true
      },
      ...styles
    ];
  }
  function getDefaultStyle(styles) {
    return styles?.find((style) => style.isDefault);
  }

  // packages/block-editor/build-module/components/block-styles/use-styles-for-block.js
  function useGenericPreviewBlock(block, type) {
    return (0, import_element100.useMemo)(() => {
      const example = type?.example;
      const blockName = type?.name;
      if (example && blockName) {
        return (0, import_blocks47.getBlockFromExample)(blockName, {
          attributes: example.attributes,
          innerBlocks: example.innerBlocks
        });
      }
      if (block) {
        return (0, import_blocks47.cloneBlock)(block);
      }
    }, [type?.example ? block?.name : block, type]);
  }
  function useStylesForBlocks({ clientId, onSwitch }) {
    const selector3 = (select2) => {
      const { getBlock: getBlock2 } = select2(store);
      const block2 = getBlock2(clientId);
      if (!block2) {
        return {};
      }
      const blockType2 = (0, import_blocks47.getBlockType)(block2.name);
      const { getBlockStyles: getBlockStyles2 } = select2(import_blocks47.store);
      return {
        block: block2,
        blockType: blockType2,
        styles: getBlockStyles2(block2.name),
        className: block2.attributes.className || ""
      };
    };
    const { styles, block, blockType, className } = (0, import_data85.useSelect)(selector3, [
      clientId
    ]);
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data85.useDispatch)(store);
    const stylesToRender = getRenderedStyles(styles);
    const activeStyle = getActiveStyle(stylesToRender, className);
    const genericPreviewBlock = useGenericPreviewBlock(block, blockType);
    const onSelect = (style) => {
      const styleClassName = replaceActiveStyle(
        className,
        activeStyle,
        style
      );
      updateBlockAttributes2(clientId, {
        className: styleClassName
      });
      onSwitch();
    };
    return {
      onSelect,
      stylesToRender,
      activeStyle,
      genericPreviewBlock,
      className
    };
  }

  // packages/block-editor/build-module/components/block-styles/menu-items.js
  var noop8 = () => {
  };
  function BlockStylesMenuItems({ clientId, onSwitch = noop8 }) {
    const { onSelect, stylesToRender, activeStyle } = useStylesForBlocks({
      clientId,
      onSwitch
    });
    if (!stylesToRender || stylesToRender.length === 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime212.jsx)(import_jsx_runtime212.Fragment, { children: stylesToRender.map((style) => {
      const menuItemText = style.label || style.name;
      return /* @__PURE__ */ (0, import_jsx_runtime212.jsx)(
        import_components76.MenuItem,
        {
          icon: activeStyle.name === style.name ? check_default : null,
          onClick: () => onSelect(style),
          children: /* @__PURE__ */ (0, import_jsx_runtime212.jsx)(
            import_components76.__experimentalText,
            {
              as: "span",
              limit: 18,
              ellipsizeMode: "tail",
              truncate: true,
              children: menuItemText
            }
          )
        },
        style.name
      );
    }) });
  }

  // packages/block-editor/build-module/components/block-switcher/block-styles-menu.js
  function BlockStylesMenu({ hoveredBlock, onSwitch }) {
    const { clientId } = hoveredBlock;
    return /* @__PURE__ */ (0, import_jsx_runtime213.jsx)(
      import_components77.MenuGroup,
      {
        label: (0, import_i18n77.__)("Styles"),
        className: "block-editor-block-switcher__styles__menugroup",
        children: /* @__PURE__ */ (0, import_jsx_runtime213.jsx)(BlockStylesMenuItems, { clientId, onSwitch })
      }
    );
  }

  // packages/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js
  var import_jsx_runtime214 = __toESM(require_jsx_runtime());
  var import_i18n78 = __toESM(require_i18n());
  var import_element102 = __toESM(require_element());
  var import_compose60 = __toESM(require_compose());
  var import_components78 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-switcher/use-transformed-patterns.js
  var import_element101 = __toESM(require_element());
  var import_blocks49 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/block-switcher/utils.js
  var import_blocks48 = __toESM(require_blocks());
  var getMatchingBlockByName = (block, selectedBlockName, consumedBlocks = /* @__PURE__ */ new Set()) => {
    const { clientId, name, innerBlocks = [] } = block;
    if (consumedBlocks.has(clientId)) {
      return;
    }
    if (name === selectedBlockName) {
      return block;
    }
    for (const innerBlock of innerBlocks) {
      const match2 = getMatchingBlockByName(
        innerBlock,
        selectedBlockName,
        consumedBlocks
      );
      if (match2) {
        return match2;
      }
    }
  };
  var getRetainedBlockAttributes = (name, attributes) => {
    const contentAttributes = (0, import_blocks48.getBlockAttributesNamesByRole)(name, "content");
    if (!contentAttributes?.length) {
      return attributes;
    }
    return contentAttributes.reduce((_accumulator, attribute) => {
      if (attributes[attribute]) {
        _accumulator[attribute] = attributes[attribute];
      }
      return _accumulator;
    }, {});
  };

  // packages/block-editor/build-module/components/block-switcher/use-transformed-patterns.js
  var transformMatchingBlock = (match2, selectedBlock) => {
    const retainedBlockAttributes = getRetainedBlockAttributes(
      selectedBlock.name,
      selectedBlock.attributes
    );
    match2.attributes = {
      ...match2.attributes,
      ...retainedBlockAttributes
    };
  };
  var getPatternTransformedBlocks = (selectedBlocks, patternBlocks) => {
    const _patternBlocks = patternBlocks.map(
      (block) => (0, import_blocks49.cloneBlock)(block)
    );
    const consumedBlocks = /* @__PURE__ */ new Set();
    for (const selectedBlock of selectedBlocks) {
      let isMatch = false;
      for (const patternBlock of _patternBlocks) {
        const match2 = getMatchingBlockByName(
          patternBlock,
          selectedBlock.name,
          consumedBlocks
        );
        if (!match2) {
          continue;
        }
        isMatch = true;
        consumedBlocks.add(match2.clientId);
        transformMatchingBlock(match2, selectedBlock);
        break;
      }
      if (!isMatch) {
        return;
      }
    }
    return _patternBlocks;
  };
  var useTransformedPatterns = (patterns, selectedBlocks) => {
    return (0, import_element101.useMemo)(
      () => patterns.reduce((accumulator, _pattern) => {
        const transformedBlocks = getPatternTransformedBlocks(
          selectedBlocks,
          _pattern.blocks
        );
        if (transformedBlocks) {
          accumulator.push({
            ..._pattern,
            transformedBlocks
          });
        }
        return accumulator;
      }, []),
      [patterns, selectedBlocks]
    );
  };
  var use_transformed_patterns_default = useTransformedPatterns;

  // packages/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js
  function PatternTransformationsMenu({
    blocks: blocks2,
    patterns: statePatterns,
    onSelect
  }) {
    const [showTransforms, setShowTransforms] = (0, import_element102.useState)(false);
    const patterns = use_transformed_patterns_default(statePatterns, blocks2);
    if (!patterns.length) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime214.jsxs)(import_components78.MenuGroup, { className: "block-editor-block-switcher__pattern__transforms__menugroup", children: [
      showTransforms && /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
        PreviewPatternsPopover,
        {
          patterns,
          onSelect
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
        import_components78.MenuItem,
        {
          onClick: (event) => {
            event.preventDefault();
            setShowTransforms(!showTransforms);
          },
          icon: chevron_right_default,
          children: (0, import_i18n78.__)("Patterns")
        }
      )
    ] });
  }
  function PreviewPatternsPopover({ patterns, onSelect }) {
    const isMobile = (0, import_compose60.useViewportMatch)("medium", "<");
    return /* @__PURE__ */ (0, import_jsx_runtime214.jsx)("div", { className: "block-editor-block-switcher__popover-preview-container", children: /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
      import_components78.Popover,
      {
        className: "block-editor-block-switcher__popover-preview",
        placement: isMobile ? "bottom" : "right-start",
        offset: 16,
        children: /* @__PURE__ */ (0, import_jsx_runtime214.jsx)("div", { className: "block-editor-block-switcher__preview is-pattern-list-preview", children: /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
          BlockPatternsList2,
          {
            patterns,
            onSelect
          }
        ) })
      }
    ) });
  }
  function BlockPatternsList2({ patterns, onSelect }) {
    return /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
      import_components78.Composite,
      {
        role: "listbox",
        className: "block-editor-block-switcher__preview-patterns-container",
        "aria-label": (0, import_i18n78.__)("Patterns list"),
        children: patterns.map((pattern) => /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
          BlockPattern2,
          {
            pattern,
            onSelect
          },
          pattern.name
        ))
      }
    );
  }
  function BlockPattern2({ pattern, onSelect }) {
    const baseClassName = "block-editor-block-switcher__preview-patterns-container";
    const descriptionId = (0, import_compose60.useInstanceId)(
      BlockPattern2,
      `${baseClassName}-list__item-description`
    );
    return /* @__PURE__ */ (0, import_jsx_runtime214.jsxs)("div", { className: `${baseClassName}-list__list-item`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime214.jsxs)(
        import_components78.Composite.Item,
        {
          render: /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
            "div",
            {
              role: "option",
              "aria-label": pattern.title,
              "aria-describedby": pattern.description ? descriptionId : void 0,
              className: `${baseClassName}-list__item`
            }
          ),
          onClick: () => onSelect(pattern.transformedBlocks),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(
              block_preview_default,
              {
                blocks: pattern.transformedBlocks,
                viewportWidth: pattern.viewportWidth || 500
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime214.jsx)("div", { className: `${baseClassName}-list__item-title`, children: pattern.title })
          ]
        }
      ),
      !!pattern.description && /* @__PURE__ */ (0, import_jsx_runtime214.jsx)(import_components78.VisuallyHidden, { id: descriptionId, children: pattern.description })
    ] });
  }
  var pattern_transformations_menu_default = PatternTransformationsMenu;

  // packages/block-editor/build-module/components/block-switcher/index.js
  function BlockSwitcherDropdownMenuContents({
    onClose,
    clientIds,
    hasBlockStyles,
    canRemove
  }) {
    const { replaceBlocks: replaceBlocks2, multiSelect: multiSelect2, updateBlockAttributes: updateBlockAttributes2 } = (0, import_data86.useDispatch)(store);
    const { possibleBlockTransformations, patterns, blocks: blocks2, isUsingBindings } = (0, import_data86.useSelect)(
      (select2) => {
        const {
          getBlockAttributes: getBlockAttributes3,
          getBlocksByClientId: getBlocksByClientId2,
          getBlockRootClientId: getBlockRootClientId2,
          getBlockTransformItems: getBlockTransformItems2,
          __experimentalGetPatternTransformItems: __experimentalGetPatternTransformItems2
        } = select2(store);
        const rootClientId = getBlockRootClientId2(clientIds[0]);
        const _blocks = getBlocksByClientId2(clientIds);
        return {
          blocks: _blocks,
          possibleBlockTransformations: getBlockTransformItems2(
            _blocks,
            rootClientId
          ),
          patterns: __experimentalGetPatternTransformItems2(
            _blocks,
            rootClientId
          ),
          isUsingBindings: clientIds.every(
            (clientId) => !!getBlockAttributes3(clientId)?.metadata?.bindings
          )
        };
      },
      [clientIds]
    );
    const blockVariationTransformations = useBlockVariationTransforms({
      clientIds,
      blocks: blocks2
    });
    function selectForMultipleBlocks(insertedBlocks) {
      if (insertedBlocks.length > 1) {
        multiSelect2(
          insertedBlocks[0].clientId,
          insertedBlocks[insertedBlocks.length - 1].clientId
        );
      }
    }
    function onBlockTransform(name) {
      const newBlocks = (0, import_blocks50.switchToBlockType)(blocks2, name);
      replaceBlocks2(clientIds, newBlocks);
      selectForMultipleBlocks(newBlocks);
    }
    function onBlockVariationTransform(name) {
      updateBlockAttributes2(blocks2[0].clientId, {
        ...blockVariationTransformations.find(
          ({ name: variationName }) => variationName === name
        ).attributes
      });
    }
    function onPatternTransform(transformedBlocks) {
      replaceBlocks2(clientIds, transformedBlocks);
      selectForMultipleBlocks(transformedBlocks);
    }
    const isSingleBlock = blocks2.length === 1;
    const isSynced = isSingleBlock && ((0, import_blocks50.isTemplatePart)(blocks2[0]) || (0, import_blocks50.isReusableBlock)(blocks2[0]));
    const hasPossibleBlockTransformations = !!possibleBlockTransformations?.length && canRemove && !isSynced;
    const hasPossibleBlockVariationTransformations = !!blockVariationTransformations?.length;
    const hasPatternTransformation = !!patterns?.length && canRemove;
    const hasBlockOrBlockVariationTransforms = hasPossibleBlockTransformations || hasPossibleBlockVariationTransformations;
    const hasContents = hasBlockStyles || hasBlockOrBlockVariationTransforms || hasPatternTransformation;
    if (!hasContents) {
      return /* @__PURE__ */ (0, import_jsx_runtime215.jsx)("p", { className: "block-editor-block-switcher__no-transforms", children: (0, import_i18n79.__)("No transforms.") });
    }
    const connectedBlockDescription = isSingleBlock ? (0, import_i18n79._x)(
      "This block is connected.",
      "block toolbar button label and description"
    ) : (0, import_i18n79._x)(
      "These blocks are connected.",
      "block toolbar button label and description"
    );
    return /* @__PURE__ */ (0, import_jsx_runtime215.jsxs)("div", { className: "block-editor-block-switcher__container", children: [
      hasPatternTransformation && /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
        pattern_transformations_menu_default,
        {
          blocks: blocks2,
          patterns,
          onSelect: (transformedBlocks) => {
            onPatternTransform(transformedBlocks);
            onClose();
          }
        }
      ),
      hasBlockOrBlockVariationTransforms && /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
        block_transformations_menu_default,
        {
          className: "block-editor-block-switcher__transforms__menugroup",
          possibleBlockTransformations,
          possibleBlockVariationTransformations: blockVariationTransformations,
          blocks: blocks2,
          onSelect: (name) => {
            onBlockTransform(name);
            onClose();
          },
          onSelectVariation: (name) => {
            onBlockVariationTransform(name);
            onClose();
          }
        }
      ),
      hasBlockStyles && /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
        BlockStylesMenu,
        {
          hoveredBlock: blocks2[0],
          onSwitch: onClose
        }
      ),
      isUsingBindings && /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(import_components79.MenuGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(import_components79.__experimentalText, { className: "block-editor-block-switcher__binding-indicator", children: connectedBlockDescription }) })
    ] });
  }
  var BlockSwitcher = ({ clientIds }) => {
    const {
      hasContentOnlyLocking,
      canRemove,
      hasBlockStyles,
      icon,
      invalidBlocks,
      isReusable,
      isTemplate,
      isDisabled,
      isSectionInSelection
    } = (0, import_data86.useSelect)(
      (select2) => {
        const {
          getTemplateLock: getTemplateLock2,
          getBlocksByClientId: getBlocksByClientId2,
          getBlockAttributes: getBlockAttributes3,
          canRemoveBlocks: canRemoveBlocks2,
          getBlockEditingMode: getBlockEditingMode2,
          isSectionBlock: isSectionBlock2
        } = unlock(select2(store));
        const { getBlockStyles: getBlockStyles2, getBlockType: getBlockType21, getActiveBlockVariation } = select2(import_blocks50.store);
        const _blocks = getBlocksByClientId2(clientIds);
        if (!_blocks.length || _blocks.some((block) => !block)) {
          return { invalidBlocks: true };
        }
        const [{ name: firstBlockName }] = _blocks;
        const _isSingleBlockSelected = _blocks.length === 1;
        const blockType = getBlockType21(firstBlockName);
        const editingMode = getBlockEditingMode2(clientIds[0]);
        let _icon;
        let _hasTemplateLock;
        if (_isSingleBlockSelected) {
          const match2 = getActiveBlockVariation(
            firstBlockName,
            getBlockAttributes3(clientIds[0])
          );
          _icon = match2?.icon || blockType.icon;
          _hasTemplateLock = getTemplateLock2(clientIds[0]) === "contentOnly";
        } else {
          const isSelectionOfSameType = new Set(_blocks.map(({ name }) => name)).size === 1;
          _hasTemplateLock = clientIds.some(
            (id) => getTemplateLock2(id) === "contentOnly"
          );
          _icon = isSelectionOfSameType ? blockType.icon : copy_default;
        }
        const _isSectionInSelection = clientIds.some(
          (id) => isSectionBlock2(id)
        );
        return {
          canRemove: canRemoveBlocks2(clientIds),
          hasBlockStyles: _isSingleBlockSelected && !!getBlockStyles2(firstBlockName)?.length,
          icon: _icon,
          isReusable: _isSingleBlockSelected && (0, import_blocks50.isReusableBlock)(_blocks[0]),
          isTemplate: _isSingleBlockSelected && (0, import_blocks50.isTemplatePart)(_blocks[0]),
          hasContentOnlyLocking: _hasTemplateLock,
          isDisabled: editingMode !== "default",
          isSectionInSelection: _isSectionInSelection
        };
      },
      [clientIds]
    );
    const blockTitle = useBlockDisplayTitle({
      clientId: clientIds?.[0],
      maximumLength: 35
    });
    const showIconLabels = (0, import_data86.useSelect)(
      (select2) => select2(import_preferences2.store).get("core", "showIconLabels"),
      []
    );
    if (invalidBlocks) {
      return null;
    }
    const isSingleBlock = clientIds.length === 1;
    const blockSwitcherLabel = isSingleBlock ? blockTitle : (0, import_i18n79.__)("Multiple blocks selected");
    const blockIndicatorText = (isReusable || isTemplate) && !showIconLabels && blockTitle ? blockTitle : void 0;
    const hideTransformsForSections = window?.__experimentalContentOnlyPatternInsertion && isSectionInSelection;
    const hideDropdown = hideTransformsForSections || isDisabled || !hasBlockStyles && !canRemove || hasContentOnlyLocking;
    if (hideDropdown) {
      return /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(import_components79.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
        import_components79.ToolbarButton,
        {
          disabled: true,
          className: "block-editor-block-switcher__no-switcher-icon",
          title: blockSwitcherLabel,
          icon: /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
            block_icon_default,
            {
              className: "block-editor-block-switcher__toggle",
              icon,
              showColors: true
            }
          ),
          text: blockIndicatorText
        }
      ) });
    }
    const blockSwitcherDescription = isSingleBlock ? (0, import_i18n79.__)("Change block type or style") : (0, import_i18n79.sprintf)(
      /* translators: %d: number of blocks. */
      (0, import_i18n79._n)(
        "Change type of %d block",
        "Change type of %d blocks",
        clientIds.length
      ),
      clientIds.length
    );
    return /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(import_components79.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(import_components79.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
      import_components79.DropdownMenu,
      {
        className: "block-editor-block-switcher",
        label: blockSwitcherLabel,
        popoverProps: {
          placement: "bottom-start",
          className: "block-editor-block-switcher__popover"
        },
        icon: /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
          block_icon_default,
          {
            className: "block-editor-block-switcher__toggle",
            icon,
            showColors: true
          }
        ),
        text: blockIndicatorText,
        toggleProps: {
          description: blockSwitcherDescription,
          ...toggleProps
        },
        menuProps: { orientation: "both" },
        children: ({ onClose }) => /* @__PURE__ */ (0, import_jsx_runtime215.jsx)(
          BlockSwitcherDropdownMenuContents,
          {
            onClose,
            clientIds,
            hasBlockStyles,
            canRemove
          }
        )
      }
    ) }) });
  };
  var block_switcher_default = BlockSwitcher;

  // packages/block-editor/build-module/components/block-controls/index.js
  var import_jsx_runtime218 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/block-controls/fill.js
  var import_jsx_runtime216 = __toESM(require_jsx_runtime());
  var import_components81 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-controls/groups.js
  var import_components80 = __toESM(require_components());
  var BlockControlsDefault = (0, import_components80.createSlotFill)("BlockControls");
  var BlockControlsBlock = (0, import_components80.createSlotFill)("BlockControlsBlock");
  var BlockControlsInline = (0, import_components80.createSlotFill)("BlockFormatControls");
  var BlockControlsOther = (0, import_components80.createSlotFill)("BlockControlsOther");
  var BlockControlsParent = (0, import_components80.createSlotFill)("BlockControlsParent");
  var groups2 = {
    default: BlockControlsDefault,
    block: BlockControlsBlock,
    inline: BlockControlsInline,
    other: BlockControlsOther,
    parent: BlockControlsParent
  };
  var groups_default2 = groups2;

  // packages/block-editor/build-module/components/block-controls/hook.js
  function useBlockControlsFill(group, shareWithChildBlocks) {
    const context = useBlockEditContext();
    if (context[mayDisplayControlsKey]) {
      return groups_default2[group]?.Fill;
    }
    if (context[mayDisplayParentControlsKey] && shareWithChildBlocks) {
      return groups_default2.parent.Fill;
    }
    return null;
  }

  // packages/block-editor/build-module/components/block-controls/fill.js
  function BlockControlsFill({
    group = "default",
    controls,
    children,
    __experimentalShareWithChildBlocks = false
  }) {
    const Fill3 = useBlockControlsFill(
      group,
      __experimentalShareWithChildBlocks
    );
    if (!Fill3) {
      return null;
    }
    const innerMarkup = /* @__PURE__ */ (0, import_jsx_runtime216.jsxs)(import_jsx_runtime216.Fragment, { children: [
      group === "default" && /* @__PURE__ */ (0, import_jsx_runtime216.jsx)(import_components81.ToolbarGroup, { controls }),
      children
    ] });
    return /* @__PURE__ */ (0, import_jsx_runtime216.jsx)(import_components81.__experimentalStyleProvider, { document, children: /* @__PURE__ */ (0, import_jsx_runtime216.jsx)(Fill3, { children: (fillProps) => {
      const { forwardedContext = [] } = fillProps;
      return forwardedContext.reduce(
        (inner, [Provider2, props]) => /* @__PURE__ */ (0, import_jsx_runtime216.jsx)(Provider2, { ...props, children: inner }),
        innerMarkup
      );
    } }) });
  }

  // packages/block-editor/build-module/components/block-controls/slot.js
  var import_jsx_runtime217 = __toESM(require_jsx_runtime());
  var import_element103 = __toESM(require_element());
  var import_components82 = __toESM(require_components());
  var import_warning7 = __toESM(require_warning());
  var { ComponentsContext } = unlock(import_components82.privateApis);
  function BlockControlsSlot({ group = "default", ...props }) {
    const toolbarState = (0, import_element103.useContext)(import_components82.__experimentalToolbarContext);
    const contextState = (0, import_element103.useContext)(ComponentsContext);
    const fillProps = (0, import_element103.useMemo)(
      () => ({
        forwardedContext: [
          [import_components82.__experimentalToolbarContext.Provider, { value: toolbarState }],
          [ComponentsContext.Provider, { value: contextState }]
        ]
      }),
      [toolbarState, contextState]
    );
    const slotFill = groups_default2[group];
    const fills = (0, import_components82.__experimentalUseSlotFills)(slotFill.name);
    if (!slotFill) {
      (0, import_warning7.default)(`Unknown BlockControls group "${group}" provided.`);
      return null;
    }
    if (!fills?.length) {
      return null;
    }
    const { Slot: Slot6 } = slotFill;
    const slot = /* @__PURE__ */ (0, import_jsx_runtime217.jsx)(Slot6, { ...props, bubblesVirtually: true, fillProps });
    if (group === "default") {
      return slot;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime217.jsx)(import_components82.ToolbarGroup, { children: slot });
  }

  // packages/block-editor/build-module/components/block-controls/index.js
  var BlockControls = BlockControlsFill;
  BlockControls.Slot = BlockControlsSlot;
  var BlockFormatControls = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime218.jsx)(BlockControlsFill, { group: "inline", ...props });
  };
  BlockFormatControls.Slot = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime218.jsx)(BlockControlsSlot, { group: "inline", ...props });
  };
  var block_controls_default = BlockControls;

  // packages/block-editor/build-module/components/block-toolbar/block-toolbar-last-item.js
  var import_components83 = __toESM(require_components());
  var { Fill: __unstableBlockToolbarLastItem, Slot: Slot2 } = (0, import_components83.createSlotFill)(
    "__unstableBlockToolbarLastItem"
  );
  __unstableBlockToolbarLastItem.Slot = Slot2;
  var block_toolbar_last_item_default = __unstableBlockToolbarLastItem;

  // packages/block-editor/build-module/components/block-settings-menu/index.js
  var import_jsx_runtime234 = __toESM(require_jsx_runtime());
  var import_components102 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js
  var import_jsx_runtime233 = __toESM(require_jsx_runtime());
  var import_blocks63 = __toESM(require_blocks());
  var import_components100 = __toESM(require_components());
  var import_data102 = __toESM(require_data());
  var import_element113 = __toESM(require_element());
  var import_i18n94 = __toESM(require_i18n());
  var import_keyboard_shortcuts5 = __toESM(require_keyboard_shortcuts());
  var import_compose62 = __toESM(require_compose());

  // packages/block-editor/build-module/components/block-actions/index.js
  var import_data88 = __toESM(require_data());
  var import_blocks53 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/use-paste-styles/index.js
  var import_element105 = __toESM(require_element());
  var import_blocks52 = __toESM(require_blocks());
  var import_data87 = __toESM(require_data());
  var import_notices6 = __toESM(require_notices());
  var import_i18n80 = __toESM(require_i18n());

  // packages/block-editor/build-module/hooks/supports.js
  var import_blocks51 = __toESM(require_blocks());
  var import_element104 = __toESM(require_element());
  var ALIGN_SUPPORT_KEY = "align";
  var BORDER_SUPPORT_KEY = "__experimentalBorder";
  var COLOR_SUPPORT_KEY = "color";
  var CUSTOM_CLASS_NAME_SUPPORT_KEY = "customClassName";
  var FONT_FAMILY_SUPPORT_KEY = "typography.__experimentalFontFamily";
  var FONT_SIZE_SUPPORT_KEY = "typography.fontSize";
  var LINE_HEIGHT_SUPPORT_KEY = "typography.lineHeight";
  var FONT_STYLE_SUPPORT_KEY = "typography.__experimentalFontStyle";
  var FONT_WEIGHT_SUPPORT_KEY = "typography.__experimentalFontWeight";
  var TEXT_ALIGN_SUPPORT_KEY = "typography.textAlign";
  var TEXT_COLUMNS_SUPPORT_KEY = "typography.textColumns";
  var TEXT_DECORATION_SUPPORT_KEY = "typography.__experimentalTextDecoration";
  var WRITING_MODE_SUPPORT_KEY = "typography.__experimentalWritingMode";
  var TEXT_TRANSFORM_SUPPORT_KEY = "typography.__experimentalTextTransform";
  var LETTER_SPACING_SUPPORT_KEY = "typography.__experimentalLetterSpacing";
  var LAYOUT_SUPPORT_KEY = "layout";
  var TYPOGRAPHY_SUPPORT_KEYS = [
    LINE_HEIGHT_SUPPORT_KEY,
    FONT_SIZE_SUPPORT_KEY,
    FONT_STYLE_SUPPORT_KEY,
    FONT_WEIGHT_SUPPORT_KEY,
    FONT_FAMILY_SUPPORT_KEY,
    TEXT_ALIGN_SUPPORT_KEY,
    TEXT_COLUMNS_SUPPORT_KEY,
    TEXT_DECORATION_SUPPORT_KEY,
    TEXT_TRANSFORM_SUPPORT_KEY,
    WRITING_MODE_SUPPORT_KEY,
    LETTER_SPACING_SUPPORT_KEY
  ];
  var EFFECTS_SUPPORT_KEYS = ["shadow"];
  var SPACING_SUPPORT_KEY = "spacing";
  var styleSupportKeys = [
    ...EFFECTS_SUPPORT_KEYS,
    ...TYPOGRAPHY_SUPPORT_KEYS,
    BORDER_SUPPORT_KEY,
    COLOR_SUPPORT_KEY,
    SPACING_SUPPORT_KEY
  ];
  var hasAlignSupport = (nameOrType) => (0, import_blocks51.hasBlockSupport)(nameOrType, ALIGN_SUPPORT_KEY);
  function hasBorderSupport(nameOrType, feature = "any") {
    if (import_element104.Platform.OS !== "web") {
      return false;
    }
    const support = (0, import_blocks51.getBlockSupport)(nameOrType, BORDER_SUPPORT_KEY);
    if (support === true) {
      return true;
    }
    if (feature === "any") {
      return !!(support?.color || support?.radius || support?.width || support?.style);
    }
    return !!support?.[feature];
  }
  var hasGradientSupport = (nameOrType) => {
    const colorSupport = (0, import_blocks51.getBlockSupport)(nameOrType, COLOR_SUPPORT_KEY);
    return colorSupport !== null && typeof colorSupport === "object" && !!colorSupport.gradients;
  };
  var hasBackgroundColorSupport = (nameOrType) => {
    const colorSupport = (0, import_blocks51.getBlockSupport)(nameOrType, COLOR_SUPPORT_KEY);
    return colorSupport && colorSupport.background !== false;
  };
  var hasTextAlignSupport = (nameOrType) => (0, import_blocks51.hasBlockSupport)(nameOrType, TEXT_ALIGN_SUPPORT_KEY);
  var hasTextColorSupport = (nameOrType) => {
    const colorSupport = (0, import_blocks51.getBlockSupport)(nameOrType, COLOR_SUPPORT_KEY);
    return colorSupport && colorSupport.text !== false;
  };
  var hasCustomClassNameSupport = (nameOrType) => (0, import_blocks51.hasBlockSupport)(nameOrType, CUSTOM_CLASS_NAME_SUPPORT_KEY, true);
  var hasFontFamilySupport = (nameOrType) => (0, import_blocks51.hasBlockSupport)(nameOrType, FONT_FAMILY_SUPPORT_KEY);
  var hasFontSizeSupport = (nameOrType) => (0, import_blocks51.hasBlockSupport)(nameOrType, FONT_SIZE_SUPPORT_KEY);
  var hasLayoutSupport = (nameOrType) => (0, import_blocks51.hasBlockSupport)(nameOrType, LAYOUT_SUPPORT_KEY);
  var hasStyleSupport = (nameOrType) => styleSupportKeys.some((key) => (0, import_blocks51.hasBlockSupport)(nameOrType, key));

  // packages/block-editor/build-module/components/use-paste-styles/index.js
  function hasSerializedBlocks(text) {
    try {
      const blocks2 = (0, import_blocks52.parse)(text, {
        __unstableSkipMigrationLogs: true,
        __unstableSkipAutop: true
      });
      if (blocks2.length === 1 && blocks2[0].name === "core/freeform") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  var STYLE_ATTRIBUTES = {
    align: hasAlignSupport,
    borderColor: (nameOrType) => hasBorderSupport(nameOrType, "color"),
    backgroundColor: hasBackgroundColorSupport,
    textAlign: hasTextAlignSupport,
    textColor: hasTextColorSupport,
    gradient: hasGradientSupport,
    className: hasCustomClassNameSupport,
    fontFamily: hasFontFamilySupport,
    fontSize: hasFontSizeSupport,
    layout: hasLayoutSupport,
    style: hasStyleSupport
  };
  function getStyleAttributes(sourceBlock, targetBlock) {
    return Object.entries(STYLE_ATTRIBUTES).reduce(
      (attributes, [attributeKey, hasSupport]) => {
        if (hasSupport(sourceBlock.name) && hasSupport(targetBlock.name)) {
          attributes[attributeKey] = sourceBlock.attributes[attributeKey];
        }
        return attributes;
      },
      {}
    );
  }
  function recursivelyUpdateBlockAttributes(targetBlocks, sourceBlocks, updateBlockAttributes2) {
    for (let index = 0; index < Math.min(sourceBlocks.length, targetBlocks.length); index += 1) {
      updateBlockAttributes2(
        targetBlocks[index].clientId,
        getStyleAttributes(sourceBlocks[index], targetBlocks[index])
      );
      recursivelyUpdateBlockAttributes(
        targetBlocks[index].innerBlocks,
        sourceBlocks[index].innerBlocks,
        updateBlockAttributes2
      );
    }
  }
  function usePasteStyles() {
    const registry = (0, import_data87.useRegistry)();
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data87.useDispatch)(store);
    const { createSuccessNotice, createWarningNotice, createErrorNotice } = (0, import_data87.useDispatch)(import_notices6.store);
    return (0, import_element105.useCallback)(
      async (targetBlocks) => {
        let html = "";
        try {
          if (!window.navigator.clipboard) {
            createErrorNotice(
              (0, import_i18n80.__)(
                "Unable to paste styles. This feature is only available on secure (https) sites in supporting browsers."
              ),
              { type: "snackbar" }
            );
            return;
          }
          html = await window.navigator.clipboard.readText();
        } catch (error) {
          createErrorNotice(
            (0, import_i18n80.__)(
              "Unable to paste styles. Please allow browser clipboard permissions before continuing."
            ),
            {
              type: "snackbar"
            }
          );
          return;
        }
        if (!html || !hasSerializedBlocks(html)) {
          createWarningNotice(
            (0, import_i18n80.__)(
              "Unable to paste styles. Block styles couldn't be found within the copied content."
            ),
            {
              type: "snackbar"
            }
          );
          return;
        }
        const copiedBlocks = (0, import_blocks52.parse)(html);
        if (copiedBlocks.length === 1) {
          registry.batch(() => {
            recursivelyUpdateBlockAttributes(
              targetBlocks,
              targetBlocks.map(() => copiedBlocks[0]),
              updateBlockAttributes2
            );
          });
        } else {
          registry.batch(() => {
            recursivelyUpdateBlockAttributes(
              targetBlocks,
              copiedBlocks,
              updateBlockAttributes2
            );
          });
        }
        if (targetBlocks.length === 1) {
          const title = (0, import_blocks52.getBlockType)(targetBlocks[0].name)?.title;
          createSuccessNotice(
            (0, import_i18n80.sprintf)(
              // Translators: %s: Name of the block being pasted, e.g. "Paragraph".
              (0, import_i18n80.__)("Pasted styles to %s."),
              title
            ),
            { type: "snackbar" }
          );
        } else {
          createSuccessNotice(
            (0, import_i18n80.sprintf)(
              // Translators: %d: The number of the blocks.
              (0, import_i18n80.__)("Pasted styles to %d blocks."),
              targetBlocks.length
            ),
            { type: "snackbar" }
          );
        }
      },
      [
        registry.batch,
        updateBlockAttributes2,
        createSuccessNotice,
        createWarningNotice,
        createErrorNotice
      ]
    );
  }

  // packages/block-editor/build-module/components/block-actions/index.js
  function BlockActions({
    clientIds,
    children,
    __experimentalUpdateSelection: updateSelection
  }) {
    const { getDefaultBlockName: getDefaultBlockName7, getGroupingBlockName } = (0, import_data88.useSelect)(import_blocks53.store);
    const selected = (0, import_data88.useSelect)(
      (select2) => {
        const {
          canInsertBlockType: canInsertBlockType2,
          getBlockRootClientId: getBlockRootClientId2,
          getBlocksByClientId: getBlocksByClientId22,
          getDirectInsertBlock: getDirectInsertBlock2,
          canRemoveBlocks: canRemoveBlocks2
        } = select2(store);
        const blocks2 = getBlocksByClientId22(clientIds);
        const rootClientId = getBlockRootClientId2(clientIds[0]);
        const canInsertDefaultBlock = canInsertBlockType2(
          getDefaultBlockName7(),
          rootClientId
        );
        const directInsertBlock = rootClientId ? getDirectInsertBlock2(rootClientId) : null;
        return {
          canRemove: canRemoveBlocks2(clientIds),
          canInsertBlock: blocks2.every((block) => {
            return (canInsertDefaultBlock || !!directInsertBlock) && canInsertBlockType2(block.name, rootClientId);
          }),
          canCopyStyles: blocks2.every((block) => {
            return !!block && ((0, import_blocks53.hasBlockSupport)(block.name, "color") || (0, import_blocks53.hasBlockSupport)(block.name, "typography"));
          }),
          canDuplicate: blocks2.every((block) => {
            return !!block && (0, import_blocks53.hasBlockSupport)(block.name, "multiple", true) && canInsertBlockType2(block.name, rootClientId);
          })
        };
      },
      [clientIds, getDefaultBlockName7]
    );
    const { getBlocksByClientId: getBlocksByClientId2, getBlocks: getBlocks2 } = (0, import_data88.useSelect)(store);
    const { canRemove, canInsertBlock, canCopyStyles, canDuplicate } = selected;
    const {
      removeBlocks: removeBlocks2,
      replaceBlocks: replaceBlocks2,
      duplicateBlocks: duplicateBlocks2,
      insertAfterBlock: insertAfterBlock2,
      insertBeforeBlock: insertBeforeBlock2,
      flashBlock: flashBlock2
    } = (0, import_data88.useDispatch)(store);
    const pasteStyles = usePasteStyles();
    return children({
      canCopyStyles,
      canDuplicate,
      canInsertBlock,
      canRemove,
      onDuplicate() {
        return duplicateBlocks2(clientIds, updateSelection);
      },
      onRemove() {
        return removeBlocks2(clientIds, updateSelection);
      },
      onInsertBefore() {
        insertBeforeBlock2(clientIds[0]);
      },
      onInsertAfter() {
        insertAfterBlock2(clientIds[clientIds.length - 1]);
      },
      onGroup() {
        if (!clientIds.length) {
          return;
        }
        const groupingBlockName = getGroupingBlockName();
        const newBlocks = (0, import_blocks53.switchToBlockType)(
          getBlocksByClientId2(clientIds),
          groupingBlockName
        );
        if (!newBlocks) {
          return;
        }
        replaceBlocks2(clientIds, newBlocks);
      },
      onUngroup() {
        if (!clientIds.length) {
          return;
        }
        const innerBlocks = getBlocks2(clientIds[0]);
        if (!innerBlocks.length) {
          return;
        }
        replaceBlocks2(clientIds, innerBlocks);
      },
      onCopy() {
        if (clientIds.length === 1) {
          flashBlock2(clientIds[0]);
        }
      },
      async onPasteStyles() {
        await pasteStyles(getBlocksByClientId2(clientIds));
      }
    });
  }

  // packages/block-editor/build-module/components/collab/block-comment-icon-slot.js
  var import_components84 = __toESM(require_components());
  var CommentIconSlotFill = (0, import_components84.createSlotFill)(Symbol("CommentIconSlotFill"));
  var block_comment_icon_slot_default = CommentIconSlotFill;

  // packages/block-editor/build-module/components/block-settings-menu/block-html-convert-button.js
  var import_jsx_runtime219 = __toESM(require_jsx_runtime());
  var import_i18n81 = __toESM(require_i18n());
  var import_components85 = __toESM(require_components());
  var import_blocks54 = __toESM(require_blocks());
  var import_data89 = __toESM(require_data());
  function BlockHTMLConvertButton({ clientId }) {
    const block = (0, import_data89.useSelect)(
      (select2) => select2(store).getBlock(clientId),
      [clientId]
    );
    const { replaceBlocks: replaceBlocks2 } = (0, import_data89.useDispatch)(store);
    if (!block || block.name !== "core/html") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime219.jsx)(
      import_components85.MenuItem,
      {
        onClick: () => replaceBlocks2(
          clientId,
          (0, import_blocks54.rawHandler)({ HTML: (0, import_blocks54.getBlockContent)(block) })
        ),
        children: (0, import_i18n81.__)("Convert to Blocks")
      }
    );
  }
  var block_html_convert_button_default = BlockHTMLConvertButton;

  // packages/block-editor/build-module/components/block-settings-menu/block-settings-menu-first-item.js
  var import_components86 = __toESM(require_components());
  var { Fill: __unstableBlockSettingsMenuFirstItem, Slot: Slot3 } = (0, import_components86.createSlotFill)(
    "__unstableBlockSettingsMenuFirstItem"
  );
  __unstableBlockSettingsMenuFirstItem.Slot = Slot3;
  var block_settings_menu_first_item_default = __unstableBlockSettingsMenuFirstItem;

  // packages/block-editor/build-module/components/block-settings-menu-controls/index.js
  var import_jsx_runtime231 = __toESM(require_jsx_runtime());
  var import_components98 = __toESM(require_components());
  var import_blocks62 = __toESM(require_blocks());
  var import_data100 = __toESM(require_data());

  // packages/block-editor/build-module/components/convert-to-group-buttons/index.js
  var import_jsx_runtime221 = __toESM(require_jsx_runtime());
  var import_components88 = __toESM(require_components());
  var import_i18n83 = __toESM(require_i18n());
  var import_blocks57 = __toESM(require_blocks());
  var import_data92 = __toESM(require_data());
  var import_keycodes9 = __toESM(require_keycodes());

  // packages/block-editor/build-module/components/convert-to-group-buttons/use-convert-to-group-button-props.js
  var import_blocks55 = __toESM(require_blocks());
  var import_data90 = __toESM(require_data());
  function useConvertToGroupButtonProps(selectedClientIds) {
    return (0, import_data90.useSelect)(
      (select2) => {
        const {
          getBlocksByClientId: getBlocksByClientId2,
          getSelectedBlockClientIds: getSelectedBlockClientIds2,
          isUngroupable: isUngroupable2,
          isGroupable: isGroupable2
        } = select2(store);
        const { getGroupingBlockName, getBlockType: getBlockType21 } = select2(import_blocks55.store);
        const clientIds = selectedClientIds?.length ? selectedClientIds : getSelectedBlockClientIds2();
        const blocksSelection = getBlocksByClientId2(clientIds);
        const [firstSelectedBlock] = blocksSelection;
        const _isUngroupable = clientIds.length === 1 && isUngroupable2(clientIds[0]);
        return {
          clientIds,
          isGroupable: isGroupable2(clientIds),
          isUngroupable: _isUngroupable,
          blocksSelection,
          groupingBlockName: getGroupingBlockName(),
          onUngroup: _isUngroupable && getBlockType21(firstSelectedBlock.name)?.transforms?.ungroup
        };
      },
      [selectedClientIds]
    );
  }

  // packages/block-editor/build-module/components/convert-to-group-buttons/toolbar.js
  var import_jsx_runtime220 = __toESM(require_jsx_runtime());
  var import_data91 = __toESM(require_data());
  var import_blocks56 = __toESM(require_blocks());
  var import_components87 = __toESM(require_components());
  var import_i18n82 = __toESM(require_i18n());
  var layouts = {
    group: { type: "constrained" },
    row: { type: "flex", flexWrap: "nowrap" },
    stack: { type: "flex", orientation: "vertical" },
    grid: { type: "grid" }
  };
  function BlockGroupToolbar() {
    const { blocksSelection, clientIds, groupingBlockName, isGroupable: isGroupable2 } = useConvertToGroupButtonProps();
    const { replaceBlocks: replaceBlocks2 } = (0, import_data91.useDispatch)(store);
    const { canRemove, variations } = (0, import_data91.useSelect)(
      (select2) => {
        const { canRemoveBlocks: canRemoveBlocks2 } = select2(store);
        const { getBlockVariations: getBlockVariations2 } = select2(import_blocks56.store);
        return {
          canRemove: canRemoveBlocks2(clientIds),
          variations: getBlockVariations2(
            groupingBlockName,
            "transform"
          )
        };
      },
      [clientIds, groupingBlockName]
    );
    const onConvertToGroup = (layout) => {
      const newBlocks = (0, import_blocks56.switchToBlockType)(
        blocksSelection,
        groupingBlockName
      );
      if (typeof layout !== "string") {
        layout = "group";
      }
      if (newBlocks && newBlocks.length > 0) {
        newBlocks[0].attributes.layout = layouts[layout];
        replaceBlocks2(clientIds, newBlocks);
      }
    };
    const onConvertToRow = () => onConvertToGroup("row");
    const onConvertToStack = () => onConvertToGroup("stack");
    const onConvertToGrid = () => onConvertToGroup("grid");
    if (!isGroupable2 || !canRemove) {
      return null;
    }
    const canInsertRow = !!variations.find(
      ({ name }) => name === "group-row"
    );
    const canInsertStack = !!variations.find(
      ({ name }) => name === "group-stack"
    );
    const canInsertGrid = !!variations.find(
      ({ name }) => name === "group-grid"
    );
    return /* @__PURE__ */ (0, import_jsx_runtime220.jsxs)(import_components87.ToolbarGroup, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime220.jsx)(
        import_components87.ToolbarButton,
        {
          icon: group_default,
          label: (0, import_i18n82._x)("Group", "action: convert blocks to group"),
          onClick: onConvertToGroup
        }
      ),
      canInsertRow && /* @__PURE__ */ (0, import_jsx_runtime220.jsx)(
        import_components87.ToolbarButton,
        {
          icon: row_default,
          label: (0, import_i18n82._x)("Row", "action: convert blocks to row"),
          onClick: onConvertToRow
        }
      ),
      canInsertStack && /* @__PURE__ */ (0, import_jsx_runtime220.jsx)(
        import_components87.ToolbarButton,
        {
          icon: stack_default,
          label: (0, import_i18n82._x)("Stack", "action: convert blocks to stack"),
          onClick: onConvertToStack
        }
      ),
      canInsertGrid && /* @__PURE__ */ (0, import_jsx_runtime220.jsx)(
        import_components87.ToolbarButton,
        {
          icon: grid_default,
          label: (0, import_i18n82._x)("Grid", "action: convert blocks to grid"),
          onClick: onConvertToGrid
        }
      )
    ] });
  }
  var toolbar_default = BlockGroupToolbar;

  // packages/block-editor/build-module/components/convert-to-group-buttons/index.js
  function ConvertToGroupButton({
    clientIds,
    isGroupable: isGroupable2,
    isUngroupable: isUngroupable2,
    onUngroup,
    blocksSelection,
    groupingBlockName,
    onClose = () => {
    }
  }) {
    const { getSelectedBlockClientIds: getSelectedBlockClientIds2 } = (0, import_data92.useSelect)(store);
    const { replaceBlocks: replaceBlocks2 } = (0, import_data92.useDispatch)(store);
    const onConvertToGroup = () => {
      const newBlocks = (0, import_blocks57.switchToBlockType)(
        blocksSelection,
        groupingBlockName
      );
      if (newBlocks) {
        replaceBlocks2(clientIds, newBlocks);
      }
    };
    const onConvertFromGroup = () => {
      let innerBlocks = blocksSelection[0].innerBlocks;
      if (!innerBlocks.length) {
        return;
      }
      if (onUngroup) {
        innerBlocks = onUngroup(
          blocksSelection[0].attributes,
          blocksSelection[0].innerBlocks
        );
      }
      replaceBlocks2(clientIds, innerBlocks);
    };
    if (!isGroupable2 && !isUngroupable2) {
      return null;
    }
    const selectedBlockClientIds = getSelectedBlockClientIds2();
    return /* @__PURE__ */ (0, import_jsx_runtime221.jsxs)(import_jsx_runtime221.Fragment, { children: [
      isGroupable2 && /* @__PURE__ */ (0, import_jsx_runtime221.jsx)(
        import_components88.MenuItem,
        {
          shortcut: selectedBlockClientIds.length > 1 ? import_keycodes9.displayShortcut.primary("g") : void 0,
          onClick: () => {
            onConvertToGroup();
            onClose();
          },
          children: (0, import_i18n83._x)("Group", "verb")
        }
      ),
      isUngroupable2 && /* @__PURE__ */ (0, import_jsx_runtime221.jsx)(
        import_components88.MenuItem,
        {
          onClick: () => {
            onConvertFromGroup();
            onClose();
          },
          children: (0, import_i18n83._x)(
            "Ungroup",
            "Ungrouping blocks from within a grouping block back into individual blocks within the Editor"
          )
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/block-lock/menu-item.js
  var import_jsx_runtime223 = __toESM(require_jsx_runtime());
  var import_i18n85 = __toESM(require_i18n());
  var import_element107 = __toESM(require_element());
  var import_components90 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-lock/use-block-lock.js
  var import_data93 = __toESM(require_data());
  function useBlockLock(clientId) {
    return (0, import_data93.useSelect)(
      (select2) => {
        const {
          canEditBlock: canEditBlock2,
          canMoveBlock: canMoveBlock2,
          canRemoveBlock: canRemoveBlock2,
          canLockBlockType: canLockBlockType2,
          getBlockName: getBlockName2,
          getTemplateLock: getTemplateLock2
        } = select2(store);
        const canEdit = canEditBlock2(clientId);
        const canMove = canMoveBlock2(clientId);
        const canRemove = canRemoveBlock2(clientId);
        return {
          canEdit,
          canMove,
          canRemove,
          canLock: canLockBlockType2(getBlockName2(clientId)),
          isContentLocked: getTemplateLock2(clientId) === "contentOnly",
          isLocked: !canEdit || !canMove || !canRemove
        };
      },
      [clientId]
    );
  }

  // packages/block-editor/build-module/components/block-lock/modal.js
  var import_jsx_runtime222 = __toESM(require_jsx_runtime());
  var import_i18n84 = __toESM(require_i18n());
  var import_element106 = __toESM(require_element());
  var import_components89 = __toESM(require_components());
  var import_data94 = __toESM(require_data());
  var import_blocks58 = __toESM(require_blocks());
  var ALLOWS_EDIT_LOCKING = ["core/navigation"];
  function getTemplateLockValue(lock3) {
    if (lock3.remove && lock3.move) {
      return "all";
    }
    if (lock3.remove && !lock3.move) {
      return "insert";
    }
    return false;
  }
  function BlockLockModal({ clientId, onClose }) {
    const [lock3, setLock] = (0, import_element106.useState)({ move: false, remove: false });
    const { canEdit, canMove, canRemove } = useBlockLock(clientId);
    const { allowsEditLocking, templateLock, hasTemplateLock } = (0, import_data94.useSelect)(
      (select2) => {
        const { getBlockName: getBlockName2, getBlockAttributes: getBlockAttributes3 } = select2(store);
        const blockName = getBlockName2(clientId);
        const blockType = (0, import_blocks58.getBlockType)(blockName);
        return {
          allowsEditLocking: ALLOWS_EDIT_LOCKING.includes(blockName),
          templateLock: getBlockAttributes3(clientId)?.templateLock,
          hasTemplateLock: !!blockType?.attributes?.templateLock
        };
      },
      [clientId]
    );
    const [applyTemplateLock, setApplyTemplateLock] = (0, import_element106.useState)(
      !!templateLock
    );
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data94.useDispatch)(store);
    const blockInformation = useBlockDisplayInformation(clientId);
    (0, import_element106.useEffect)(() => {
      setLock({
        move: !canMove,
        remove: !canRemove,
        ...allowsEditLocking ? { edit: !canEdit } : {}
      });
    }, [canEdit, canMove, canRemove, allowsEditLocking]);
    const isAllChecked = Object.values(lock3).every(Boolean);
    const isMixed = Object.values(lock3).some(Boolean) && !isAllChecked;
    return /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
      import_components89.Modal,
      {
        title: (0, import_i18n84.sprintf)(
          /* translators: %s: Name of the block. */
          (0, import_i18n84.__)("Lock %s"),
          blockInformation.title
        ),
        overlayClassName: "block-editor-block-lock-modal",
        onRequestClose: onClose,
        size: "small",
        children: /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)(
          "form",
          {
            onSubmit: (event) => {
              event.preventDefault();
              updateBlockAttributes2([clientId], {
                lock: lock3,
                templateLock: applyTemplateLock ? getTemplateLockValue(lock3) : void 0
              });
              onClose();
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)("fieldset", { className: "block-editor-block-lock-modal__options", children: [
                /* @__PURE__ */ (0, import_jsx_runtime222.jsx)("legend", { children: (0, import_i18n84.__)("Select the features you want to lock") }),
                /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                  "ul",
                  {
                    role: "list",
                    className: "block-editor-block-lock-modal__checklist",
                    children: /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)("li", { children: [
                      /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                        import_components89.CheckboxControl,
                        {
                          __nextHasNoMarginBottom: true,
                          className: "block-editor-block-lock-modal__options-all",
                          label: (0, import_i18n84.__)("Lock all"),
                          checked: isAllChecked,
                          indeterminate: isMixed,
                          onChange: (newValue) => setLock({
                            move: newValue,
                            remove: newValue,
                            ...allowsEditLocking ? { edit: newValue } : {}
                          })
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)(
                        "ul",
                        {
                          role: "list",
                          className: "block-editor-block-lock-modal__checklist",
                          children: [
                            allowsEditLocking && /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)("li", { className: "block-editor-block-lock-modal__checklist-item", children: [
                              /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                                import_components89.CheckboxControl,
                                {
                                  __nextHasNoMarginBottom: true,
                                  label: (0, import_i18n84.__)("Lock editing"),
                                  checked: !!lock3.edit,
                                  onChange: (edit) => setLock((prevLock) => ({
                                    ...prevLock,
                                    edit
                                  }))
                                }
                              ),
                              /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                                import_components89.Icon,
                                {
                                  className: "block-editor-block-lock-modal__lock-icon",
                                  icon: lock3.edit ? lock_default : unlock_default
                                }
                              )
                            ] }),
                            /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)("li", { className: "block-editor-block-lock-modal__checklist-item", children: [
                              /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                                import_components89.CheckboxControl,
                                {
                                  __nextHasNoMarginBottom: true,
                                  label: (0, import_i18n84.__)("Lock movement"),
                                  checked: lock3.move,
                                  onChange: (move) => setLock((prevLock) => ({
                                    ...prevLock,
                                    move
                                  }))
                                }
                              ),
                              /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                                import_components89.Icon,
                                {
                                  className: "block-editor-block-lock-modal__lock-icon",
                                  icon: lock3.move ? lock_default : unlock_default
                                }
                              )
                            ] }),
                            /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)("li", { className: "block-editor-block-lock-modal__checklist-item", children: [
                              /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                                import_components89.CheckboxControl,
                                {
                                  __nextHasNoMarginBottom: true,
                                  label: (0, import_i18n84.__)("Lock removal"),
                                  checked: lock3.remove,
                                  onChange: (remove5) => setLock((prevLock) => ({
                                    ...prevLock,
                                    remove: remove5
                                  }))
                                }
                              ),
                              /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                                import_components89.Icon,
                                {
                                  className: "block-editor-block-lock-modal__lock-icon",
                                  icon: lock3.remove ? lock_default : unlock_default
                                }
                              )
                            ] })
                          ]
                        }
                      )
                    ] })
                  }
                ),
                hasTemplateLock && /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                  import_components89.ToggleControl,
                  {
                    __nextHasNoMarginBottom: true,
                    className: "block-editor-block-lock-modal__template-lock",
                    label: (0, import_i18n84.__)("Apply to all blocks inside"),
                    checked: applyTemplateLock,
                    disabled: lock3.move && !lock3.remove,
                    onChange: () => setApplyTemplateLock(!applyTemplateLock)
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime222.jsxs)(
                import_components89.Flex,
                {
                  className: "block-editor-block-lock-modal__actions",
                  justify: "flex-end",
                  expanded: false,
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(import_components89.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                      import_components89.Button,
                      {
                        variant: "tertiary",
                        onClick: onClose,
                        __next40pxDefaultSize: true,
                        children: (0, import_i18n84.__)("Cancel")
                      }
                    ) }),
                    /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(import_components89.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime222.jsx)(
                      import_components89.Button,
                      {
                        variant: "primary",
                        type: "submit",
                        __next40pxDefaultSize: true,
                        children: (0, import_i18n84.__)("Apply")
                      }
                    ) })
                  ]
                }
              )
            ]
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/block-lock/menu-item.js
  function BlockLockMenuItem({ clientId }) {
    const { canLock, isLocked } = useBlockLock(clientId);
    const [isModalOpen, toggleModal] = (0, import_element107.useReducer)(
      (isActive) => !isActive,
      false
    );
    if (!canLock) {
      return null;
    }
    const label = isLocked ? (0, import_i18n85.__)("Unlock") : (0, import_i18n85.__)("Lock");
    return /* @__PURE__ */ (0, import_jsx_runtime223.jsxs)(import_jsx_runtime223.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime223.jsx)(
        import_components90.MenuItem,
        {
          icon: isLocked ? unlock_default : lock_outline_default,
          onClick: toggleModal,
          "aria-expanded": isModalOpen,
          "aria-haspopup": "dialog",
          children: label
        }
      ),
      isModalOpen && /* @__PURE__ */ (0, import_jsx_runtime223.jsx)(BlockLockModal, { clientId, onClose: toggleModal })
    ] });
  }

  // packages/block-editor/build-module/components/block-lock/toolbar.js
  var import_jsx_runtime224 = __toESM(require_jsx_runtime());
  var import_i18n86 = __toESM(require_i18n());
  var import_components91 = __toESM(require_components());
  var import_element108 = __toESM(require_element());
  function BlockLockToolbar({ clientId }) {
    const { canLock, isLocked } = useBlockLock(clientId);
    const [isModalOpen, toggleModal] = (0, import_element108.useReducer)(
      (isActive) => !isActive,
      false
    );
    const hasLockButtonShownRef = (0, import_element108.useRef)(false);
    (0, import_element108.useEffect)(() => {
      if (isLocked) {
        hasLockButtonShownRef.current = true;
      }
    }, [isLocked]);
    if (!isLocked && !hasLockButtonShownRef.current) {
      return null;
    }
    let label = isLocked ? (0, import_i18n86.__)("Unlock") : (0, import_i18n86.__)("Lock");
    if (!canLock && isLocked) {
      label = (0, import_i18n86.__)("Locked");
    }
    return /* @__PURE__ */ (0, import_jsx_runtime224.jsxs)(import_jsx_runtime224.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime224.jsx)(import_components91.ToolbarGroup, { className: "block-editor-block-lock-toolbar", children: /* @__PURE__ */ (0, import_jsx_runtime224.jsx)(
        import_components91.ToolbarButton,
        {
          disabled: !canLock,
          icon: isLocked ? lock_default : unlock_default,
          label,
          onClick: toggleModal,
          "aria-expanded": isModalOpen,
          "aria-haspopup": "dialog"
        }
      ) }),
      isModalOpen && /* @__PURE__ */ (0, import_jsx_runtime224.jsx)(BlockLockModal, { clientId, onClose: toggleModal })
    ] });
  }

  // packages/block-editor/build-module/components/block-settings-menu/block-mode-toggle.js
  var import_jsx_runtime225 = __toESM(require_jsx_runtime());
  var import_i18n87 = __toESM(require_i18n());
  var import_components92 = __toESM(require_components());
  var import_blocks59 = __toESM(require_blocks());
  var import_data95 = __toESM(require_data());
  var noop9 = () => {
  };
  function BlockModeToggle({ clientId, onToggle = noop9 }) {
    const { blockType, mode: mode2, enabled } = (0, import_data95.useSelect)(
      (select2) => {
        const { getBlock: getBlock2, getBlockMode: getBlockMode2, getSettings: getSettings4 } = select2(store);
        const block = getBlock2(clientId);
        return {
          mode: getBlockMode2(clientId),
          blockType: block ? (0, import_blocks59.getBlockType)(block.name) : null,
          enabled: getSettings4().codeEditingEnabled && !!block?.isValid
        };
      },
      [clientId]
    );
    const { toggleBlockMode: toggleBlockMode2 } = (0, import_data95.useDispatch)(store);
    if (!blockType || !(0, import_blocks59.hasBlockSupport)(blockType, "html", true) || !enabled) {
      return null;
    }
    const label = mode2 === "visual" ? (0, import_i18n87.__)("Edit as HTML") : (0, import_i18n87.__)("Edit visually");
    return /* @__PURE__ */ (0, import_jsx_runtime225.jsx)(
      import_components92.MenuItem,
      {
        onClick: () => {
          toggleBlockMode2(clientId);
          onToggle();
        },
        children: label
      }
    );
  }

  // packages/block-editor/build-module/components/content-lock/modify-content-lock-menu-item.js
  var import_jsx_runtime226 = __toESM(require_jsx_runtime());
  var import_components93 = __toESM(require_components());
  var import_data96 = __toESM(require_data());
  var import_i18n88 = __toESM(require_i18n());
  function ModifyContentLockMenuItem({ clientId, onClose }) {
    const { templateLock, isLockedByParent, isEditingAsBlocks } = (0, import_data96.useSelect)(
      (select2) => {
        const {
          getContentLockingParent: getContentLockingParent2,
          getTemplateLock: getTemplateLock2,
          getTemporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks2
        } = unlock(select2(store));
        return {
          templateLock: getTemplateLock2(clientId),
          isLockedByParent: !!getContentLockingParent2(clientId),
          isEditingAsBlocks: getTemporarilyEditingAsBlocks2() === clientId
        };
      },
      [clientId]
    );
    const blockEditorActions = (0, import_data96.useDispatch)(store);
    const isContentLocked = !isLockedByParent && templateLock === "contentOnly";
    if (!isContentLocked && !isEditingAsBlocks) {
      return null;
    }
    const { modifyContentLockBlock: modifyContentLockBlock2 } = unlock(blockEditorActions);
    const showStartEditingAsBlocks = !isEditingAsBlocks && isContentLocked;
    return showStartEditingAsBlocks && /* @__PURE__ */ (0, import_jsx_runtime226.jsx)(
      import_components93.MenuItem,
      {
        onClick: () => {
          modifyContentLockBlock2(clientId);
          onClose();
        },
        children: (0, import_i18n88._x)("Modify", "Unlock content locked blocks")
      }
    );
  }

  // packages/block-editor/build-module/components/block-rename/rename-control.js
  var import_jsx_runtime228 = __toESM(require_jsx_runtime());
  var import_components95 = __toESM(require_components());
  var import_i18n90 = __toESM(require_i18n());
  var import_element110 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-rename/modal.js
  var import_jsx_runtime227 = __toESM(require_jsx_runtime());
  var import_components94 = __toESM(require_components());
  var import_i18n89 = __toESM(require_i18n());
  var import_element109 = __toESM(require_element());
  var import_a11y11 = __toESM(require_a11y());
  var import_data97 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-rename/is-empty-string.js
  function isEmptyString(testString) {
    return testString?.trim()?.length === 0;
  }

  // packages/block-editor/build-module/components/block-rename/modal.js
  function BlockRenameModal({ clientId, onClose }) {
    const [editedBlockName, setEditedBlockName] = (0, import_element109.useState)();
    const blockInformation = useBlockDisplayInformation(clientId);
    const { metadata } = (0, import_data97.useSelect)(
      (select2) => {
        const { getBlockAttributes: getBlockAttributes3 } = select2(store);
        return {
          metadata: getBlockAttributes3(clientId)?.metadata
        };
      },
      [clientId]
    );
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data97.useDispatch)(store);
    const blockName = metadata?.name || "";
    const originalBlockName = blockInformation?.title;
    const hasOverridesWarning = !!blockName && !!metadata?.bindings && Object.values(metadata.bindings).some(
      (binding) => binding.source === "core/pattern-overrides"
    );
    const nameHasChanged = editedBlockName !== void 0 && editedBlockName !== blockName;
    const nameIsOriginal = editedBlockName === originalBlockName;
    const nameIsEmpty = isEmptyString(editedBlockName);
    const isNameValid = nameHasChanged || nameIsOriginal;
    const autoSelectInputText = (event) => event.target.select();
    const handleSubmit = () => {
      const newName = nameIsOriginal || nameIsEmpty ? void 0 : editedBlockName;
      const message = nameIsOriginal || nameIsEmpty ? (0, import_i18n89.sprintf)(
        /* translators: %s: new name/label for the block */
        (0, import_i18n89.__)('Block name reset to: "%s".'),
        editedBlockName
      ) : (0, import_i18n89.sprintf)(
        /* translators: %s: new name/label for the block */
        (0, import_i18n89.__)('Block name changed to: "%s".'),
        editedBlockName
      );
      (0, import_a11y11.speak)(message, "assertive");
      updateBlockAttributes2([clientId], {
        metadata: cleanEmptyObject({
          ...metadata,
          name: newName
        })
      });
      onClose();
    };
    return /* @__PURE__ */ (0, import_jsx_runtime227.jsx)(
      import_components94.Modal,
      {
        title: (0, import_i18n89.__)("Rename"),
        onRequestClose: onClose,
        overlayClassName: "block-editor-block-rename-modal",
        focusOnMount: "firstContentElement",
        size: "small",
        children: /* @__PURE__ */ (0, import_jsx_runtime227.jsx)(
          "form",
          {
            onSubmit: (e2) => {
              e2.preventDefault();
              if (!isNameValid) {
                return;
              }
              handleSubmit();
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime227.jsxs)(import_components94.__experimentalVStack, { spacing: "3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime227.jsx)(
                import_components94.TextControl,
                {
                  __nextHasNoMarginBottom: true,
                  __next40pxDefaultSize: true,
                  value: editedBlockName ?? blockName,
                  label: (0, import_i18n89.__)("Name"),
                  help: hasOverridesWarning ? (0, import_i18n89.__)(
                    "This block allows overrides. Changing the name can cause problems with content entered into instances of this pattern."
                  ) : void 0,
                  placeholder: originalBlockName,
                  onChange: setEditedBlockName,
                  onFocus: autoSelectInputText
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime227.jsxs)(import_components94.__experimentalHStack, { justify: "right", children: [
                /* @__PURE__ */ (0, import_jsx_runtime227.jsx)(
                  import_components94.Button,
                  {
                    __next40pxDefaultSize: true,
                    variant: "tertiary",
                    onClick: onClose,
                    children: (0, import_i18n89.__)("Cancel")
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime227.jsx)(
                  import_components94.Button,
                  {
                    __next40pxDefaultSize: true,
                    accessibleWhenDisabled: true,
                    disabled: !isNameValid,
                    variant: "primary",
                    type: "submit",
                    children: (0, import_i18n89.__)("Save")
                  }
                )
              ] })
            ] })
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/block-rename/rename-control.js
  function BlockRenameControl({ clientId }) {
    const [renamingBlock, setRenamingBlock] = (0, import_element110.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime228.jsxs)(import_jsx_runtime228.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime228.jsx)(
        import_components95.MenuItem,
        {
          onClick: () => {
            setRenamingBlock(true);
          },
          "aria-expanded": renamingBlock,
          "aria-haspopup": "dialog",
          children: (0, import_i18n90.__)("Rename")
        }
      ),
      renamingBlock && /* @__PURE__ */ (0, import_jsx_runtime228.jsx)(
        BlockRenameModal,
        {
          clientId,
          onClose: () => setRenamingBlock(false)
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/block-rename/use-block-rename.js
  var import_blocks60 = __toESM(require_blocks());
  function useBlockRename(name) {
    return {
      canRename: (0, import_blocks60.getBlockSupport)(name, "renaming", true)
    };
  }

  // packages/block-editor/build-module/components/block-visibility/menu-item.js
  var import_jsx_runtime229 = __toESM(require_jsx_runtime());
  var import_i18n91 = __toESM(require_i18n());
  var import_components96 = __toESM(require_components());
  var import_data98 = __toESM(require_data());
  var import_notices7 = __toESM(require_notices());
  var import_keyboard_shortcuts4 = __toESM(require_keyboard_shortcuts());
  function BlockVisibilityMenuItem({ clientIds }) {
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data98.useDispatch)(store);
    const { createSuccessNotice } = (0, import_data98.useDispatch)(import_notices7.store);
    const blocks2 = (0, import_data98.useSelect)(
      (select2) => {
        return select2(store).getBlocksByClientId(clientIds);
      },
      [clientIds]
    );
    const listViewShortcut = (0, import_data98.useSelect)((select2) => {
      return select2(import_keyboard_shortcuts4.store).getShortcutRepresentation(
        "core/editor/toggle-list-view"
      );
    }, []);
    const hasHiddenBlock = blocks2.some(
      (block) => block.attributes.metadata?.blockVisibility === false
    );
    const toggleBlockVisibility = () => {
      const isHiding = !hasHiddenBlock;
      const attributesByClientId = Object.fromEntries(
        blocks2?.map(({ clientId, attributes }) => [
          clientId,
          {
            metadata: cleanEmptyObject({
              ...attributes?.metadata,
              blockVisibility: isHiding ? false : void 0
            })
          }
        ])
      );
      updateBlockAttributes2(clientIds, attributesByClientId, {
        uniqueByBlock: true
      });
      if (isHiding) {
        if (blocks2.length > 1) {
          createSuccessNotice(
            (0, import_i18n91.sprintf)(
              // translators: %s: The shortcut key to access the List View.
              (0, import_i18n91.__)(
                "Blocks hidden. You can access them via the List View (%s)."
              ),
              listViewShortcut
            ),
            {
              id: "block-visibility-hidden",
              type: "snackbar"
            }
          );
        } else {
          createSuccessNotice(
            (0, import_i18n91.sprintf)(
              // translators: %s: The shortcut key to access the List View.
              (0, import_i18n91.__)(
                "Block hidden. You can access it via the List View (%s)."
              ),
              listViewShortcut
            ),
            {
              id: "block-visibility-hidden",
              type: "snackbar"
            }
          );
        }
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime229.jsx)(
      import_components96.MenuItem,
      {
        icon: hasHiddenBlock ? seen_default : unseen_default,
        onClick: toggleBlockVisibility,
        children: hasHiddenBlock ? (0, import_i18n91.__)("Show") : (0, import_i18n91.__)("Hide")
      }
    );
  }

  // packages/block-editor/build-module/components/block-visibility/toolbar.js
  var import_jsx_runtime230 = __toESM(require_jsx_runtime());
  var import_i18n92 = __toESM(require_i18n());
  var import_components97 = __toESM(require_components());
  var import_element111 = __toESM(require_element());
  var import_data99 = __toESM(require_data());
  var import_blocks61 = __toESM(require_blocks());
  function BlockVisibilityToolbar({ clientIds }) {
    const { blocks: blocks2, canToggleBlockVisibility } = (0, import_data99.useSelect)(
      (select2) => {
        const { getBlockName: getBlockName2, getBlocksByClientId: getBlocksByClientId2 } = select2(store);
        const _blocks = getBlocksByClientId2(clientIds);
        return {
          blocks: _blocks,
          canToggleBlockVisibility: _blocks.every(
            ({ clientId }) => (0, import_blocks61.hasBlockSupport)(
              getBlockName2(clientId),
              "blockVisibility",
              true
            )
          )
        };
      },
      [clientIds]
    );
    const hasHiddenBlock = blocks2.some(
      (block) => block.attributes.metadata?.blockVisibility === false
    );
    const hasBlockVisibilityButtonShownRef = (0, import_element111.useRef)(false);
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data99.useDispatch)(store);
    (0, import_element111.useEffect)(() => {
      if (hasHiddenBlock) {
        hasBlockVisibilityButtonShownRef.current = true;
      }
    }, [hasHiddenBlock]);
    if (!hasHiddenBlock && !hasBlockVisibilityButtonShownRef.current) {
      return null;
    }
    const toggleBlockVisibility = () => {
      const attributesByClientId = Object.fromEntries(
        blocks2?.map(({ clientId, attributes }) => [
          clientId,
          {
            metadata: cleanEmptyObject({
              ...attributes?.metadata,
              blockVisibility: hasHiddenBlock ? void 0 : false
            })
          }
        ])
      );
      updateBlockAttributes2(clientIds, attributesByClientId, {
        uniqueByBlock: true
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime230.jsx)(import_jsx_runtime230.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime230.jsx)(import_components97.ToolbarGroup, { className: "block-editor-block-lock-toolbar", children: /* @__PURE__ */ (0, import_jsx_runtime230.jsx)(
      import_components97.ToolbarButton,
      {
        disabled: !canToggleBlockVisibility,
        icon: hasHiddenBlock ? unseen_default : seen_default,
        label: hasHiddenBlock ? (0, import_i18n92.__)("Hidden") : (0, import_i18n92.__)("Visible"),
        onClick: toggleBlockVisibility
      }
    ) }) });
  }

  // packages/block-editor/build-module/components/block-settings-menu-controls/index.js
  var { Fill, Slot: Slot4 } = (0, import_components98.createSlotFill)("BlockSettingsMenuControls");
  var BlockSettingsMenuControlsSlot = ({ fillProps, clientIds = null }) => {
    const {
      selectedBlocks,
      selectedClientIds,
      isContentOnly,
      canToggleSelectedBlocksVisibility
    } = (0, import_data100.useSelect)(
      (select2) => {
        const {
          getBlocksByClientId: getBlocksByClientId2,
          getBlockNamesByClientId: getBlockNamesByClientId2,
          getSelectedBlockClientIds: getSelectedBlockClientIds2,
          getBlockEditingMode: getBlockEditingMode2
        } = select2(store);
        const ids = clientIds !== null ? clientIds : getSelectedBlockClientIds2();
        return {
          selectedBlocks: getBlockNamesByClientId2(ids),
          selectedClientIds: ids,
          isContentOnly: getBlockEditingMode2(ids[0]) === "contentOnly",
          canToggleSelectedBlocksVisibility: getBlocksByClientId2(
            ids
          ).every(
            (block) => (0, import_blocks62.hasBlockSupport)(block.name, "blockVisibility", true)
          )
        };
      },
      [clientIds]
    );
    const { canLock } = useBlockLock(selectedClientIds[0]);
    const { canRename } = useBlockRename(selectedBlocks[0]);
    const showLockButton = selectedClientIds.length === 1 && canLock && !isContentOnly;
    const showRenameButton = selectedClientIds.length === 1 && canRename && !isContentOnly;
    const showVisibilityButton = canToggleSelectedBlocksVisibility && !isContentOnly;
    const convertToGroupButtonProps = useConvertToGroupButtonProps(selectedClientIds);
    const { isGroupable: isGroupable2, isUngroupable: isUngroupable2 } = convertToGroupButtonProps;
    const showConvertToGroupButton = (isGroupable2 || isUngroupable2) && !isContentOnly;
    return /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(
      Slot4,
      {
        fillProps: {
          ...fillProps,
          selectedBlocks,
          selectedClientIds
        },
        children: (fills) => {
          if (!fills?.length > 0 && !showConvertToGroupButton && !showLockButton) {
            return null;
          }
          return /* @__PURE__ */ (0, import_jsx_runtime231.jsxs)(import_components98.MenuGroup, { children: [
            showConvertToGroupButton && /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(
              ConvertToGroupButton,
              {
                ...convertToGroupButtonProps,
                onClose: fillProps?.onClose
              }
            ),
            showLockButton && /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(
              BlockLockMenuItem,
              {
                clientId: selectedClientIds[0]
              }
            ),
            showRenameButton && /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(
              BlockRenameControl,
              {
                clientId: selectedClientIds[0]
              }
            ),
            showVisibilityButton && /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(
              BlockVisibilityMenuItem,
              {
                clientIds: selectedClientIds
              }
            ),
            fills,
            selectedClientIds.length === 1 && /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(
              ModifyContentLockMenuItem,
              {
                clientId: selectedClientIds[0],
                onClose: fillProps?.onClose
              }
            ),
            fillProps?.count === 1 && !isContentOnly && /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(
              BlockModeToggle,
              {
                clientId: fillProps?.firstBlockClientId,
                onToggle: fillProps?.onClose
              }
            )
          ] });
        }
      }
    );
  };
  function BlockSettingsMenuControls({ ...props }) {
    return /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(import_components98.__experimentalStyleProvider, { document, children: /* @__PURE__ */ (0, import_jsx_runtime231.jsx)(Fill, { ...props }) });
  }
  BlockSettingsMenuControls.Slot = BlockSettingsMenuControlsSlot;
  var block_settings_menu_controls_default = BlockSettingsMenuControls;

  // packages/block-editor/build-module/components/block-settings-menu/block-parent-selector-menu-item.js
  var import_jsx_runtime232 = __toESM(require_jsx_runtime());
  var import_element112 = __toESM(require_element());
  var import_components99 = __toESM(require_components());
  var import_compose61 = __toESM(require_compose());
  var import_data101 = __toESM(require_data());
  var import_i18n93 = __toESM(require_i18n());
  function BlockParentSelectorMenuItem({
    parentClientId,
    parentBlockType
  }) {
    const isSmallViewport = (0, import_compose61.useViewportMatch)("medium", "<");
    const { selectBlock: selectBlock2 } = (0, import_data101.useDispatch)(store);
    const menuItemRef = (0, import_element112.useRef)();
    const gesturesProps = useShowHoveredOrFocusedGestures({
      ref: menuItemRef,
      highlightParent: true
    });
    if (!isSmallViewport) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime232.jsx)(
      import_components99.MenuItem,
      {
        ...gesturesProps,
        ref: menuItemRef,
        icon: /* @__PURE__ */ (0, import_jsx_runtime232.jsx)(block_icon_default, { icon: parentBlockType.icon }),
        onClick: () => selectBlock2(parentClientId),
        children: (0, import_i18n93.sprintf)(
          /* translators: %s: Name of the block's parent. */
          (0, import_i18n93.__)("Select parent block (%s)"),
          parentBlockType.title
        )
      }
    );
  }

  // packages/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js
  var POPOVER_PROPS4 = {
    className: "block-editor-block-settings-menu__popover",
    placement: "bottom-start"
  };
  function CopyMenuItem({
    clientIds,
    onCopy,
    label,
    shortcut,
    eventType = "copy",
    __experimentalUpdateSelection: updateSelection = false
  }) {
    const { getBlocksByClientId: getBlocksByClientId2 } = (0, import_data102.useSelect)(store);
    const { removeBlocks: removeBlocks2 } = (0, import_data102.useDispatch)(store);
    const notifyCopy = useNotifyCopy();
    const ref = (0, import_compose62.useCopyToClipboard)(
      () => (0, import_blocks63.serialize)(getBlocksByClientId2(clientIds)),
      () => {
        switch (eventType) {
          case "copy":
          case "copyStyles":
            onCopy();
            notifyCopy(eventType, clientIds);
            break;
          case "cut":
            notifyCopy(eventType, clientIds);
            removeBlocks2(clientIds, updateSelection);
            break;
          default:
            break;
        }
      }
    );
    const copyMenuItemLabel = label ? label : (0, import_i18n94.__)("Copy");
    return /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(import_components100.MenuItem, { ref, shortcut, children: copyMenuItemLabel });
  }
  function BlockSettingsDropdown({
    block,
    clientIds,
    children,
    __experimentalSelectBlock,
    ...props
  }) {
    const currentClientId = block?.clientId;
    const count = clientIds.length;
    const firstBlockClientId = clientIds[0];
    const {
      firstParentClientId,
      parentBlockType,
      previousBlockClientId,
      selectedBlockClientIds,
      openedBlockSettingsMenu: openedBlockSettingsMenu2,
      isContentOnly,
      isZoomOut: isZoomOut2
    } = (0, import_data102.useSelect)(
      (select2) => {
        const {
          getBlockName: getBlockName2,
          getBlockRootClientId: getBlockRootClientId2,
          getPreviousBlockClientId: getPreviousBlockClientId2,
          getSelectedBlockClientIds: getSelectedBlockClientIds22,
          getBlockAttributes: getBlockAttributes3,
          getOpenedBlockSettingsMenu: getOpenedBlockSettingsMenu2,
          getBlockEditingMode: getBlockEditingMode2,
          isZoomOut: _isZoomOut
        } = unlock(select2(store));
        const { getActiveBlockVariation } = select2(import_blocks63.store);
        const _firstParentClientId = getBlockRootClientId2(firstBlockClientId);
        const parentBlockName = _firstParentClientId && getBlockName2(_firstParentClientId);
        return {
          firstParentClientId: _firstParentClientId,
          parentBlockType: _firstParentClientId && (getActiveBlockVariation(
            parentBlockName,
            getBlockAttributes3(_firstParentClientId)
          ) || (0, import_blocks63.getBlockType)(parentBlockName)),
          previousBlockClientId: getPreviousBlockClientId2(firstBlockClientId),
          selectedBlockClientIds: getSelectedBlockClientIds22(),
          openedBlockSettingsMenu: getOpenedBlockSettingsMenu2(),
          isContentOnly: getBlockEditingMode2(firstBlockClientId) === "contentOnly",
          isZoomOut: _isZoomOut()
        };
      },
      [firstBlockClientId]
    );
    const { getBlockOrder: getBlockOrder2, getSelectedBlockClientIds: getSelectedBlockClientIds2 } = (0, import_data102.useSelect)(store);
    const { setOpenedBlockSettingsMenu: setOpenedBlockSettingsMenu2 } = unlock(
      (0, import_data102.useDispatch)(store)
    );
    const shortcuts = (0, import_data102.useSelect)((select2) => {
      const { getShortcutRepresentation } = select2(import_keyboard_shortcuts5.store);
      return {
        copy: getShortcutRepresentation("core/block-editor/copy"),
        cut: getShortcutRepresentation("core/block-editor/cut"),
        duplicate: getShortcutRepresentation(
          "core/block-editor/duplicate"
        ),
        remove: getShortcutRepresentation("core/block-editor/remove"),
        insertAfter: getShortcutRepresentation(
          "core/block-editor/insert-after"
        ),
        insertBefore: getShortcutRepresentation(
          "core/block-editor/insert-before"
        )
      };
    }, []);
    const hasSelectedBlocks = selectedBlockClientIds.length > 0;
    async function updateSelectionAfterDuplicate(clientIdsPromise) {
      if (!__experimentalSelectBlock) {
        return;
      }
      const ids = await clientIdsPromise;
      if (ids && ids[0]) {
        __experimentalSelectBlock(ids[0], false);
      }
    }
    function updateSelectionAfterRemove() {
      if (!__experimentalSelectBlock) {
        return;
      }
      let blockToFocus = previousBlockClientId || firstParentClientId;
      if (!blockToFocus) {
        blockToFocus = getBlockOrder2()[0];
      }
      const shouldUpdateSelection = hasSelectedBlocks && getSelectedBlockClientIds2().length === 0;
      __experimentalSelectBlock(blockToFocus, shouldUpdateSelection);
    }
    const parentBlockIsSelected = selectedBlockClientIds?.includes(firstParentClientId);
    const open = !currentClientId ? void 0 : openedBlockSettingsMenu2 === currentClientId || false;
    function onToggle(localOpen) {
      if (localOpen && openedBlockSettingsMenu2 !== currentClientId) {
        setOpenedBlockSettingsMenu2(currentClientId);
      } else if (!localOpen && openedBlockSettingsMenu2 && openedBlockSettingsMenu2 === currentClientId) {
        setOpenedBlockSettingsMenu2(void 0);
      }
    }
    const shouldShowBlockParentMenuItem = !parentBlockIsSelected && !!firstParentClientId;
    return /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
      BlockActions,
      {
        clientIds,
        __experimentalUpdateSelection: !__experimentalSelectBlock,
        children: ({
          canCopyStyles,
          canDuplicate,
          canInsertBlock,
          canRemove,
          onDuplicate,
          onInsertAfter,
          onInsertBefore,
          onRemove,
          onCopy,
          onPasteStyles
        }) => {
          const isEmpty3 = !canRemove && !canDuplicate && !canInsertBlock && isContentOnly;
          if (isEmpty3) {
            return null;
          }
          return /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
            import_components100.DropdownMenu,
            {
              icon: more_vertical_default,
              label: (0, import_i18n94.__)("Options"),
              className: "block-editor-block-settings-menu",
              popoverProps: POPOVER_PROPS4,
              open,
              onToggle,
              noIcons: true,
              ...props,
              children: ({ onClose }) => /* @__PURE__ */ (0, import_jsx_runtime233.jsxs)(import_jsx_runtime233.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime233.jsxs)(import_components100.MenuGroup, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    block_settings_menu_first_item_default.Slot,
                    {
                      fillProps: { onClose }
                    }
                  ),
                  shouldShowBlockParentMenuItem && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    BlockParentSelectorMenuItem,
                    {
                      parentClientId: firstParentClientId,
                      parentBlockType
                    }
                  ),
                  count === 1 && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    block_html_convert_button_default,
                    {
                      clientId: firstBlockClientId
                    }
                  ),
                  !isContentOnly && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    CopyMenuItem,
                    {
                      clientIds,
                      onCopy,
                      shortcut: shortcuts.copy
                    }
                  ),
                  !isContentOnly && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    CopyMenuItem,
                    {
                      clientIds,
                      label: (0, import_i18n94.__)("Cut"),
                      eventType: "cut",
                      shortcut: shortcuts.cut,
                      __experimentalUpdateSelection: !__experimentalSelectBlock
                    }
                  ),
                  canDuplicate && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    import_components100.MenuItem,
                    {
                      onClick: (0, import_compose62.pipe)(
                        onClose,
                        onDuplicate,
                        updateSelectionAfterDuplicate
                      ),
                      shortcut: shortcuts.duplicate,
                      children: (0, import_i18n94.__)("Duplicate")
                    }
                  ),
                  canInsertBlock && !isZoomOut2 && /* @__PURE__ */ (0, import_jsx_runtime233.jsxs)(import_jsx_runtime233.Fragment, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                      import_components100.MenuItem,
                      {
                        onClick: (0, import_compose62.pipe)(
                          onClose,
                          onInsertBefore
                        ),
                        shortcut: shortcuts.insertBefore,
                        children: (0, import_i18n94.__)("Add before")
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                      import_components100.MenuItem,
                      {
                        onClick: (0, import_compose62.pipe)(
                          onClose,
                          onInsertAfter
                        ),
                        shortcut: shortcuts.insertAfter,
                        children: (0, import_i18n94.__)("Add after")
                      }
                    )
                  ] }),
                  count === 1 && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    block_comment_icon_slot_default.Slot,
                    {
                      fillProps: { onClose }
                    }
                  )
                ] }),
                canCopyStyles && !isContentOnly && /* @__PURE__ */ (0, import_jsx_runtime233.jsxs)(import_components100.MenuGroup, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                    CopyMenuItem,
                    {
                      clientIds,
                      onCopy,
                      label: (0, import_i18n94.__)("Copy styles"),
                      eventType: "copyStyles"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(import_components100.MenuItem, { onClick: onPasteStyles, children: (0, import_i18n94.__)("Paste styles") })
                ] }),
                !isContentOnly && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                  block_settings_menu_controls_default.Slot,
                  {
                    fillProps: {
                      onClose,
                      count,
                      firstBlockClientId
                    },
                    clientIds
                  }
                ),
                typeof children === "function" ? children({ onClose }) : import_element113.Children.map(
                  (child) => (0, import_element113.cloneElement)(child, { onClose })
                ),
                canRemove && /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(import_components100.MenuGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime233.jsx)(
                  import_components100.MenuItem,
                  {
                    onClick: (0, import_compose62.pipe)(
                      onClose,
                      onRemove,
                      updateSelectionAfterRemove
                    ),
                    shortcut: shortcuts.remove,
                    children: (0, import_i18n94.__)("Delete")
                  }
                ) })
              ] })
            }
          );
        }
      }
    );
  }
  var block_settings_dropdown_default = BlockSettingsDropdown;

  // packages/block-editor/build-module/components/collab/block-comment-icon-toolbar-slot.js
  var import_components101 = __toESM(require_components());
  var CommentIconToolbarSlotFill = (0, import_components101.createSlotFill)(
    Symbol("CommentIconToolbarSlotFill")
  );
  var block_comment_icon_toolbar_slot_default = CommentIconToolbarSlotFill;

  // packages/block-editor/build-module/components/block-settings-menu/index.js
  function BlockSettingsMenu({ clientIds, ...props }) {
    return /* @__PURE__ */ (0, import_jsx_runtime234.jsxs)(import_components102.ToolbarGroup, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime234.jsx)(block_comment_icon_toolbar_slot_default.Slot, {}),
      /* @__PURE__ */ (0, import_jsx_runtime234.jsx)(import_components102.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0, import_jsx_runtime234.jsx)(
        block_settings_dropdown_default,
        {
          clientIds,
          toggleProps,
          ...props
        }
      ) })
    ] });
  }
  var block_settings_menu_default = BlockSettingsMenu;

  // packages/block-editor/build-module/components/block-edit-visually-button/index.js
  var import_jsx_runtime235 = __toESM(require_jsx_runtime());
  var import_components103 = __toESM(require_components());
  var import_i18n95 = __toESM(require_i18n());
  var import_data103 = __toESM(require_data());
  function BlockEditVisuallyButton({ clientIds }) {
    const clientId = clientIds.length === 1 ? clientIds[0] : void 0;
    const canEditVisually = (0, import_data103.useSelect)(
      (select2) => !!clientId && select2(store).getBlockMode(clientId) === "html",
      [clientId]
    );
    const { toggleBlockMode: toggleBlockMode2 } = (0, import_data103.useDispatch)(store);
    if (!canEditVisually) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime235.jsx)(import_components103.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime235.jsx)(
      import_components103.ToolbarButton,
      {
        onClick: () => {
          toggleBlockMode2(clientId);
        },
        children: (0, import_i18n95.__)("Edit visually")
      }
    ) });
  }

  // packages/block-editor/build-module/components/block-toolbar/block-name-context.js
  var import_element114 = __toESM(require_element());
  var __unstableBlockNameContext = (0, import_element114.createContext)("");
  __unstableBlockNameContext.displayName = "__unstableBlockNameContext";
  var block_name_context_default = __unstableBlockNameContext;

  // packages/block-editor/build-module/components/navigable-toolbar/index.js
  var import_jsx_runtime236 = __toESM(require_jsx_runtime());
  var import_components104 = __toESM(require_components());
  var import_element115 = __toESM(require_element());
  var import_data104 = __toESM(require_data());
  var import_deprecated12 = __toESM(require_deprecated());
  var import_dom27 = __toESM(require_dom());
  var import_keyboard_shortcuts6 = __toESM(require_keyboard_shortcuts());
  var import_keycodes10 = __toESM(require_keycodes());
  function hasOnlyToolbarItem(elements) {
    const dataProp = "toolbarItem";
    return !elements.some((element) => !(dataProp in element.dataset));
  }
  function getAllFocusableToolbarItemsIn(container) {
    return Array.from(
      container.querySelectorAll("[data-toolbar-item]:not([disabled])")
    );
  }
  function hasFocusWithin(container) {
    return container.contains(container.ownerDocument.activeElement);
  }
  function focusFirstTabbableIn(container) {
    const [firstTabbable] = import_dom27.focus.tabbable.find(container);
    if (firstTabbable) {
      firstTabbable.focus({
        // When focusing newly mounted toolbars,
        // the position of the popover is often not right on the first render
        // This prevents the layout shifts when focusing the dialogs.
        preventScroll: true
      });
    }
  }
  function useIsAccessibleToolbar(toolbarRef) {
    const initialAccessibleToolbarState = true;
    const [isAccessibleToolbar, setIsAccessibleToolbar] = (0, import_element115.useState)(
      initialAccessibleToolbarState
    );
    const determineIsAccessibleToolbar = (0, import_element115.useCallback)(() => {
      const tabbables = import_dom27.focus.tabbable.find(toolbarRef.current);
      const onlyToolbarItem = hasOnlyToolbarItem(tabbables);
      if (!onlyToolbarItem) {
        (0, import_deprecated12.default)("Using custom components as toolbar controls", {
          since: "5.6",
          alternative: "ToolbarItem, ToolbarButton or ToolbarDropdownMenu components",
          link: "https://developer.wordpress.org/block-editor/components/toolbar-button/#inside-blockcontrols"
        });
      }
      setIsAccessibleToolbar(onlyToolbarItem);
    }, [toolbarRef]);
    (0, import_element115.useLayoutEffect)(() => {
      const observer = new window.MutationObserver(
        determineIsAccessibleToolbar
      );
      observer.observe(toolbarRef.current, {
        childList: true,
        subtree: true
      });
      return () => observer.disconnect();
    }, [determineIsAccessibleToolbar, isAccessibleToolbar, toolbarRef]);
    return isAccessibleToolbar;
  }
  function useToolbarFocus({
    toolbarRef,
    focusOnMount,
    isAccessibleToolbar,
    defaultIndex,
    onIndexChange,
    shouldUseKeyboardFocusShortcut,
    focusEditorOnEscape
  }) {
    const [initialFocusOnMount] = (0, import_element115.useState)(focusOnMount);
    const [initialIndex] = (0, import_element115.useState)(defaultIndex);
    const focusToolbar = (0, import_element115.useCallback)(() => {
      focusFirstTabbableIn(toolbarRef.current);
    }, [toolbarRef]);
    const focusToolbarViaShortcut = () => {
      if (shouldUseKeyboardFocusShortcut) {
        focusToolbar();
      }
    };
    (0, import_keyboard_shortcuts6.useShortcut)("core/block-editor/focus-toolbar", focusToolbarViaShortcut);
    (0, import_element115.useEffect)(() => {
      if (initialFocusOnMount) {
        focusToolbar();
      }
    }, [isAccessibleToolbar, initialFocusOnMount, focusToolbar]);
    (0, import_element115.useEffect)(() => {
      const navigableToolbarRef = toolbarRef.current;
      let raf2 = 0;
      if (!initialFocusOnMount && !hasFocusWithin(navigableToolbarRef)) {
        raf2 = window.requestAnimationFrame(() => {
          const items = getAllFocusableToolbarItemsIn(navigableToolbarRef);
          const index = initialIndex || 0;
          if (items[index] && hasFocusWithin(navigableToolbarRef)) {
            items[index].focus({
              // When focusing newly mounted toolbars,
              // the position of the popover is often not right on the first render
              // This prevents the layout shifts when focusing the dialogs.
              preventScroll: true
            });
          }
        });
      }
      return () => {
        window.cancelAnimationFrame(raf2);
        if (!onIndexChange || !navigableToolbarRef) {
          return;
        }
        const items = getAllFocusableToolbarItemsIn(navigableToolbarRef);
        const index = items.findIndex((item) => item.tabIndex === 0);
        onIndexChange(index);
      };
    }, [initialIndex, initialFocusOnMount, onIndexChange, toolbarRef]);
    const { getLastFocus: getLastFocus2 } = unlock((0, import_data104.useSelect)(store));
    (0, import_element115.useEffect)(() => {
      const navigableToolbarRef = toolbarRef.current;
      if (focusEditorOnEscape) {
        const handleKeyDown = (event) => {
          const lastFocus2 = getLastFocus2();
          if (event.keyCode === import_keycodes10.ESCAPE && lastFocus2?.current) {
            event.preventDefault();
            lastFocus2.current.focus();
          }
        };
        navigableToolbarRef.addEventListener("keydown", handleKeyDown);
        return () => {
          navigableToolbarRef.removeEventListener(
            "keydown",
            handleKeyDown
          );
        };
      }
    }, [focusEditorOnEscape, getLastFocus2, toolbarRef]);
  }
  function NavigableToolbar({
    children,
    focusOnMount,
    focusEditorOnEscape = false,
    shouldUseKeyboardFocusShortcut = true,
    __experimentalInitialIndex: initialIndex,
    __experimentalOnIndexChange: onIndexChange,
    orientation = "horizontal",
    ...props
  }) {
    const toolbarRef = (0, import_element115.useRef)();
    const isAccessibleToolbar = useIsAccessibleToolbar(toolbarRef);
    useToolbarFocus({
      toolbarRef,
      focusOnMount,
      defaultIndex: initialIndex,
      onIndexChange,
      isAccessibleToolbar,
      shouldUseKeyboardFocusShortcut,
      focusEditorOnEscape
    });
    if (isAccessibleToolbar) {
      return /* @__PURE__ */ (0, import_jsx_runtime236.jsx)(
        import_components104.Toolbar,
        {
          label: props["aria-label"],
          ref: toolbarRef,
          orientation,
          ...props,
          children
        }
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime236.jsx)(
      import_components104.NavigableMenu,
      {
        orientation,
        role: "toolbar",
        ref: toolbarRef,
        ...props,
        children
      }
    );
  }

  // packages/block-editor/build-module/components/block-toolbar/use-has-block-toolbar.js
  var import_data105 = __toESM(require_data());
  var import_blocks64 = __toESM(require_blocks());
  function useHasBlockToolbar() {
    const enabled = (0, import_data105.useSelect)((select2) => {
      const { getBlockEditingMode: getBlockEditingMode2, getBlockName: getBlockName2, getBlockSelectionStart: getBlockSelectionStart2 } = select2(store);
      const selectedBlockClientId = getBlockSelectionStart2();
      const blockType = selectedBlockClientId && (0, import_blocks64.getBlockType)(getBlockName2(selectedBlockClientId));
      return blockType && (0, import_blocks64.hasBlockSupport)(blockType, "__experimentalToolbar", true) && getBlockEditingMode2(selectedBlockClientId) !== "disabled";
    }, []);
    return enabled;
  }

  // packages/block-editor/build-module/components/block-toolbar/change-design.js
  var import_jsx_runtime237 = __toESM(require_jsx_runtime());
  var import_components105 = __toESM(require_components());
  var import_i18n96 = __toESM(require_i18n());
  var import_blocks65 = __toESM(require_blocks());
  var import_element116 = __toESM(require_element());
  var import_data106 = __toESM(require_data());
  var EMPTY_ARRAY8 = [];
  var MAX_PATTERNS_TO_SHOW = 6;
  var POPOVER_PROPS5 = {
    placement: "bottom-start"
  };
  function ChangeDesign({ clientId }) {
    const { categories, currentPatternName, patterns } = (0, import_data106.useSelect)(
      (select2) => {
        const {
          getBlockAttributes: getBlockAttributes3,
          getBlockRootClientId: getBlockRootClientId2,
          __experimentalGetAllowedPatterns: __experimentalGetAllowedPatterns2
        } = select2(store);
        const attributes = getBlockAttributes3(clientId);
        const _categories = attributes?.metadata?.categories || EMPTY_ARRAY8;
        const rootBlock = getBlockRootClientId2(clientId);
        const _patterns = _categories.length > 0 ? __experimentalGetAllowedPatterns2(rootBlock) : EMPTY_ARRAY8;
        return {
          categories: _categories,
          currentPatternName: attributes?.metadata?.patternName,
          patterns: _patterns
        };
      },
      [clientId]
    );
    const { replaceBlocks: replaceBlocks2 } = (0, import_data106.useDispatch)(store);
    const sameCategoryPatternsWithSingleWrapper = (0, import_element116.useMemo)(() => {
      if (categories.length === 0 || !patterns || patterns.length === 0) {
        return EMPTY_ARRAY8;
      }
      return patterns.filter((pattern) => {
        const isCorePattern = pattern.source === "core" || pattern.source?.startsWith("pattern-directory") && pattern.source !== "pattern-directory/theme";
        return (
          // Check if the pattern has only one top level block,
          // otherwise we may switch to a pattern that doesn't have replacement suggestions.
          pattern.blocks.length === 1 && // We exclude the core patterns and pattern directory patterns that are not theme patterns.
          !isCorePattern && // Exclude current pattern.
          currentPatternName !== pattern.name && pattern.categories?.some((category) => {
            return categories.includes(category);
          }) && // Check if the pattern is not a synced pattern.
          (pattern.syncStatus === "unsynced" || !pattern.id)
        );
      }).slice(0, MAX_PATTERNS_TO_SHOW);
    }, [categories, currentPatternName, patterns]);
    if (sameCategoryPatternsWithSingleWrapper.length < 2) {
      return null;
    }
    const onClickPattern = (pattern) => {
      const newBlocks = (pattern.blocks ?? []).map((block) => {
        return (0, import_blocks65.cloneBlock)(block);
      });
      newBlocks[0].attributes.metadata = {
        ...newBlocks[0].attributes.metadata,
        categories
      };
      replaceBlocks2(clientId, newBlocks);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime237.jsx)(
      import_components105.Dropdown,
      {
        popoverProps: POPOVER_PROPS5,
        renderToggle: ({ onToggle, isOpen }) => {
          return /* @__PURE__ */ (0, import_jsx_runtime237.jsx)(import_components105.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime237.jsx)(
            import_components105.ToolbarButton,
            {
              onClick: () => onToggle(!isOpen),
              "aria-expanded": isOpen,
              children: (0, import_i18n96.__)("Change design")
            }
          ) });
        },
        renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime237.jsx)(
          import_components105.__experimentalDropdownContentWrapper,
          {
            className: "block-editor-block-toolbar-change-design-content-wrapper",
            paddingSize: "none",
            children: /* @__PURE__ */ (0, import_jsx_runtime237.jsx)(
              block_patterns_list_default,
              {
                blockPatterns: sameCategoryPatternsWithSingleWrapper,
                onClickPattern,
                showTitlesAsTooltip: true
              }
            )
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/block-toolbar/switch-section-style.js
  var import_jsx_runtime281 = __toESM(require_jsx_runtime());
  var import_components146 = __toESM(require_components());
  var import_i18n142 = __toESM(require_i18n());
  var import_data121 = __toESM(require_data());
  var import_element150 = __toESM(require_element());

  // packages/block-editor/build-module/components/global-styles/index.js
  var global_styles_exports = {};
  __export(global_styles_exports, {
    AdvancedPanel: () => AdvancedPanel,
    BackgroundPanel: () => BackgroundImagePanel2,
    BorderPanel: () => BorderPanel,
    ColorPanel: () => ColorPanel,
    DimensionsPanel: () => DimensionsPanel,
    FiltersPanel: () => FiltersPanel,
    GlobalStylesContext: () => GlobalStylesContext,
    ImageSettingsPanel: () => ImageSettingsPanel,
    TypographyPanel: () => TypographyPanel,
    areGlobalStyleConfigsEqual: () => areGlobalStyleConfigsEqual,
    getBlockCSSSelector: () => getBlockCSSSelector,
    getBlockSelectors: () => getBlockSelectors,
    getGlobalStylesChanges: () => getGlobalStylesChanges,
    getLayoutStyles: () => getLayoutStyles,
    toStyles: () => toStyles,
    useGlobalSetting: () => useGlobalSetting,
    useGlobalStyle: () => useGlobalStyle,
    useGlobalStylesOutput: () => useGlobalStylesOutput,
    useGlobalStylesOutputWithConfig: () => useGlobalStylesOutputWithConfig,
    useGlobalStylesReset: () => useGlobalStylesReset,
    useHasBackgroundPanel: () => useHasBackgroundPanel,
    useHasBorderPanel: () => useHasBorderPanel,
    useHasBorderPanelControls: () => useHasBorderPanelControls,
    useHasColorPanel: () => useHasColorPanel,
    useHasDimensionsPanel: () => useHasDimensionsPanel,
    useHasFiltersPanel: () => useHasFiltersPanel,
    useHasImageSettingsPanel: () => useHasImageSettingsPanel,
    useHasTypographyPanel: () => useHasTypographyPanel,
    useSettingsForBlockElement: () => useSettingsForBlockElement
  });

  // packages/block-editor/build-module/components/global-styles/hooks.js
  var import_es64 = __toESM(require_es6());
  var import_element118 = __toESM(require_element());
  var import_data107 = __toESM(require_data());
  var import_blocks66 = __toESM(require_blocks());
  var import_i18n97 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/global-styles/context.js
  var import_element117 = __toESM(require_element());
  var DEFAULT_GLOBAL_STYLES_CONTEXT = {
    user: {},
    base: {},
    merged: {},
    setUserConfig: () => {
    }
  };
  var GlobalStylesContext = (0, import_element117.createContext)(
    DEFAULT_GLOBAL_STYLES_CONTEXT
  );
  GlobalStylesContext.displayName = "GlobalStylesContext";

  // packages/block-editor/build-module/components/global-styles/hooks.js
  var EMPTY_CONFIG = { settings: {}, styles: {} };
  var VALID_SETTINGS = [
    "appearanceTools",
    "useRootPaddingAwareAlignments",
    "background.backgroundImage",
    "background.backgroundRepeat",
    "background.backgroundSize",
    "background.backgroundPosition",
    "border.color",
    "border.radius",
    "border.style",
    "border.width",
    "border.radiusSizes",
    "shadow.presets",
    "shadow.defaultPresets",
    "color.background",
    "color.button",
    "color.caption",
    "color.custom",
    "color.customDuotone",
    "color.customGradient",
    "color.defaultDuotone",
    "color.defaultGradients",
    "color.defaultPalette",
    "color.duotone",
    "color.gradients",
    "color.heading",
    "color.link",
    "color.palette",
    "color.text",
    "custom",
    "dimensions.aspectRatio",
    "dimensions.minHeight",
    "layout.contentSize",
    "layout.definitions",
    "layout.wideSize",
    "lightbox.enabled",
    "lightbox.allowEditing",
    "position.fixed",
    "position.sticky",
    "spacing.customSpacingSize",
    "spacing.defaultSpacingSizes",
    "spacing.spacingSizes",
    "spacing.spacingScale",
    "spacing.blockGap",
    "spacing.margin",
    "spacing.padding",
    "spacing.units",
    "typography.fluid",
    "typography.customFontSize",
    "typography.defaultFontSizes",
    "typography.dropCap",
    "typography.fontFamilies",
    "typography.fontSizes",
    "typography.fontStyle",
    "typography.fontWeight",
    "typography.letterSpacing",
    "typography.lineHeight",
    "typography.textAlign",
    "typography.textColumns",
    "typography.textDecoration",
    "typography.textTransform",
    "typography.writingMode"
  ];
  var useGlobalStylesReset = () => {
    const { user, setUserConfig } = (0, import_element118.useContext)(GlobalStylesContext);
    const config2 = {
      settings: user.settings,
      styles: user.styles
    };
    const canReset = !!config2 && !(0, import_es64.default)(config2, EMPTY_CONFIG);
    return [
      canReset,
      (0, import_element118.useCallback)(() => setUserConfig(EMPTY_CONFIG), [setUserConfig])
    ];
  };
  function useGlobalSetting(propertyPath, blockName, source = "all") {
    const { setUserConfig, ...configs } = (0, import_element118.useContext)(GlobalStylesContext);
    const appendedBlockPath = blockName ? ".blocks." + blockName : "";
    const appendedPropertyPath = propertyPath ? "." + propertyPath : "";
    const contextualPath = `settings${appendedBlockPath}${appendedPropertyPath}`;
    const globalPath = `settings${appendedPropertyPath}`;
    const sourceKey = source === "all" ? "merged" : source;
    const settingValue = (0, import_element118.useMemo)(() => {
      const configToUse = configs[sourceKey];
      if (!configToUse) {
        throw "Unsupported source";
      }
      if (propertyPath) {
        return getValueFromObjectPath(configToUse, contextualPath) ?? getValueFromObjectPath(configToUse, globalPath);
      }
      let result = {};
      VALID_SETTINGS.forEach((setting) => {
        const value = getValueFromObjectPath(
          configToUse,
          `settings${appendedBlockPath}.${setting}`
        ) ?? getValueFromObjectPath(configToUse, `settings.${setting}`);
        if (value !== void 0) {
          result = setImmutably(result, setting.split("."), value);
        }
      });
      return result;
    }, [
      configs,
      sourceKey,
      propertyPath,
      contextualPath,
      globalPath,
      appendedBlockPath
    ]);
    const setSetting = (newValue) => {
      setUserConfig(
        (currentConfig) => setImmutably(currentConfig, contextualPath.split("."), newValue)
      );
    };
    return [settingValue, setSetting];
  }
  function useGlobalStyle(path, blockName, source = "all", { shouldDecodeEncode = true } = {}) {
    const {
      merged: mergedConfig,
      base: baseConfig,
      user: userConfig,
      setUserConfig
    } = (0, import_element118.useContext)(GlobalStylesContext);
    const appendedPath = path ? "." + path : "";
    const finalPath = !blockName ? `styles${appendedPath}` : `styles.blocks.${blockName}${appendedPath}`;
    const setStyle = (newValue) => {
      setUserConfig(
        (currentConfig) => setImmutably(
          currentConfig,
          finalPath.split("."),
          shouldDecodeEncode ? getPresetVariableFromValue(
            mergedConfig.settings,
            blockName,
            path,
            newValue
          ) : newValue
        )
      );
    };
    let rawResult, result;
    switch (source) {
      case "all":
        rawResult = getValueFromObjectPath(mergedConfig, finalPath);
        result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
        break;
      case "user":
        rawResult = getValueFromObjectPath(userConfig, finalPath);
        result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
        break;
      case "base":
        rawResult = getValueFromObjectPath(baseConfig, finalPath);
        result = shouldDecodeEncode ? getValueFromVariable(baseConfig, blockName, rawResult) : rawResult;
        break;
      default:
        throw "Unsupported source";
    }
    return [result, setStyle];
  }
  function useSettingsForBlockElement(parentSettings, blockName, element) {
    const { supportedStyles, supports } = (0, import_data107.useSelect)(
      (select2) => {
        return {
          supportedStyles: unlock(
            select2(import_blocks66.store)
          ).getSupportedStyles(blockName, element),
          supports: select2(import_blocks66.store).getBlockType(blockName)?.supports
        };
      },
      [blockName, element]
    );
    return (0, import_element118.useMemo)(() => {
      const updatedSettings = { ...parentSettings };
      if (!supportedStyles.includes("fontSize")) {
        updatedSettings.typography = {
          ...updatedSettings.typography,
          fontSizes: {},
          customFontSize: false,
          defaultFontSizes: false
        };
      }
      if (!supportedStyles.includes("fontFamily")) {
        updatedSettings.typography = {
          ...updatedSettings.typography,
          fontFamilies: {}
        };
      }
      updatedSettings.color = {
        ...updatedSettings.color,
        text: updatedSettings.color?.text && supportedStyles.includes("color"),
        background: updatedSettings.color?.background && (supportedStyles.includes("background") || supportedStyles.includes("backgroundColor")),
        button: updatedSettings.color?.button && supportedStyles.includes("buttonColor"),
        heading: updatedSettings.color?.heading && supportedStyles.includes("headingColor"),
        link: updatedSettings.color?.link && supportedStyles.includes("linkColor"),
        caption: updatedSettings.color?.caption && supportedStyles.includes("captionColor")
      };
      if (!supportedStyles.includes("background")) {
        updatedSettings.color.gradients = [];
        updatedSettings.color.customGradient = false;
      }
      if (!supportedStyles.includes("filter")) {
        updatedSettings.color.defaultDuotone = false;
        updatedSettings.color.customDuotone = false;
      }
      [
        "lineHeight",
        "fontStyle",
        "fontWeight",
        "letterSpacing",
        "textAlign",
        "textTransform",
        "textDecoration",
        "writingMode"
      ].forEach((key) => {
        if (!supportedStyles.includes(key)) {
          updatedSettings.typography = {
            ...updatedSettings.typography,
            [key]: false
          };
        }
      });
      if (!supportedStyles.includes("columnCount")) {
        updatedSettings.typography = {
          ...updatedSettings.typography,
          textColumns: false
        };
      }
      ["contentSize", "wideSize"].forEach((key) => {
        if (!supportedStyles.includes(key)) {
          updatedSettings.layout = {
            ...updatedSettings.layout,
            [key]: false
          };
        }
      });
      ["padding", "margin", "blockGap"].forEach((key) => {
        if (!supportedStyles.includes(key)) {
          updatedSettings.spacing = {
            ...updatedSettings.spacing,
            [key]: false
          };
        }
        const sides = Array.isArray(supports?.spacing?.[key]) ? supports?.spacing?.[key] : supports?.spacing?.[key]?.sides;
        if (sides?.length && updatedSettings.spacing?.[key]) {
          updatedSettings.spacing = {
            ...updatedSettings.spacing,
            [key]: {
              ...updatedSettings.spacing?.[key],
              sides
            }
          };
        }
      });
      ["aspectRatio", "minHeight"].forEach((key) => {
        if (!supportedStyles.includes(key)) {
          updatedSettings.dimensions = {
            ...updatedSettings.dimensions,
            [key]: false
          };
        }
      });
      ["radius", "color", "style", "width"].forEach((key) => {
        if (!supportedStyles.includes(
          "border" + key.charAt(0).toUpperCase() + key.slice(1)
        )) {
          updatedSettings.border = {
            ...updatedSettings.border,
            [key]: false
          };
        }
      });
      ["backgroundImage", "backgroundSize"].forEach((key) => {
        if (!supportedStyles.includes(key)) {
          updatedSettings.background = {
            ...updatedSettings.background,
            [key]: false
          };
        }
      });
      updatedSettings.shadow = supportedStyles.includes("shadow") ? updatedSettings.shadow : false;
      if (element) {
        updatedSettings.typography.textAlign = false;
      }
      return updatedSettings;
    }, [parentSettings, supportedStyles, supports, element]);
  }
  function useColorsPerOrigin(settings2) {
    const customColors = settings2?.color?.palette?.custom;
    const themeColors = settings2?.color?.palette?.theme;
    const defaultColors = settings2?.color?.palette?.default;
    const shouldDisplayDefaultColors = settings2?.color?.defaultPalette;
    return (0, import_element118.useMemo)(() => {
      const result = [];
      if (themeColors && themeColors.length) {
        result.push({
          name: (0, import_i18n97._x)(
            "Theme",
            "Indicates this palette comes from the theme."
          ),
          colors: themeColors
        });
      }
      if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
        result.push({
          name: (0, import_i18n97._x)(
            "Default",
            "Indicates this palette comes from WordPress."
          ),
          colors: defaultColors
        });
      }
      if (customColors && customColors.length) {
        result.push({
          name: (0, import_i18n97._x)(
            "Custom",
            "Indicates this palette is created by the user."
          ),
          colors: customColors
        });
      }
      return result;
    }, [
      customColors,
      themeColors,
      defaultColors,
      shouldDisplayDefaultColors
    ]);
  }
  function useGradientsPerOrigin(settings2) {
    const customGradients = settings2?.color?.gradients?.custom;
    const themeGradients = settings2?.color?.gradients?.theme;
    const defaultGradients = settings2?.color?.gradients?.default;
    const shouldDisplayDefaultGradients = settings2?.color?.defaultGradients;
    return (0, import_element118.useMemo)(() => {
      const result = [];
      if (themeGradients && themeGradients.length) {
        result.push({
          name: (0, import_i18n97._x)(
            "Theme",
            "Indicates this palette comes from the theme."
          ),
          gradients: themeGradients
        });
      }
      if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
        result.push({
          name: (0, import_i18n97._x)(
            "Default",
            "Indicates this palette comes from WordPress."
          ),
          gradients: defaultGradients
        });
      }
      if (customGradients && customGradients.length) {
        result.push({
          name: (0, import_i18n97._x)(
            "Custom",
            "Indicates this palette is created by the user."
          ),
          gradients: customGradients
        });
      }
      return result;
    }, [
      customGradients,
      themeGradients,
      defaultGradients,
      shouldDisplayDefaultGradients
    ]);
  }

  // packages/block-editor/build-module/components/global-styles/get-block-css-selector.js
  function getBlockCSSSelector(blockType, target = "root", options = {}) {
    if (!target) {
      return null;
    }
    const { fallback = false } = options;
    const { name, selectors, supports } = blockType;
    const hasSelectors = selectors && Object.keys(selectors).length > 0;
    const path = Array.isArray(target) ? target.join(".") : target;
    let rootSelector = null;
    if (hasSelectors && selectors.root) {
      rootSelector = selectors?.root;
    } else if (supports?.__experimentalSelector) {
      rootSelector = supports.__experimentalSelector;
    } else {
      rootSelector = ".wp-block-" + name.replace("core/", "").replace("/", "-");
    }
    if (path === "root") {
      return rootSelector;
    }
    const pathArray = Array.isArray(target) ? target : target.split(".");
    if (pathArray.length === 1) {
      const fallbackSelector = fallback ? rootSelector : null;
      if (hasSelectors) {
        const featureSelector2 = getValueFromObjectPath(selectors, `${path}.root`, null) || getValueFromObjectPath(selectors, path, null);
        return featureSelector2 || fallbackSelector;
      }
      const featureSelector = getValueFromObjectPath(
        supports,
        `${path}.__experimentalSelector`,
        null
      );
      if (!featureSelector) {
        return fallbackSelector;
      }
      return scopeSelector(rootSelector, featureSelector);
    }
    let subfeatureSelector;
    if (hasSelectors) {
      subfeatureSelector = getValueFromObjectPath(selectors, path, null);
    }
    if (subfeatureSelector) {
      return subfeatureSelector;
    }
    if (fallback) {
      return getBlockCSSSelector(blockType, pathArray[0], options);
    }
    return null;
  }

  // packages/block-editor/build-module/components/global-styles/use-global-styles-output.js
  var import_blocks68 = __toESM(require_blocks());
  var import_data115 = __toESM(require_data());
  var import_element130 = __toESM(require_element());
  var import_style_engine3 = __toESM(require_style_engine());
  var import_components117 = __toESM(require_components());

  // packages/block-editor/build-module/components/duotone/utils.js
  function getValuesFromColors(colors2 = []) {
    const values = { r: [], g: [], b: [], a: [] };
    colors2.forEach((color) => {
      const rgbColor = w(color).toRgb();
      values.r.push(rgbColor.r / 255);
      values.g.push(rgbColor.g / 255);
      values.b.push(rgbColor.b / 255);
      values.a.push(rgbColor.a);
    });
    return values;
  }
  function getDuotoneUnsetStylesheet(selector3) {
    return `${selector3}{filter:none}`;
  }
  function getDuotoneStylesheet(selector3, id) {
    return `${selector3}{filter:url(#${id})}`;
  }
  function getDuotoneFilter(id, colors2) {
    const values = getValuesFromColors(colors2);
    return `
<svg
	xmlns:xlink="http://www.w3.org/1999/xlink"
	viewBox="0 0 0 0"
	width="0"
	height="0"
	focusable="false"
	role="none"
	aria-hidden="true"
	style="visibility: hidden; position: absolute; left: -9999px; overflow: hidden;"
>
	<defs>
		<filter id="${id}">
			<!--
				Use sRGB instead of linearRGB so transparency looks correct.
				Use perceptual brightness to convert to grayscale.
			-->
			<feColorMatrix color-interpolation-filters="sRGB" type="matrix" values=" .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 "></feColorMatrix>
			<!-- Use sRGB instead of linearRGB to be consistent with how CSS gradients work. -->
			<feComponentTransfer color-interpolation-filters="sRGB">
				<feFuncR type="table" tableValues="${values.r.join(" ")}"></feFuncR>
				<feFuncG type="table" tableValues="${values.g.join(" ")}"></feFuncG>
				<feFuncB type="table" tableValues="${values.b.join(" ")}"></feFuncB>
				<feFuncA type="table" tableValues="${values.a.join(" ")}"></feFuncA>
			</feComponentTransfer>
			<!-- Re-mask the image with the original transparency since the feColorMatrix above loses that information. -->
			<feComposite in2="SourceGraphic" operator="in"></feComposite>
		</filter>
	</defs>
</svg>`;
  }

  // packages/block-editor/build-module/hooks/background.js
  var import_jsx_runtime249 = __toESM(require_jsx_runtime());
  var import_blocks67 = __toESM(require_blocks());
  var import_data114 = __toESM(require_data());
  var import_element129 = __toESM(require_element());

  // packages/block-editor/build-module/components/global-styles/background-panel.js
  var import_jsx_runtime248 = __toESM(require_jsx_runtime());
  var import_components116 = __toESM(require_components());
  var import_element128 = __toESM(require_element());

  // packages/block-editor/build-module/components/background-image-control/index.js
  var import_jsx_runtime247 = __toESM(require_jsx_runtime());
  var import_components115 = __toESM(require_components());
  var import_i18n109 = __toESM(require_i18n());
  var import_notices10 = __toESM(require_notices());
  var import_url8 = __toESM(require_url());
  var import_element127 = __toESM(require_element());
  var import_data113 = __toESM(require_data());
  var import_dom32 = __toESM(require_dom());
  var import_blob3 = __toESM(require_blob());

  // packages/block-editor/build-module/components/media-replace-flow/index.js
  var import_jsx_runtime246 = __toESM(require_jsx_runtime());
  var import_i18n108 = __toESM(require_i18n());
  var import_a11y12 = __toESM(require_a11y());
  var import_components114 = __toESM(require_components());
  var import_data112 = __toESM(require_data());
  var import_keycodes12 = __toESM(require_keycodes());
  var import_compose67 = __toESM(require_compose());
  var import_dom31 = __toESM(require_dom());
  var import_notices9 = __toESM(require_notices());

  // packages/block-editor/build-module/components/link-control/index.js
  var import_jsx_runtime245 = __toESM(require_jsx_runtime());
  var import_components113 = __toESM(require_components());
  var import_i18n107 = __toESM(require_i18n());
  var import_element126 = __toESM(require_element());
  var import_compose66 = __toESM(require_compose());
  var import_dom30 = __toESM(require_dom());
  var import_keycodes11 = __toESM(require_keycodes());
  var import_is_shallow_equal2 = __toESM(require_is_shallow_equal());
  var import_data111 = __toESM(require_data());
  var import_preferences4 = __toESM(require_preferences());

  // packages/block-editor/build-module/components/link-control/settings-drawer.js
  var import_jsx_runtime238 = __toESM(require_jsx_runtime());
  var import_components106 = __toESM(require_components());
  var import_compose63 = __toESM(require_compose());
  var import_i18n98 = __toESM(require_i18n());
  var import_element119 = __toESM(require_element());
  function LinkSettingsDrawer({ children, settingsOpen, setSettingsOpen }) {
    const prefersReducedMotion = (0, import_compose63.useReducedMotion)();
    const MaybeAnimatePresence = prefersReducedMotion ? import_element119.Fragment : import_components106.__unstableAnimatePresence;
    const MaybeMotionDiv = prefersReducedMotion ? "div" : import_components106.__unstableMotion.div;
    const id = (0, import_compose63.useInstanceId)(LinkSettingsDrawer);
    const settingsDrawerId = `link-control-settings-drawer-${id}`;
    return /* @__PURE__ */ (0, import_jsx_runtime238.jsxs)(import_jsx_runtime238.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime238.jsx)(
        import_components106.Button,
        {
          __next40pxDefaultSize: true,
          className: "block-editor-link-control__drawer-toggle",
          "aria-expanded": settingsOpen,
          onClick: () => setSettingsOpen(!settingsOpen),
          icon: (0, import_i18n98.isRTL)() ? chevron_left_small_default : chevron_right_small_default,
          "aria-controls": settingsDrawerId,
          children: (0, import_i18n98._x)("Advanced", "Additional link settings")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime238.jsx)(MaybeAnimatePresence, { children: settingsOpen && /* @__PURE__ */ (0, import_jsx_runtime238.jsx)(
        MaybeMotionDiv,
        {
          className: "block-editor-link-control__drawer",
          hidden: !settingsOpen,
          id: settingsDrawerId,
          initial: "collapsed",
          animate: "open",
          exit: "collapsed",
          variants: {
            open: { opacity: 1, height: "auto" },
            collapsed: { opacity: 0, height: 0 }
          },
          transition: {
            duration: 0.1
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime238.jsx)("div", { className: "block-editor-link-control__drawer-inner", children })
        }
      ) })
    ] });
  }
  var settings_drawer_default = LinkSettingsDrawer;

  // packages/block-editor/build-module/components/link-control/search-input.js
  var import_jsx_runtime242 = __toESM(require_jsx_runtime());
  var import_element122 = __toESM(require_element());
  var import_i18n103 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/link-control/search-results.js
  var import_jsx_runtime241 = __toESM(require_jsx_runtime());
  var import_i18n102 = __toESM(require_i18n());
  var import_components109 = __toESM(require_components());

  // packages/block-editor/build-module/components/link-control/search-create-button.js
  var import_jsx_runtime239 = __toESM(require_jsx_runtime());
  var import_i18n99 = __toESM(require_i18n());
  var import_components107 = __toESM(require_components());
  var import_element120 = __toESM(require_element());
  var LinkControlSearchCreate = ({
    searchTerm,
    onClick,
    itemProps,
    buttonText
  }) => {
    if (!searchTerm) {
      return null;
    }
    let text;
    if (buttonText) {
      text = typeof buttonText === "function" ? buttonText(searchTerm) : buttonText;
    } else {
      text = (0, import_element120.createInterpolateElement)(
        (0, import_i18n99.sprintf)(
          /* translators: %s: search term. */
          (0, import_i18n99.__)("Create: <mark>%s</mark>"),
          searchTerm
        ),
        { mark: /* @__PURE__ */ (0, import_jsx_runtime239.jsx)("mark", {}) }
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime239.jsx)(
      import_components107.MenuItem,
      {
        ...itemProps,
        iconPosition: "left",
        icon: plus_default,
        className: "block-editor-link-control__search-item",
        onClick,
        children: text
      }
    );
  };
  var search_create_button_default = LinkControlSearchCreate;

  // packages/block-editor/build-module/components/link-control/search-item.js
  var import_jsx_runtime240 = __toESM(require_jsx_runtime());
  var import_i18n100 = __toESM(require_i18n());
  var import_components108 = __toESM(require_components());
  var import_dom28 = __toESM(require_dom());
  var import_url5 = __toESM(require_url());
  var import_compose64 = __toESM(require_compose());
  var import_deprecated13 = __toESM(require_deprecated());
  var TYPES = {
    post: {
      icon: post_list_default,
      label: (0, import_i18n100.__)("Post")
    },
    page: {
      icon: page_default,
      label: (0, import_i18n100.__)("Page")
    },
    post_tag: {
      icon: tag_default,
      label: (0, import_i18n100.__)("Tag")
    },
    category: {
      icon: category_default,
      label: (0, import_i18n100.__)("Category")
    },
    attachment: {
      icon: file_default,
      label: (0, import_i18n100.__)("Attachment")
    }
  };
  function SearchItemIcon({ isURL: isURL3, suggestion }) {
    let icon = null;
    if (isURL3) {
      icon = globe_default;
    } else if (suggestion.type in TYPES) {
      icon = TYPES[suggestion.type].icon;
      if (suggestion.type === "page") {
        if (suggestion.isFrontPage) {
          icon = home_default;
        }
        if (suggestion.isBlogHome) {
          icon = verse_default;
        }
      }
    }
    if (icon) {
      return /* @__PURE__ */ (0, import_jsx_runtime240.jsx)(
        icon_default,
        {
          className: "block-editor-link-control__search-item-icon",
          icon
        }
      );
    }
    return null;
  }
  function addLeadingSlash(url) {
    const trimmedURL = url?.trim();
    if (!trimmedURL?.length) {
      return url;
    }
    return url?.replace(/^\/?/, "/");
  }
  function removeTrailingSlash(url) {
    const trimmedURL = url?.trim();
    if (!trimmedURL?.length) {
      return url;
    }
    return url?.replace(/\/$/, "");
  }
  var partialRight = (fn, ...partialArgs) => (...args) => fn(...args, ...partialArgs);
  var defaultTo = (d2) => (v2) => {
    return v2 === null || v2 === void 0 || v2 !== v2 ? d2 : v2;
  };
  function getURLForDisplay(url) {
    if (!url) {
      return url;
    }
    return (0, import_compose64.pipe)(
      import_url5.safeDecodeURI,
      import_url5.getPath,
      defaultTo(""),
      partialRight(import_url5.filterURLForDisplay, 24),
      removeTrailingSlash,
      addLeadingSlash
    )(url);
  }
  var LinkControlSearchItem = ({
    itemProps,
    suggestion,
    searchTerm,
    onClick,
    isURL: isURL3 = false,
    shouldShowType = false
  }) => {
    const info = isURL3 ? (0, import_i18n100.__)("Press ENTER to add this link") : getURLForDisplay(suggestion.url);
    return /* @__PURE__ */ (0, import_jsx_runtime240.jsx)(
      import_components108.MenuItem,
      {
        ...itemProps,
        info,
        iconPosition: "left",
        icon: /* @__PURE__ */ (0, import_jsx_runtime240.jsx)(SearchItemIcon, { suggestion, isURL: isURL3 }),
        onClick,
        shortcut: shouldShowType && getVisualTypeName(suggestion),
        className: "block-editor-link-control__search-item",
        children: /* @__PURE__ */ (0, import_jsx_runtime240.jsx)(
          import_components108.TextHighlight,
          {
            text: (0, import_dom28.__unstableStripHTML)(suggestion.title),
            highlight: searchTerm
          }
        )
      }
    );
  };
  function getVisualTypeName(suggestion) {
    if (suggestion.isFrontPage) {
      return (0, import_i18n100.__)("Front page");
    }
    if (suggestion.isBlogHome) {
      return (0, import_i18n100.__)("Blog home");
    }
    if (suggestion.type in TYPES) {
      return TYPES[suggestion.type].label;
    }
    return suggestion.type;
  }
  var search_item_default = LinkControlSearchItem;
  var __experimentalLinkControlSearchItem = (props) => {
    (0, import_deprecated13.default)("wp.blockEditor.__experimentalLinkControlSearchItem", {
      since: "6.8"
    });
    return /* @__PURE__ */ (0, import_jsx_runtime240.jsx)(LinkControlSearchItem, { ...props });
  };

  // packages/block-editor/build-module/components/link-control/constants.js
  var import_i18n101 = __toESM(require_i18n());
  var CREATE_TYPE = "__CREATE__";
  var TEL_TYPE = "tel";
  var URL_TYPE = "link";
  var MAILTO_TYPE = "mailto";
  var INTERNAL_TYPE = "internal";
  var LINK_ENTRY_TYPES = [
    URL_TYPE,
    MAILTO_TYPE,
    TEL_TYPE,
    INTERNAL_TYPE
  ];
  var DEFAULT_LINK_SETTINGS = [
    {
      id: "opensInNewTab",
      title: (0, import_i18n101.__)("Open in new tab")
    }
  ];

  // packages/block-editor/build-module/components/link-control/search-results.js
  var import_deprecated14 = __toESM(require_deprecated());
  function LinkControlSearchResults({
    withCreateSuggestion,
    currentInputValue,
    handleSuggestionClick,
    suggestionsListProps,
    buildSuggestionItemProps,
    suggestions,
    selectedSuggestion,
    isLoading,
    isInitialSuggestions,
    createSuggestionButtonText,
    suggestionsQuery
  }) {
    const resultsListClasses = clsx_default(
      "block-editor-link-control__search-results",
      {
        "is-loading": isLoading
      }
    );
    const isSingleDirectEntryResult = suggestions.length === 1 && LINK_ENTRY_TYPES.includes(suggestions[0].type);
    const shouldShowCreateSuggestion = withCreateSuggestion && !isSingleDirectEntryResult && !isInitialSuggestions;
    const shouldShowSuggestionsTypes = !suggestionsQuery?.type;
    const labelText = isInitialSuggestions ? (0, import_i18n102.__)("Suggestions") : (0, import_i18n102.sprintf)(
      /* translators: %s: search term. */
      (0, import_i18n102.__)('Search results for "%s"'),
      currentInputValue
    );
    return /* @__PURE__ */ (0, import_jsx_runtime241.jsx)("div", { className: "block-editor-link-control__search-results-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime241.jsx)(
      "div",
      {
        ...suggestionsListProps,
        className: resultsListClasses,
        "aria-label": labelText,
        children: /* @__PURE__ */ (0, import_jsx_runtime241.jsx)(import_components109.MenuGroup, { children: suggestions.map((suggestion, index) => {
          if (shouldShowCreateSuggestion && CREATE_TYPE === suggestion.type) {
            return /* @__PURE__ */ (0, import_jsx_runtime241.jsx)(
              search_create_button_default,
              {
                searchTerm: currentInputValue,
                buttonText: createSuggestionButtonText,
                onClick: () => handleSuggestionClick(suggestion),
                itemProps: buildSuggestionItemProps(
                  suggestion,
                  index
                ),
                isSelected: index === selectedSuggestion
              },
              suggestion.type
            );
          }
          if (CREATE_TYPE === suggestion.type) {
            return null;
          }
          return /* @__PURE__ */ (0, import_jsx_runtime241.jsx)(
            search_item_default,
            {
              itemProps: buildSuggestionItemProps(
                suggestion,
                index
              ),
              suggestion,
              index,
              onClick: () => {
                handleSuggestionClick(suggestion);
              },
              isSelected: index === selectedSuggestion,
              isURL: LINK_ENTRY_TYPES.includes(
                suggestion.type
              ),
              searchTerm: currentInputValue,
              shouldShowType: shouldShowSuggestionsTypes,
              isFrontPage: suggestion?.isFrontPage,
              isBlogHome: suggestion?.isBlogHome
            },
            `${suggestion.id}-${suggestion.type}`
          );
        }) })
      }
    ) });
  }
  var search_results_default2 = LinkControlSearchResults;
  var __experimentalLinkControlSearchResults = (props) => {
    (0, import_deprecated14.default)("wp.blockEditor.__experimentalLinkControlSearchResults", {
      since: "6.8"
    });
    return /* @__PURE__ */ (0, import_jsx_runtime241.jsx)(LinkControlSearchResults, { ...props });
  };

  // packages/block-editor/build-module/components/link-control/use-search-handler.js
  var import_url6 = __toESM(require_url());
  var import_element121 = __toESM(require_element());
  var import_data108 = __toESM(require_data());
  var handleNoop = () => Promise.resolve([]);
  var handleDirectEntry = (val) => {
    let type = URL_TYPE;
    const protocol = (0, import_url6.getProtocol)(val) || "";
    if (protocol.includes("mailto")) {
      type = MAILTO_TYPE;
    }
    if (protocol.includes("tel")) {
      type = TEL_TYPE;
    }
    if (val?.startsWith("#")) {
      type = INTERNAL_TYPE;
    }
    return Promise.resolve([
      {
        id: val,
        title: val,
        url: type === "URL" ? (0, import_url6.prependHTTP)(val) : val,
        type
      }
    ]);
  };
  var handleEntitySearch = async (val, suggestionsQuery, fetchSearchSuggestions, withCreateSuggestion, pageOnFront, pageForPosts) => {
    const { isInitialSuggestions } = suggestionsQuery;
    const results = await fetchSearchSuggestions(val, suggestionsQuery);
    results.map((result) => {
      if (Number(result.id) === pageOnFront) {
        result.isFrontPage = true;
        return result;
      } else if (Number(result.id) === pageForPosts) {
        result.isBlogHome = true;
        return result;
      }
      return result;
    });
    if (isInitialSuggestions) {
      return results;
    }
    return isURLLike(val) || !withCreateSuggestion ? results : results.concat({
      // the `id` prop is intentionally omitted here because it
      // is never exposed as part of the component's public API.
      // see: https://github.com/WordPress/gutenberg/pull/19775#discussion_r378931316.
      title: val,
      // Must match the existing `<input>`s text value.
      url: val,
      // Must match the existing `<input>`s text value.
      type: CREATE_TYPE
    });
  };
  function useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion) {
    const { fetchSearchSuggestions, pageOnFront, pageForPosts } = (0, import_data108.useSelect)(
      (select2) => {
        const { getSettings: getSettings4 } = select2(store);
        return {
          pageOnFront: getSettings4().pageOnFront,
          pageForPosts: getSettings4().pageForPosts,
          fetchSearchSuggestions: getSettings4().__experimentalFetchLinkSuggestions
        };
      },
      []
    );
    const directEntryHandler = allowDirectEntry ? handleDirectEntry : handleNoop;
    return (0, import_element121.useCallback)(
      (val, { isInitialSuggestions }) => {
        return isURLLike(val) ? directEntryHandler(val, { isInitialSuggestions }) : handleEntitySearch(
          val,
          { ...suggestionsQuery, isInitialSuggestions },
          fetchSearchSuggestions,
          withCreateSuggestion,
          pageOnFront,
          pageForPosts
        );
      },
      [
        directEntryHandler,
        fetchSearchSuggestions,
        pageOnFront,
        pageForPosts,
        suggestionsQuery,
        withCreateSuggestion
      ]
    );
  }

  // packages/block-editor/build-module/components/link-control/search-input.js
  var import_deprecated15 = __toESM(require_deprecated());
  var noopSearchHandler = () => Promise.resolve([]);
  var noop10 = () => {
  };
  var LinkControlSearchInput = (0, import_element122.forwardRef)(
    ({
      value,
      children,
      currentLink = {},
      className = null,
      placeholder = null,
      withCreateSuggestion = false,
      onCreateSuggestion = noop10,
      onChange = noop10,
      onSelect = noop10,
      showSuggestions = true,
      renderSuggestions = (props) => /* @__PURE__ */ (0, import_jsx_runtime242.jsx)(search_results_default2, { ...props }),
      fetchSuggestions = null,
      allowDirectEntry = true,
      showInitialSuggestions = false,
      suggestionsQuery = {},
      withURLSuggestion = true,
      createSuggestionButtonText,
      hideLabelFromVision = false,
      suffix,
      isEntity = false
    }, ref) => {
      const genericSearchHandler = useSearchHandler(
        suggestionsQuery,
        allowDirectEntry,
        withCreateSuggestion,
        withURLSuggestion
      );
      const searchHandler = showSuggestions ? fetchSuggestions || genericSearchHandler : noopSearchHandler;
      const [focusedSuggestion, setFocusedSuggestion] = (0, import_element122.useState)();
      const onInputChange = (selection2, suggestion) => {
        onChange(selection2);
        setFocusedSuggestion(suggestion);
      };
      const handleRenderSuggestions = (props) => renderSuggestions({
        ...props,
        withCreateSuggestion,
        createSuggestionButtonText,
        suggestionsQuery,
        handleSuggestionClick: (suggestion) => {
          if (props.handleSuggestionClick) {
            props.handleSuggestionClick(suggestion);
          }
          onSuggestionSelected(suggestion);
        }
      });
      const onSuggestionSelected = async (selectedSuggestion) => {
        let suggestion = selectedSuggestion;
        if (CREATE_TYPE === selectedSuggestion.type) {
          try {
            suggestion = await onCreateSuggestion(
              selectedSuggestion.title
            );
            if (suggestion?.url) {
              onSelect(suggestion);
            }
          } catch (e2) {
          }
          return;
        }
        if (allowDirectEntry || suggestion && Object.keys(suggestion).length >= 1) {
          const { id, url, ...restLinkProps } = currentLink ?? {};
          onSelect(
            // Some direct entries don't have types or IDs, and we still need to clear the previous ones.
            { ...restLinkProps, ...suggestion },
            suggestion
          );
        }
      };
      const _placeholder = placeholder ?? (0, import_i18n103.__)("Search or type URL");
      const label = hideLabelFromVision && placeholder !== "" ? _placeholder : (0, import_i18n103.__)("Link");
      return /* @__PURE__ */ (0, import_jsx_runtime242.jsxs)("div", { className: "block-editor-link-control__search-input-container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime242.jsx)(
          url_input_default,
          {
            disableSuggestions: currentLink?.url === value,
            label,
            hideLabelFromVision,
            className,
            value,
            onChange: onInputChange,
            placeholder: _placeholder,
            __experimentalRenderSuggestions: showSuggestions ? handleRenderSuggestions : null,
            __experimentalFetchLinkSuggestions: searchHandler,
            __experimentalHandleURLSuggestions: true,
            __experimentalShowInitialSuggestions: showInitialSuggestions,
            onSubmit: (suggestion, event) => {
              const hasSuggestion = suggestion || focusedSuggestion;
              if (!hasSuggestion && !value?.trim()?.length) {
                event.preventDefault();
              } else {
                onSuggestionSelected(
                  hasSuggestion || { url: value }
                );
              }
            },
            inputRef: ref,
            suffix,
            disabled: isEntity
          }
        ),
        children
      ] });
    }
  );
  var search_input_default = LinkControlSearchInput;
  var __experimentalLinkControlSearchInput = (props) => {
    (0, import_deprecated15.default)("wp.blockEditor.__experimentalLinkControlSearchInput", {
      since: "6.8"
    });
    return /* @__PURE__ */ (0, import_jsx_runtime242.jsx)(LinkControlSearchInput, { ...props });
  };

  // packages/block-editor/build-module/components/link-control/link-preview.js
  var import_jsx_runtime243 = __toESM(require_jsx_runtime());
  var import_i18n104 = __toESM(require_i18n());
  var import_components111 = __toESM(require_components());
  var import_compose65 = __toESM(require_compose());
  var import_url7 = __toESM(require_url());
  var import_dom29 = __toESM(require_dom());
  var import_data110 = __toESM(require_data());
  var import_notices8 = __toESM(require_notices());
  var import_preferences3 = __toESM(require_preferences());

  // packages/block-editor/build-module/components/link-control/viewer-slot.js
  var import_components110 = __toESM(require_components());
  var { Slot: ViewerSlot, Fill: ViewerFill } = (0, import_components110.createSlotFill)(
    "BlockEditorLinkControlViewer"
  );

  // packages/block-editor/build-module/components/link-control/use-rich-url-data.js
  var import_data109 = __toESM(require_data());
  var import_element123 = __toESM(require_element());
  function reducer2(state, action) {
    switch (action.type) {
      case "RESOLVED":
        return {
          ...state,
          isFetching: false,
          richData: action.richData
        };
      case "ERROR":
        return {
          ...state,
          isFetching: false,
          richData: null
        };
      case "LOADING":
        return {
          ...state,
          isFetching: true
        };
      default:
        throw new Error(`Unexpected action type ${action.type}`);
    }
  }
  function useRemoteUrlData(url) {
    const [state, dispatch] = (0, import_element123.useReducer)(reducer2, {
      richData: null,
      isFetching: false
    });
    const { fetchRichUrlData } = (0, import_data109.useSelect)((select2) => {
      const { getSettings: getSettings4 } = select2(store);
      return {
        fetchRichUrlData: getSettings4().__experimentalFetchRichUrlData
      };
    }, []);
    (0, import_element123.useEffect)(() => {
      if (url?.length && fetchRichUrlData && typeof AbortController !== "undefined") {
        dispatch({
          type: "LOADING"
        });
        const controller = new window.AbortController();
        const signal = controller.signal;
        fetchRichUrlData(url, {
          signal
        }).then((urlData) => {
          dispatch({
            type: "RESOLVED",
            richData: urlData
          });
        }).catch(() => {
          if (!signal.aborted) {
            dispatch({
              type: "ERROR"
            });
          }
        });
        return () => {
          controller.abort();
        };
      }
    }, [url]);
    return state;
  }
  var use_rich_url_data_default = useRemoteUrlData;

  // packages/block-editor/build-module/components/link-control/link-preview.js
  function filterTitleForDisplay(title) {
    return title.replace(/^[a-z\-.\+]+[0-9]*:(\/\/)?/i, "").replace(/^www\./i, "");
  }
  function LinkPreview({
    value,
    onEditClick,
    hasRichPreviews = false,
    hasUnlinkControl = false,
    onRemove
  }) {
    const showIconLabels = (0, import_data110.useSelect)(
      (select2) => select2(import_preferences3.store).get("core", "showIconLabels"),
      []
    );
    const showRichPreviews = hasRichPreviews ? value?.url : null;
    const { richData, isFetching } = use_rich_url_data_default(showRichPreviews);
    const hasRichData = richData && Object.keys(richData).length;
    const displayURL = value && (0, import_url7.filterURLForDisplay)((0, import_url7.safeDecodeURI)(value.url), 24) || "";
    const isEmptyURL = !value?.url?.length;
    const displayTitle = !isEmptyURL && (0, import_dom29.__unstableStripHTML)(richData?.title || value?.title || displayURL);
    const isUrlRedundant = !value?.url || filterTitleForDisplay(displayTitle) === displayURL;
    let icon;
    if (richData?.icon) {
      icon = /* @__PURE__ */ (0, import_jsx_runtime243.jsx)("img", { src: richData?.icon, alt: "" });
    } else if (isEmptyURL) {
      icon = /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(icon_default, { icon: info_default, size: 32 });
    } else {
      icon = /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(icon_default, { icon: globe_default });
    }
    const { createNotice } = (0, import_data110.useDispatch)(import_notices8.store);
    const ref = (0, import_compose65.useCopyToClipboard)(value.url, () => {
      createNotice("info", (0, import_i18n104.__)("Link copied to clipboard."), {
        isDismissible: true,
        type: "snackbar"
      });
    });
    return /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(
      "div",
      {
        role: "group",
        "aria-label": (0, import_i18n104.__)("Manage link"),
        className: clsx_default("block-editor-link-control__search-item", {
          "is-current": true,
          "is-rich": hasRichData,
          "is-fetching": !!isFetching,
          "is-preview": true,
          "is-error": isEmptyURL,
          "is-url-title": displayTitle === displayURL
        }),
        children: /* @__PURE__ */ (0, import_jsx_runtime243.jsxs)("div", { className: "block-editor-link-control__search-item-top", children: [
          /* @__PURE__ */ (0, import_jsx_runtime243.jsxs)(
            "span",
            {
              className: "block-editor-link-control__search-item-header",
              role: "figure",
              "aria-label": (
                /* translators: Accessibility text for the link preview when editing a link. */
                (0, import_i18n104.__)("Link information")
              ),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(
                  "span",
                  {
                    className: clsx_default(
                      "block-editor-link-control__search-item-icon",
                      {
                        "is-image": richData?.icon
                      }
                    ),
                    children: icon
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime243.jsx)("span", { className: "block-editor-link-control__search-item-details", children: !isEmptyURL ? /* @__PURE__ */ (0, import_jsx_runtime243.jsxs)(import_jsx_runtime243.Fragment, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(
                    import_components111.ExternalLink,
                    {
                      className: "block-editor-link-control__search-item-title",
                      href: value.url,
                      children: /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(import_components111.__experimentalTruncate, { numberOfLines: 1, children: displayTitle })
                    }
                  ),
                  !isUrlRedundant && /* @__PURE__ */ (0, import_jsx_runtime243.jsx)("span", { className: "block-editor-link-control__search-item-info", children: /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(import_components111.__experimentalTruncate, { numberOfLines: 1, children: displayURL }) })
                ] }) : /* @__PURE__ */ (0, import_jsx_runtime243.jsx)("span", { className: "block-editor-link-control__search-item-error-notice", children: (0, import_i18n104.__)("Link is empty") }) })
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(
            import_components111.Button,
            {
              icon: pencil_default,
              label: (0, import_i18n104.__)("Edit link"),
              onClick: onEditClick,
              size: "compact",
              showTooltip: !showIconLabels
            }
          ),
          hasUnlinkControl && /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(
            import_components111.Button,
            {
              icon: link_off_default,
              label: (0, import_i18n104.__)("Remove link"),
              onClick: onRemove,
              size: "compact",
              showTooltip: !showIconLabels
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(
            import_components111.Button,
            {
              icon: copy_small_default,
              label: (0, import_i18n104.__)("Copy link"),
              ref,
              accessibleWhenDisabled: true,
              disabled: isEmptyURL,
              size: "compact",
              showTooltip: !showIconLabels
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime243.jsx)(ViewerSlot, { fillProps: value })
        ] })
      }
    );
  }

  // packages/block-editor/build-module/components/link-control/settings.js
  var import_jsx_runtime244 = __toESM(require_jsx_runtime());
  var import_i18n105 = __toESM(require_i18n());
  var import_components112 = __toESM(require_components());
  var noop11 = () => {
  };
  var LinkControlSettings = ({ value, onChange = noop11, settings: settings2 }) => {
    if (!settings2 || !settings2.length) {
      return null;
    }
    const handleSettingChange = (setting) => (newValue) => {
      onChange({
        ...value,
        [setting.id]: newValue
      });
    };
    const theSettings = settings2.map((setting) => {
      if ("render" in setting) {
        if (typeof setting.render === "function") {
          const renderedContent = setting.render(
            setting,
            value,
            onChange
          );
          return /* @__PURE__ */ (0, import_jsx_runtime244.jsx)(
            "div",
            {
              className: "block-editor-link-control__setting",
              children: renderedContent
            },
            setting.id
          );
        }
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime244.jsx)(
        import_components112.CheckboxControl,
        {
          __nextHasNoMarginBottom: true,
          className: "block-editor-link-control__setting",
          label: setting.title,
          onChange: handleSettingChange(setting),
          checked: value ? !!value[setting.id] : false,
          help: setting?.help
        },
        setting.id
      );
    }).filter(Boolean);
    return /* @__PURE__ */ (0, import_jsx_runtime244.jsxs)("fieldset", { className: "block-editor-link-control__settings", children: [
      /* @__PURE__ */ (0, import_jsx_runtime244.jsx)(import_components112.VisuallyHidden, { as: "legend", children: (0, import_i18n105.__)("Currently selected link settings") }),
      theSettings
    ] });
  };
  var settings_default2 = LinkControlSettings;

  // packages/block-editor/build-module/components/link-control/use-create-page.js
  var import_i18n106 = __toESM(require_i18n());
  var import_element124 = __toESM(require_element());
  function useCreatePage(handleCreatePage) {
    const cancelableCreateSuggestion = (0, import_element124.useRef)();
    const [isCreatingPage, setIsCreatingPage] = (0, import_element124.useState)(false);
    const [errorMessage, setErrorMessage] = (0, import_element124.useState)(null);
    const createPage = async function(suggestionTitle) {
      setIsCreatingPage(true);
      setErrorMessage(null);
      try {
        cancelableCreateSuggestion.current = makeCancelable(
          // Using Promise.resolve to allow createSuggestion to return a
          // non-Promise based value.
          Promise.resolve(handleCreatePage(suggestionTitle))
        );
        return await cancelableCreateSuggestion.current.promise;
      } catch (error) {
        if (error && error.isCanceled) {
          return;
        }
        setErrorMessage(
          error.message || (0, import_i18n106.__)(
            "An unknown error occurred during creation. Please try again."
          )
        );
        throw error;
      } finally {
        setIsCreatingPage(false);
      }
    };
    (0, import_element124.useEffect)(() => {
      return () => {
        if (cancelableCreateSuggestion.current) {
          cancelableCreateSuggestion.current.cancel();
        }
      };
    }, []);
    return {
      createPage,
      isCreatingPage,
      errorMessage
    };
  }
  var makeCancelable = (promise) => {
    let hasCanceled_ = false;
    const wrappedPromise = new Promise((resolve, reject) => {
      promise.then(
        (val) => hasCanceled_ ? reject({ isCanceled: true }) : resolve(val),
        (error) => hasCanceled_ ? reject({ isCanceled: true }) : reject(error)
      );
    });
    return {
      promise: wrappedPromise,
      cancel() {
        hasCanceled_ = true;
      }
    };
  };

  // packages/block-editor/build-module/components/link-control/use-internal-value.js
  var import_element125 = __toESM(require_element());
  var import_fast_deep_equal = __toESM(require_fast_deep_equal());
  function useInternalValue(value) {
    const [internalValue, setInternalValue] = (0, import_element125.useState)(value || {});
    const [previousValue, setPreviousValue] = (0, import_element125.useState)(value);
    if (!(0, import_fast_deep_equal.default)(value, previousValue)) {
      setPreviousValue(value);
      setInternalValue(value);
    }
    const setInternalURLInputValue = (nextValue) => {
      setInternalValue({
        ...internalValue,
        url: nextValue
      });
    };
    const setInternalTextInputValue = (nextValue) => {
      setInternalValue({
        ...internalValue,
        title: nextValue
      });
    };
    const createSetInternalSettingValueHandler = (settingsKeys) => (nextValue) => {
      const settingsUpdates = Object.keys(nextValue).reduce(
        (acc, key) => {
          if (settingsKeys.includes(key)) {
            acc[key] = nextValue[key];
          }
          return acc;
        },
        {}
      );
      setInternalValue({
        ...internalValue,
        ...settingsUpdates
      });
    };
    return [
      internalValue,
      setInternalValue,
      setInternalURLInputValue,
      setInternalTextInputValue,
      createSetInternalSettingValueHandler
    ];
  }

  // packages/block-editor/build-module/components/link-control/index.js
  var import_deprecated16 = __toESM(require_deprecated());
  var noop12 = () => {
  };
  var PREFERENCE_SCOPE = "core/block-editor";
  var PREFERENCE_KEY = "linkControlSettingsDrawer";
  function LinkControl({
    searchInputPlaceholder,
    value,
    settings: settings2 = DEFAULT_LINK_SETTINGS,
    onChange = noop12,
    onRemove,
    onCancel,
    noDirectEntry = false,
    showSuggestions = true,
    showInitialSuggestions,
    forceIsEditingLink,
    createSuggestion,
    withCreateSuggestion,
    inputValue: propInputValue = "",
    suggestionsQuery = {},
    noURLSuggestion = false,
    createSuggestionButtonText,
    hasRichPreviews = false,
    hasTextControl = false,
    renderControlBottom = null,
    handleEntities = false
  }) {
    if (withCreateSuggestion === void 0 && createSuggestion) {
      withCreateSuggestion = true;
    }
    const [settingsOpen, setSettingsOpen] = (0, import_element126.useState)(false);
    const { advancedSettingsPreference } = (0, import_data111.useSelect)((select2) => {
      const prefsStore = select2(import_preferences4.store);
      return {
        advancedSettingsPreference: prefsStore.get(PREFERENCE_SCOPE, PREFERENCE_KEY) ?? false
      };
    }, []);
    const { set: setPreference } = (0, import_data111.useDispatch)(import_preferences4.store);
    const setSettingsOpenWithPreference = (prefVal) => {
      if (setPreference) {
        setPreference(PREFERENCE_SCOPE, PREFERENCE_KEY, prefVal);
      }
      setSettingsOpen(prefVal);
    };
    const isSettingsOpen = advancedSettingsPreference || settingsOpen;
    const isMountingRef = (0, import_element126.useRef)(true);
    const wrapperNode = (0, import_element126.useRef)();
    const textInputRef = (0, import_element126.useRef)();
    const searchInputRef = (0, import_element126.useRef)();
    const isEndingEditWithFocusRef = (0, import_element126.useRef)(false);
    const settingsKeys = settings2.map(({ id }) => id);
    const [
      internalControlValue,
      setInternalControlValue,
      setInternalURLInputValue,
      setInternalTextInputValue,
      createSetInternalSettingValueHandler
    ] = useInternalValue(value);
    const isEntity = handleEntities && !!internalControlValue?.id;
    const baseId = (0, import_compose66.useInstanceId)(LinkControl, "link-control");
    const helpTextId = isEntity ? `${baseId}__help` : null;
    const valueHasChanges = value && !(0, import_is_shallow_equal2.isShallowEqualObjects)(internalControlValue, value);
    const [isEditingLink, setIsEditingLink] = (0, import_element126.useState)(
      forceIsEditingLink !== void 0 ? forceIsEditingLink : !value || !value.url
    );
    const { createPage, isCreatingPage, errorMessage } = useCreatePage(createSuggestion);
    (0, import_element126.useEffect)(() => {
      if (forceIsEditingLink === void 0) {
        return;
      }
      setIsEditingLink(forceIsEditingLink);
    }, [forceIsEditingLink]);
    (0, import_element126.useEffect)(() => {
      if (isMountingRef.current) {
        return;
      }
      const nextFocusTarget = import_dom30.focus.focusable.find(wrapperNode.current)[0] || wrapperNode.current;
      nextFocusTarget.focus();
      isEndingEditWithFocusRef.current = false;
    }, [isEditingLink, isCreatingPage]);
    (0, import_element126.useEffect)(() => {
      isMountingRef.current = false;
      return () => {
        isMountingRef.current = true;
      };
    }, []);
    const hasLinkValue = value?.url?.trim()?.length > 0;
    const stopEditing = () => {
      isEndingEditWithFocusRef.current = !!wrapperNode.current?.contains(
        wrapperNode.current.ownerDocument.activeElement
      );
      setIsEditingLink(false);
    };
    const handleSelectSuggestion = (updatedValue) => {
      const nonSettingsChanges = Object.keys(updatedValue).reduce(
        (acc, key) => {
          if (!settingsKeys.includes(key)) {
            acc[key] = updatedValue[key];
          }
          return acc;
        },
        {}
      );
      onChange({
        ...internalControlValue,
        ...nonSettingsChanges,
        // As title is not a setting, it must be manually applied
        // in such a way as to preserve the users changes over
        // any "title" value provided by the "suggestion".
        title: internalControlValue?.title || updatedValue?.title
      });
      stopEditing();
    };
    const handleSubmit = () => {
      if (valueHasChanges) {
        onChange({
          ...value,
          ...internalControlValue,
          url: currentUrlInputValue
        });
      }
      stopEditing();
    };
    const handleSubmitWithEnter = (event) => {
      const { keyCode } = event;
      if (keyCode === import_keycodes11.ENTER && !currentInputIsEmpty) {
        event.preventDefault();
        handleSubmit();
      }
    };
    const resetInternalValues = () => {
      setInternalControlValue(value);
    };
    const handleCancel = (event) => {
      event.preventDefault();
      event.stopPropagation();
      resetInternalValues();
      if (hasLinkValue) {
        stopEditing();
      } else {
        onRemove?.();
      }
      onCancel?.();
    };
    const [shouldFocusSearchInput, setShouldFocusSearchInput] = (0, import_element126.useState)(false);
    const handleUnlink = () => {
      const { id, kind, type, ...restValue } = internalControlValue;
      setInternalControlValue({
        ...restValue,
        id: void 0,
        kind: void 0,
        type: void 0,
        url: void 0
      });
      setShouldFocusSearchInput(true);
    };
    (0, import_element126.useEffect)(() => {
      if (shouldFocusSearchInput) {
        searchInputRef.current?.focus();
        setShouldFocusSearchInput(false);
      }
    }, [shouldFocusSearchInput]);
    const currentUrlInputValue = propInputValue || internalControlValue?.url || "";
    const currentInputIsEmpty = !currentUrlInputValue?.trim()?.length;
    const shownUnlinkControl = onRemove && value && !isEditingLink && !isCreatingPage;
    const showActions = isEditingLink && hasLinkValue;
    const showTextControl = hasLinkValue && hasTextControl;
    const isEditing = (isEditingLink || !value) && !isCreatingPage;
    const isDisabled = !valueHasChanges || currentInputIsEmpty;
    const showSettings = !!settings2?.length && isEditingLink && hasLinkValue;
    return /* @__PURE__ */ (0, import_jsx_runtime245.jsxs)(
      "div",
      {
        tabIndex: -1,
        ref: wrapperNode,
        className: "block-editor-link-control",
        children: [
          isCreatingPage && /* @__PURE__ */ (0, import_jsx_runtime245.jsxs)("div", { className: "block-editor-link-control__loading", children: [
            /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(import_components113.Spinner, {}),
            " ",
            (0, import_i18n107.__)("Creating"),
            "\u2026"
          ] }),
          isEditing && /* @__PURE__ */ (0, import_jsx_runtime245.jsxs)(import_jsx_runtime245.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime245.jsxs)(
              "div",
              {
                className: clsx_default({
                  "block-editor-link-control__search-input-wrapper": true,
                  "has-text-control": showTextControl,
                  "has-actions": showActions
                }),
                children: [
                  showTextControl && /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
                    import_components113.TextControl,
                    {
                      __nextHasNoMarginBottom: true,
                      ref: textInputRef,
                      className: "block-editor-link-control__field block-editor-link-control__text-content",
                      label: (0, import_i18n107.__)("Text"),
                      value: internalControlValue?.title,
                      onChange: setInternalTextInputValue,
                      onKeyDown: handleSubmitWithEnter,
                      __next40pxDefaultSize: true
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
                    search_input_default,
                    {
                      ref: searchInputRef,
                      currentLink: value,
                      className: "block-editor-link-control__field block-editor-link-control__search-input",
                      placeholder: searchInputPlaceholder,
                      value: currentUrlInputValue,
                      withCreateSuggestion,
                      onCreateSuggestion: createPage,
                      onChange: setInternalURLInputValue,
                      onSelect: handleSelectSuggestion,
                      showInitialSuggestions,
                      allowDirectEntry: !noDirectEntry,
                      showSuggestions,
                      suggestionsQuery,
                      withURLSuggestion: !noURLSuggestion,
                      createSuggestionButtonText,
                      hideLabelFromVision: !showTextControl,
                      isEntity,
                      suffix: /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
                        SearchSuffixControl,
                        {
                          isEntity,
                          showActions,
                          isDisabled,
                          onUnlink: handleUnlink,
                          onSubmit: handleSubmit,
                          helpTextId
                        }
                      )
                    }
                  ),
                  isEntity && helpTextId && /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
                    "p",
                    {
                      id: helpTextId,
                      className: "block-editor-link-control__help",
                      children: (0, import_i18n107.sprintf)(
                        /* translators: %s: entity type (e.g., page, post) */
                        (0, import_i18n107.__)("Synced with the selected %s."),
                        internalControlValue?.type || "item"
                      )
                    }
                  )
                ]
              }
            ),
            errorMessage && /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
              import_components113.Notice,
              {
                className: "block-editor-link-control__search-error",
                status: "error",
                isDismissible: false,
                children: errorMessage
              }
            )
          ] }),
          value && !isEditingLink && !isCreatingPage && /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
            LinkPreview,
            {
              value,
              onEditClick: () => setIsEditingLink(true),
              hasRichPreviews,
              hasUnlinkControl: shownUnlinkControl,
              onRemove: () => {
                onRemove();
                setIsEditingLink(true);
              }
            },
            value?.url
          ),
          showSettings && /* @__PURE__ */ (0, import_jsx_runtime245.jsx)("div", { className: "block-editor-link-control__tools", children: !currentInputIsEmpty && /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
            settings_drawer_default,
            {
              settingsOpen: isSettingsOpen,
              setSettingsOpen: setSettingsOpenWithPreference,
              children: /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
                settings_default2,
                {
                  value: internalControlValue,
                  settings: settings2,
                  onChange: createSetInternalSettingValueHandler(
                    settingsKeys
                  )
                }
              )
            }
          ) }),
          showActions && /* @__PURE__ */ (0, import_jsx_runtime245.jsxs)(
            import_components113.__experimentalHStack,
            {
              justify: "right",
              className: "block-editor-link-control__search-actions",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
                  import_components113.Button,
                  {
                    __next40pxDefaultSize: true,
                    variant: "tertiary",
                    onClick: handleCancel,
                    children: (0, import_i18n107.__)("Cancel")
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
                  import_components113.Button,
                  {
                    __next40pxDefaultSize: true,
                    variant: "primary",
                    onClick: isDisabled ? noop12 : handleSubmit,
                    className: "block-editor-link-control__search-submit",
                    "aria-disabled": isDisabled,
                    children: (0, import_i18n107.__)("Apply")
                  }
                )
              ]
            }
          ),
          !isCreatingPage && renderControlBottom && renderControlBottom()
        ]
      }
    );
  }
  function SearchSuffixControl({
    isEntity,
    showActions,
    isDisabled,
    onUnlink,
    onSubmit,
    helpTextId
  }) {
    if (isEntity) {
      return /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
        import_components113.Button,
        {
          icon: link_off_default,
          onClick: onUnlink,
          "aria-describedby": helpTextId,
          showTooltip: true,
          label: (0, import_i18n107.__)("Unsync and edit"),
          __next40pxDefaultSize: true
        }
      );
    }
    if (showActions) {
      return void 0;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(import_components113.__experimentalInputControlSuffixWrapper, { variant: "control", children: /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(
      import_components113.Button,
      {
        onClick: isDisabled ? noop12 : onSubmit,
        label: (0, import_i18n107.__)("Submit"),
        icon: keyboard_return_default,
        className: "block-editor-link-control__search-submit",
        "aria-disabled": isDisabled,
        size: "small"
      }
    ) });
  }
  LinkControl.ViewerFill = ViewerFill;
  LinkControl.DEFAULT_LINK_SETTINGS = DEFAULT_LINK_SETTINGS;
  var DeprecatedExperimentalLinkControl = (props) => {
    (0, import_deprecated16.default)("wp.blockEditor.__experimentalLinkControl", {
      since: "6.8",
      alternative: "wp.blockEditor.LinkControl"
    });
    return /* @__PURE__ */ (0, import_jsx_runtime245.jsx)(LinkControl, { ...props });
  };
  DeprecatedExperimentalLinkControl.ViewerFill = LinkControl.ViewerFill;
  DeprecatedExperimentalLinkControl.DEFAULT_LINK_SETTINGS = LinkControl.DEFAULT_LINK_SETTINGS;
  var link_control_default = LinkControl;

  // packages/block-editor/build-module/components/media-replace-flow/index.js
  var noop13 = () => {
  };
  var uniqueId = 0;
  var MediaReplaceFlow = ({
    mediaURL,
    mediaId,
    mediaIds,
    allowedTypes,
    accept,
    onError,
    onSelect,
    onSelectURL,
    onReset,
    onToggleFeaturedImage,
    useFeaturedImage,
    onFilesUpload = noop13,
    name = (0, import_i18n108.__)("Replace"),
    createNotice,
    removeNotice,
    children,
    multiple = false,
    addToGallery,
    handleUpload = true,
    popoverProps: popoverProps3,
    renderToggle: renderToggle3
  }) => {
    const { getSettings: getSettings4 } = (0, import_data112.useSelect)(store);
    const errorNoticeID = `block-editor/media-replace-flow/error-notice/${++uniqueId}`;
    const onUploadError = (message) => {
      const safeMessage = (0, import_dom31.__unstableStripHTML)(message);
      if (onError) {
        onError(safeMessage);
        return;
      }
      setTimeout(() => {
        createNotice("error", safeMessage, {
          speak: true,
          id: errorNoticeID,
          isDismissible: true
        });
      }, 1e3);
    };
    const selectMedia = (media, closeMenu) => {
      if (useFeaturedImage && onToggleFeaturedImage) {
        onToggleFeaturedImage();
      }
      closeMenu();
      onSelect(media);
      (0, import_a11y12.speak)((0, import_i18n108.__)("The media file has been replaced"));
      removeNotice(errorNoticeID);
    };
    const uploadFiles = (event, closeMenu) => {
      const files = event.target.files;
      if (!handleUpload) {
        closeMenu();
        return onSelect(files);
      }
      onFilesUpload(files);
      getSettings4().mediaUpload({
        allowedTypes,
        filesList: files,
        onFileChange: ([media]) => {
          selectMedia(media, closeMenu);
        },
        onError: onUploadError
      });
    };
    const openOnArrowDown = (event) => {
      if (event.keyCode === import_keycodes12.DOWN) {
        event.preventDefault();
        event.target.click();
      }
    };
    const onlyAllowsImages = () => {
      if (!allowedTypes || allowedTypes.length === 0) {
        return false;
      }
      return allowedTypes.every(
        (allowedType) => allowedType === "image" || allowedType.startsWith("image/")
      );
    };
    const gallery = multiple && onlyAllowsImages();
    return /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
      import_components114.Dropdown,
      {
        popoverProps: popoverProps3,
        contentClassName: "block-editor-media-replace-flow__options",
        renderToggle: ({ isOpen, onToggle }) => {
          if (renderToggle3) {
            return renderToggle3({
              "aria-expanded": isOpen,
              "aria-haspopup": "true",
              onClick: onToggle,
              onKeyDown: openOnArrowDown,
              children: name
            });
          }
          return /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
            import_components114.ToolbarButton,
            {
              "aria-expanded": isOpen,
              "aria-haspopup": "true",
              onClick: onToggle,
              onKeyDown: openOnArrowDown,
              children: name
            }
          );
        },
        renderContent: ({ onClose }) => /* @__PURE__ */ (0, import_jsx_runtime246.jsxs)(import_jsx_runtime246.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime246.jsxs)(import_components114.NavigableMenu, { className: "block-editor-media-replace-flow__media-upload-menu", children: [
            /* @__PURE__ */ (0, import_jsx_runtime246.jsxs)(check_default2, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
                media_upload_default,
                {
                  gallery,
                  addToGallery,
                  multiple,
                  value: multiple ? mediaIds : mediaId,
                  onSelect: (media) => selectMedia(media, onClose),
                  allowedTypes,
                  render: ({ open }) => /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
                    import_components114.MenuItem,
                    {
                      icon: media_default,
                      onClick: open,
                      children: (0, import_i18n108.__)("Open Media Library")
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
                import_components114.FormFileUpload,
                {
                  onChange: (event) => {
                    uploadFiles(event, onClose);
                  },
                  accept,
                  multiple: !!multiple,
                  render: ({ openFileDialog }) => {
                    return /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
                      import_components114.MenuItem,
                      {
                        icon: upload_default,
                        onClick: () => {
                          openFileDialog();
                        },
                        children: (0, import_i18n108._x)("Upload", "verb")
                      }
                    );
                  }
                }
              )
            ] }),
            onToggleFeaturedImage && /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
              import_components114.MenuItem,
              {
                icon: post_featured_image_default,
                onClick: onToggleFeaturedImage,
                isPressed: useFeaturedImage,
                children: (0, import_i18n108.__)("Use featured image")
              }
            ),
            mediaURL && onReset && /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
              import_components114.MenuItem,
              {
                onClick: () => {
                  onReset();
                  onClose();
                },
                children: (0, import_i18n108.__)("Reset")
              }
            ),
            typeof children === "function" ? children({ onClose }) : children
          ] }),
          onSelectURL && // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
          /* @__PURE__ */ (0, import_jsx_runtime246.jsxs)("form", { className: "block-editor-media-flow__url-input", children: [
            /* @__PURE__ */ (0, import_jsx_runtime246.jsx)("span", { className: "block-editor-media-replace-flow__image-url-label", children: (0, import_i18n108.__)("Current media URL:") }),
            /* @__PURE__ */ (0, import_jsx_runtime246.jsx)(
              link_control_default,
              {
                value: { url: mediaURL },
                settings: [],
                showSuggestions: false,
                onChange: ({ url }) => {
                  onSelectURL(url);
                },
                searchInputPlaceholder: (0, import_i18n108.__)(
                  "Paste or type URL"
                )
              }
            )
          ] })
        ] })
      }
    );
  };
  var media_replace_flow_default = (0, import_compose67.compose)([
    (0, import_data112.withDispatch)((dispatch) => {
      const { createNotice, removeNotice } = dispatch(import_notices9.store);
      return {
        createNotice,
        removeNotice
      };
    }),
    (0, import_components114.withFilters)("editor.MediaReplaceFlow")
  ])(MediaReplaceFlow);

  // packages/block-editor/build-module/components/background-image-control/index.js
  var IMAGE_BACKGROUND_TYPE = "image";
  var BACKGROUND_POPOVER_PROPS = {
    placement: "left-start",
    offset: 36,
    shift: true,
    className: "block-editor-global-styles-background-panel__popover"
  };
  var noop14 = () => {
  };
  var focusToggleButton = (containerRef) => {
    window.requestAnimationFrame(() => {
      const [toggleButton] = import_dom32.focus.tabbable.find(containerRef?.current);
      if (!toggleButton) {
        return;
      }
      toggleButton.focus();
    });
  };
  function backgroundSizeHelpText(value) {
    if (value === "cover" || value === void 0) {
      return (0, import_i18n109.__)("Image covers the space evenly.");
    }
    if (value === "contain") {
      return (0, import_i18n109.__)("Image is contained without distortion.");
    }
    return (0, import_i18n109.__)("Image has a fixed width.");
  }
  var coordsToBackgroundPosition = (value) => {
    if (!value || isNaN(value.x) && isNaN(value.y)) {
      return void 0;
    }
    const x2 = isNaN(value.x) ? 0.5 : value.x;
    const y2 = isNaN(value.y) ? 0.5 : value.y;
    return `${x2 * 100}% ${y2 * 100}%`;
  };
  var backgroundPositionToCoords = (value) => {
    if (!value) {
      return { x: void 0, y: void 0 };
    }
    let [x2, y2] = value.split(" ").map((v2) => parseFloat(v2) / 100);
    x2 = isNaN(x2) ? void 0 : x2;
    y2 = isNaN(y2) ? x2 : y2;
    return { x: x2, y: y2 };
  };
  function InspectorImagePreviewItem({
    as = "span",
    imgUrl,
    toggleProps = {},
    filename,
    label,
    onToggleCallback = noop14
  }) {
    const { isOpen, ...restToggleProps } = toggleProps;
    (0, import_element127.useEffect)(() => {
      if (typeof isOpen !== "undefined") {
        onToggleCallback(isOpen);
      }
    }, [isOpen, onToggleCallback]);
    const renderPreviewContent = () => {
      return /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)(
        import_components115.__experimentalHStack,
        {
          justify: "flex-start",
          as: "span",
          className: "block-editor-global-styles-background-panel__inspector-preview-inner",
          children: [
            imgUrl && /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
              "span",
              {
                className: "block-editor-global-styles-background-panel__inspector-image-indicator-wrapper",
                "aria-hidden": true,
                children: /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
                  "span",
                  {
                    className: "block-editor-global-styles-background-panel__inspector-image-indicator",
                    style: {
                      backgroundImage: `url(${imgUrl})`
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)(import_components115.FlexItem, { as: "span", style: imgUrl ? {} : { flexGrow: 1 }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
                import_components115.__experimentalTruncate,
                {
                  numberOfLines: 1,
                  className: "block-editor-global-styles-background-panel__inspector-media-replace-title",
                  children: label
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(import_components115.VisuallyHidden, { as: "span", children: imgUrl ? (0, import_i18n109.sprintf)(
                /* translators: %s: file name */
                (0, import_i18n109.__)("Background image: %s"),
                filename || label
              ) : (0, import_i18n109.__)("No background image selected") })
            ] })
          ]
        }
      );
    };
    return as === "button" ? /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(import_components115.Button, { __next40pxDefaultSize: true, ...restToggleProps, children: renderPreviewContent() }) : renderPreviewContent();
  }
  function BackgroundControlsPanel({
    label,
    filename,
    url: imgUrl,
    children,
    onToggle: onToggleCallback = noop14,
    hasImageValue,
    onReset,
    containerRef
  }) {
    if (!hasImageValue) {
      return;
    }
    const imgLabel = label || (0, import_url8.getFilename)(imgUrl) || (0, import_i18n109.__)("Add background image");
    return /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
      import_components115.Dropdown,
      {
        popoverProps: BACKGROUND_POPOVER_PROPS,
        renderToggle: ({ onToggle, isOpen }) => {
          const toggleProps = {
            onClick: onToggle,
            className: "block-editor-global-styles-background-panel__dropdown-toggle",
            "aria-expanded": isOpen,
            "aria-label": (0, import_i18n109.__)(
              "Background size, position and repeat options."
            ),
            isOpen
          };
          return /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)(import_jsx_runtime247.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
              InspectorImagePreviewItem,
              {
                imgUrl,
                filename,
                label: imgLabel,
                toggleProps,
                as: "button",
                onToggleCallback
              }
            ),
            onReset && /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
              import_components115.Button,
              {
                __next40pxDefaultSize: true,
                label: (0, import_i18n109.__)("Reset"),
                className: "block-editor-global-styles-background-panel__reset",
                size: "small",
                icon: reset_default,
                onClick: () => {
                  onReset();
                  if (isOpen) {
                    onToggle();
                  }
                  focusToggleButton(containerRef);
                }
              }
            )
          ] });
        },
        renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
          import_components115.__experimentalDropdownContentWrapper,
          {
            className: "block-editor-global-styles-background-panel__dropdown-content-wrapper",
            paddingSize: "medium",
            children
          }
        )
      }
    );
  }
  function LoadingSpinner() {
    return /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(import_components115.Placeholder, { className: "block-editor-global-styles-background-panel__loading", children: /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(import_components115.Spinner, {}) });
  }
  function BackgroundImageControls({
    onChange,
    style,
    inheritedValue,
    onRemoveImage = noop14,
    onResetImage = noop14,
    displayInPanel,
    defaultValues,
    containerRef
  }) {
    const [isUploading2, setIsUploading] = (0, import_element127.useState)(false);
    const { getSettings: getSettings4 } = (0, import_data113.useSelect)(store);
    const { id, title, url } = style?.background?.backgroundImage || {
      ...inheritedValue?.background?.backgroundImage
    };
    const { createErrorNotice } = (0, import_data113.useDispatch)(import_notices10.store);
    const onUploadError = (message) => {
      createErrorNotice(message, { type: "snackbar" });
      setIsUploading(false);
    };
    const resetBackgroundImage = () => onChange(
      setImmutably(
        style,
        ["background", "backgroundImage"],
        void 0
      )
    );
    const onSelectMedia = (media) => {
      if (!media || !media.url) {
        resetBackgroundImage();
        setIsUploading(false);
        return;
      }
      if ((0, import_blob3.isBlobURL)(media.url)) {
        setIsUploading(true);
        return;
      }
      if (media.media_type && media.media_type !== IMAGE_BACKGROUND_TYPE || !media.media_type && media.type && media.type !== IMAGE_BACKGROUND_TYPE) {
        onUploadError(
          (0, import_i18n109.__)("Only images can be used as a background image.")
        );
        return;
      }
      const sizeValue = style?.background?.backgroundSize || defaultValues?.backgroundSize;
      const positionValue = style?.background?.backgroundPosition;
      onChange(
        setImmutably(style, ["background"], {
          ...style?.background,
          backgroundImage: {
            url: media.url,
            id: media.id,
            source: "file",
            title: media.title || void 0
          },
          backgroundPosition: (
            /*
             * A background image uploaded and set in the editor receives a default background position of '50% 0',
             * when the background image size is the equivalent of "Tile".
             * This is to increase the chance that the image's focus point is visible.
             * This is in-editor only to assist with the user experience.
             */
            !positionValue && ("auto" === sizeValue || !sizeValue) ? "50% 0" : positionValue
          ),
          backgroundSize: sizeValue
        })
      );
      setIsUploading(false);
      focusToggleButton(containerRef);
    };
    const onFilesDrop2 = (filesList) => {
      getSettings4().mediaUpload({
        allowedTypes: [IMAGE_BACKGROUND_TYPE],
        filesList,
        onFileChange([image]) {
          onSelectMedia(image);
        },
        onError: onUploadError,
        multiple: false
      });
    };
    const hasValue = hasBackgroundImageValue(style);
    const onRemove = () => onChange(
      setImmutably(style, ["background"], {
        backgroundImage: "none"
      })
    );
    const canRemove = !hasValue && hasBackgroundImageValue(inheritedValue);
    const imgLabel = title || (0, import_url8.getFilename)(url) || (0, import_i18n109.__)("Add background image");
    return /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)("div", { className: "block-editor-global-styles-background-panel__image-tools-panel-item", children: [
      isUploading2 && /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(LoadingSpinner, {}),
      /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
        media_replace_flow_default,
        {
          mediaId: id,
          mediaURL: url,
          allowedTypes: [IMAGE_BACKGROUND_TYPE],
          accept: "image/*",
          onSelect: onSelectMedia,
          popoverProps: {
            className: clsx_default({
              "block-editor-global-styles-background-panel__media-replace-popover": displayInPanel
            })
          },
          name: /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
            InspectorImagePreviewItem,
            {
              imgUrl: url,
              filename: title,
              label: imgLabel
            }
          ),
          renderToggle: (props) => /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(import_components115.Button, { ...props, __next40pxDefaultSize: true }),
          onError: onUploadError,
          onReset: () => {
            focusToggleButton(containerRef);
            onResetImage();
          },
          children: canRemove && /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
            import_components115.MenuItem,
            {
              onClick: () => {
                focusToggleButton(containerRef);
                onRemove();
                onRemoveImage();
              },
              children: (0, import_i18n109.__)("Remove")
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
        import_components115.DropZone,
        {
          onFilesDrop: onFilesDrop2,
          label: (0, import_i18n109.__)("Drop to upload")
        }
      )
    ] });
  }
  function BackgroundSizeControls({
    onChange,
    style,
    inheritedValue,
    defaultValues
  }) {
    const sizeValue = style?.background?.backgroundSize || inheritedValue?.background?.backgroundSize;
    const repeatValue = style?.background?.backgroundRepeat || inheritedValue?.background?.backgroundRepeat;
    const imageValue = style?.background?.backgroundImage?.url || inheritedValue?.background?.backgroundImage?.url;
    const isUploadedImage = style?.background?.backgroundImage?.id;
    const positionValue = style?.background?.backgroundPosition || inheritedValue?.background?.backgroundPosition;
    const attachmentValue = style?.background?.backgroundAttachment || inheritedValue?.background?.backgroundAttachment;
    let currentValueForToggle = !sizeValue && isUploadedImage ? defaultValues?.backgroundSize : sizeValue || "auto";
    currentValueForToggle = !["cover", "contain", "auto"].includes(
      currentValueForToggle
    ) ? "auto" : currentValueForToggle;
    const repeatCheckedValue = !(repeatValue === "no-repeat" || currentValueForToggle === "cover" && repeatValue === void 0);
    const updateBackgroundSize = (next2) => {
      let nextRepeat = repeatValue;
      let nextPosition = positionValue;
      if (next2 === "contain") {
        nextRepeat = "no-repeat";
        nextPosition = void 0;
      }
      if (next2 === "cover") {
        nextRepeat = void 0;
        nextPosition = void 0;
      }
      if ((currentValueForToggle === "cover" || currentValueForToggle === "contain") && next2 === "auto") {
        nextRepeat = void 0;
        if (!!style?.background?.backgroundImage?.id) {
          nextPosition = "50% 0";
        }
      }
      if (!next2 && currentValueForToggle === "auto") {
        next2 = "auto";
      }
      onChange(
        setImmutably(style, ["background"], {
          ...style?.background,
          backgroundPosition: nextPosition,
          backgroundRepeat: nextRepeat,
          backgroundSize: next2
        })
      );
    };
    const updateBackgroundPosition = (next2) => {
      onChange(
        setImmutably(
          style,
          ["background", "backgroundPosition"],
          coordsToBackgroundPosition(next2)
        )
      );
    };
    const toggleIsRepeated = () => onChange(
      setImmutably(
        style,
        ["background", "backgroundRepeat"],
        repeatCheckedValue === true ? "no-repeat" : "repeat"
      )
    );
    const toggleScrollWithPage = () => onChange(
      setImmutably(
        style,
        ["background", "backgroundAttachment"],
        attachmentValue === "fixed" ? "scroll" : "fixed"
      )
    );
    const backgroundPositionValue = !positionValue && isUploadedImage && "contain" === sizeValue ? defaultValues?.backgroundPosition : positionValue;
    return /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)(import_components115.__experimentalVStack, { spacing: 3, className: "single-column", children: [
      /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
        import_components115.FocalPointPicker,
        {
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n109.__)("Focal point"),
          url: imageValue,
          value: backgroundPositionToCoords(backgroundPositionValue),
          onChange: updateBackgroundPosition
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
        import_components115.ToggleControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n109.__)("Fixed background"),
          checked: attachmentValue === "fixed",
          onChange: toggleScrollWithPage
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)(
        import_components115.__experimentalToggleGroupControl,
        {
          __nextHasNoMarginBottom: true,
          size: "__unstable-large",
          label: (0, import_i18n109.__)("Size"),
          value: currentValueForToggle,
          onChange: updateBackgroundSize,
          isBlock: true,
          help: backgroundSizeHelpText(
            sizeValue || defaultValues?.backgroundSize
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
              import_components115.__experimentalToggleGroupControlOption,
              {
                value: "cover",
                label: (0, import_i18n109._x)(
                  "Cover",
                  "Size option for background image control"
                )
              },
              "cover"
            ),
            /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
              import_components115.__experimentalToggleGroupControlOption,
              {
                value: "contain",
                label: (0, import_i18n109._x)(
                  "Contain",
                  "Size option for background image control"
                )
              },
              "contain"
            ),
            /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
              import_components115.__experimentalToggleGroupControlOption,
              {
                value: "auto",
                label: (0, import_i18n109._x)(
                  "Tile",
                  "Size option for background image control"
                )
              },
              "tile"
            )
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)(import_components115.__experimentalHStack, { justify: "flex-start", spacing: 2, as: "span", children: [
        /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
          import_components115.__experimentalUnitControl,
          {
            "aria-label": (0, import_i18n109.__)("Background image width"),
            onChange: updateBackgroundSize,
            value: sizeValue,
            size: "__unstable-large",
            __unstableInputWidth: "100px",
            min: 0,
            placeholder: (0, import_i18n109.__)("Auto"),
            disabled: currentValueForToggle !== "auto" || currentValueForToggle === void 0
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
          import_components115.ToggleControl,
          {
            __nextHasNoMarginBottom: true,
            label: (0, import_i18n109.__)("Repeat"),
            checked: repeatCheckedValue,
            onChange: toggleIsRepeated,
            disabled: currentValueForToggle === "cover"
          }
        )
      ] })
    ] });
  }
  function BackgroundImagePanel({
    value,
    onChange,
    inheritedValue = value,
    settings: settings2,
    defaultValues = {}
  }) {
    const { globalStyles, _links } = (0, import_data113.useSelect)((select2) => {
      const { getSettings: getSettings4 } = select2(store);
      const _settings = getSettings4();
      return {
        globalStyles: _settings[globalStylesDataKey],
        _links: _settings[globalStylesLinksDataKey]
      };
    }, []);
    const resolvedInheritedValue = (0, import_element127.useMemo)(() => {
      const resolvedValues = {
        background: {}
      };
      if (!inheritedValue?.background) {
        return inheritedValue;
      }
      Object.entries(inheritedValue?.background).forEach(
        ([key, backgroundValue]) => {
          resolvedValues.background[key] = getResolvedValue(
            backgroundValue,
            {
              styles: globalStyles,
              _links
            }
          );
        }
      );
      return resolvedValues;
    }, [globalStyles, _links, inheritedValue]);
    const resetBackground = () => onChange(setImmutably(value, ["background"], {}));
    const { title, url } = value?.background?.backgroundImage || {
      ...resolvedInheritedValue?.background?.backgroundImage
    };
    const hasImageValue = hasBackgroundImageValue(value) || hasBackgroundImageValue(resolvedInheritedValue);
    const imageValue = value?.background?.backgroundImage || inheritedValue?.background?.backgroundImage;
    const shouldShowBackgroundImageControls = hasImageValue && "none" !== imageValue && (settings2?.background?.backgroundSize || settings2?.background?.backgroundPosition || settings2?.background?.backgroundRepeat);
    const [isDropDownOpen, setIsDropDownOpen] = (0, import_element127.useState)(false);
    const containerRef = (0, import_element127.useRef)();
    return /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
      "div",
      {
        ref: containerRef,
        className: clsx_default(
          "block-editor-global-styles-background-panel__inspector-media-replace-container",
          {
            "is-open": isDropDownOpen
          }
        ),
        children: shouldShowBackgroundImageControls ? /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
          BackgroundControlsPanel,
          {
            label: title,
            filename: title,
            url,
            onToggle: setIsDropDownOpen,
            hasImageValue,
            onReset: resetBackground,
            containerRef,
            children: /* @__PURE__ */ (0, import_jsx_runtime247.jsxs)(import_components115.__experimentalVStack, { spacing: 3, className: "single-column", children: [
              /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
                BackgroundImageControls,
                {
                  onChange,
                  style: value,
                  inheritedValue: resolvedInheritedValue,
                  displayInPanel: true,
                  onResetImage: () => {
                    setIsDropDownOpen(false);
                    resetBackground();
                  },
                  onRemoveImage: () => setIsDropDownOpen(false),
                  defaultValues,
                  containerRef
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
                BackgroundSizeControls,
                {
                  onChange,
                  style: value,
                  defaultValues,
                  inheritedValue: resolvedInheritedValue
                }
              )
            ] })
          }
        ) : /* @__PURE__ */ (0, import_jsx_runtime247.jsx)(
          BackgroundImageControls,
          {
            onChange,
            style: value,
            inheritedValue: resolvedInheritedValue,
            defaultValues,
            onResetImage: () => {
              setIsDropDownOpen(false);
              resetBackground();
            },
            onRemoveImage: () => setIsDropDownOpen(false),
            containerRef
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/background-panel.js
  var import_i18n110 = __toESM(require_i18n());
  var DEFAULT_CONTROLS2 = {
    backgroundImage: true
  };
  function useHasBackgroundPanel(settings2) {
    return import_element128.Platform.OS === "web" && settings2?.background?.backgroundImage;
  }
  function hasBackgroundImageValue(style) {
    return !!style?.background?.backgroundImage?.id || // Supports url() string values in theme.json.
    "string" === typeof style?.background?.backgroundImage || !!style?.background?.backgroundImage?.url;
  }
  function BackgroundToolsPanel({
    resetAllFilter,
    onChange,
    value,
    panelId,
    children,
    headerLabel
  }) {
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const resetAll = () => {
      const updatedValue = resetAllFilter(value);
      onChange(updatedValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime248.jsx)(
      import_components116.__experimentalToolsPanel,
      {
        label: headerLabel,
        resetAll,
        panelId,
        dropdownMenuProps,
        children
      }
    );
  }
  function BackgroundImagePanel2({
    as: Wrapper = BackgroundToolsPanel,
    value,
    onChange,
    inheritedValue,
    settings: settings2,
    panelId,
    defaultControls = DEFAULT_CONTROLS2,
    defaultValues = {},
    headerLabel = (0, import_i18n110.__)("Background image")
  }) {
    const showBackgroundImageControl = useHasBackgroundPanel(settings2);
    const resetBackground = () => onChange(setImmutably(value, ["background"], {}));
    const resetAllFilter = (0, import_element128.useCallback)((previousValue) => {
      return {
        ...previousValue,
        background: {}
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime248.jsx)(
      Wrapper,
      {
        resetAllFilter,
        value,
        onChange,
        panelId,
        headerLabel,
        children: showBackgroundImageControl && /* @__PURE__ */ (0, import_jsx_runtime248.jsx)(
          import_components116.__experimentalToolsPanelItem,
          {
            hasValue: () => !!value?.background,
            label: (0, import_i18n110.__)("Image"),
            onDeselect: resetBackground,
            isShownByDefault: defaultControls.backgroundImage,
            panelId,
            children: /* @__PURE__ */ (0, import_jsx_runtime248.jsx)(
              BackgroundImagePanel,
              {
                value,
                onChange,
                settings: settings2,
                inheritedValue,
                defaultControls,
                defaultValues
              }
            )
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/hooks/background.js
  var BACKGROUND_SUPPORT_KEY = "background";
  var BACKGROUND_BLOCK_DEFAULT_VALUES = {
    backgroundSize: "cover",
    backgroundPosition: "50% 50%"
    // used only when backgroundSize is 'contain'.
  };
  function hasBackgroundSupport(blockName, feature = "any") {
    const support = (0, import_blocks67.getBlockSupport)(blockName, BACKGROUND_SUPPORT_KEY);
    if (support === true) {
      return true;
    }
    if (feature === "any") {
      return !!support?.backgroundImage || !!support?.backgroundSize || !!support?.backgroundRepeat;
    }
    return !!support?.[feature];
  }
  function setBackgroundStyleDefaults(backgroundStyle) {
    if (!backgroundStyle || !backgroundStyle?.backgroundImage?.url) {
      return;
    }
    let backgroundStylesWithDefaults;
    if (!backgroundStyle?.backgroundSize) {
      backgroundStylesWithDefaults = {
        backgroundSize: BACKGROUND_BLOCK_DEFAULT_VALUES.backgroundSize
      };
    }
    if ("contain" === backgroundStyle?.backgroundSize && !backgroundStyle?.backgroundPosition) {
      backgroundStylesWithDefaults = {
        backgroundPosition: BACKGROUND_BLOCK_DEFAULT_VALUES.backgroundPosition
      };
    }
    return backgroundStylesWithDefaults;
  }
  function useBlockProps3({ name, style }) {
    if (!hasBackgroundSupport(name) || !style?.background?.backgroundImage) {
      return;
    }
    const backgroundStyles = setBackgroundStyleDefaults(style?.background);
    if (!backgroundStyles) {
      return;
    }
    return {
      style: {
        ...backgroundStyles
      }
    };
  }
  function getBackgroundImageClasses(style) {
    return hasBackgroundImageValue(style) ? "has-background" : "";
  }
  function BackgroundInspectorControl({ children }) {
    const resetAllFilter = (0, import_element129.useCallback)((attributes) => {
      return {
        ...attributes,
        style: {
          ...attributes.style,
          background: void 0
        }
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime249.jsx)(inspector_controls_default, { group: "background", resetAllFilter, children });
  }
  function BackgroundImagePanel3({
    clientId,
    name,
    setAttributes,
    settings: settings2
  }) {
    const { style, inheritedValue } = (0, import_data114.useSelect)(
      (select2) => {
        const { getBlockAttributes: getBlockAttributes3, getSettings: getSettings4 } = select2(store);
        const _settings = getSettings4();
        return {
          style: getBlockAttributes3(clientId)?.style,
          /*
           * To ensure we pass down the right inherited values:
           * @TODO 1. Pass inherited value down to all block style controls,
           *   See: packages/block-editor/src/hooks/style.js
           * @TODO 2. Add support for block style variations,
           *   See implementation: packages/block-editor/src/hooks/block-style-variation.js
           */
          inheritedValue: _settings[globalStylesDataKey]?.blocks?.[name]
        };
      },
      [clientId, name]
    );
    if (!useHasBackgroundPanel(settings2) || !hasBackgroundSupport(name, "backgroundImage")) {
      return null;
    }
    const onChange = (newStyle) => {
      setAttributes({
        style: cleanEmptyObject(newStyle)
      });
    };
    const updatedSettings = {
      ...settings2,
      background: {
        ...settings2.background,
        backgroundSize: settings2?.background?.backgroundSize && hasBackgroundSupport(name, "backgroundSize")
      }
    };
    const defaultControls = (0, import_blocks67.getBlockSupport)(name, [
      BACKGROUND_SUPPORT_KEY,
      "defaultControls"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime249.jsx)(
      BackgroundImagePanel2,
      {
        inheritedValue,
        as: BackgroundInspectorControl,
        panelId: clientId,
        defaultValues: BACKGROUND_BLOCK_DEFAULT_VALUES,
        settings: updatedSettings,
        onChange,
        defaultControls,
        value: style
      }
    );
  }
  var background_default = {
    useBlockProps: useBlockProps3,
    attributeKeys: ["style"],
    hasSupport: hasBackgroundSupport
  };

  // packages/block-editor/build-module/components/global-styles/use-global-styles-output.js
  var ELEMENT_CLASS_NAMES = {
    button: "wp-element-button",
    caption: "wp-element-caption"
  };
  var BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS = {
    __experimentalBorder: "border",
    color: "color",
    spacing: "spacing",
    typography: "typography"
  };
  var { kebabCase: kebabCase4 } = unlock(import_components117.privateApis);
  function getPresetsDeclarations(blockPresets = {}, mergedSettings) {
    return PRESET_METADATA.reduce(
      (declarations, { path, valueKey, valueFunc, cssVarInfix }) => {
        const presetByOrigin = getValueFromObjectPath(
          blockPresets,
          path,
          []
        );
        ["default", "theme", "custom"].forEach((origin) => {
          if (presetByOrigin[origin]) {
            presetByOrigin[origin].forEach((value) => {
              if (valueKey && !valueFunc) {
                declarations.push(
                  `--wp--preset--${cssVarInfix}--${kebabCase4(
                    value.slug
                  )}: ${value[valueKey]}`
                );
              } else if (valueFunc && typeof valueFunc === "function") {
                declarations.push(
                  `--wp--preset--${cssVarInfix}--${kebabCase4(
                    value.slug
                  )}: ${valueFunc(value, mergedSettings)}`
                );
              }
            });
          }
        });
        return declarations;
      },
      []
    );
  }
  function getPresetsClasses(blockSelector = "*", blockPresets = {}) {
    return PRESET_METADATA.reduce(
      (declarations, { path, cssVarInfix, classes }) => {
        if (!classes) {
          return declarations;
        }
        const presetByOrigin = getValueFromObjectPath(
          blockPresets,
          path,
          []
        );
        ["default", "theme", "custom"].forEach((origin) => {
          if (presetByOrigin[origin]) {
            presetByOrigin[origin].forEach(({ slug }) => {
              classes.forEach(({ classSuffix, propertyName }) => {
                const classSelectorToUse = `.has-${kebabCase4(
                  slug
                )}-${classSuffix}`;
                const selectorToUse = blockSelector.split(",").map(
                  (selector3) => `${selector3}${classSelectorToUse}`
                ).join(",");
                const value = `var(--wp--preset--${cssVarInfix}--${kebabCase4(
                  slug
                )})`;
                declarations += `${selectorToUse}{${propertyName}: ${value} !important;}`;
              });
            });
          }
        });
        return declarations;
      },
      ""
    );
  }
  function getPresetsSvgFilters(blockPresets = {}) {
    return PRESET_METADATA.filter(
      // Duotone are the only type of filters for now.
      (metadata) => metadata.path.at(-1) === "duotone"
    ).flatMap((metadata) => {
      const presetByOrigin = getValueFromObjectPath(
        blockPresets,
        metadata.path,
        {}
      );
      return ["default", "theme"].filter((origin) => presetByOrigin[origin]).flatMap(
        (origin) => presetByOrigin[origin].map(
          (preset) => getDuotoneFilter(
            `wp-duotone-${preset.slug}`,
            preset.colors
          )
        )
      ).join("");
    });
  }
  function flattenTree(input = {}, prefix3, token2) {
    let result = [];
    Object.keys(input).forEach((key) => {
      const newKey = prefix3 + kebabCase4(key.replace("/", "-"));
      const newLeaf = input[key];
      if (newLeaf instanceof Object) {
        const newPrefix = newKey + token2;
        result = [...result, ...flattenTree(newLeaf, newPrefix, token2)];
      } else {
        result.push(`${newKey}: ${newLeaf}`);
      }
    });
    return result;
  }
  function concatFeatureVariationSelectorString(featureSelector, styleVariationSelector) {
    const featureSelectors = featureSelector.split(",");
    const combinedSelectors = [];
    featureSelectors.forEach((selector3) => {
      combinedSelectors.push(
        `${styleVariationSelector.trim()}${selector3.trim()}`
      );
    });
    return combinedSelectors.join(", ");
  }
  var getFeatureDeclarations = (selectors, styles) => {
    const declarations = {};
    Object.entries(selectors).forEach(([feature, selector3]) => {
      if (feature === "root" || !styles?.[feature]) {
        return;
      }
      const isShorthand = typeof selector3 === "string";
      if (!isShorthand) {
        Object.entries(selector3).forEach(
          ([subfeature, subfeatureSelector]) => {
            if (subfeature === "root" || !styles?.[feature][subfeature]) {
              return;
            }
            const subfeatureStyles = {
              [feature]: {
                [subfeature]: styles[feature][subfeature]
              }
            };
            const newDeclarations = getStylesDeclarations(subfeatureStyles);
            declarations[subfeatureSelector] = [
              ...declarations[subfeatureSelector] || [],
              ...newDeclarations
            ];
            delete styles[feature][subfeature];
          }
        );
      }
      if (isShorthand || selector3.root) {
        const featureSelector = isShorthand ? selector3 : selector3.root;
        const featureStyles = { [feature]: styles[feature] };
        const newDeclarations = getStylesDeclarations(featureStyles);
        declarations[featureSelector] = [
          ...declarations[featureSelector] || [],
          ...newDeclarations
        ];
        delete styles[feature];
      }
    });
    return declarations;
  };
  function getStylesDeclarations(blockStyles = {}, selector3 = "", useRootPaddingAlign, tree = {}, disableRootPadding = false) {
    const isRoot = ROOT_BLOCK_SELECTOR === selector3;
    const output = Object.entries(import_blocks68.__EXPERIMENTAL_STYLE_PROPERTY).reduce(
      (declarations, [key, { value, properties, useEngine, rootOnly }]) => {
        if (rootOnly && !isRoot) {
          return declarations;
        }
        const pathToValue = value;
        if (pathToValue[0] === "elements" || useEngine) {
          return declarations;
        }
        const styleValue = getValueFromObjectPath(
          blockStyles,
          pathToValue
        );
        if (key === "--wp--style--root--padding" && (typeof styleValue === "string" || !useRootPaddingAlign)) {
          return declarations;
        }
        if (properties && typeof styleValue !== "string") {
          Object.entries(properties).forEach((entry) => {
            const [name, prop] = entry;
            if (!getValueFromObjectPath(styleValue, [prop], false)) {
              return;
            }
            const cssProperty = name.startsWith("--") ? name : kebabCase4(name);
            declarations.push(
              `${cssProperty}: ${(0, import_style_engine3.getCSSValueFromRawStyle)(
                getValueFromObjectPath(styleValue, [prop])
              )}`
            );
          });
        } else if (getValueFromObjectPath(blockStyles, pathToValue, false)) {
          const cssProperty = key.startsWith("--") ? key : kebabCase4(key);
          declarations.push(
            `${cssProperty}: ${(0, import_style_engine3.getCSSValueFromRawStyle)(
              getValueFromObjectPath(blockStyles, pathToValue)
            )}`
          );
        }
        return declarations;
      },
      []
    );
    if (!!blockStyles.background) {
      if (blockStyles.background?.backgroundImage) {
        blockStyles.background.backgroundImage = getResolvedValue(
          blockStyles.background.backgroundImage,
          tree
        );
      }
      if (!isRoot && !!blockStyles.background?.backgroundImage?.id) {
        blockStyles = {
          ...blockStyles,
          background: {
            ...blockStyles.background,
            ...setBackgroundStyleDefaults(blockStyles.background)
          }
        };
      }
    }
    const extraRules = (0, import_style_engine3.getCSSRules)(blockStyles);
    extraRules.forEach((rule) => {
      if (isRoot && (useRootPaddingAlign || disableRootPadding) && rule.key.startsWith("padding")) {
        return;
      }
      const cssProperty = rule.key.startsWith("--") ? rule.key : kebabCase4(rule.key);
      let ruleValue = getResolvedValue(rule.value, tree, null);
      if (cssProperty === "font-size") {
        ruleValue = getTypographyFontSizeValue(
          { size: ruleValue },
          tree?.settings
        );
      }
      if (cssProperty === "aspect-ratio") {
        output.push("min-height: unset");
      }
      output.push(`${cssProperty}: ${ruleValue}`);
    });
    return output;
  }
  function getLayoutStyles({
    layoutDefinitions = LAYOUT_DEFINITIONS,
    style,
    selector: selector3,
    hasBlockGapSupport,
    hasFallbackGapSupport,
    fallbackGapValue
  }) {
    let ruleset2 = "";
    let gapValue = hasBlockGapSupport ? getGapCSSValue(style?.spacing?.blockGap) : "";
    if (hasFallbackGapSupport) {
      if (selector3 === ROOT_BLOCK_SELECTOR) {
        gapValue = !gapValue ? "0.5em" : gapValue;
      } else if (!hasBlockGapSupport && fallbackGapValue) {
        gapValue = fallbackGapValue;
      }
    }
    if (gapValue && layoutDefinitions) {
      Object.values(layoutDefinitions).forEach(
        ({ className, name, spacingStyles }) => {
          if (!hasBlockGapSupport && "flex" !== name && "grid" !== name) {
            return;
          }
          if (spacingStyles?.length) {
            spacingStyles.forEach((spacingStyle) => {
              const declarations = [];
              if (spacingStyle.rules) {
                Object.entries(spacingStyle.rules).forEach(
                  ([cssProperty, cssValue]) => {
                    declarations.push(
                      `${cssProperty}: ${cssValue ? cssValue : gapValue}`
                    );
                  }
                );
              }
              if (declarations.length) {
                let combinedSelector = "";
                if (!hasBlockGapSupport) {
                  combinedSelector = selector3 === ROOT_BLOCK_SELECTOR ? `:where(.${className}${spacingStyle?.selector || ""})` : `:where(${selector3}.${className}${spacingStyle?.selector || ""})`;
                } else {
                  combinedSelector = selector3 === ROOT_BLOCK_SELECTOR ? `:root :where(.${className})${spacingStyle?.selector || ""}` : `:root :where(${selector3}-${className})${spacingStyle?.selector || ""}`;
                }
                ruleset2 += `${combinedSelector} { ${declarations.join(
                  "; "
                )}; }`;
              }
            });
          }
        }
      );
      if (selector3 === ROOT_BLOCK_SELECTOR && hasBlockGapSupport) {
        ruleset2 += `${ROOT_CSS_PROPERTIES_SELECTOR} { --wp--style--block-gap: ${gapValue}; }`;
      }
    }
    if (selector3 === ROOT_BLOCK_SELECTOR && layoutDefinitions) {
      const validDisplayModes = ["block", "flex", "grid"];
      Object.values(layoutDefinitions).forEach(
        ({ className, displayMode, baseStyles }) => {
          if (displayMode && validDisplayModes.includes(displayMode)) {
            ruleset2 += `${selector3} .${className} { display:${displayMode}; }`;
          }
          if (baseStyles?.length) {
            baseStyles.forEach((baseStyle) => {
              const declarations = [];
              if (baseStyle.rules) {
                Object.entries(baseStyle.rules).forEach(
                  ([cssProperty, cssValue]) => {
                    declarations.push(
                      `${cssProperty}: ${cssValue}`
                    );
                  }
                );
              }
              if (declarations.length) {
                const combinedSelector = `.${className}${baseStyle?.selector || ""}`;
                ruleset2 += `${combinedSelector} { ${declarations.join(
                  "; "
                )}; }`;
              }
            });
          }
        }
      );
    }
    return ruleset2;
  }
  var STYLE_KEYS = [
    "border",
    "color",
    "dimensions",
    "spacing",
    "typography",
    "filter",
    "outline",
    "shadow",
    "background"
  ];
  function pickStyleKeys(treeToPickFrom) {
    if (!treeToPickFrom) {
      return {};
    }
    const entries = Object.entries(treeToPickFrom);
    const pickedEntries = entries.filter(
      ([key]) => STYLE_KEYS.includes(key)
    );
    const clonedEntries = pickedEntries.map(([key, style]) => [
      key,
      JSON.parse(JSON.stringify(style))
    ]);
    return Object.fromEntries(clonedEntries);
  }
  var getNodesWithStyles = (tree, blockSelectors) => {
    const nodes = [];
    if (!tree?.styles) {
      return nodes;
    }
    const styles = pickStyleKeys(tree.styles);
    if (styles) {
      nodes.push({
        styles,
        selector: ROOT_BLOCK_SELECTOR,
        // Root selector (body) styles should not be wrapped in `:root where()` to keep
        // specificity at (0,0,1) and maintain backwards compatibility.
        skipSelectorWrapper: true
      });
    }
    Object.entries(import_blocks68.__EXPERIMENTAL_ELEMENTS).forEach(([name, selector3]) => {
      if (tree.styles?.elements?.[name]) {
        nodes.push({
          styles: tree.styles?.elements?.[name],
          selector: selector3,
          // Top level elements that don't use a class name should not receive the
          // `:root :where()` wrapper to maintain backwards compatibility.
          skipSelectorWrapper: !ELEMENT_CLASS_NAMES[name]
        });
      }
    });
    Object.entries(tree.styles?.blocks ?? {}).forEach(
      ([blockName, node2]) => {
        const blockStyles = pickStyleKeys(node2);
        if (node2?.variations) {
          const variations = {};
          Object.entries(node2.variations).forEach(
            ([variationName, variation]) => {
              variations[variationName] = pickStyleKeys(variation);
              if (variation?.css) {
                variations[variationName].css = variation.css;
              }
              const variationSelector = blockSelectors[blockName]?.styleVariationSelectors?.[variationName];
              Object.entries(variation?.elements ?? {}).forEach(
                ([element, elementStyles]) => {
                  if (elementStyles && import_blocks68.__EXPERIMENTAL_ELEMENTS[element]) {
                    nodes.push({
                      styles: elementStyles,
                      selector: scopeSelector(
                        variationSelector,
                        import_blocks68.__EXPERIMENTAL_ELEMENTS[element]
                      )
                    });
                  }
                }
              );
              Object.entries(variation?.blocks ?? {}).forEach(
                ([
                  variationBlockName,
                  variationBlockStyles
                ]) => {
                  const variationBlockSelector = scopeSelector(
                    variationSelector,
                    blockSelectors[variationBlockName]?.selector
                  );
                  const variationDuotoneSelector = scopeSelector(
                    variationSelector,
                    blockSelectors[variationBlockName]?.duotoneSelector
                  );
                  const variationFeatureSelectors = scopeFeatureSelectors(
                    variationSelector,
                    blockSelectors[variationBlockName]?.featureSelectors
                  );
                  const variationBlockStyleNodes = pickStyleKeys(variationBlockStyles);
                  if (variationBlockStyles?.css) {
                    variationBlockStyleNodes.css = variationBlockStyles.css;
                  }
                  nodes.push({
                    selector: variationBlockSelector,
                    duotoneSelector: variationDuotoneSelector,
                    featureSelectors: variationFeatureSelectors,
                    fallbackGapValue: blockSelectors[variationBlockName]?.fallbackGapValue,
                    hasLayoutSupport: blockSelectors[variationBlockName]?.hasLayoutSupport,
                    styles: variationBlockStyleNodes
                  });
                  Object.entries(
                    variationBlockStyles.elements ?? {}
                  ).forEach(
                    ([
                      variationBlockElement,
                      variationBlockElementStyles
                    ]) => {
                      if (variationBlockElementStyles && import_blocks68.__EXPERIMENTAL_ELEMENTS[variationBlockElement]) {
                        nodes.push({
                          styles: variationBlockElementStyles,
                          selector: scopeSelector(
                            variationBlockSelector,
                            import_blocks68.__EXPERIMENTAL_ELEMENTS[variationBlockElement]
                          )
                        });
                      }
                    }
                  );
                }
              );
            }
          );
          blockStyles.variations = variations;
        }
        if (blockSelectors?.[blockName]?.selector) {
          nodes.push({
            duotoneSelector: blockSelectors[blockName].duotoneSelector,
            fallbackGapValue: blockSelectors[blockName].fallbackGapValue,
            hasLayoutSupport: blockSelectors[blockName].hasLayoutSupport,
            selector: blockSelectors[blockName].selector,
            styles: blockStyles,
            featureSelectors: blockSelectors[blockName].featureSelectors,
            styleVariationSelectors: blockSelectors[blockName].styleVariationSelectors
          });
        }
        Object.entries(node2?.elements ?? {}).forEach(
          ([elementName, value]) => {
            if (value && blockSelectors?.[blockName] && import_blocks68.__EXPERIMENTAL_ELEMENTS[elementName]) {
              nodes.push({
                styles: value,
                selector: blockSelectors[blockName]?.selector.split(",").map((sel) => {
                  const elementSelectors = import_blocks68.__EXPERIMENTAL_ELEMENTS[elementName].split(",");
                  return elementSelectors.map(
                    (elementSelector) => sel + " " + elementSelector
                  );
                }).join(",")
              });
            }
          }
        );
      }
    );
    return nodes;
  };
  var getNodesWithSettings = (tree, blockSelectors) => {
    const nodes = [];
    if (!tree?.settings) {
      return nodes;
    }
    const pickPresets = (treeToPickFrom) => {
      let presets2 = {};
      PRESET_METADATA.forEach(({ path }) => {
        const value = getValueFromObjectPath(treeToPickFrom, path, false);
        if (value !== false) {
          presets2 = setImmutably(presets2, path, value);
        }
      });
      return presets2;
    };
    const presets = pickPresets(tree.settings);
    const custom = tree.settings?.custom;
    if (Object.keys(presets).length > 0 || custom) {
      nodes.push({
        presets,
        custom,
        selector: ROOT_CSS_PROPERTIES_SELECTOR
      });
    }
    Object.entries(tree.settings?.blocks ?? {}).forEach(
      ([blockName, node2]) => {
        const blockPresets = pickPresets(node2);
        const blockCustom = node2.custom;
        if (Object.keys(blockPresets).length > 0 || blockCustom) {
          nodes.push({
            presets: blockPresets,
            custom: blockCustom,
            selector: blockSelectors[blockName]?.selector
          });
        }
      }
    );
    return nodes;
  };
  var toCustomProperties = (tree, blockSelectors) => {
    const settings2 = getNodesWithSettings(tree, blockSelectors);
    let ruleset2 = "";
    settings2.forEach(({ presets, custom, selector: selector3 }) => {
      const declarations = getPresetsDeclarations(presets, tree?.settings);
      const customProps = flattenTree(custom, "--wp--custom--", "--");
      if (customProps.length > 0) {
        declarations.push(...customProps);
      }
      if (declarations.length > 0) {
        ruleset2 += `${selector3}{${declarations.join(";")};}`;
      }
    });
    return ruleset2;
  };
  var toStyles = (tree, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles = false, disableRootPadding = false, styleOptions = void 0) => {
    const options = {
      blockGap: true,
      blockStyles: true,
      layoutStyles: true,
      marginReset: true,
      presets: true,
      rootPadding: true,
      variationStyles: false,
      ...styleOptions
    };
    const nodesWithStyles = getNodesWithStyles(tree, blockSelectors);
    const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
    const useRootPaddingAlign = tree?.settings?.useRootPaddingAwareAlignments;
    const { contentSize, wideSize } = tree?.settings?.layout || {};
    const hasBodyStyles = options.marginReset || options.rootPadding || options.layoutStyles;
    let ruleset2 = "";
    if (options.presets && (contentSize || wideSize)) {
      ruleset2 += `${ROOT_CSS_PROPERTIES_SELECTOR} {`;
      ruleset2 = contentSize ? ruleset2 + ` --wp--style--global--content-size: ${contentSize};` : ruleset2;
      ruleset2 = wideSize ? ruleset2 + ` --wp--style--global--wide-size: ${wideSize};` : ruleset2;
      ruleset2 += "}";
    }
    if (hasBodyStyles) {
      ruleset2 += ":where(body) {margin: 0;";
      if (options.rootPadding && useRootPaddingAlign) {
        ruleset2 += `padding-right: 0; padding-left: 0; padding-top: var(--wp--style--root--padding-top); padding-bottom: var(--wp--style--root--padding-bottom) }
				.has-global-padding { padding-right: var(--wp--style--root--padding-right); padding-left: var(--wp--style--root--padding-left); }
				.has-global-padding > .alignfull { margin-right: calc(var(--wp--style--root--padding-right) * -1); margin-left: calc(var(--wp--style--root--padding-left) * -1); }
				.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) { padding-right: 0; padding-left: 0; }
				.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) > .alignfull { margin-left: 0; margin-right: 0;
				`;
      }
      ruleset2 += "}";
    }
    if (options.blockStyles) {
      nodesWithStyles.forEach(
        ({
          selector: selector3,
          duotoneSelector,
          styles,
          fallbackGapValue,
          hasLayoutSupport: hasLayoutSupport2,
          featureSelectors,
          styleVariationSelectors,
          skipSelectorWrapper
        }) => {
          if (featureSelectors) {
            const featureDeclarations = getFeatureDeclarations(
              featureSelectors,
              styles
            );
            Object.entries(featureDeclarations).forEach(
              ([cssSelector, declarations]) => {
                if (declarations.length) {
                  const rules = declarations.join(";");
                  ruleset2 += `:root :where(${cssSelector}){${rules};}`;
                }
              }
            );
          }
          if (duotoneSelector) {
            const duotoneStyles = {};
            if (styles?.filter) {
              duotoneStyles.filter = styles.filter;
              delete styles.filter;
            }
            const duotoneDeclarations = getStylesDeclarations(duotoneStyles);
            if (duotoneDeclarations.length) {
              ruleset2 += `${duotoneSelector}{${duotoneDeclarations.join(
                ";"
              )};}`;
            }
          }
          if (!disableLayoutStyles && (ROOT_BLOCK_SELECTOR === selector3 || hasLayoutSupport2)) {
            ruleset2 += getLayoutStyles({
              style: styles,
              selector: selector3,
              hasBlockGapSupport,
              hasFallbackGapSupport,
              fallbackGapValue
            });
          }
          const styleDeclarations = getStylesDeclarations(
            styles,
            selector3,
            useRootPaddingAlign,
            tree,
            disableRootPadding
          );
          if (styleDeclarations?.length) {
            const generalSelector = skipSelectorWrapper ? selector3 : `:root :where(${selector3})`;
            ruleset2 += `${generalSelector}{${styleDeclarations.join(
              ";"
            )};}`;
          }
          if (styles?.css) {
            ruleset2 += processCSSNesting(
              styles.css,
              `:root :where(${selector3})`
            );
          }
          if (options.variationStyles && styleVariationSelectors) {
            Object.entries(styleVariationSelectors).forEach(
              ([styleVariationName, styleVariationSelector]) => {
                const styleVariations = styles?.variations?.[styleVariationName];
                if (styleVariations) {
                  if (featureSelectors) {
                    const featureDeclarations = getFeatureDeclarations(
                      featureSelectors,
                      styleVariations
                    );
                    Object.entries(
                      featureDeclarations
                    ).forEach(
                      ([baseSelector, declarations]) => {
                        if (declarations.length) {
                          const cssSelector = concatFeatureVariationSelectorString(
                            baseSelector,
                            styleVariationSelector
                          );
                          const rules = declarations.join(";");
                          ruleset2 += `:root :where(${cssSelector}){${rules};}`;
                        }
                      }
                    );
                  }
                  const styleVariationDeclarations = getStylesDeclarations(
                    styleVariations,
                    styleVariationSelector,
                    useRootPaddingAlign,
                    tree
                  );
                  if (styleVariationDeclarations.length) {
                    ruleset2 += `:root :where(${styleVariationSelector}){${styleVariationDeclarations.join(
                      ";"
                    )};}`;
                  }
                  if (styleVariations?.css) {
                    ruleset2 += processCSSNesting(
                      styleVariations.css,
                      `:root :where(${styleVariationSelector})`
                    );
                  }
                }
              }
            );
          }
          const pseudoSelectorStyles = Object.entries(styles).filter(
            ([key]) => key.startsWith(":")
          );
          if (pseudoSelectorStyles?.length) {
            pseudoSelectorStyles.forEach(
              ([pseudoKey, pseudoStyle]) => {
                const pseudoDeclarations = getStylesDeclarations(pseudoStyle);
                if (!pseudoDeclarations?.length) {
                  return;
                }
                const _selector = selector3.split(",").map((sel) => sel + pseudoKey).join(",");
                const pseudoRule = `:root :where(${_selector}){${pseudoDeclarations.join(
                  ";"
                )};}`;
                ruleset2 += pseudoRule;
              }
            );
          }
        }
      );
    }
    if (options.layoutStyles) {
      ruleset2 = ruleset2 + ".wp-site-blocks > .alignleft { float: left; margin-right: 2em; }";
      ruleset2 = ruleset2 + ".wp-site-blocks > .alignright { float: right; margin-left: 2em; }";
      ruleset2 = ruleset2 + ".wp-site-blocks > .aligncenter { justify-content: center; margin-left: auto; margin-right: auto; }";
    }
    if (options.blockGap && hasBlockGapSupport) {
      const gapValue = getGapCSSValue(tree?.styles?.spacing?.blockGap) || "0.5em";
      ruleset2 = ruleset2 + `:root :where(.wp-site-blocks) > * { margin-block-start: ${gapValue}; margin-block-end: 0; }`;
      ruleset2 = ruleset2 + ":root :where(.wp-site-blocks) > :first-child { margin-block-start: 0; }";
      ruleset2 = ruleset2 + ":root :where(.wp-site-blocks) > :last-child { margin-block-end: 0; }";
    }
    if (options.presets) {
      nodesWithSettings.forEach(({ selector: selector3, presets }) => {
        if (ROOT_BLOCK_SELECTOR === selector3 || ROOT_CSS_PROPERTIES_SELECTOR === selector3) {
          selector3 = "";
        }
        const classes = getPresetsClasses(selector3, presets);
        if (classes.length > 0) {
          ruleset2 += classes;
        }
      });
    }
    return ruleset2;
  };
  function toSvgFilters(tree, blockSelectors) {
    const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
    return nodesWithSettings.flatMap(({ presets }) => {
      return getPresetsSvgFilters(presets);
    });
  }
  var getSelectorsConfig = (blockType, rootSelector) => {
    if (blockType?.selectors && Object.keys(blockType.selectors).length > 0) {
      return blockType.selectors;
    }
    const config2 = { root: rootSelector };
    Object.entries(BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS).forEach(
      ([featureKey, featureName]) => {
        const featureSelector = getBlockCSSSelector(
          blockType,
          featureKey
        );
        if (featureSelector) {
          config2[featureName] = featureSelector;
        }
      }
    );
    return config2;
  };
  var getBlockSelectors = (blockTypes, getBlockStyles2, variationInstanceId) => {
    const result = {};
    blockTypes.forEach((blockType) => {
      const name = blockType.name;
      const selector3 = getBlockCSSSelector(blockType);
      let duotoneSelector = getBlockCSSSelector(
        blockType,
        "filter.duotone"
      );
      if (!duotoneSelector) {
        const rootSelector = getBlockCSSSelector(blockType);
        const duotoneSupport = (0, import_blocks68.getBlockSupport)(
          blockType,
          "color.__experimentalDuotone",
          false
        );
        duotoneSelector = duotoneSupport && scopeSelector(rootSelector, duotoneSupport);
      }
      const hasLayoutSupport2 = !!blockType?.supports?.layout || !!blockType?.supports?.__experimentalLayout;
      const fallbackGapValue = blockType?.supports?.spacing?.blockGap?.__experimentalDefault;
      const blockStyleVariations = getBlockStyles2(name);
      const styleVariationSelectors = {};
      blockStyleVariations?.forEach((variation) => {
        const variationSuffix = variationInstanceId ? `-${variationInstanceId}` : "";
        const variationName = `${variation.name}${variationSuffix}`;
        const styleVariationSelector = getBlockStyleVariationSelector(
          variationName,
          selector3
        );
        styleVariationSelectors[variationName] = styleVariationSelector;
      });
      const featureSelectors = getSelectorsConfig(blockType, selector3);
      result[name] = {
        duotoneSelector,
        fallbackGapValue,
        featureSelectors: Object.keys(featureSelectors).length ? featureSelectors : void 0,
        hasLayoutSupport: hasLayoutSupport2,
        name,
        selector: selector3,
        styleVariationSelectors: blockStyleVariations?.length ? styleVariationSelectors : void 0
      };
    });
    return result;
  };
  function updateConfigWithSeparator(config2) {
    const needsSeparatorStyleUpdate = config2.styles?.blocks?.["core/separator"] && config2.styles?.blocks?.["core/separator"].color?.background && !config2.styles?.blocks?.["core/separator"].color?.text && !config2.styles?.blocks?.["core/separator"].border?.color;
    if (needsSeparatorStyleUpdate) {
      return {
        ...config2,
        styles: {
          ...config2.styles,
          blocks: {
            ...config2.styles.blocks,
            "core/separator": {
              ...config2.styles.blocks["core/separator"],
              color: {
                ...config2.styles.blocks["core/separator"].color,
                text: config2.styles?.blocks["core/separator"].color.background
              }
            }
          }
        }
      };
    }
    return config2;
  }
  function processCSSNesting(css, blockSelector) {
    let processedCSS = "";
    if (!css || css.trim() === "") {
      return processedCSS;
    }
    const parts = css.split("&");
    parts.forEach((part) => {
      if (!part || part.trim() === "") {
        return;
      }
      const isRootCss = !part.includes("{");
      if (isRootCss) {
        processedCSS += `:root :where(${blockSelector}){${part.trim()}}`;
      } else {
        const splitPart = part.replace("}", "").split("{");
        if (splitPart.length !== 2) {
          return;
        }
        const [nestedSelector, cssValue] = splitPart;
        const matches = nestedSelector.match(/([>+~\s]*::[a-zA-Z-]+)/);
        const pseudoPart = matches ? matches[1] : "";
        const withoutPseudoElement = matches ? nestedSelector.replace(pseudoPart, "").trim() : nestedSelector.trim();
        let combinedSelector;
        if (withoutPseudoElement === "") {
          combinedSelector = blockSelector;
        } else {
          combinedSelector = nestedSelector.startsWith(" ") ? scopeSelector(blockSelector, withoutPseudoElement) : appendToSelector(blockSelector, withoutPseudoElement);
        }
        processedCSS += `:root :where(${combinedSelector})${pseudoPart}{${cssValue.trim()}}`;
      }
    });
    return processedCSS;
  }
  function useGlobalStylesOutputWithConfig(mergedConfig = {}, disableRootPadding) {
    const [blockGap] = useGlobalSetting("spacing.blockGap");
    const hasBlockGapSupport = blockGap !== null;
    const hasFallbackGapSupport = !hasBlockGapSupport;
    const disableLayoutStyles = (0, import_data115.useSelect)((select2) => {
      const { getSettings: getSettings4 } = select2(store);
      return !!getSettings4().disableLayoutStyles;
    });
    const { getBlockStyles: getBlockStyles2 } = (0, import_data115.useSelect)(import_blocks68.store);
    return (0, import_element130.useMemo)(() => {
      if (!mergedConfig?.styles || !mergedConfig?.settings) {
        return [];
      }
      const updatedConfig = updateConfigWithSeparator(mergedConfig);
      const blockSelectors = getBlockSelectors(
        (0, import_blocks68.getBlockTypes)(),
        getBlockStyles2
      );
      const customProperties = toCustomProperties(
        updatedConfig,
        blockSelectors
      );
      const globalStyles = toStyles(
        updatedConfig,
        blockSelectors,
        hasBlockGapSupport,
        hasFallbackGapSupport,
        disableLayoutStyles,
        disableRootPadding
      );
      const svgs = toSvgFilters(updatedConfig, blockSelectors);
      const styles = [
        {
          css: customProperties,
          isGlobalStyles: true
        },
        {
          css: globalStyles,
          isGlobalStyles: true
        },
        // Load custom CSS in own stylesheet so that any invalid CSS entered in the input won't break all the global styles in the editor.
        {
          css: updatedConfig.styles.css ?? "",
          isGlobalStyles: true
        },
        {
          assets: svgs,
          __unstableType: "svg",
          isGlobalStyles: true
        }
      ];
      (0, import_blocks68.getBlockTypes)().forEach((blockType) => {
        if (updatedConfig.styles.blocks[blockType.name]?.css) {
          const selector3 = blockSelectors[blockType.name].selector;
          styles.push({
            css: processCSSNesting(
              updatedConfig.styles.blocks[blockType.name]?.css,
              selector3
            ),
            isGlobalStyles: true
          });
        }
      });
      return [styles, updatedConfig.settings];
    }, [
      hasBlockGapSupport,
      hasFallbackGapSupport,
      mergedConfig,
      disableLayoutStyles,
      disableRootPadding,
      getBlockStyles2
    ]);
  }
  function useGlobalStylesOutput(disableRootPadding = false) {
    const { merged: mergedConfig } = (0, import_element130.useContext)(GlobalStylesContext);
    return useGlobalStylesOutputWithConfig(mergedConfig, disableRootPadding);
  }

  // packages/block-editor/build-module/components/global-styles/typography-panel.js
  var import_jsx_runtime258 = __toESM(require_jsx_runtime());
  var import_components126 = __toESM(require_components());
  var import_i18n119 = __toESM(require_i18n());
  var import_element133 = __toESM(require_element());

  // packages/block-editor/build-module/components/font-family/index.js
  var import_jsx_runtime250 = __toESM(require_jsx_runtime());
  var import_components118 = __toESM(require_components());
  var import_deprecated17 = __toESM(require_deprecated());
  var import_i18n111 = __toESM(require_i18n());
  function FontFamilyControl({
    /** Start opting into the larger default height that will become the default size in a future version. */
    __next40pxDefaultSize = false,
    /** Start opting into the new margin-free styles that will become the default in a future version. */
    __nextHasNoMarginBottom = false,
    value = "",
    onChange,
    fontFamilies,
    className,
    ...props
  }) {
    const [blockLevelFontFamilies] = useSettings("typography.fontFamilies");
    if (!fontFamilies) {
      fontFamilies = blockLevelFontFamilies;
    }
    if (!fontFamilies || fontFamilies.length === 0) {
      return null;
    }
    const options = [
      {
        key: "",
        name: (0, import_i18n111.__)("Default")
      },
      ...fontFamilies.map(({ fontFamily, name }) => ({
        key: fontFamily,
        name: name || fontFamily,
        style: { fontFamily }
      }))
    ];
    if (!__nextHasNoMarginBottom) {
      (0, import_deprecated17.default)(
        "Bottom margin styles for wp.blockEditor.FontFamilyControl",
        {
          since: "6.7",
          version: "7.0",
          hint: "Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version"
        }
      );
    }
    if (!__next40pxDefaultSize && (props.size === void 0 || props.size === "default")) {
      (0, import_deprecated17.default)(
        `36px default size for wp.blockEditor.__experimentalFontFamilyControl`,
        {
          since: "6.8",
          version: "7.1",
          hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
        }
      );
    }
    const selectedValue = options.find((option) => option.key === value) ?? "";
    return /* @__PURE__ */ (0, import_jsx_runtime250.jsx)(
      import_components118.CustomSelectControl,
      {
        __next40pxDefaultSize,
        __shouldNotWarnDeprecated36pxSize: true,
        label: (0, import_i18n111.__)("Font"),
        value: selectedValue,
        onChange: ({ selectedItem }) => onChange(selectedItem.key),
        options,
        className: clsx_default("block-editor-font-family-control", className, {
          "is-next-has-no-margin-bottom": __nextHasNoMarginBottom
        }),
        ...props
      }
    );
  }

  // packages/block-editor/build-module/components/font-appearance-control/index.js
  var import_jsx_runtime251 = __toESM(require_jsx_runtime());
  var import_components119 = __toESM(require_components());
  var import_deprecated18 = __toESM(require_deprecated());
  var import_element131 = __toESM(require_element());
  var import_i18n112 = __toESM(require_i18n());
  var getFontAppearanceLabel = (hasFontStyles, hasFontWeights) => {
    if (!hasFontStyles) {
      return (0, import_i18n112.__)("Font weight");
    }
    if (!hasFontWeights) {
      return (0, import_i18n112.__)("Font style");
    }
    return (0, import_i18n112.__)("Appearance");
  };
  function FontAppearanceControl(props) {
    const {
      /** Start opting into the larger default height that will become the default size in a future version. */
      __next40pxDefaultSize = false,
      onChange,
      hasFontStyles = true,
      hasFontWeights = true,
      fontFamilyFaces,
      value: { fontStyle, fontWeight },
      ...otherProps
    } = props;
    const hasStylesOrWeights = hasFontStyles || hasFontWeights;
    const label = getFontAppearanceLabel(hasFontStyles, hasFontWeights);
    const defaultOption = {
      key: "default",
      name: (0, import_i18n112.__)("Default"),
      style: { fontStyle: void 0, fontWeight: void 0 }
    };
    const { fontStyles, fontWeights, combinedStyleAndWeightOptions } = getFontStylesAndWeights(fontFamilyFaces);
    const combineOptions = () => {
      const combinedOptions = [defaultOption];
      if (combinedStyleAndWeightOptions) {
        combinedOptions.push(...combinedStyleAndWeightOptions);
      }
      return combinedOptions;
    };
    const styleOptions = () => {
      const combinedOptions = [defaultOption];
      fontStyles.forEach(({ name, value }) => {
        combinedOptions.push({
          key: value,
          name,
          style: { fontStyle: value, fontWeight: void 0 }
        });
      });
      return combinedOptions;
    };
    const weightOptions = () => {
      const combinedOptions = [defaultOption];
      fontWeights.forEach(({ name, value }) => {
        combinedOptions.push({
          key: value,
          name,
          style: { fontStyle: void 0, fontWeight: value }
        });
      });
      return combinedOptions;
    };
    const selectOptions = (0, import_element131.useMemo)(() => {
      if (hasFontStyles && hasFontWeights) {
        return combineOptions();
      }
      return hasFontStyles ? styleOptions() : weightOptions();
    }, [
      props.options,
      fontStyles,
      fontWeights,
      combinedStyleAndWeightOptions
    ]);
    const currentSelection = selectOptions.find(
      (option) => option.style.fontStyle === fontStyle && option.style.fontWeight === fontWeight
    ) || selectOptions[0];
    const getDescribedBy = () => {
      if (!currentSelection) {
        return (0, import_i18n112.__)("No selected font appearance");
      }
      if (!hasFontStyles) {
        return (0, import_i18n112.sprintf)(
          // translators: %s: Currently selected font weight.
          (0, import_i18n112.__)("Currently selected font weight: %s"),
          currentSelection.name
        );
      }
      if (!hasFontWeights) {
        return (0, import_i18n112.sprintf)(
          // translators: %s: Currently selected font style.
          (0, import_i18n112.__)("Currently selected font style: %s"),
          currentSelection.name
        );
      }
      return (0, import_i18n112.sprintf)(
        // translators: %s: Currently selected font appearance.
        (0, import_i18n112.__)("Currently selected font appearance: %s"),
        currentSelection.name
      );
    };
    if (!__next40pxDefaultSize && (otherProps.size === void 0 || otherProps.size === "default")) {
      (0, import_deprecated18.default)(
        `36px default size for wp.blockEditor.__experimentalFontAppearanceControl`,
        {
          since: "6.8",
          version: "7.1",
          hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
        }
      );
    }
    return hasStylesOrWeights && /* @__PURE__ */ (0, import_jsx_runtime251.jsx)(
      import_components119.CustomSelectControl,
      {
        ...otherProps,
        className: "components-font-appearance-control",
        __next40pxDefaultSize,
        __shouldNotWarnDeprecated36pxSize: true,
        label,
        describedBy: getDescribedBy(),
        options: selectOptions,
        value: currentSelection,
        onChange: ({ selectedItem }) => onChange(selectedItem.style)
      }
    );
  }

  // packages/block-editor/build-module/components/line-height-control/index.js
  var import_jsx_runtime252 = __toESM(require_jsx_runtime());
  var import_i18n113 = __toESM(require_i18n());
  var import_components120 = __toESM(require_components());
  var import_deprecated19 = __toESM(require_deprecated());

  // packages/block-editor/build-module/components/line-height-control/utils.js
  var BASE_DEFAULT_VALUE = 1.5;
  var STEP = 0.01;
  var SPIN_FACTOR = 10;
  var RESET_VALUE = "";
  function isLineHeightDefined(lineHeight) {
    return lineHeight !== void 0 && lineHeight !== RESET_VALUE;
  }

  // packages/block-editor/build-module/components/line-height-control/index.js
  var LineHeightControl = ({
    /** Start opting into the larger default height that will become the default size in a future version. */
    __next40pxDefaultSize = false,
    value: lineHeight,
    onChange,
    __unstableInputWidth = "60px",
    ...otherProps
  }) => {
    const isDefined = isLineHeightDefined(lineHeight);
    const adjustNextValue = (nextValue, wasTypedOrPasted) => {
      if (isDefined) {
        return nextValue;
      }
      const spin = STEP * SPIN_FACTOR;
      switch (`${nextValue}`) {
        case `${spin}`:
          return BASE_DEFAULT_VALUE + spin;
        case "0": {
          if (wasTypedOrPasted) {
            return nextValue;
          }
          return BASE_DEFAULT_VALUE - spin;
        }
        case "":
          return BASE_DEFAULT_VALUE;
        default:
          return nextValue;
      }
    };
    const stateReducer = (state, action) => {
      const wasTypedOrPasted = ["insertText", "insertFromPaste"].includes(
        action.payload.event.nativeEvent?.inputType
      );
      const value2 = adjustNextValue(state.value, wasTypedOrPasted);
      return { ...state, value: value2 };
    };
    const value = isDefined ? lineHeight : RESET_VALUE;
    const handleOnChange = (nextValue, { event }) => {
      if (nextValue === "") {
        onChange();
        return;
      }
      if (event.type === "click") {
        onChange(adjustNextValue(`${nextValue}`, false));
        return;
      }
      onChange(`${nextValue}`);
    };
    if (!__next40pxDefaultSize && (otherProps.size === void 0 || otherProps.size === "default")) {
      (0, import_deprecated19.default)(`36px default size for wp.blockEditor.LineHeightControl`, {
        since: "6.8",
        version: "7.1",
        hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
      });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime252.jsx)("div", { className: "block-editor-line-height-control", children: /* @__PURE__ */ (0, import_jsx_runtime252.jsx)(
      import_components120.__experimentalNumberControl,
      {
        ...otherProps,
        __shouldNotWarnDeprecated36pxSize: true,
        __next40pxDefaultSize,
        __unstableInputWidth,
        __unstableStateReducer: stateReducer,
        onChange: handleOnChange,
        label: (0, import_i18n113.__)("Line height"),
        placeholder: BASE_DEFAULT_VALUE,
        step: STEP,
        spinFactor: SPIN_FACTOR,
        value,
        min: 0,
        spinControls: "custom"
      }
    ) });
  };
  var line_height_control_default = LineHeightControl;

  // packages/block-editor/build-module/components/letter-spacing-control/index.js
  var import_jsx_runtime253 = __toESM(require_jsx_runtime());
  var import_components121 = __toESM(require_components());
  var import_deprecated20 = __toESM(require_deprecated());
  var import_i18n114 = __toESM(require_i18n());
  function LetterSpacingControl({
    __next40pxDefaultSize = false,
    value,
    onChange,
    __unstableInputWidth = "60px",
    ...otherProps
  }) {
    const [availableUnits] = useSettings("spacing.units");
    const units2 = (0, import_components121.__experimentalUseCustomUnits)({
      availableUnits: availableUnits || ["px", "em", "rem"],
      defaultValues: { px: 2, em: 0.2, rem: 0.2 }
    });
    if (!__next40pxDefaultSize && (otherProps.size === void 0 || otherProps.size === "default")) {
      (0, import_deprecated20.default)(
        `36px default size for wp.blockEditor.__experimentalLetterSpacingControl`,
        {
          since: "6.8",
          version: "7.1",
          hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
        }
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime253.jsx)(
      import_components121.__experimentalUnitControl,
      {
        __next40pxDefaultSize,
        __shouldNotWarnDeprecated36pxSize: true,
        ...otherProps,
        label: (0, import_i18n114.__)("Letter spacing"),
        value,
        __unstableInputWidth,
        units: units2,
        onChange
      }
    );
  }

  // packages/block-editor/build-module/components/text-alignment-control/index.js
  var import_jsx_runtime254 = __toESM(require_jsx_runtime());
  var import_i18n115 = __toESM(require_i18n());
  var import_element132 = __toESM(require_element());
  var import_components122 = __toESM(require_components());
  var TEXT_ALIGNMENT_OPTIONS = [
    {
      label: (0, import_i18n115.__)("Align text left"),
      value: "left",
      icon: align_left_default
    },
    {
      label: (0, import_i18n115.__)("Align text center"),
      value: "center",
      icon: align_center_default
    },
    {
      label: (0, import_i18n115.__)("Align text right"),
      value: "right",
      icon: align_right_default
    },
    {
      label: (0, import_i18n115.__)("Justify text"),
      value: "justify",
      icon: align_justify_default
    }
  ];
  var DEFAULT_OPTIONS = ["left", "center", "right"];
  function TextAlignmentControl({
    className,
    value,
    onChange,
    options = DEFAULT_OPTIONS
  }) {
    const validOptions = (0, import_element132.useMemo)(
      () => TEXT_ALIGNMENT_OPTIONS.filter(
        (option) => options.includes(option.value)
      ),
      [options]
    );
    if (!validOptions.length) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime254.jsx)(
      import_components122.__experimentalToggleGroupControl,
      {
        isDeselectable: true,
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: true,
        label: (0, import_i18n115.__)("Text alignment"),
        className: clsx_default(
          "block-editor-text-alignment-control",
          className
        ),
        value,
        onChange: (newValue) => {
          onChange(newValue === value ? void 0 : newValue);
        },
        children: validOptions.map((option) => {
          return /* @__PURE__ */ (0, import_jsx_runtime254.jsx)(
            import_components122.__experimentalToggleGroupControlOptionIcon,
            {
              value: option.value,
              icon: option.icon,
              label: option.label
            },
            option.value
          );
        })
      }
    );
  }

  // packages/block-editor/build-module/components/text-transform-control/index.js
  var import_jsx_runtime255 = __toESM(require_jsx_runtime());
  var import_i18n116 = __toESM(require_i18n());
  var import_components123 = __toESM(require_components());
  var TEXT_TRANSFORMS = [
    {
      label: (0, import_i18n116.__)("None"),
      value: "none",
      icon: reset_default
    },
    {
      label: (0, import_i18n116.__)("Uppercase"),
      value: "uppercase",
      icon: format_uppercase_default
    },
    {
      label: (0, import_i18n116.__)("Lowercase"),
      value: "lowercase",
      icon: format_lowercase_default
    },
    {
      label: (0, import_i18n116.__)("Capitalize"),
      value: "capitalize",
      icon: format_capitalize_default
    }
  ];
  function TextTransformControl({ className, value, onChange }) {
    return /* @__PURE__ */ (0, import_jsx_runtime255.jsx)(
      import_components123.__experimentalToggleGroupControl,
      {
        isDeselectable: true,
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: true,
        label: (0, import_i18n116.__)("Letter case"),
        className: clsx_default(
          "block-editor-text-transform-control",
          className
        ),
        value,
        onChange: (newValue) => {
          onChange(newValue === value ? void 0 : newValue);
        },
        children: TEXT_TRANSFORMS.map((option) => {
          return /* @__PURE__ */ (0, import_jsx_runtime255.jsx)(
            import_components123.__experimentalToggleGroupControlOptionIcon,
            {
              value: option.value,
              icon: option.icon,
              label: option.label
            },
            option.value
          );
        })
      }
    );
  }

  // packages/block-editor/build-module/components/text-decoration-control/index.js
  var import_jsx_runtime256 = __toESM(require_jsx_runtime());
  var import_i18n117 = __toESM(require_i18n());
  var import_components124 = __toESM(require_components());
  var TEXT_DECORATIONS = [
    {
      label: (0, import_i18n117.__)("None"),
      value: "none",
      icon: reset_default
    },
    {
      label: (0, import_i18n117.__)("Underline"),
      value: "underline",
      icon: format_underline_default
    },
    {
      label: (0, import_i18n117.__)("Strikethrough"),
      value: "line-through",
      icon: format_strikethrough_default
    }
  ];
  function TextDecorationControl({
    value,
    onChange,
    className
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime256.jsx)(
      import_components124.__experimentalToggleGroupControl,
      {
        isDeselectable: true,
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: true,
        label: (0, import_i18n117.__)("Decoration"),
        className: clsx_default(
          "block-editor-text-decoration-control",
          className
        ),
        value,
        onChange: (newValue) => {
          onChange(newValue === value ? void 0 : newValue);
        },
        children: TEXT_DECORATIONS.map((option) => {
          return /* @__PURE__ */ (0, import_jsx_runtime256.jsx)(
            import_components124.__experimentalToggleGroupControlOptionIcon,
            {
              value: option.value,
              icon: option.icon,
              label: option.label
            },
            option.value
          );
        })
      }
    );
  }

  // packages/block-editor/build-module/components/writing-mode-control/index.js
  var import_jsx_runtime257 = __toESM(require_jsx_runtime());
  var import_i18n118 = __toESM(require_i18n());
  var import_components125 = __toESM(require_components());
  var WRITING_MODES = [
    {
      label: (0, import_i18n118.__)("Horizontal"),
      value: "horizontal-tb",
      icon: text_horizontal_default
    },
    {
      label: (0, import_i18n118.__)("Vertical"),
      value: (0, import_i18n118.isRTL)() ? "vertical-lr" : "vertical-rl",
      icon: text_vertical_default
    }
  ];
  function WritingModeControl({ className, value, onChange }) {
    return /* @__PURE__ */ (0, import_jsx_runtime257.jsx)(
      import_components125.__experimentalToggleGroupControl,
      {
        isDeselectable: true,
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: true,
        label: (0, import_i18n118.__)("Orientation"),
        className: clsx_default("block-editor-writing-mode-control", className),
        value,
        onChange: (newValue) => {
          onChange(newValue === value ? void 0 : newValue);
        },
        children: WRITING_MODES.map((option) => {
          return /* @__PURE__ */ (0, import_jsx_runtime257.jsx)(
            import_components125.__experimentalToggleGroupControlOptionIcon,
            {
              value: option.value,
              icon: option.icon,
              label: option.label
            },
            option.value
          );
        })
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/typography-panel.js
  var MIN_TEXT_COLUMNS = 1;
  var MAX_TEXT_COLUMNS = 6;
  function useHasTypographyPanel(settings2) {
    const hasFontFamily = useHasFontFamilyControl(settings2);
    const hasLineHeight = useHasLineHeightControl(settings2);
    const hasFontAppearance = useHasAppearanceControl(settings2);
    const hasLetterSpacing = useHasLetterSpacingControl(settings2);
    const hasTextAlign = useHasTextAlignmentControl(settings2);
    const hasTextTransform = useHasTextTransformControl(settings2);
    const hasTextDecoration = useHasTextDecorationControl(settings2);
    const hasWritingMode = useHasWritingModeControl(settings2);
    const hasTextColumns = useHasTextColumnsControl(settings2);
    const hasFontSize = useHasFontSizeControl(settings2);
    return hasFontFamily || hasLineHeight || hasFontAppearance || hasLetterSpacing || hasTextAlign || hasTextTransform || hasFontSize || hasTextDecoration || hasWritingMode || hasTextColumns;
  }
  function useHasFontSizeControl(settings2) {
    return settings2?.typography?.defaultFontSizes !== false && settings2?.typography?.fontSizes?.default?.length || settings2?.typography?.fontSizes?.theme?.length || settings2?.typography?.fontSizes?.custom?.length || settings2?.typography?.customFontSize;
  }
  function useHasFontFamilyControl(settings2) {
    return ["default", "theme", "custom"].some(
      (key) => settings2?.typography?.fontFamilies?.[key]?.length
    );
  }
  function useHasLineHeightControl(settings2) {
    return settings2?.typography?.lineHeight;
  }
  function useHasAppearanceControl(settings2) {
    return settings2?.typography?.fontStyle || settings2?.typography?.fontWeight;
  }
  function useAppearanceControlLabel(settings2) {
    if (!settings2?.typography?.fontStyle) {
      return (0, import_i18n119.__)("Font weight");
    }
    if (!settings2?.typography?.fontWeight) {
      return (0, import_i18n119.__)("Font style");
    }
    return (0, import_i18n119.__)("Appearance");
  }
  function useHasLetterSpacingControl(settings2) {
    return settings2?.typography?.letterSpacing;
  }
  function useHasTextTransformControl(settings2) {
    return settings2?.typography?.textTransform;
  }
  function useHasTextAlignmentControl(settings2) {
    return settings2?.typography?.textAlign;
  }
  function useHasTextDecorationControl(settings2) {
    return settings2?.typography?.textDecoration;
  }
  function useHasWritingModeControl(settings2) {
    return settings2?.typography?.writingMode;
  }
  function useHasTextColumnsControl(settings2) {
    return settings2?.typography?.textColumns;
  }
  function getMergedFontSizes(settings2) {
    const fontSizes = settings2?.typography?.fontSizes;
    const defaultFontSizesEnabled = !!settings2?.typography?.defaultFontSizes;
    return [
      ...fontSizes?.custom ?? [],
      ...fontSizes?.theme ?? [],
      ...defaultFontSizesEnabled ? fontSizes?.default ?? [] : []
    ];
  }
  function TypographyToolsPanel({
    resetAllFilter,
    onChange,
    value,
    panelId,
    children
  }) {
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const resetAll = () => {
      const updatedValue = resetAllFilter(value);
      onChange(updatedValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
      import_components126.__experimentalToolsPanel,
      {
        label: (0, import_i18n119.__)("Typography"),
        resetAll,
        panelId,
        dropdownMenuProps,
        children
      }
    );
  }
  var DEFAULT_CONTROLS3 = {
    fontFamily: true,
    fontSize: true,
    fontAppearance: true,
    lineHeight: true,
    letterSpacing: true,
    textAlign: true,
    textTransform: true,
    textDecoration: true,
    writingMode: true,
    textColumns: true
  };
  function TypographyPanel({
    as: Wrapper = TypographyToolsPanel,
    value,
    onChange,
    inheritedValue = value,
    settings: settings2,
    panelId,
    defaultControls = DEFAULT_CONTROLS3
  }) {
    const decodeValue = (rawValue) => getValueFromVariable({ settings: settings2 }, "", rawValue);
    const hasFontFamilyEnabled = useHasFontFamilyControl(settings2);
    const fontFamily = decodeValue(inheritedValue?.typography?.fontFamily);
    const { fontFamilies, fontFamilyFaces } = (0, import_element133.useMemo)(() => {
      return getMergedFontFamiliesAndFontFamilyFaces(settings2, fontFamily);
    }, [settings2, fontFamily]);
    const setFontFamily = (newValue) => {
      const slug = fontFamilies?.find(
        ({ fontFamily: f2 }) => f2 === newValue
      )?.slug;
      onChange(
        setImmutably(
          value,
          ["typography", "fontFamily"],
          slug ? `var:preset|font-family|${slug}` : newValue || void 0
        )
      );
    };
    const hasFontFamily = () => !!value?.typography?.fontFamily;
    const resetFontFamily = () => setFontFamily(void 0);
    const hasFontSizeEnabled = useHasFontSizeControl(settings2);
    const disableCustomFontSizes = !settings2?.typography?.customFontSize;
    const mergedFontSizes = getMergedFontSizes(settings2);
    const fontSize = decodeValue(inheritedValue?.typography?.fontSize);
    const setFontSize = (newValue, metadata) => {
      const actualValue = !!metadata?.slug ? `var:preset|font-size|${metadata?.slug}` : newValue;
      onChange(
        setImmutably(
          value,
          ["typography", "fontSize"],
          actualValue || void 0
        )
      );
    };
    const hasFontSize = () => !!value?.typography?.fontSize;
    const resetFontSize = () => setFontSize(void 0);
    const hasAppearanceControl = useHasAppearanceControl(settings2);
    const appearanceControlLabel = useAppearanceControlLabel(settings2);
    const hasFontStyles = settings2?.typography?.fontStyle;
    const hasFontWeights = settings2?.typography?.fontWeight;
    const fontStyle = decodeValue(inheritedValue?.typography?.fontStyle);
    const fontWeight = decodeValue(inheritedValue?.typography?.fontWeight);
    const { nearestFontStyle, nearestFontWeight } = findNearestStyleAndWeight(
      fontFamilyFaces,
      fontStyle,
      fontWeight
    );
    const setFontAppearance = (0, import_element133.useCallback)(
      ({ fontStyle: newFontStyle, fontWeight: newFontWeight }) => {
        if (newFontStyle !== fontStyle || newFontWeight !== fontWeight) {
          onChange({
            ...value,
            typography: {
              ...value?.typography,
              fontStyle: newFontStyle || void 0,
              fontWeight: newFontWeight || void 0
            }
          });
        }
      },
      [fontStyle, fontWeight, onChange, value]
    );
    const hasFontAppearance = () => !!value?.typography?.fontStyle || !!value?.typography?.fontWeight;
    const resetFontAppearance = (0, import_element133.useCallback)(() => {
      setFontAppearance({});
    }, [setFontAppearance]);
    (0, import_element133.useEffect)(() => {
      if (nearestFontStyle && nearestFontWeight) {
        setFontAppearance({
          fontStyle: nearestFontStyle,
          fontWeight: nearestFontWeight
        });
      } else {
        resetFontAppearance();
      }
    }, [
      nearestFontStyle,
      nearestFontWeight,
      resetFontAppearance,
      setFontAppearance
    ]);
    const hasLineHeightEnabled = useHasLineHeightControl(settings2);
    const lineHeight = decodeValue(inheritedValue?.typography?.lineHeight);
    const setLineHeight = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["typography", "lineHeight"],
          newValue || void 0
        )
      );
    };
    const hasLineHeight = () => value?.typography?.lineHeight !== void 0;
    const resetLineHeight = () => setLineHeight(void 0);
    const hasLetterSpacingControl = useHasLetterSpacingControl(settings2);
    const letterSpacing = decodeValue(
      inheritedValue?.typography?.letterSpacing
    );
    const setLetterSpacing = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["typography", "letterSpacing"],
          newValue || void 0
        )
      );
    };
    const hasLetterSpacing = () => !!value?.typography?.letterSpacing;
    const resetLetterSpacing = () => setLetterSpacing(void 0);
    const hasTextColumnsControl = useHasTextColumnsControl(settings2);
    const textColumns = decodeValue(inheritedValue?.typography?.textColumns);
    const setTextColumns = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["typography", "textColumns"],
          newValue || void 0
        )
      );
    };
    const hasTextColumns = () => !!value?.typography?.textColumns;
    const resetTextColumns = () => setTextColumns(void 0);
    const hasTextTransformControl = useHasTextTransformControl(settings2);
    const textTransform = decodeValue(
      inheritedValue?.typography?.textTransform
    );
    const setTextTransform = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["typography", "textTransform"],
          newValue || void 0
        )
      );
    };
    const hasTextTransform = () => !!value?.typography?.textTransform;
    const resetTextTransform = () => setTextTransform(void 0);
    const hasTextDecorationControl = useHasTextDecorationControl(settings2);
    const textDecoration = decodeValue(
      inheritedValue?.typography?.textDecoration
    );
    const setTextDecoration = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["typography", "textDecoration"],
          newValue || void 0
        )
      );
    };
    const hasTextDecoration = () => !!value?.typography?.textDecoration;
    const resetTextDecoration = () => setTextDecoration(void 0);
    const hasWritingModeControl = useHasWritingModeControl(settings2);
    const writingMode = decodeValue(inheritedValue?.typography?.writingMode);
    const setWritingMode = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["typography", "writingMode"],
          newValue || void 0
        )
      );
    };
    const hasWritingMode = () => !!value?.typography?.writingMode;
    const resetWritingMode = () => setWritingMode(void 0);
    const hasTextAlignmentControl = useHasTextAlignmentControl(settings2);
    const textAlign = decodeValue(inheritedValue?.typography?.textAlign);
    const setTextAlign = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["typography", "textAlign"],
          newValue || void 0
        )
      );
    };
    const hasTextAlign = () => !!value?.typography?.textAlign;
    const resetTextAlign = () => setTextAlign(void 0);
    const resetAllFilter = (0, import_element133.useCallback)((previousValue) => {
      return {
        ...previousValue,
        typography: {}
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime258.jsxs)(
      Wrapper,
      {
        resetAllFilter,
        value,
        onChange,
        panelId,
        children: [
          hasFontFamilyEnabled && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              label: (0, import_i18n119.__)("Font"),
              hasValue: hasFontFamily,
              onDeselect: resetFontFamily,
              isShownByDefault: defaultControls.fontFamily,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                FontFamilyControl,
                {
                  fontFamilies,
                  value: fontFamily,
                  onChange: setFontFamily,
                  size: "__unstable-large",
                  __nextHasNoMarginBottom: true
                }
              )
            }
          ),
          hasFontSizeEnabled && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              label: (0, import_i18n119.__)("Size"),
              hasValue: hasFontSize,
              onDeselect: resetFontSize,
              isShownByDefault: defaultControls.fontSize,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                import_components126.FontSizePicker,
                {
                  value: fontSize,
                  onChange: setFontSize,
                  fontSizes: mergedFontSizes,
                  disableCustomFontSizes,
                  withReset: false,
                  withSlider: true,
                  size: "__unstable-large"
                }
              )
            }
          ),
          hasAppearanceControl && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              className: "single-column",
              label: appearanceControlLabel,
              hasValue: hasFontAppearance,
              onDeselect: resetFontAppearance,
              isShownByDefault: defaultControls.fontAppearance,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                FontAppearanceControl,
                {
                  value: {
                    fontStyle,
                    fontWeight
                  },
                  onChange: setFontAppearance,
                  hasFontStyles,
                  hasFontWeights,
                  fontFamilyFaces,
                  size: "__unstable-large"
                }
              )
            }
          ),
          hasLineHeightEnabled && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              className: "single-column",
              label: (0, import_i18n119.__)("Line height"),
              hasValue: hasLineHeight,
              onDeselect: resetLineHeight,
              isShownByDefault: defaultControls.lineHeight,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                line_height_control_default,
                {
                  __unstableInputWidth: "auto",
                  value: lineHeight,
                  onChange: setLineHeight,
                  size: "__unstable-large"
                }
              )
            }
          ),
          hasLetterSpacingControl && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              className: "single-column",
              label: (0, import_i18n119.__)("Letter spacing"),
              hasValue: hasLetterSpacing,
              onDeselect: resetLetterSpacing,
              isShownByDefault: defaultControls.letterSpacing,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                LetterSpacingControl,
                {
                  value: letterSpacing,
                  onChange: setLetterSpacing,
                  size: "__unstable-large",
                  __unstableInputWidth: "auto"
                }
              )
            }
          ),
          hasTextColumnsControl && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              className: "single-column",
              label: (0, import_i18n119.__)("Columns"),
              hasValue: hasTextColumns,
              onDeselect: resetTextColumns,
              isShownByDefault: defaultControls.textColumns,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                import_components126.__experimentalNumberControl,
                {
                  label: (0, import_i18n119.__)("Columns"),
                  max: MAX_TEXT_COLUMNS,
                  min: MIN_TEXT_COLUMNS,
                  onChange: setTextColumns,
                  size: "__unstable-large",
                  spinControls: "custom",
                  value: textColumns,
                  initialPosition: 1
                }
              )
            }
          ),
          hasTextDecorationControl && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              className: "single-column",
              label: (0, import_i18n119.__)("Decoration"),
              hasValue: hasTextDecoration,
              onDeselect: resetTextDecoration,
              isShownByDefault: defaultControls.textDecoration,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                TextDecorationControl,
                {
                  value: textDecoration,
                  onChange: setTextDecoration,
                  size: "__unstable-large",
                  __unstableInputWidth: "auto"
                }
              )
            }
          ),
          hasWritingModeControl && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              className: "single-column",
              label: (0, import_i18n119.__)("Orientation"),
              hasValue: hasWritingMode,
              onDeselect: resetWritingMode,
              isShownByDefault: defaultControls.writingMode,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                WritingModeControl,
                {
                  value: writingMode,
                  onChange: setWritingMode,
                  size: "__unstable-large",
                  __nextHasNoMarginBottom: true
                }
              )
            }
          ),
          hasTextTransformControl && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              label: (0, import_i18n119.__)("Letter case"),
              hasValue: hasTextTransform,
              onDeselect: resetTextTransform,
              isShownByDefault: defaultControls.textTransform,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                TextTransformControl,
                {
                  value: textTransform,
                  onChange: setTextTransform,
                  showNone: true,
                  isBlock: true,
                  size: "__unstable-large",
                  __nextHasNoMarginBottom: true
                }
              )
            }
          ),
          hasTextAlignmentControl && /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
            import_components126.__experimentalToolsPanelItem,
            {
              label: (0, import_i18n119.__)("Text alignment"),
              hasValue: hasTextAlign,
              onDeselect: resetTextAlign,
              isShownByDefault: defaultControls.textAlign,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime258.jsx)(
                TextAlignmentControl,
                {
                  value: textAlign,
                  onChange: setTextAlign,
                  size: "__unstable-large",
                  __nextHasNoMarginBottom: true
                }
              )
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/dimensions-panel.js
  var import_jsx_runtime268 = __toESM(require_jsx_runtime());
  var import_i18n127 = __toESM(require_i18n());
  var import_components133 = __toESM(require_components());
  var import_element139 = __toESM(require_element());

  // packages/block-editor/build-module/components/spacing-sizes-control/index.js
  var import_jsx_runtime264 = __toESM(require_jsx_runtime());
  var import_components129 = __toESM(require_components());
  var import_element136 = __toESM(require_element());
  var import_i18n123 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/spacing-sizes-control/hooks/use-spacing-sizes.js
  var import_element134 = __toESM(require_element());
  var import_i18n120 = __toESM(require_i18n());
  var EMPTY_ARRAY9 = [];
  var compare = new Intl.Collator("und", { numeric: true }).compare;
  function useSpacingSizes() {
    const [
      customSpacingSizes,
      themeSpacingSizes,
      defaultSpacingSizes,
      defaultSpacingSizesEnabled
    ] = useSettings(
      "spacing.spacingSizes.custom",
      "spacing.spacingSizes.theme",
      "spacing.spacingSizes.default",
      "spacing.defaultSpacingSizes"
    );
    const customSizes = customSpacingSizes ?? EMPTY_ARRAY9;
    const themeSizes = themeSpacingSizes ?? EMPTY_ARRAY9;
    const defaultSizes = defaultSpacingSizes && defaultSpacingSizesEnabled !== false ? defaultSpacingSizes : EMPTY_ARRAY9;
    return (0, import_element134.useMemo)(() => {
      const sizes = [
        { name: (0, import_i18n120.__)("None"), slug: "0", size: 0 },
        ...customSizes,
        ...themeSizes,
        ...defaultSizes
      ];
      if (sizes.every(({ slug }) => /^[0-9]/.test(slug))) {
        sizes.sort((a2, b2) => compare(a2.slug, b2.slug));
      }
      return sizes.length > RANGE_CONTROL_MAX_SIZE ? [
        {
          name: (0, import_i18n120.__)("Default"),
          slug: "default",
          size: void 0
        },
        ...sizes
      ] : sizes;
    }, [customSizes, themeSizes, defaultSizes]);
  }

  // packages/block-editor/build-module/components/spacing-sizes-control/input-controls/axial.js
  var import_jsx_runtime260 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/spacing-sizes-control/input-controls/spacing-input-control.js
  var import_jsx_runtime259 = __toESM(require_jsx_runtime());
  var import_components127 = __toESM(require_components());
  var import_data116 = __toESM(require_data());
  var import_element135 = __toESM(require_element());
  var import_compose68 = __toESM(require_compose());
  var import_i18n121 = __toESM(require_i18n());
  var CUSTOM_VALUE_SETTINGS = {
    px: { max: 300, steps: 1 },
    "%": { max: 100, steps: 1 },
    vw: { max: 100, steps: 1 },
    vh: { max: 100, steps: 1 },
    em: { max: 10, steps: 0.1 },
    rm: { max: 10, steps: 0.1 },
    svw: { max: 100, steps: 1 },
    lvw: { max: 100, steps: 1 },
    dvw: { max: 100, steps: 1 },
    svh: { max: 100, steps: 1 },
    lvh: { max: 100, steps: 1 },
    dvh: { max: 100, steps: 1 },
    vi: { max: 100, steps: 1 },
    svi: { max: 100, steps: 1 },
    lvi: { max: 100, steps: 1 },
    dvi: { max: 100, steps: 1 },
    vb: { max: 100, steps: 1 },
    svb: { max: 100, steps: 1 },
    lvb: { max: 100, steps: 1 },
    dvb: { max: 100, steps: 1 },
    vmin: { max: 100, steps: 1 },
    svmin: { max: 100, steps: 1 },
    lvmin: { max: 100, steps: 1 },
    dvmin: { max: 100, steps: 1 },
    vmax: { max: 100, steps: 1 },
    svmax: { max: 100, steps: 1 },
    lvmax: { max: 100, steps: 1 },
    dvmax: { max: 100, steps: 1 }
  };
  function SpacingInputControl({
    icon,
    isMixed = false,
    minimumCustomValue,
    onChange,
    onMouseOut,
    onMouseOver,
    showSideInLabel = true,
    side,
    spacingSizes,
    type,
    value
  }) {
    value = getPresetValueFromCustomValue(value, spacingSizes);
    let selectListSizes = spacingSizes;
    const showRangeControl = spacingSizes.length <= RANGE_CONTROL_MAX_SIZE;
    const disableCustomSpacingSizes = (0, import_data116.useSelect)((select2) => {
      const editorSettings = select2(store).getSettings();
      return editorSettings?.disableCustomSpacingSizes;
    });
    const [showCustomValueControl, setShowCustomValueControl] = (0, import_element135.useState)(
      !disableCustomSpacingSizes && value !== void 0 && !isValueSpacingPreset(value)
    );
    const [minValue, setMinValue] = (0, import_element135.useState)(minimumCustomValue);
    const previousValue = (0, import_compose68.usePrevious)(value);
    if (!!value && previousValue !== value && !isValueSpacingPreset(value) && showCustomValueControl !== true) {
      setShowCustomValueControl(true);
    }
    const [availableUnits] = useSettings("spacing.units");
    const units2 = (0, import_components127.__experimentalUseCustomUnits)({
      availableUnits: availableUnits || ["px", "em", "rem"]
    });
    let currentValue = null;
    const showCustomValueInSelectList = !showRangeControl && !showCustomValueControl && value !== void 0 && (!isValueSpacingPreset(value) || isValueSpacingPreset(value) && isMixed);
    if (showCustomValueInSelectList) {
      selectListSizes = [
        ...spacingSizes,
        {
          name: !isMixed ? (
            // translators: %s: A custom measurement, e.g. a number followed by a unit like 12px.
            (0, import_i18n121.sprintf)((0, import_i18n121.__)("Custom (%s)"), value)
          ) : (0, import_i18n121.__)("Mixed"),
          slug: "custom",
          size: value
        }
      ];
      currentValue = selectListSizes.length - 1;
    } else if (!isMixed) {
      currentValue = !showCustomValueControl ? getSliderValueFromPreset(value, spacingSizes) : getCustomValueFromPreset(value, spacingSizes);
    }
    const selectedUnit = (0, import_element135.useMemo)(
      () => (0, import_components127.__experimentalParseQuantityAndUnitFromRawValue)(currentValue),
      [currentValue]
    )[1] || units2[0]?.value;
    const setInitialValue = () => {
      if (value === void 0) {
        onChange("0");
      }
    };
    const customTooltipContent = (newValue) => value === void 0 ? void 0 : spacingSizes[newValue]?.name;
    const customRangeValue = parseFloat(currentValue, 10);
    const getNewCustomValue = (newSize) => {
      const isNumeric = !isNaN(parseFloat(newSize));
      const nextValue = isNumeric ? newSize : void 0;
      return nextValue;
    };
    const getNewPresetValue = (newSize, controlType) => {
      const size = parseInt(newSize, 10);
      if (controlType === "selectList") {
        if (size === 0) {
          return void 0;
        }
        if (size === 1) {
          return "0";
        }
      } else if (size === 0) {
        return "0";
      }
      return `var:preset|spacing|${spacingSizes[newSize]?.slug}`;
    };
    const handleCustomValueSliderChange = (next2) => {
      onChange([next2, selectedUnit].join(""));
    };
    const allPlaceholder = isMixed ? (0, import_i18n121.__)("Mixed") : null;
    const options = selectListSizes.map((size, index) => ({
      key: index,
      name: size.name
    }));
    const marks = spacingSizes.slice(1, spacingSizes.length - 1).map((_newValue, index) => ({
      value: index + 1,
      label: void 0
    }));
    const sideLabel = ALL_SIDES.includes(side) && showSideInLabel ? LABELS[side] : "";
    const typeLabel = showSideInLabel ? type?.toLowerCase() : type;
    const ariaLabel = (0, import_i18n121.sprintf)(
      // translators: 1: The side of the block being modified (top, bottom, left etc.). 2. Type of spacing being modified (padding, margin, etc).
      (0, import_i18n121._x)("%1$s %2$s", "spacing"),
      sideLabel,
      typeLabel
    ).trim();
    return /* @__PURE__ */ (0, import_jsx_runtime259.jsxs)(import_components127.__experimentalHStack, { className: "spacing-sizes-control__wrapper", children: [
      icon && /* @__PURE__ */ (0, import_jsx_runtime259.jsx)(
        import_components127.Icon,
        {
          className: "spacing-sizes-control__icon",
          icon,
          size: 24
        }
      ),
      showCustomValueControl && /* @__PURE__ */ (0, import_jsx_runtime259.jsxs)(import_jsx_runtime259.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime259.jsx)(
          import_components127.__experimentalUnitControl,
          {
            onMouseOver,
            onMouseOut,
            onFocus: onMouseOver,
            onBlur: onMouseOut,
            onChange: (newSize) => onChange(getNewCustomValue(newSize)),
            value: currentValue,
            units: units2,
            min: minValue,
            placeholder: allPlaceholder,
            disableUnits: isMixed,
            label: ariaLabel,
            hideLabelFromVision: true,
            className: "spacing-sizes-control__custom-value-input",
            size: "__unstable-large",
            onDragStart: () => {
              if (value?.charAt(0) === "-") {
                setMinValue(0);
              }
            },
            onDrag: () => {
              if (value?.charAt(0) === "-") {
                setMinValue(0);
              }
            },
            onDragEnd: () => {
              setMinValue(minimumCustomValue);
            }
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime259.jsx)(
          import_components127.RangeControl,
          {
            __next40pxDefaultSize: true,
            onMouseOver,
            onMouseOut,
            onFocus: onMouseOver,
            onBlur: onMouseOut,
            value: customRangeValue,
            min: 0,
            max: CUSTOM_VALUE_SETTINGS[selectedUnit]?.max ?? 10,
            step: CUSTOM_VALUE_SETTINGS[selectedUnit]?.steps ?? 0.1,
            withInputField: false,
            onChange: handleCustomValueSliderChange,
            className: "spacing-sizes-control__custom-value-range",
            __nextHasNoMarginBottom: true,
            label: ariaLabel,
            hideLabelFromVision: true
          }
        )
      ] }),
      showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0, import_jsx_runtime259.jsx)(
        import_components127.RangeControl,
        {
          __next40pxDefaultSize: true,
          onMouseOver,
          onMouseOut,
          className: "spacing-sizes-control__range-control",
          value: currentValue,
          onChange: (newSize) => onChange(getNewPresetValue(newSize)),
          onMouseDown: (event) => {
            if (event?.nativeEvent?.offsetX < 35) {
              setInitialValue();
            }
          },
          withInputField: false,
          "aria-valuenow": currentValue,
          "aria-valuetext": spacingSizes[currentValue]?.name,
          renderTooltipContent: customTooltipContent,
          min: 0,
          max: spacingSizes.length - 1,
          marks,
          label: ariaLabel,
          hideLabelFromVision: true,
          __nextHasNoMarginBottom: true,
          onFocus: onMouseOver,
          onBlur: onMouseOut
        }
      ),
      !showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0, import_jsx_runtime259.jsx)(
        import_components127.CustomSelectControl,
        {
          className: "spacing-sizes-control__custom-select-control",
          value: (
            // passing empty string as a fallback to continue using the
            // component in controlled mode
            options.find(
              (option) => option.key === currentValue
            ) || ""
          ),
          onChange: (selection2) => {
            onChange(
              getNewPresetValue(
                selection2.selectedItem.key,
                "selectList"
              )
            );
          },
          options,
          label: ariaLabel,
          hideLabelFromVision: true,
          size: "__unstable-large",
          onMouseOver,
          onMouseOut,
          onFocus: onMouseOver,
          onBlur: onMouseOut
        }
      ),
      !disableCustomSpacingSizes && /* @__PURE__ */ (0, import_jsx_runtime259.jsx)(
        import_components127.Button,
        {
          label: showCustomValueControl ? (0, import_i18n121.__)("Use size preset") : (0, import_i18n121.__)("Set custom size"),
          icon: settings_default,
          onClick: () => {
            setShowCustomValueControl(!showCustomValueControl);
          },
          isPressed: showCustomValueControl,
          size: "small",
          className: "spacing-sizes-control__custom-toggle",
          iconSize: 24
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/spacing-sizes-control/input-controls/axial.js
  var groupedSides = ["vertical", "horizontal"];
  function AxialInputControls({
    minimumCustomValue,
    onChange,
    onMouseOut,
    onMouseOver,
    sides,
    spacingSizes,
    type,
    values
  }) {
    const createHandleOnChange = (side) => (next2) => {
      if (!onChange) {
        return;
      }
      const nextValues = {
        ...Object.keys(values).reduce((acc, key) => {
          acc[key] = getPresetValueFromCustomValue(
            values[key],
            spacingSizes
          );
          return acc;
        }, {})
      };
      if (side === "vertical") {
        nextValues.top = next2;
        nextValues.bottom = next2;
      }
      if (side === "horizontal") {
        nextValues.left = next2;
        nextValues.right = next2;
      }
      onChange(nextValues);
    };
    const filteredSides = sides?.length ? groupedSides.filter((side) => hasAxisSupport(sides, side)) : groupedSides;
    return /* @__PURE__ */ (0, import_jsx_runtime260.jsx)(import_jsx_runtime260.Fragment, { children: filteredSides.map((side) => {
      const axisValue = side === "vertical" ? values.top : values.left;
      return /* @__PURE__ */ (0, import_jsx_runtime260.jsx)(
        SpacingInputControl,
        {
          icon: ICONS[side],
          label: LABELS[side],
          minimumCustomValue,
          onChange: createHandleOnChange(side),
          onMouseOut,
          onMouseOver,
          side,
          spacingSizes,
          type,
          value: axisValue,
          withInputField: false
        },
        `spacing-sizes-control-${side}`
      );
    }) });
  }

  // packages/block-editor/build-module/components/spacing-sizes-control/input-controls/separated.js
  var import_jsx_runtime261 = __toESM(require_jsx_runtime());
  function SeparatedInputControls({
    minimumCustomValue,
    onChange,
    onMouseOut,
    onMouseOver,
    sides,
    spacingSizes,
    type,
    values
  }) {
    const filteredSides = sides?.length ? ALL_SIDES.filter((side) => sides.includes(side)) : ALL_SIDES;
    const createHandleOnChange = (side) => (next2) => {
      const nextValues = {
        ...Object.keys(values).reduce((acc, key) => {
          acc[key] = getPresetValueFromCustomValue(
            values[key],
            spacingSizes
          );
          return acc;
        }, {})
      };
      nextValues[side] = next2;
      onChange(nextValues);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime261.jsx)(import_jsx_runtime261.Fragment, { children: filteredSides.map((side) => {
      return /* @__PURE__ */ (0, import_jsx_runtime261.jsx)(
        SpacingInputControl,
        {
          icon: ICONS[side],
          label: LABELS[side],
          minimumCustomValue,
          onChange: createHandleOnChange(side),
          onMouseOut,
          onMouseOver,
          side,
          spacingSizes,
          type,
          value: values[side],
          withInputField: false
        },
        `spacing-sizes-control-${side}`
      );
    }) });
  }

  // packages/block-editor/build-module/components/spacing-sizes-control/input-controls/single.js
  var import_jsx_runtime262 = __toESM(require_jsx_runtime());
  function SingleInputControl({
    minimumCustomValue,
    onChange,
    onMouseOut,
    onMouseOver,
    showSideInLabel,
    side,
    spacingSizes,
    type,
    values
  }) {
    const createHandleOnChange = (currentSide) => (next2) => {
      const nextValues = {
        ...Object.keys(values).reduce((acc, key) => {
          acc[key] = getPresetValueFromCustomValue(
            values[key],
            spacingSizes
          );
          return acc;
        }, {})
      };
      nextValues[currentSide] = next2;
      onChange(nextValues);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime262.jsx)(
      SpacingInputControl,
      {
        label: LABELS[side],
        minimumCustomValue,
        onChange: createHandleOnChange(side),
        onMouseOut,
        onMouseOver,
        showSideInLabel,
        side,
        spacingSizes,
        type,
        value: values[side],
        withInputField: false
      }
    );
  }

  // packages/block-editor/build-module/components/spacing-sizes-control/linked-button.js
  var import_jsx_runtime263 = __toESM(require_jsx_runtime());
  var import_components128 = __toESM(require_components());
  var import_i18n122 = __toESM(require_i18n());
  function LinkedButton({ isLinked, ...props }) {
    const label = isLinked ? (0, import_i18n122.__)("Unlink sides") : (0, import_i18n122.__)("Link sides");
    return /* @__PURE__ */ (0, import_jsx_runtime263.jsx)(
      import_components128.Button,
      {
        ...props,
        size: "small",
        icon: isLinked ? link_default : link_off_default,
        iconSize: 24,
        label
      }
    );
  }

  // packages/block-editor/build-module/components/spacing-sizes-control/index.js
  function SpacingSizesControl({
    inputProps,
    label: labelProp,
    minimumCustomValue = 0,
    onChange,
    onMouseOut,
    onMouseOver,
    showSideInLabel = true,
    sides = ALL_SIDES,
    useSelect: useSelect160,
    values
  }) {
    const spacingSizes = useSpacingSizes();
    const inputValues = values || DEFAULT_VALUES;
    const hasOneSide = sides?.length === 1;
    const hasOnlyAxialSides = sides?.includes("horizontal") && sides?.includes("vertical") && sides?.length === 2;
    const [view, setView] = (0, import_element136.useState)(getInitialView(inputValues, sides));
    const toggleLinked = () => {
      setView(view === VIEWS.axial ? VIEWS.custom : VIEWS.axial);
    };
    const handleOnChange = (nextValue) => {
      const newValues = { ...values, ...nextValue };
      onChange(newValues);
    };
    const inputControlProps = {
      ...inputProps,
      minimumCustomValue,
      onChange: handleOnChange,
      onMouseOut,
      onMouseOver,
      sides,
      spacingSizes,
      type: labelProp,
      useSelect: useSelect160,
      values: inputValues
    };
    const renderControls = () => {
      if (view === VIEWS.axial) {
        return /* @__PURE__ */ (0, import_jsx_runtime264.jsx)(AxialInputControls, { ...inputControlProps });
      }
      if (view === VIEWS.custom) {
        return /* @__PURE__ */ (0, import_jsx_runtime264.jsx)(SeparatedInputControls, { ...inputControlProps });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime264.jsx)(
        SingleInputControl,
        {
          side: view,
          ...inputControlProps,
          showSideInLabel
        }
      );
    };
    const sideLabel = ALL_SIDES.includes(view) && showSideInLabel ? LABELS[view] : "";
    const label = (0, import_i18n123.sprintf)(
      // translators: 1: The side of the block being modified (top, bottom, left etc.). 2. Type of spacing being modified (padding, margin, etc).
      (0, import_i18n123._x)("%1$s %2$s", "spacing"),
      labelProp,
      sideLabel
    ).trim();
    return /* @__PURE__ */ (0, import_jsx_runtime264.jsxs)("fieldset", { className: "spacing-sizes-control", children: [
      /* @__PURE__ */ (0, import_jsx_runtime264.jsxs)(import_components129.__experimentalHStack, { className: "spacing-sizes-control__header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime264.jsx)(
          import_components129.BaseControl.VisualLabel,
          {
            as: "legend",
            className: "spacing-sizes-control__label",
            children: label
          }
        ),
        !hasOneSide && !hasOnlyAxialSides && /* @__PURE__ */ (0, import_jsx_runtime264.jsx)(
          LinkedButton,
          {
            label: labelProp,
            onClick: toggleLinked,
            isLinked: view === VIEWS.axial
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime264.jsx)(import_components129.__experimentalVStack, { spacing: 0.5, children: renderControls() })
    ] });
  }

  // packages/block-editor/build-module/components/height-control/index.js
  var import_jsx_runtime265 = __toESM(require_jsx_runtime());
  var import_element137 = __toESM(require_element());
  var import_components130 = __toESM(require_components());
  var import_i18n124 = __toESM(require_i18n());
  var RANGE_CONTROL_CUSTOM_SETTINGS = {
    px: { max: 1e3, step: 1 },
    "%": { max: 100, step: 1 },
    vw: { max: 100, step: 1 },
    vh: { max: 100, step: 1 },
    em: { max: 50, step: 0.1 },
    rem: { max: 50, step: 0.1 },
    svw: { max: 100, step: 1 },
    lvw: { max: 100, step: 1 },
    dvw: { max: 100, step: 1 },
    svh: { max: 100, step: 1 },
    lvh: { max: 100, step: 1 },
    dvh: { max: 100, step: 1 },
    vi: { max: 100, step: 1 },
    svi: { max: 100, step: 1 },
    lvi: { max: 100, step: 1 },
    dvi: { max: 100, step: 1 },
    vb: { max: 100, step: 1 },
    svb: { max: 100, step: 1 },
    lvb: { max: 100, step: 1 },
    dvb: { max: 100, step: 1 },
    vmin: { max: 100, step: 1 },
    svmin: { max: 100, step: 1 },
    lvmin: { max: 100, step: 1 },
    dvmin: { max: 100, step: 1 },
    vmax: { max: 100, step: 1 },
    svmax: { max: 100, step: 1 },
    lvmax: { max: 100, step: 1 },
    dvmax: { max: 100, step: 1 }
  };
  function HeightControl({
    label = (0, import_i18n124.__)("Height"),
    onChange,
    value
  }) {
    const customRangeValue = parseFloat(value);
    const [availableUnits] = useSettings("spacing.units");
    const units2 = (0, import_components130.__experimentalUseCustomUnits)({
      availableUnits: availableUnits || [
        "%",
        "px",
        "em",
        "rem",
        "vh",
        "vw"
      ]
    });
    const selectedUnit = (0, import_element137.useMemo)(
      () => (0, import_components130.__experimentalParseQuantityAndUnitFromRawValue)(value),
      [value]
    )[1] || units2[0]?.value || "px";
    const handleSliderChange = (next2) => {
      onChange([next2, selectedUnit].join(""));
    };
    const handleUnitChange = (newUnit) => {
      const [currentValue, currentUnit] = (0, import_components130.__experimentalParseQuantityAndUnitFromRawValue)(value);
      if (["em", "rem"].includes(newUnit) && currentUnit === "px") {
        onChange((currentValue / 16).toFixed(2) + newUnit);
      } else if (["em", "rem"].includes(currentUnit) && newUnit === "px") {
        onChange(Math.round(currentValue * 16) + newUnit);
      } else if ([
        "%",
        "vw",
        "svw",
        "lvw",
        "dvw",
        "vh",
        "svh",
        "lvh",
        "dvh",
        "vi",
        "svi",
        "lvi",
        "dvi",
        "vb",
        "svb",
        "lvb",
        "dvb",
        "vmin",
        "svmin",
        "lvmin",
        "dvmin",
        "vmax",
        "svmax",
        "lvmax",
        "dvmax"
      ].includes(newUnit) && currentValue > 100) {
        onChange(100 + newUnit);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime265.jsxs)("fieldset", { className: "block-editor-height-control", children: [
      /* @__PURE__ */ (0, import_jsx_runtime265.jsx)(import_components130.BaseControl.VisualLabel, { as: "legend", children: label }),
      /* @__PURE__ */ (0, import_jsx_runtime265.jsxs)(import_components130.Flex, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime265.jsx)(import_components130.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0, import_jsx_runtime265.jsx)(
          import_components130.__experimentalUnitControl,
          {
            value,
            units: units2,
            onChange,
            onUnitChange: handleUnitChange,
            min: 0,
            size: "__unstable-large",
            label,
            hideLabelFromVision: true
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime265.jsx)(import_components130.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0, import_jsx_runtime265.jsx)(import_components130.__experimentalSpacer, { marginX: 2, marginBottom: 0, children: /* @__PURE__ */ (0, import_jsx_runtime265.jsx)(
          import_components130.RangeControl,
          {
            __next40pxDefaultSize: true,
            value: customRangeValue,
            min: 0,
            max: RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.max ?? 100,
            step: RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.step ?? 0.1,
            withInputField: false,
            onChange: handleSliderChange,
            __nextHasNoMarginBottom: true,
            label,
            hideLabelFromVision: true
          }
        ) }) })
      ] })
    ] });
  }

  // packages/block-editor/build-module/components/child-layout-control/index.js
  var import_jsx_runtime266 = __toESM(require_jsx_runtime());
  var import_components131 = __toESM(require_components());
  var import_i18n125 = __toESM(require_i18n());
  var import_element138 = __toESM(require_element());
  var import_data118 = __toESM(require_data());

  // packages/block-editor/build-module/components/grid/use-get-number-of-blocks-before-cell.js
  var import_data117 = __toESM(require_data());
  function useGetNumberOfBlocksBeforeCell(gridClientId, numColumns) {
    const { getBlockOrder: getBlockOrder2, getBlockAttributes: getBlockAttributes3 } = (0, import_data117.useSelect)(store);
    const getNumberOfBlocksBeforeCell = (column2, row) => {
      const targetIndex = (row - 1) * numColumns + column2 - 1;
      let count = 0;
      for (const clientId of getBlockOrder2(gridClientId)) {
        const { columnStart, rowStart } = getBlockAttributes3(clientId).style?.layout ?? {};
        const cellIndex = (rowStart - 1) * numColumns + columnStart - 1;
        if (cellIndex < targetIndex) {
          count++;
        }
      }
      return count;
    };
    return getNumberOfBlocksBeforeCell;
  }

  // packages/block-editor/build-module/components/child-layout-control/index.js
  function helpText(selfStretch, parentLayout) {
    const { orientation = "horizontal" } = parentLayout;
    if (selfStretch === "fill") {
      return (0, import_i18n125.__)("Stretch to fill available space.");
    }
    if (selfStretch === "fixed" && orientation === "horizontal") {
      return (0, import_i18n125.__)("Specify a fixed width.");
    } else if (selfStretch === "fixed") {
      return (0, import_i18n125.__)("Specify a fixed height.");
    }
    return (0, import_i18n125.__)("Fit contents.");
  }
  function ChildLayoutControl({
    value: childLayout = {},
    onChange,
    parentLayout,
    isShownByDefault,
    panelId
  }) {
    const {
      type: parentType,
      default: { type: defaultParentType = "default" } = {}
    } = parentLayout ?? {};
    const parentLayoutType = parentType || defaultParentType;
    if (parentLayoutType === "flex") {
      return /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
        FlexControls,
        {
          childLayout,
          onChange,
          parentLayout,
          isShownByDefault,
          panelId
        }
      );
    } else if (parentLayoutType === "grid") {
      return /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
        GridControls,
        {
          childLayout,
          onChange,
          parentLayout,
          isShownByDefault,
          panelId
        }
      );
    }
    return null;
  }
  function FlexControls({
    childLayout,
    onChange,
    parentLayout,
    isShownByDefault,
    panelId
  }) {
    const { selfStretch, flexSize } = childLayout;
    const { orientation = "horizontal" } = parentLayout ?? {};
    const hasFlexValue = () => !!selfStretch;
    const flexResetLabel = orientation === "horizontal" ? (0, import_i18n125.__)("Width") : (0, import_i18n125.__)("Height");
    const [availableUnits] = useSettings("spacing.units");
    const units2 = (0, import_components131.__experimentalUseCustomUnits)({
      availableUnits: availableUnits || [
        "%",
        "px",
        "em",
        "rem",
        "vh",
        "vw"
      ]
    });
    const resetFlex = () => {
      onChange({
        selfStretch: void 0,
        flexSize: void 0
      });
    };
    (0, import_element138.useEffect)(() => {
      if (selfStretch === "fixed" && !flexSize) {
        onChange({
          ...childLayout,
          selfStretch: "fit"
        });
      }
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime266.jsxs)(
      import_components131.__experimentalVStack,
      {
        as: import_components131.__experimentalToolsPanelItem,
        spacing: 2,
        hasValue: hasFlexValue,
        label: flexResetLabel,
        onDeselect: resetFlex,
        isShownByDefault,
        panelId,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime266.jsxs)(
            import_components131.__experimentalToggleGroupControl,
            {
              __nextHasNoMarginBottom: true,
              size: "__unstable-large",
              label: childLayoutOrientation(parentLayout),
              value: selfStretch || "fit",
              help: helpText(selfStretch, parentLayout),
              onChange: (value) => {
                const newFlexSize = value !== "fixed" ? null : flexSize;
                onChange({
                  selfStretch: value,
                  flexSize: newFlexSize
                });
              },
              isBlock: true,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
                  import_components131.__experimentalToggleGroupControlOption,
                  {
                    value: "fit",
                    label: (0, import_i18n125._x)(
                      "Fit",
                      "Intrinsic block width in flex layout"
                    )
                  },
                  "fit"
                ),
                /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
                  import_components131.__experimentalToggleGroupControlOption,
                  {
                    value: "fill",
                    label: (0, import_i18n125._x)(
                      "Grow",
                      "Block with expanding width in flex layout"
                    )
                  },
                  "fill"
                ),
                /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
                  import_components131.__experimentalToggleGroupControlOption,
                  {
                    value: "fixed",
                    label: (0, import_i18n125._x)(
                      "Fixed",
                      "Block with fixed width in flex layout"
                    )
                  },
                  "fixed"
                )
              ]
            }
          ),
          selfStretch === "fixed" && /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
            import_components131.__experimentalUnitControl,
            {
              size: "__unstable-large",
              units: units2,
              onChange: (value) => {
                onChange({
                  selfStretch,
                  flexSize: value
                });
              },
              value: flexSize,
              min: 0,
              label: flexResetLabel,
              hideLabelFromVision: true
            }
          )
        ]
      }
    );
  }
  function childLayoutOrientation(parentLayout) {
    const { orientation = "horizontal" } = parentLayout;
    return orientation === "horizontal" ? (0, import_i18n125.__)("Width") : (0, import_i18n125.__)("Height");
  }
  function GridControls({
    childLayout,
    onChange,
    parentLayout,
    isShownByDefault,
    panelId
  }) {
    const { columnStart, rowStart, columnSpan, rowSpan } = childLayout;
    const { columnCount, rowCount } = parentLayout ?? {};
    const rootClientId = (0, import_data118.useSelect)(
      (select2) => select2(store).getBlockRootClientId(panelId)
    );
    const { moveBlocksToPosition: moveBlocksToPosition2, __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2 } = (0, import_data118.useDispatch)(store);
    const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
      rootClientId,
      columnCount || 3
    );
    const hasStartValue = () => !!columnStart || !!rowStart;
    const hasSpanValue = () => !!columnSpan || !!rowSpan;
    const resetGridStarts = () => {
      onChange({
        columnStart: void 0,
        rowStart: void 0
      });
    };
    const resetGridSpans = () => {
      onChange({
        columnSpan: void 0,
        rowSpan: void 0
      });
    };
    const maxColumnSpan = columnCount ? columnCount - (columnStart ?? 1) + 1 : void 0;
    const maxRowSpan = window.__experimentalEnableGridInteractivity && rowCount ? rowCount - (rowStart ?? 1) + 1 : void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime266.jsxs)(import_jsx_runtime266.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime266.jsxs)(
        import_components131.Flex,
        {
          as: import_components131.__experimentalToolsPanelItem,
          hasValue: hasSpanValue,
          label: (0, import_i18n125.__)("Grid span"),
          onDeselect: resetGridSpans,
          isShownByDefault,
          panelId,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(import_components131.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
              import_components131.__experimentalInputControl,
              {
                size: "__unstable-large",
                label: (0, import_i18n125.__)("Column span"),
                type: "number",
                onChange: (value) => {
                  const newColumnSpan = value === "" ? 1 : parseInt(value, 10);
                  const constrainedValue = maxColumnSpan ? Math.min(newColumnSpan, maxColumnSpan) : newColumnSpan;
                  onChange({
                    columnStart,
                    rowStart,
                    rowSpan,
                    columnSpan: constrainedValue
                  });
                },
                value: columnSpan ?? 1,
                min: 1,
                max: maxColumnSpan
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(import_components131.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
              import_components131.__experimentalInputControl,
              {
                size: "__unstable-large",
                label: (0, import_i18n125.__)("Row span"),
                type: "number",
                onChange: (value) => {
                  const newRowSpan = value === "" ? 1 : parseInt(value, 10);
                  const constrainedValue = maxRowSpan ? Math.min(newRowSpan, maxRowSpan) : newRowSpan;
                  onChange({
                    columnStart,
                    rowStart,
                    columnSpan,
                    rowSpan: constrainedValue
                  });
                },
                value: rowSpan ?? 1,
                min: 1,
                max: maxRowSpan
              }
            ) })
          ]
        }
      ),
      window.__experimentalEnableGridInteractivity && // Use Flex with an explicit width on the FlexItem instead of HStack to
      // work around an issue in webkit where inputs with a max attribute are
      // sized incorrectly.
      /* @__PURE__ */ (0, import_jsx_runtime266.jsxs)(
        import_components131.Flex,
        {
          as: import_components131.__experimentalToolsPanelItem,
          hasValue: hasStartValue,
          label: (0, import_i18n125.__)("Grid placement"),
          onDeselect: resetGridStarts,
          isShownByDefault: false,
          panelId,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(import_components131.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
              import_components131.__experimentalInputControl,
              {
                size: "__unstable-large",
                label: (0, import_i18n125.__)("Column"),
                type: "number",
                onChange: (value) => {
                  const newColumnStart = value === "" ? 1 : parseInt(value, 10);
                  onChange({
                    columnStart: newColumnStart,
                    rowStart,
                    columnSpan,
                    rowSpan
                  });
                  __unstableMarkNextChangeAsNotPersistent2();
                  moveBlocksToPosition2(
                    [panelId],
                    rootClientId,
                    rootClientId,
                    getNumberOfBlocksBeforeCell(
                      newColumnStart,
                      rowStart
                    )
                  );
                },
                value: columnStart ?? 1,
                min: 1,
                max: columnCount ? columnCount - (columnSpan ?? 1) + 1 : void 0
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(import_components131.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0, import_jsx_runtime266.jsx)(
              import_components131.__experimentalInputControl,
              {
                size: "__unstable-large",
                label: (0, import_i18n125.__)("Row"),
                type: "number",
                onChange: (value) => {
                  const newRowStart = value === "" ? 1 : parseInt(value, 10);
                  onChange({
                    columnStart,
                    rowStart: newRowStart,
                    columnSpan,
                    rowSpan
                  });
                  __unstableMarkNextChangeAsNotPersistent2();
                  moveBlocksToPosition2(
                    [panelId],
                    rootClientId,
                    rootClientId,
                    getNumberOfBlocksBeforeCell(
                      columnStart,
                      newRowStart
                    )
                  );
                },
                value: rowStart ?? 1,
                min: 1,
                max: rowCount ? rowCount - (rowSpan ?? 1) + 1 : void 0
              }
            ) })
          ]
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/dimensions-tool/aspect-ratio-tool.js
  var import_jsx_runtime267 = __toESM(require_jsx_runtime());
  var import_components132 = __toESM(require_components());
  var import_i18n126 = __toESM(require_i18n());
  function AspectRatioTool({
    panelId,
    value,
    onChange = () => {
    },
    options,
    defaultValue = "auto",
    hasValue,
    isShownByDefault = true
  }) {
    const displayValue = value ?? "auto";
    const [defaultRatios, themeRatios, showDefaultRatios] = useSettings(
      "dimensions.aspectRatios.default",
      "dimensions.aspectRatios.theme",
      "dimensions.defaultAspectRatios"
    );
    const themeOptions = themeRatios?.map(({ name, ratio }) => ({
      label: name,
      value: ratio
    }));
    const defaultOptions = defaultRatios?.map(({ name, ratio }) => ({
      label: name,
      value: ratio
    }));
    const aspectRatioOptions = [
      {
        label: (0, import_i18n126._x)(
          "Original",
          "Aspect ratio option for dimensions control"
        ),
        value: "auto"
      },
      ...showDefaultRatios ? defaultOptions : [],
      ...themeOptions ? themeOptions : [],
      {
        label: (0, import_i18n126._x)("Custom", "Aspect ratio option for dimensions control"),
        value: "custom",
        disabled: true,
        hidden: true
      }
    ];
    return /* @__PURE__ */ (0, import_jsx_runtime267.jsx)(
      import_components132.__experimentalToolsPanelItem,
      {
        hasValue: hasValue ? hasValue : () => displayValue !== defaultValue,
        label: (0, import_i18n126.__)("Aspect ratio"),
        onDeselect: () => onChange(void 0),
        isShownByDefault,
        panelId,
        children: /* @__PURE__ */ (0, import_jsx_runtime267.jsx)(
          import_components132.SelectControl,
          {
            label: (0, import_i18n126.__)("Aspect ratio"),
            value: displayValue,
            options: options ?? aspectRatioOptions,
            onChange,
            size: "__unstable-large",
            __nextHasNoMarginBottom: true
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/dimensions-panel.js
  var AXIAL_SIDES = ["horizontal", "vertical"];
  function useHasDimensionsPanel(settings2) {
    const hasContentSize = useHasContentSize(settings2);
    const hasWideSize = useHasWideSize(settings2);
    const hasPadding = useHasPadding(settings2);
    const hasMargin = useHasMargin(settings2);
    const hasGap = useHasGap(settings2);
    const hasMinHeight = useHasMinHeight(settings2);
    const hasAspectRatio = useHasAspectRatio(settings2);
    const hasChildLayout = useHasChildLayout(settings2);
    return import_element139.Platform.OS === "web" && (hasContentSize || hasWideSize || hasPadding || hasMargin || hasGap || hasMinHeight || hasAspectRatio || hasChildLayout);
  }
  function useHasContentSize(settings2) {
    return settings2?.layout?.contentSize;
  }
  function useHasWideSize(settings2) {
    return settings2?.layout?.wideSize;
  }
  function useHasPadding(settings2) {
    return settings2?.spacing?.padding;
  }
  function useHasMargin(settings2) {
    return settings2?.spacing?.margin;
  }
  function useHasGap(settings2) {
    return settings2?.spacing?.blockGap;
  }
  function useHasMinHeight(settings2) {
    return settings2?.dimensions?.minHeight;
  }
  function useHasAspectRatio(settings2) {
    return settings2?.dimensions?.aspectRatio;
  }
  function useHasChildLayout(settings2) {
    const {
      type: parentLayoutType = "default",
      default: { type: defaultParentLayoutType = "default" } = {},
      allowSizingOnChildren = false
    } = settings2?.parentLayout ?? {};
    const support = (defaultParentLayoutType === "flex" || parentLayoutType === "flex" || defaultParentLayoutType === "grid" || parentLayoutType === "grid") && allowSizingOnChildren;
    return !!settings2?.layout && support;
  }
  function useHasSpacingPresets(settings2) {
    const { defaultSpacingSizes, spacingSizes } = settings2?.spacing || {};
    return defaultSpacingSizes !== false && spacingSizes?.default?.length > 0 || spacingSizes?.theme?.length > 0 || spacingSizes?.custom?.length > 0;
  }
  function filterValuesBySides(values, sides) {
    if (!sides || !values) {
      return values;
    }
    const filteredValues = {};
    sides.forEach((side) => {
      if (side === "vertical") {
        filteredValues.top = values.top;
        filteredValues.bottom = values.bottom;
      }
      if (side === "horizontal") {
        filteredValues.left = values.left;
        filteredValues.right = values.right;
      }
      filteredValues[side] = values?.[side];
    });
    return filteredValues;
  }
  function splitStyleValue(value) {
    if (value && typeof value === "string") {
      return {
        top: value,
        right: value,
        bottom: value,
        left: value
      };
    }
    return value;
  }
  function splitGapValue(value, isAxialGap) {
    if (!value) {
      return value;
    }
    if (typeof value === "string") {
      return isAxialGap ? { top: value, right: value, bottom: value, left: value } : { top: value };
    }
    return {
      ...value,
      right: value?.left,
      bottom: value?.top
    };
  }
  function DimensionsToolsPanel({
    resetAllFilter,
    onChange,
    value,
    panelId,
    children
  }) {
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const resetAll = () => {
      const updatedValue = resetAllFilter(value);
      onChange(updatedValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
      import_components133.__experimentalToolsPanel,
      {
        label: (0, import_i18n127.__)("Dimensions"),
        resetAll,
        panelId,
        dropdownMenuProps,
        children
      }
    );
  }
  var DEFAULT_CONTROLS4 = {
    contentSize: true,
    wideSize: true,
    padding: true,
    margin: true,
    blockGap: true,
    minHeight: true,
    aspectRatio: true,
    childLayout: true
  };
  function DimensionsPanel({
    as: Wrapper = DimensionsToolsPanel,
    value,
    onChange,
    inheritedValue = value,
    settings: settings2,
    panelId,
    defaultControls = DEFAULT_CONTROLS4,
    onVisualize = () => {
    },
    // Special case because the layout controls are not part of the dimensions panel
    // in global styles but not in block inspector.
    includeLayoutControls = false
  }) {
    const { dimensions, spacing } = settings2;
    const decodeValue = (rawValue) => {
      if (rawValue && typeof rawValue === "object") {
        return Object.keys(rawValue).reduce((acc, key) => {
          acc[key] = getValueFromVariable(
            { settings: { dimensions, spacing } },
            "",
            rawValue[key]
          );
          return acc;
        }, {});
      }
      return getValueFromVariable(
        { settings: { dimensions, spacing } },
        "",
        rawValue
      );
    };
    const showSpacingPresetsControl = useHasSpacingPresets(settings2);
    const units2 = (0, import_components133.__experimentalUseCustomUnits)({
      availableUnits: settings2?.spacing?.units || [
        "%",
        "px",
        "em",
        "rem",
        "vw"
      ]
    });
    const minimumMargin = -Infinity;
    const [minMarginValue, setMinMarginValue] = (0, import_element139.useState)(minimumMargin);
    const showContentSizeControl = useHasContentSize(settings2) && includeLayoutControls;
    const contentSizeValue = decodeValue(inheritedValue?.layout?.contentSize);
    const setContentSizeValue = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["layout", "contentSize"],
          newValue || void 0
        )
      );
    };
    const hasUserSetContentSizeValue = () => !!value?.layout?.contentSize;
    const resetContentSizeValue = () => setContentSizeValue(void 0);
    const showWideSizeControl = useHasWideSize(settings2) && includeLayoutControls;
    const wideSizeValue = decodeValue(inheritedValue?.layout?.wideSize);
    const setWideSizeValue = (newValue) => {
      onChange(
        setImmutably(
          value,
          ["layout", "wideSize"],
          newValue || void 0
        )
      );
    };
    const hasUserSetWideSizeValue = () => !!value?.layout?.wideSize;
    const resetWideSizeValue = () => setWideSizeValue(void 0);
    const showPaddingControl = useHasPadding(settings2);
    const rawPadding = decodeValue(inheritedValue?.spacing?.padding);
    const paddingValues = splitStyleValue(rawPadding);
    const paddingSides = Array.isArray(settings2?.spacing?.padding) ? settings2?.spacing?.padding : settings2?.spacing?.padding?.sides;
    const isAxialPadding = paddingSides && paddingSides.some((side) => AXIAL_SIDES.includes(side));
    const setPaddingValues = (newPaddingValues) => {
      const padding = filterValuesBySides(newPaddingValues, paddingSides);
      onChange(setImmutably(value, ["spacing", "padding"], padding));
    };
    const hasPaddingValue = () => !!value?.spacing?.padding && Object.keys(value?.spacing?.padding).length;
    const resetPaddingValue = () => setPaddingValues(void 0);
    const onMouseOverPadding = () => onVisualize("padding");
    const showMarginControl = useHasMargin(settings2);
    const rawMargin = decodeValue(inheritedValue?.spacing?.margin);
    const marginValues = splitStyleValue(rawMargin);
    const marginSides = Array.isArray(settings2?.spacing?.margin) ? settings2?.spacing?.margin : settings2?.spacing?.margin?.sides;
    const isAxialMargin = marginSides && marginSides.some((side) => AXIAL_SIDES.includes(side));
    const setMarginValues = (newMarginValues) => {
      const margin = filterValuesBySides(newMarginValues, marginSides);
      onChange(setImmutably(value, ["spacing", "margin"], margin));
    };
    const hasMarginValue = () => !!value?.spacing?.margin && Object.keys(value?.spacing?.margin).length;
    const resetMarginValue = () => setMarginValues(void 0);
    const onMouseOverMargin = () => onVisualize("margin");
    const showGapControl = useHasGap(settings2);
    const gapSides = Array.isArray(settings2?.spacing?.blockGap) ? settings2?.spacing?.blockGap : settings2?.spacing?.blockGap?.sides;
    const isAxialGap = gapSides && gapSides.some((side) => AXIAL_SIDES.includes(side));
    const gapValue = decodeValue(inheritedValue?.spacing?.blockGap);
    const gapValues = splitGapValue(gapValue, isAxialGap);
    const setGapValue = (newGapValue) => {
      onChange(
        setImmutably(value, ["spacing", "blockGap"], newGapValue)
      );
    };
    const setGapValues = (nextBoxGapValue) => {
      if (!nextBoxGapValue) {
        setGapValue(null);
      }
      if (!isAxialGap && nextBoxGapValue?.hasOwnProperty("top")) {
        setGapValue(nextBoxGapValue.top);
      } else {
        setGapValue({
          top: nextBoxGapValue?.top,
          left: nextBoxGapValue?.left
        });
      }
    };
    const resetGapValue = () => setGapValue(void 0);
    const hasGapValue = () => !!value?.spacing?.blockGap;
    const showMinHeightControl = useHasMinHeight(settings2);
    const minHeightValue = decodeValue(inheritedValue?.dimensions?.minHeight);
    const setMinHeightValue = (newValue) => {
      const tempValue = setImmutably(
        value,
        ["dimensions", "minHeight"],
        newValue
      );
      onChange(
        setImmutably(
          tempValue,
          ["dimensions", "aspectRatio"],
          void 0
        )
      );
    };
    const resetMinHeightValue = () => {
      setMinHeightValue(void 0);
    };
    const hasMinHeightValue = () => !!value?.dimensions?.minHeight;
    const showAspectRatioControl = useHasAspectRatio(settings2);
    const aspectRatioValue = decodeValue(
      inheritedValue?.dimensions?.aspectRatio
    );
    const setAspectRatioValue = (newValue) => {
      const tempValue = setImmutably(
        value,
        ["dimensions", "aspectRatio"],
        newValue
      );
      onChange(
        setImmutably(tempValue, ["dimensions", "minHeight"], void 0)
      );
    };
    const hasAspectRatioValue = () => !!value?.dimensions?.aspectRatio;
    const showChildLayoutControl = useHasChildLayout(settings2);
    const childLayout = inheritedValue?.layout;
    const setChildLayout = (newChildLayout) => {
      onChange({
        ...value,
        layout: {
          ...newChildLayout
        }
      });
    };
    const resetAllFilter = (0, import_element139.useCallback)((previousValue) => {
      return {
        ...previousValue,
        layout: cleanEmptyObject({
          ...previousValue?.layout,
          contentSize: void 0,
          wideSize: void 0,
          selfStretch: void 0,
          flexSize: void 0,
          columnStart: void 0,
          rowStart: void 0,
          columnSpan: void 0,
          rowSpan: void 0
        }),
        spacing: {
          ...previousValue?.spacing,
          padding: void 0,
          margin: void 0,
          blockGap: void 0
        },
        dimensions: {
          ...previousValue?.dimensions,
          minHeight: void 0,
          aspectRatio: void 0
        }
      };
    }, []);
    const onMouseLeaveControls = () => onVisualize(false);
    return /* @__PURE__ */ (0, import_jsx_runtime268.jsxs)(
      Wrapper,
      {
        resetAllFilter,
        value,
        onChange,
        panelId,
        children: [
          (showContentSizeControl || showWideSizeControl) && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)("span", { className: "span-columns", children: (0, import_i18n127.__)("Set the width of the main content area.") }),
          showContentSizeControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
            import_components133.__experimentalToolsPanelItem,
            {
              label: (0, import_i18n127.__)("Content width"),
              hasValue: hasUserSetContentSizeValue,
              onDeselect: resetContentSizeValue,
              isShownByDefault: defaultControls.contentSize ?? DEFAULT_CONTROLS4.contentSize,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                import_components133.__experimentalUnitControl,
                {
                  __next40pxDefaultSize: true,
                  label: (0, import_i18n127.__)("Content width"),
                  labelPosition: "top",
                  value: contentSizeValue || "",
                  onChange: (nextContentSize) => {
                    setContentSizeValue(nextContentSize);
                  },
                  units: units2,
                  prefix: /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(import_components133.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(icon_default, { icon: align_none_default }) })
                }
              )
            }
          ),
          showWideSizeControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
            import_components133.__experimentalToolsPanelItem,
            {
              label: (0, import_i18n127.__)("Wide width"),
              hasValue: hasUserSetWideSizeValue,
              onDeselect: resetWideSizeValue,
              isShownByDefault: defaultControls.wideSize ?? DEFAULT_CONTROLS4.wideSize,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                import_components133.__experimentalUnitControl,
                {
                  __next40pxDefaultSize: true,
                  label: (0, import_i18n127.__)("Wide width"),
                  labelPosition: "top",
                  value: wideSizeValue || "",
                  onChange: (nextWideSize) => {
                    setWideSizeValue(nextWideSize);
                  },
                  units: units2,
                  prefix: /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(import_components133.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(icon_default, { icon: stretch_wide_default }) })
                }
              )
            }
          ),
          showPaddingControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsxs)(
            import_components133.__experimentalToolsPanelItem,
            {
              hasValue: hasPaddingValue,
              label: (0, import_i18n127.__)("Padding"),
              onDeselect: resetPaddingValue,
              isShownByDefault: defaultControls.padding ?? DEFAULT_CONTROLS4.padding,
              className: clsx_default({
                "tools-panel-item-spacing": showSpacingPresetsControl
              }),
              panelId,
              children: [
                !showSpacingPresetsControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                  import_components133.BoxControl,
                  {
                    __next40pxDefaultSize: true,
                    values: paddingValues,
                    onChange: setPaddingValues,
                    label: (0, import_i18n127.__)("Padding"),
                    sides: paddingSides,
                    units: units2,
                    allowReset: false,
                    splitOnAxis: isAxialPadding,
                    inputProps: {
                      onMouseOver: onMouseOverPadding,
                      onMouseOut: onMouseLeaveControls
                    }
                  }
                ),
                showSpacingPresetsControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                  SpacingSizesControl,
                  {
                    values: paddingValues,
                    onChange: setPaddingValues,
                    label: (0, import_i18n127.__)("Padding"),
                    sides: paddingSides,
                    units: units2,
                    allowReset: false,
                    onMouseOver: onMouseOverPadding,
                    onMouseOut: onMouseLeaveControls
                  }
                )
              ]
            }
          ),
          showMarginControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsxs)(
            import_components133.__experimentalToolsPanelItem,
            {
              hasValue: hasMarginValue,
              label: (0, import_i18n127.__)("Margin"),
              onDeselect: resetMarginValue,
              isShownByDefault: defaultControls.margin ?? DEFAULT_CONTROLS4.margin,
              className: clsx_default({
                "tools-panel-item-spacing": showSpacingPresetsControl
              }),
              panelId,
              children: [
                !showSpacingPresetsControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                  import_components133.BoxControl,
                  {
                    __next40pxDefaultSize: true,
                    values: marginValues,
                    onChange: setMarginValues,
                    inputProps: {
                      min: minMarginValue,
                      onDragStart: () => {
                        setMinMarginValue(0);
                      },
                      onDragEnd: () => {
                        setMinMarginValue(minimumMargin);
                      },
                      onMouseOver: onMouseOverMargin,
                      onMouseOut: onMouseLeaveControls
                    },
                    label: (0, import_i18n127.__)("Margin"),
                    sides: marginSides,
                    units: units2,
                    allowReset: false,
                    splitOnAxis: isAxialMargin
                  }
                ),
                showSpacingPresetsControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                  SpacingSizesControl,
                  {
                    values: marginValues,
                    onChange: setMarginValues,
                    minimumCustomValue: -Infinity,
                    label: (0, import_i18n127.__)("Margin"),
                    sides: marginSides,
                    units: units2,
                    allowReset: false,
                    onMouseOver: onMouseOverMargin,
                    onMouseOut: onMouseLeaveControls
                  }
                )
              ]
            }
          ),
          showGapControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsxs)(
            import_components133.__experimentalToolsPanelItem,
            {
              hasValue: hasGapValue,
              label: (0, import_i18n127.__)("Block spacing"),
              onDeselect: resetGapValue,
              isShownByDefault: defaultControls.blockGap ?? DEFAULT_CONTROLS4.blockGap,
              className: clsx_default({
                "tools-panel-item-spacing": showSpacingPresetsControl,
                "single-column": (
                  // If UnitControl is used, should be single-column.
                  !showSpacingPresetsControl && !isAxialGap
                )
              }),
              panelId,
              children: [
                !showSpacingPresetsControl && (isAxialGap ? /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                  import_components133.BoxControl,
                  {
                    __next40pxDefaultSize: true,
                    label: (0, import_i18n127.__)("Block spacing"),
                    min: 0,
                    onChange: setGapValues,
                    units: units2,
                    sides: gapSides,
                    values: gapValues,
                    allowReset: false,
                    splitOnAxis: isAxialGap
                  }
                ) : /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                  import_components133.__experimentalUnitControl,
                  {
                    __next40pxDefaultSize: true,
                    label: (0, import_i18n127.__)("Block spacing"),
                    min: 0,
                    onChange: setGapValue,
                    units: units2,
                    value: gapValue
                  }
                )),
                showSpacingPresetsControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                  SpacingSizesControl,
                  {
                    label: (0, import_i18n127.__)("Block spacing"),
                    min: 0,
                    onChange: setGapValues,
                    showSideInLabel: false,
                    sides: isAxialGap ? gapSides : ["top"],
                    values: gapValues,
                    allowReset: false
                  }
                )
              ]
            }
          ),
          showChildLayoutControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
            ChildLayoutControl,
            {
              value: childLayout,
              onChange: setChildLayout,
              parentLayout: settings2?.parentLayout,
              panelId,
              isShownByDefault: defaultControls.childLayout ?? DEFAULT_CONTROLS4.childLayout
            }
          ),
          showMinHeightControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
            import_components133.__experimentalToolsPanelItem,
            {
              hasValue: hasMinHeightValue,
              label: (0, import_i18n127.__)("Minimum height"),
              onDeselect: resetMinHeightValue,
              isShownByDefault: defaultControls.minHeight ?? DEFAULT_CONTROLS4.minHeight,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
                HeightControl,
                {
                  label: (0, import_i18n127.__)("Minimum height"),
                  value: minHeightValue,
                  onChange: setMinHeightValue
                }
              )
            }
          ),
          showAspectRatioControl && /* @__PURE__ */ (0, import_jsx_runtime268.jsx)(
            AspectRatioTool,
            {
              hasValue: hasAspectRatioValue,
              value: aspectRatioValue,
              onChange: setAspectRatioValue,
              panelId,
              isShownByDefault: defaultControls.aspectRatio ?? DEFAULT_CONTROLS4.aspectRatio
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/border-panel.js
  var import_jsx_runtime274 = __toESM(require_jsx_runtime());
  var import_components140 = __toESM(require_components());
  var import_element145 = __toESM(require_element());
  var import_i18n135 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/border-radius-control/index.js
  var import_jsx_runtime271 = __toESM(require_jsx_runtime());
  var import_components137 = __toESM(require_components());
  var import_element141 = __toESM(require_element());
  var import_i18n131 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/border-radius-control/linked-button.js
  var import_jsx_runtime269 = __toESM(require_jsx_runtime());
  var import_components134 = __toESM(require_components());
  var import_i18n128 = __toESM(require_i18n());
  function LinkedButton2({ isLinked, ...props }) {
    const label = isLinked ? (0, import_i18n128.__)("Unlink radii") : (0, import_i18n128.__)("Link radii");
    return /* @__PURE__ */ (0, import_jsx_runtime269.jsx)(
      import_components134.Button,
      {
        ...props,
        className: "components-border-radius-control__linked-button",
        size: "small",
        icon: isLinked ? link_default : link_off_default,
        iconSize: 24,
        label
      }
    );
  }

  // packages/block-editor/build-module/components/border-radius-control/utils.js
  var import_components135 = __toESM(require_components());
  function mode(inputArray) {
    const arr = [...inputArray];
    return arr.sort(
      (a2, b2) => inputArray.filter((v2) => v2 === b2).length - inputArray.filter((v2) => v2 === a2).length
    ).shift();
  }
  function getAllValue(values = {}) {
    if (typeof values === "string") {
      return values;
    }
    const parsedQuantitiesAndUnits = Object.values(values).map(
      (value2) => (0, import_components135.__experimentalParseQuantityAndUnitFromRawValue)(value2)
    );
    const allValues = parsedQuantitiesAndUnits.map(
      (value2) => value2[0] ?? ""
    );
    const allUnits = parsedQuantitiesAndUnits.map((value2) => value2[1]);
    const value = allValues.every((v2) => v2 === allValues[0]) ? allValues[0] : "";
    const unit = mode(allUnits);
    const allValue = value === 0 || value ? `${value}${unit || ""}` : void 0;
    return allValue;
  }
  function hasMixedValues(values = {}) {
    if (typeof values === "string") {
      return false;
    }
    if (!values || typeof values !== "object") {
      return false;
    }
    const cornerValues = Object.values(values);
    if (cornerValues.length === 0) {
      return false;
    }
    const firstValue = cornerValues[0];
    const allSame = cornerValues.every((value) => value === firstValue);
    return !allSame;
  }
  function hasDefinedValues(values) {
    if (!values) {
      return false;
    }
    if (typeof values === "string") {
      return true;
    }
    const filteredValues = Object.values(values).filter((value) => {
      return !!value || value === 0;
    });
    return !!filteredValues.length;
  }
  function isValuePreset(value) {
    if (!value?.includes) {
      return false;
    }
    return value === "0" || value.includes("var:preset|border-radius|");
  }
  function getPresetSlug(value) {
    if (!value) {
      return;
    }
    if (value === "0" || value === "default") {
      return value;
    }
    const slug = value.match(/var:preset\|border-radius\|(.+)/);
    return slug ? slug[1] : void 0;
  }
  function getSliderValueFromPreset2(presetValue, presets) {
    if (presetValue === void 0) {
      return 0;
    }
    const slug = parseFloat(presetValue, 10) === 0 ? "0" : getPresetSlug(presetValue);
    const sliderValue = presets.findIndex((size) => {
      return String(size.slug) === slug;
    });
    return sliderValue !== -1 ? sliderValue : NaN;
  }
  function getCustomValueFromPreset2(value, presets) {
    if (!isValuePreset(value)) {
      return value;
    }
    const slug = parseFloat(value, 10) === 0 ? "0" : getPresetSlug(value);
    const radiusSize = presets.find((size) => String(size.slug) === slug);
    return radiusSize?.size;
  }
  function getPresetValueFromControlValue(controlValue, controlType, presets) {
    const size = parseInt(controlValue, 10);
    if (controlType === "selectList") {
      if (size === 0) {
        return void 0;
      }
    } else if (size === 0) {
      return "0";
    }
    return `var:preset|border-radius|${presets[controlValue]?.slug}`;
  }
  function getPresetValueFromCustomValue2(value, presets) {
    if (!value || isValuePreset(value) || value === "0") {
      return value;
    }
    const spacingMatch = presets.find(
      (size) => String(size.size) === String(value)
    );
    if (spacingMatch?.slug) {
      return `var:preset|border-radius|${spacingMatch.slug}`;
    }
    return value;
  }
  function convertPresetsToCustomValues(values, presets) {
    if (!values || typeof values !== "object") {
      return values;
    }
    const converted = {};
    Object.keys(values).forEach((key) => {
      const value = values[key];
      if (isValuePreset(value)) {
        const customValue = getCustomValueFromPreset2(value, presets);
        converted[key] = customValue !== void 0 ? customValue : value;
      } else {
        converted[key] = value;
      }
    });
    return converted;
  }

  // packages/block-editor/build-module/components/border-radius-control/single-input-control.js
  var import_jsx_runtime270 = __toESM(require_jsx_runtime());
  var import_components136 = __toESM(require_components());
  var import_i18n130 = __toESM(require_i18n());
  var import_element140 = __toESM(require_element());

  // packages/block-editor/build-module/components/border-radius-control/constants.js
  var import_i18n129 = __toESM(require_i18n());
  var DEFAULT_VALUES2 = {
    topLeft: void 0,
    topRight: void 0,
    bottomLeft: void 0,
    bottomRight: void 0
  };
  var RANGE_CONTROL_MAX_SIZE2 = 8;
  var EMPTY_ARRAY10 = [];
  var CORNERS = {
    all: (0, import_i18n129.__)("Border radius"),
    topLeft: (0, import_i18n129.__)("Top left"),
    topRight: (0, import_i18n129.__)("Top right"),
    bottomLeft: (0, import_i18n129.__)("Bottom left"),
    bottomRight: (0, import_i18n129.__)("Bottom right")
  };
  var ICONS2 = {
    all: corner_all_default,
    topLeft: corner_top_left_default,
    topRight: corner_top_right_default,
    bottomLeft: corner_bottom_left_default,
    bottomRight: corner_bottom_right_default
  };
  var MIN_BORDER_RADIUS_VALUE = 0;
  var MAX_BORDER_RADIUS_VALUES = {
    px: 100,
    em: 20,
    rem: 20
  };

  // packages/block-editor/build-module/components/border-radius-control/single-input-control.js
  function SingleInputControl2({
    corner,
    onChange,
    selectedUnits,
    setSelectedUnits,
    values: valuesProp,
    units: units2,
    presets
  }) {
    const changeCornerValue = (validatedValue) => {
      if (corner === "all") {
        onChange({
          topLeft: validatedValue,
          topRight: validatedValue,
          bottomLeft: validatedValue,
          bottomRight: validatedValue
        });
      } else {
        onChange({
          ...values,
          [corner]: validatedValue
        });
      }
    };
    const onChangeValue = (next2) => {
      if (!onChange) {
        return;
      }
      const isNumeric = !isNaN(parseFloat(next2));
      const nextValue = isNumeric ? next2 : void 0;
      changeCornerValue(nextValue);
    };
    const onChangeUnit = (next2) => {
      const newUnits = { ...selectedUnits };
      if (corner === "all") {
        newUnits.topLeft = next2;
        newUnits.topRight = next2;
        newUnits.bottomLeft = next2;
        newUnits.bottomRight = next2;
      } else {
        newUnits[corner] = next2;
      }
      setSelectedUnits(newUnits);
    };
    const values = typeof valuesProp !== "string" ? valuesProp : {
      topLeft: valuesProp,
      topRight: valuesProp,
      bottomLeft: valuesProp,
      bottomRight: valuesProp
    };
    let value;
    if (corner === "all") {
      const convertedValues = convertPresetsToCustomValues(values, presets);
      const customValue = getAllValue(convertedValues);
      value = getPresetValueFromCustomValue2(customValue, presets);
    } else {
      value = getPresetValueFromCustomValue2(values[corner], presets);
    }
    const resolvedPresetValue = isValuePreset(value) ? getCustomValueFromPreset2(value, presets) : value;
    const [parsedQuantity, parsedUnit] = (0, import_components136.__experimentalParseQuantityAndUnitFromRawValue)(resolvedPresetValue);
    const computedUnit = value ? parsedUnit : selectedUnits[corner] || selectedUnits.flat || "px";
    const unitConfig = units2 && units2.find((item) => item.value === computedUnit);
    const step = unitConfig?.step || 1;
    const [showCustomValueControl, setShowCustomValueControl] = (0, import_element140.useState)(
      value !== void 0 && !isValuePreset(value)
    );
    const showRangeControl = presets.length <= RANGE_CONTROL_MAX_SIZE2;
    const presetIndex = getSliderValueFromPreset2(value, presets);
    const rangeTooltip = (newValue) => value === void 0 ? void 0 : presets[newValue]?.name;
    const marks = presets.slice(1, presets.length - 1).map((_newValue, index) => ({
      value: index + 1,
      label: void 0
    }));
    const hasPresets = marks.length > 0;
    let options = [];
    if (!showRangeControl) {
      options = [
        ...presets,
        {
          name: (0, import_i18n130.__)("Custom"),
          slug: "custom",
          size: resolvedPresetValue
        }
      ].map((size, index) => ({
        key: index,
        name: size.name
      }));
    }
    const icon = ICONS2[corner];
    const handleSliderChange = (next2) => {
      const val = next2 !== void 0 ? `${next2}${computedUnit}` : void 0;
      changeCornerValue(val);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime270.jsxs)(import_components136.__experimentalHStack, { children: [
      icon && /* @__PURE__ */ (0, import_jsx_runtime270.jsx)(
        import_components136.Icon,
        {
          className: "components-border-radius-control__icon",
          icon,
          size: 24
        }
      ),
      (!hasPresets || showCustomValueControl) && /* @__PURE__ */ (0, import_jsx_runtime270.jsxs)("div", { className: "components-border-radius-control__input-controls-wrapper", children: [
        /* @__PURE__ */ (0, import_jsx_runtime270.jsx)(import_components136.Tooltip, { text: CORNERS[corner], placement: "top", children: /* @__PURE__ */ (0, import_jsx_runtime270.jsx)("div", { className: "components-border-radius-control__tooltip-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime270.jsx)(
          import_components136.__experimentalUnitControl,
          {
            className: "components-border-radius-control__unit-control",
            "aria-label": CORNERS[corner],
            value: [parsedQuantity, computedUnit].join(
              ""
            ),
            onChange: onChangeValue,
            onUnitChange: onChangeUnit,
            size: "__unstable-large",
            min: MIN_BORDER_RADIUS_VALUE,
            units: units2
          }
        ) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime270.jsx)(
          import_components136.RangeControl,
          {
            __next40pxDefaultSize: true,
            label: (0, import_i18n130.__)("Border radius"),
            hideLabelFromVision: true,
            className: "components-border-radius-control__range-control",
            value: parsedQuantity ?? "",
            min: MIN_BORDER_RADIUS_VALUE,
            max: MAX_BORDER_RADIUS_VALUES[computedUnit],
            initialPosition: 0,
            withInputField: false,
            onChange: handleSliderChange,
            step,
            __nextHasNoMarginBottom: true
          }
        )
      ] }),
      hasPresets && showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0, import_jsx_runtime270.jsx)(
        import_components136.RangeControl,
        {
          __next40pxDefaultSize: true,
          className: "components-border-radius-control__range-control",
          value: presetIndex,
          onChange: (newSize) => {
            changeCornerValue(
              getPresetValueFromControlValue(
                newSize,
                "range",
                presets
              )
            );
          },
          withInputField: false,
          "aria-valuenow": presetIndex,
          "aria-valuetext": presets[presetIndex]?.name,
          renderTooltipContent: rangeTooltip,
          min: 0,
          max: presets.length - 1,
          marks,
          label: CORNERS[corner],
          hideLabelFromVision: true,
          __nextHasNoMarginBottom: true
        }
      ),
      !showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0, import_jsx_runtime270.jsx)(
        import_components136.CustomSelectControl,
        {
          className: "components-border-radius-control__custom-select-control",
          value: options.find(
            (option) => option.key === presetIndex
          ) || options[options.length - 1],
          onChange: (selection2) => {
            if (selection2.selectedItem.key === options.length - 1) {
              setShowCustomValueControl(true);
            } else {
              changeCornerValue(
                getPresetValueFromControlValue(
                  selection2.selectedItem.key,
                  "selectList",
                  presets
                )
              );
            }
          },
          options,
          label: CORNERS[corner],
          hideLabelFromVision: true,
          size: "__unstable-large"
        }
      ),
      hasPresets && /* @__PURE__ */ (0, import_jsx_runtime270.jsx)(
        import_components136.Button,
        {
          label: showCustomValueControl ? (0, import_i18n130.__)("Use border radius preset") : (0, import_i18n130.__)("Set custom border radius"),
          icon: settings_default,
          onClick: () => {
            setShowCustomValueControl(!showCustomValueControl);
          },
          isPressed: showCustomValueControl,
          size: "small",
          className: "components-border-radius-control__custom-toggle",
          iconSize: 24
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/border-radius-control/index.js
  function useBorderRadiusSizes(presets) {
    const defaultSizes = presets?.default ?? EMPTY_ARRAY10;
    const customSizes = presets?.custom ?? EMPTY_ARRAY10;
    const themeSizes = presets?.theme ?? EMPTY_ARRAY10;
    return (0, import_element141.useMemo)(() => {
      const sizes = [
        { name: (0, import_i18n131.__)("None"), slug: "0", size: 0 },
        ...customSizes,
        ...themeSizes,
        ...defaultSizes
      ];
      return sizes.length > RANGE_CONTROL_MAX_SIZE2 ? [
        {
          name: (0, import_i18n131.__)("Default"),
          slug: "default",
          size: void 0
        },
        ...sizes
      ] : sizes;
    }, [customSizes, themeSizes, defaultSizes]);
  }
  function BorderRadiusControl({ onChange, values, presets }) {
    const [isLinked, setIsLinked] = (0, import_element141.useState)(
      !hasDefinedValues(values) || !hasMixedValues(values)
    );
    const options = useBorderRadiusSizes(presets);
    const [selectedUnits, setSelectedUnits] = (0, import_element141.useState)({
      flat: typeof values === "string" ? (0, import_components137.__experimentalParseQuantityAndUnitFromRawValue)(values)[1] : void 0,
      topLeft: (0, import_components137.__experimentalParseQuantityAndUnitFromRawValue)(values?.topLeft)[1],
      topRight: (0, import_components137.__experimentalParseQuantityAndUnitFromRawValue)(values?.topRight)[1],
      bottomLeft: (0, import_components137.__experimentalParseQuantityAndUnitFromRawValue)(values?.bottomLeft)[1],
      bottomRight: (0, import_components137.__experimentalParseQuantityAndUnitFromRawValue)(
        values?.bottomRight
      )[1]
    });
    const [availableUnits] = useSettings("spacing.units");
    const units2 = (0, import_components137.__experimentalUseCustomUnits)({
      availableUnits: availableUnits || ["px", "em", "rem"]
    });
    const toggleLinked = () => setIsLinked(!isLinked);
    return /* @__PURE__ */ (0, import_jsx_runtime271.jsxs)("fieldset", { className: "components-border-radius-control", children: [
      /* @__PURE__ */ (0, import_jsx_runtime271.jsxs)(import_components137.__experimentalHStack, { className: "components-border-radius-control__header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime271.jsx)(import_components137.BaseControl.VisualLabel, { as: "legend", children: (0, import_i18n131.__)("Radius") }),
        /* @__PURE__ */ (0, import_jsx_runtime271.jsx)(LinkedButton2, { onClick: toggleLinked, isLinked })
      ] }),
      isLinked ? /* @__PURE__ */ (0, import_jsx_runtime271.jsx)(import_jsx_runtime271.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime271.jsx)(
        SingleInputControl2,
        {
          onChange,
          selectedUnits,
          setSelectedUnits,
          values,
          units: units2,
          corner: "all",
          presets: options
        }
      ) }) : /* @__PURE__ */ (0, import_jsx_runtime271.jsx)(import_components137.__experimentalVStack, { children: [
        "topLeft",
        "topRight",
        "bottomLeft",
        "bottomRight"
      ].map((corner) => /* @__PURE__ */ (0, import_jsx_runtime271.jsx)(
        SingleInputControl2,
        {
          onChange,
          selectedUnits,
          setSelectedUnits,
          values: values || DEFAULT_VALUES2,
          units: units2,
          corner,
          presets: options
        },
        corner
      )) })
    ] });
  }

  // packages/block-editor/build-module/hooks/border.js
  var import_jsx_runtime272 = __toESM(require_jsx_runtime());
  var import_blocks69 = __toESM(require_blocks());
  var import_components138 = __toESM(require_components());
  var import_element143 = __toESM(require_element());
  var import_hooks7 = __toESM(require_hooks());
  var import_data119 = __toESM(require_data());

  // packages/block-editor/build-module/components/colors-gradients/use-multiple-origin-colors-and-gradients.js
  var import_element142 = __toESM(require_element());
  var import_i18n132 = __toESM(require_i18n());
  function useMultipleOriginColorsAndGradients() {
    const [
      enableCustomColors,
      customColors,
      themeColors,
      defaultColors,
      shouldDisplayDefaultColors,
      enableCustomGradients,
      customGradients,
      themeGradients,
      defaultGradients,
      shouldDisplayDefaultGradients
    ] = useSettings(
      "color.custom",
      "color.palette.custom",
      "color.palette.theme",
      "color.palette.default",
      "color.defaultPalette",
      "color.customGradient",
      "color.gradients.custom",
      "color.gradients.theme",
      "color.gradients.default",
      "color.defaultGradients"
    );
    const colorGradientSettings = {
      disableCustomColors: !enableCustomColors,
      disableCustomGradients: !enableCustomGradients
    };
    colorGradientSettings.colors = (0, import_element142.useMemo)(() => {
      const result = [];
      if (themeColors && themeColors.length) {
        result.push({
          name: (0, import_i18n132._x)(
            "Theme",
            "Indicates this palette comes from the theme."
          ),
          slug: "theme",
          colors: themeColors
        });
      }
      if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
        result.push({
          name: (0, import_i18n132._x)(
            "Default",
            "Indicates this palette comes from WordPress."
          ),
          slug: "default",
          colors: defaultColors
        });
      }
      if (customColors && customColors.length) {
        result.push({
          name: (0, import_i18n132._x)(
            "Custom",
            "Indicates this palette is created by the user."
          ),
          slug: "custom",
          colors: customColors
        });
      }
      return result;
    }, [
      customColors,
      themeColors,
      defaultColors,
      shouldDisplayDefaultColors
    ]);
    colorGradientSettings.gradients = (0, import_element142.useMemo)(() => {
      const result = [];
      if (themeGradients && themeGradients.length) {
        result.push({
          name: (0, import_i18n132._x)(
            "Theme",
            "Indicates this palette comes from the theme."
          ),
          slug: "theme",
          gradients: themeGradients
        });
      }
      if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
        result.push({
          name: (0, import_i18n132._x)(
            "Default",
            "Indicates this palette comes from WordPress."
          ),
          slug: "default",
          gradients: defaultGradients
        });
      }
      if (customGradients && customGradients.length) {
        result.push({
          name: (0, import_i18n132._x)(
            "Custom",
            "Indicates this palette is created by the user."
          ),
          slug: "custom",
          gradients: customGradients
        });
      }
      return result;
    }, [
      customGradients,
      themeGradients,
      defaultGradients,
      shouldDisplayDefaultGradients
    ]);
    colorGradientSettings.hasColorsOrGradients = !!colorGradientSettings.colors.length || !!colorGradientSettings.gradients.length;
    return colorGradientSettings;
  }

  // packages/block-editor/build-module/hooks/border.js
  var import_i18n133 = __toESM(require_i18n());
  var BORDER_SUPPORT_KEY2 = "__experimentalBorder";
  var SHADOW_SUPPORT_KEY = "shadow";
  var getColorByProperty = (colors2, property, value) => {
    let matchedColor;
    colors2.some(
      (origin) => origin.colors.some((color) => {
        if (color[property] === value) {
          matchedColor = color;
          return true;
        }
        return false;
      })
    );
    return matchedColor;
  };
  var getMultiOriginColor = ({ colors: colors2, namedColor, customColor }) => {
    if (namedColor) {
      const colorObject2 = getColorByProperty(colors2, "slug", namedColor);
      if (colorObject2) {
        return colorObject2;
      }
    }
    if (!customColor) {
      return { color: void 0 };
    }
    const colorObject = getColorByProperty(colors2, "color", customColor);
    return colorObject ? colorObject : { color: customColor };
  };
  function getColorSlugFromVariable(value) {
    const namedColor = /var:preset\|color\|(.+)/.exec(value);
    if (namedColor && namedColor[1]) {
      return namedColor[1];
    }
    return null;
  }
  function styleToAttributes(style) {
    if ((0, import_components138.__experimentalHasSplitBorders)(style?.border)) {
      return {
        style,
        borderColor: void 0
      };
    }
    const borderColorValue = style?.border?.color;
    const borderColorSlug = borderColorValue?.startsWith("var:preset|color|") ? borderColorValue.substring("var:preset|color|".length) : void 0;
    const updatedStyle = { ...style };
    updatedStyle.border = {
      ...updatedStyle.border,
      color: borderColorSlug ? void 0 : borderColorValue
    };
    return {
      style: cleanEmptyObject(updatedStyle),
      borderColor: borderColorSlug
    };
  }
  function attributesToStyle(attributes) {
    if ((0, import_components138.__experimentalHasSplitBorders)(attributes.style?.border)) {
      return attributes.style;
    }
    return {
      ...attributes.style,
      border: {
        ...attributes.style?.border,
        color: attributes.borderColor ? "var:preset|color|" + attributes.borderColor : attributes.style?.border?.color
      }
    };
  }
  function BordersInspectorControl({ label, children, resetAllFilter }) {
    const attributesResetAllFilter = (0, import_element143.useCallback)(
      (attributes) => {
        const existingStyle = attributesToStyle(attributes);
        const updatedStyle = resetAllFilter(existingStyle);
        return {
          ...attributes,
          ...styleToAttributes(updatedStyle)
        };
      },
      [resetAllFilter]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime272.jsx)(
      inspector_controls_default,
      {
        group: "border",
        resetAllFilter: attributesResetAllFilter,
        label,
        children
      }
    );
  }
  function BorderPanel2({ clientId, name, setAttributes, settings: settings2 }) {
    const isEnabled = useHasBorderPanel(settings2);
    function selector3(select2) {
      const { style: style2, borderColor: borderColor2 } = select2(store).getBlockAttributes(clientId) || {};
      return { style: style2, borderColor: borderColor2 };
    }
    const { style, borderColor } = (0, import_data119.useSelect)(selector3, [clientId]);
    const value = (0, import_element143.useMemo)(() => {
      return attributesToStyle({ style, borderColor });
    }, [style, borderColor]);
    const onChange = (newStyle) => {
      setAttributes(styleToAttributes(newStyle));
    };
    if (!isEnabled) {
      return null;
    }
    const defaultControls = {
      ...(0, import_blocks69.getBlockSupport)(name, [
        BORDER_SUPPORT_KEY2,
        "__experimentalDefaultControls"
      ]),
      ...(0, import_blocks69.getBlockSupport)(name, [
        SHADOW_SUPPORT_KEY,
        "__experimentalDefaultControls"
      ])
    };
    return /* @__PURE__ */ (0, import_jsx_runtime272.jsx)(
      BorderPanel,
      {
        as: BordersInspectorControl,
        panelId: clientId,
        settings: settings2,
        value,
        onChange,
        defaultControls
      }
    );
  }
  function hasBorderSupport2(blockName, feature = "any") {
    if (import_element143.Platform.OS !== "web") {
      return false;
    }
    const support = (0, import_blocks69.getBlockSupport)(blockName, BORDER_SUPPORT_KEY2);
    if (support === true) {
      return true;
    }
    if (feature === "any") {
      return !!(support?.color || support?.radius || support?.width || support?.style);
    }
    return !!support?.[feature];
  }
  function useBorderPanelLabel({
    blockName,
    hasBorderControl,
    hasShadowControl
  } = {}) {
    const settings2 = useBlockSettings(blockName);
    const controls = useHasBorderPanelControls(settings2);
    if (!hasBorderControl && !hasShadowControl && blockName) {
      hasBorderControl = controls?.hasBorderColor || controls?.hasBorderStyle || controls?.hasBorderWidth || controls?.hasBorderRadius;
      hasShadowControl = controls?.hasShadow;
    }
    if (hasBorderControl && hasShadowControl) {
      return (0, import_i18n133.__)("Border & Shadow");
    }
    if (hasShadowControl) {
      return (0, import_i18n133.__)("Shadow");
    }
    return (0, import_i18n133.__)("Border");
  }
  function addAttributes(settings2) {
    if (!hasBorderSupport2(settings2, "color")) {
      return settings2;
    }
    if (settings2.attributes.borderColor) {
      return settings2;
    }
    return {
      ...settings2,
      attributes: {
        ...settings2.attributes,
        borderColor: {
          type: "string"
        }
      }
    };
  }
  function addSaveProps(props, blockNameOrType, attributes) {
    if (!hasBorderSupport2(blockNameOrType, "color") || shouldSkipSerialization(blockNameOrType, BORDER_SUPPORT_KEY2, "color")) {
      return props;
    }
    const borderClasses = getBorderClasses(attributes);
    const newClassName = clsx_default(props.className, borderClasses);
    props.className = newClassName ? newClassName : void 0;
    return props;
  }
  function getBorderClasses(attributes) {
    const { borderColor, style } = attributes;
    const borderColorClass = getColorClassName("border-color", borderColor);
    return clsx_default({
      "has-border-color": borderColor || style?.border?.color,
      [borderColorClass]: !!borderColorClass
    });
  }
  function useBlockProps4({ name, borderColor, style }) {
    const { colors: colors2 } = useMultipleOriginColorsAndGradients();
    if (!hasBorderSupport2(name, "color") || shouldSkipSerialization(name, BORDER_SUPPORT_KEY2, "color")) {
      return {};
    }
    const { color: borderColorValue } = getMultiOriginColor({
      colors: colors2,
      namedColor: borderColor
    });
    const { color: borderTopColor } = getMultiOriginColor({
      colors: colors2,
      namedColor: getColorSlugFromVariable(style?.border?.top?.color)
    });
    const { color: borderRightColor } = getMultiOriginColor({
      colors: colors2,
      namedColor: getColorSlugFromVariable(style?.border?.right?.color)
    });
    const { color: borderBottomColor } = getMultiOriginColor({
      colors: colors2,
      namedColor: getColorSlugFromVariable(style?.border?.bottom?.color)
    });
    const { color: borderLeftColor } = getMultiOriginColor({
      colors: colors2,
      namedColor: getColorSlugFromVariable(style?.border?.left?.color)
    });
    const extraStyles = {
      borderTopColor: borderTopColor || borderColorValue,
      borderRightColor: borderRightColor || borderColorValue,
      borderBottomColor: borderBottomColor || borderColorValue,
      borderLeftColor: borderLeftColor || borderColorValue
    };
    return addSaveProps(
      { style: cleanEmptyObject(extraStyles) || {} },
      name,
      { borderColor, style }
    );
  }
  var border_default = {
    useBlockProps: useBlockProps4,
    addSaveProps,
    attributeKeys: ["borderColor", "style"],
    hasSupport(name) {
      return hasBorderSupport2(name, "color");
    }
  };
  (0, import_hooks7.addFilter)(
    "blocks.registerBlockType",
    "core/border/addAttributes",
    addAttributes
  );

  // packages/block-editor/build-module/components/global-styles/shadow-panel-components.js
  var import_jsx_runtime273 = __toESM(require_jsx_runtime());
  var import_i18n134 = __toESM(require_i18n());
  var import_components139 = __toESM(require_components());
  var import_element144 = __toESM(require_element());
  var EMPTY_ARRAY11 = [];
  function ShadowPopoverContainer({ shadow, onShadowChange, settings: settings2 }) {
    const shadows = useShadowPresets(settings2);
    return /* @__PURE__ */ (0, import_jsx_runtime273.jsx)("div", { className: "block-editor-global-styles__shadow-popover-container", children: /* @__PURE__ */ (0, import_jsx_runtime273.jsxs)(import_components139.__experimentalVStack, { spacing: 4, children: [
      /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(import_components139.__experimentalHeading, { level: 5, children: (0, import_i18n134.__)("Drop shadow") }),
      /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
        ShadowPresets,
        {
          presets: shadows,
          activeShadow: shadow,
          onSelect: onShadowChange
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime273.jsx)("div", { className: "block-editor-global-styles__clear-shadow", children: /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
        import_components139.Button,
        {
          __next40pxDefaultSize: true,
          variant: "tertiary",
          onClick: () => onShadowChange(void 0),
          disabled: !shadow,
          accessibleWhenDisabled: true,
          children: (0, import_i18n134.__)("Clear")
        }
      ) })
    ] }) });
  }
  function ShadowPresets({ presets, activeShadow, onSelect }) {
    return !presets ? null : /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
      import_components139.Composite,
      {
        role: "listbox",
        className: "block-editor-global-styles__shadow__list",
        "aria-label": (0, import_i18n134.__)("Drop shadows"),
        children: presets.map(({ name, slug, shadow }) => /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
          ShadowIndicator,
          {
            label: name,
            isActive: shadow === activeShadow,
            type: slug === "unset" ? "unset" : "preset",
            onSelect: () => onSelect(shadow === activeShadow ? void 0 : shadow),
            shadow
          },
          slug
        ))
      }
    );
  }
  function ShadowIndicator({ type, label, isActive, onSelect, shadow }) {
    return /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(import_components139.Tooltip, { text: label, children: /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
      import_components139.Composite.Item,
      {
        role: "option",
        "aria-label": label,
        "aria-selected": isActive,
        className: clsx_default("block-editor-global-styles__shadow__item", {
          "is-active": isActive
        }),
        render: /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
          "button",
          {
            className: clsx_default(
              "block-editor-global-styles__shadow-indicator",
              {
                unset: type === "unset"
              }
            ),
            onClick: onSelect,
            style: { boxShadow: shadow },
            "aria-label": label,
            children: isActive && /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(icon_default, { icon: check_default })
          }
        )
      }
    ) });
  }
  function ShadowPopover({ shadow, onShadowChange, settings: settings2 }) {
    const popoverProps3 = {
      placement: "left-start",
      offset: 36,
      shift: true
    };
    return /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
      import_components139.Dropdown,
      {
        popoverProps: popoverProps3,
        className: "block-editor-global-styles__shadow-dropdown",
        renderToggle: renderShadowToggle(shadow, onShadowChange),
        renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(import_components139.__experimentalDropdownContentWrapper, { paddingSize: "medium", children: /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
          ShadowPopoverContainer,
          {
            shadow,
            onShadowChange,
            settings: settings2
          }
        ) })
      }
    );
  }
  function renderShadowToggle(shadow, onShadowChange) {
    return ({ onToggle, isOpen }) => {
      const shadowButtonRef = (0, import_element144.useRef)(void 0);
      const toggleProps = {
        onClick: onToggle,
        className: clsx_default(
          "block-editor-global-styles__shadow-dropdown-toggle",
          { "is-open": isOpen }
        ),
        "aria-expanded": isOpen,
        ref: shadowButtonRef
      };
      const removeButtonProps = {
        onClick: () => {
          if (isOpen) {
            onToggle();
          }
          onShadowChange(void 0);
          shadowButtonRef.current?.focus();
        },
        className: clsx_default(
          "block-editor-global-styles__shadow-editor__remove-button",
          { "is-open": isOpen }
        ),
        label: (0, import_i18n134.__)("Remove")
      };
      return /* @__PURE__ */ (0, import_jsx_runtime273.jsxs)(import_jsx_runtime273.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(import_components139.Button, { __next40pxDefaultSize: true, ...toggleProps, children: /* @__PURE__ */ (0, import_jsx_runtime273.jsxs)(import_components139.__experimentalHStack, { justify: "flex-start", children: [
          /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
            icon_default,
            {
              className: "block-editor-global-styles__toggle-icon",
              icon: shadow_default,
              size: 24
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(import_components139.FlexItem, { children: (0, import_i18n134.__)("Drop shadow") })
        ] }) }),
        !!shadow && /* @__PURE__ */ (0, import_jsx_runtime273.jsx)(
          import_components139.Button,
          {
            __next40pxDefaultSize: true,
            size: "small",
            icon: reset_default,
            ...removeButtonProps
          }
        )
      ] });
    };
  }
  function useShadowPresets(settings2) {
    return (0, import_element144.useMemo)(() => {
      if (!settings2?.shadow) {
        return EMPTY_ARRAY11;
      }
      const defaultPresetsEnabled = settings2?.shadow?.defaultPresets;
      const {
        default: defaultShadows,
        theme: themeShadows,
        custom: customShadows
      } = settings2?.shadow?.presets ?? {};
      const unsetShadow = {
        name: (0, import_i18n134.__)("Unset"),
        slug: "unset",
        shadow: "none"
      };
      const shadowPresets = [
        ...defaultPresetsEnabled && defaultShadows || EMPTY_ARRAY11,
        ...themeShadows || EMPTY_ARRAY11,
        ...customShadows || EMPTY_ARRAY11
      ];
      if (shadowPresets.length) {
        shadowPresets.unshift(unsetShadow);
      }
      return shadowPresets;
    }, [settings2]);
  }

  // packages/block-editor/build-module/components/global-styles/border-panel.js
  function useHasBorderPanel(settings2) {
    const controls = Object.values(useHasBorderPanelControls(settings2));
    return controls.some(Boolean);
  }
  function useHasBorderPanelControls(settings2) {
    const controls = {
      hasBorderColor: useHasBorderColorControl(settings2),
      hasBorderRadius: useHasBorderRadiusControl(settings2),
      hasBorderStyle: useHasBorderStyleControl(settings2),
      hasBorderWidth: useHasBorderWidthControl(settings2),
      hasShadow: useHasShadowControl(settings2)
    };
    return controls;
  }
  function useHasBorderColorControl(settings2) {
    return settings2?.border?.color;
  }
  function useHasBorderRadiusControl(settings2) {
    return settings2?.border?.radius;
  }
  function useHasBorderStyleControl(settings2) {
    return settings2?.border?.style;
  }
  function useHasBorderWidthControl(settings2) {
    return settings2?.border?.width;
  }
  function useHasShadowControl(settings2) {
    const shadows = useShadowPresets(settings2);
    return !!settings2?.shadow && shadows.length > 0;
  }
  function BorderToolsPanel({
    resetAllFilter,
    onChange,
    value,
    panelId,
    children,
    label
  }) {
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const resetAll = () => {
      const updatedValue = resetAllFilter(value);
      onChange(updatedValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime274.jsx)(
      import_components140.__experimentalToolsPanel,
      {
        label,
        resetAll,
        panelId,
        dropdownMenuProps,
        children
      }
    );
  }
  var DEFAULT_CONTROLS5 = {
    radius: true,
    color: true,
    width: true,
    shadow: true
  };
  function BorderPanel({
    as: Wrapper = BorderToolsPanel,
    value,
    onChange,
    inheritedValue = value,
    settings: settings2,
    panelId,
    name,
    defaultControls = DEFAULT_CONTROLS5
  }) {
    const colors2 = useColorsPerOrigin(settings2);
    const decodeValue = (0, import_element145.useCallback)(
      (rawValue) => getValueFromVariable({ settings: settings2 }, "", rawValue),
      [settings2]
    );
    const encodeColorValue = (colorValue) => {
      const allColors = colors2.flatMap(
        ({ colors: originColors }) => originColors
      );
      const colorObject = allColors.find(
        ({ color }) => color === colorValue
      );
      return colorObject ? "var:preset|color|" + colorObject.slug : colorValue;
    };
    const border = (0, import_element145.useMemo)(() => {
      if ((0, import_components140.__experimentalHasSplitBorders)(inheritedValue?.border)) {
        const borderValue = { ...inheritedValue?.border };
        ["top", "right", "bottom", "left"].forEach((side) => {
          borderValue[side] = {
            ...borderValue[side],
            color: decodeValue(borderValue[side]?.color)
          };
        });
        return borderValue;
      }
      return {
        ...inheritedValue?.border,
        color: inheritedValue?.border?.color ? decodeValue(inheritedValue?.border?.color) : void 0
      };
    }, [inheritedValue?.border, decodeValue]);
    const setBorder = (newBorder) => onChange({ ...value, border: newBorder });
    const showBorderColor = useHasBorderColorControl(settings2);
    const showBorderStyle = useHasBorderStyleControl(settings2);
    const showBorderWidth = useHasBorderWidthControl(settings2);
    const showBorderRadius = useHasBorderRadiusControl(settings2);
    const borderRadiusValues = (0, import_element145.useMemo)(() => {
      if (typeof border?.radius !== "object") {
        return border?.radius;
      }
      return {
        topLeft: border?.radius?.topLeft,
        topRight: border?.radius?.topRight,
        bottomLeft: border?.radius?.bottomLeft,
        bottomRight: border?.radius?.bottomRight
      };
    }, [border?.radius]);
    const setBorderRadius = (newBorderRadius) => setBorder({ ...border, radius: newBorderRadius });
    const hasBorderRadius = () => {
      const borderValues = value?.border?.radius;
      if (typeof borderValues === "object") {
        return Object.entries(borderValues).some(Boolean);
      }
      return !!borderValues;
    };
    const hasShadowControl = useHasShadowControl(settings2);
    const shadow = decodeValue(inheritedValue?.shadow);
    const shadowPresets = settings2?.shadow?.presets ?? {};
    const mergedShadowPresets = shadowPresets.custom ?? shadowPresets.theme ?? shadowPresets.default ?? [];
    const setShadow = (newValue) => {
      const slug = mergedShadowPresets?.find(
        ({ shadow: shadowName }) => shadowName === newValue
      )?.slug;
      onChange(
        setImmutably(
          value,
          ["shadow"],
          slug ? `var:preset|shadow|${slug}` : newValue || void 0
        )
      );
    };
    const hasShadow = () => !!value?.shadow;
    const resetShadow = () => setShadow(void 0);
    const resetBorder = () => {
      if (hasBorderRadius()) {
        return setBorder({ radius: value?.border?.radius });
      }
      setBorder(void 0);
    };
    const onBorderChange = (newBorder) => {
      const updatedBorder = { ...newBorder };
      if ((0, import_components140.__experimentalHasSplitBorders)(updatedBorder)) {
        ["top", "right", "bottom", "left"].forEach((side) => {
          if (updatedBorder[side]) {
            updatedBorder[side] = {
              ...updatedBorder[side],
              color: encodeColorValue(updatedBorder[side]?.color)
            };
          }
        });
      } else if (updatedBorder) {
        updatedBorder.color = encodeColorValue(updatedBorder.color);
      }
      setBorder({ radius: border?.radius, ...updatedBorder });
    };
    const resetAllFilter = (0, import_element145.useCallback)((previousValue) => {
      return {
        ...previousValue,
        border: void 0,
        shadow: void 0
      };
    }, []);
    const showBorderByDefault = defaultControls?.color || defaultControls?.width;
    const hasBorderControl = showBorderColor || showBorderStyle || showBorderWidth || showBorderRadius;
    const label = useBorderPanelLabel({
      blockName: name,
      hasShadowControl,
      hasBorderControl
    });
    return /* @__PURE__ */ (0, import_jsx_runtime274.jsxs)(
      Wrapper,
      {
        resetAllFilter,
        value,
        onChange,
        panelId,
        label,
        children: [
          (showBorderWidth || showBorderColor) && /* @__PURE__ */ (0, import_jsx_runtime274.jsx)(
            import_components140.__experimentalToolsPanelItem,
            {
              hasValue: () => (0, import_components140.__experimentalIsDefinedBorder)(value?.border),
              label: (0, import_i18n135.__)("Border"),
              onDeselect: () => resetBorder(),
              isShownByDefault: showBorderByDefault,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime274.jsx)(
                import_components140.BorderBoxControl,
                {
                  colors: colors2,
                  enableAlpha: true,
                  enableStyle: showBorderStyle,
                  onChange: onBorderChange,
                  popoverOffset: 40,
                  popoverPlacement: "left-start",
                  value: border,
                  __experimentalIsRenderedInSidebar: true,
                  size: "__unstable-large",
                  hideLabelFromVision: !hasShadowControl,
                  label: (0, import_i18n135.__)("Border")
                }
              )
            }
          ),
          showBorderRadius && /* @__PURE__ */ (0, import_jsx_runtime274.jsx)(
            import_components140.__experimentalToolsPanelItem,
            {
              hasValue: hasBorderRadius,
              label: (0, import_i18n135.__)("Radius"),
              onDeselect: () => setBorderRadius(void 0),
              isShownByDefault: defaultControls.radius,
              panelId,
              children: /* @__PURE__ */ (0, import_jsx_runtime274.jsx)(
                BorderRadiusControl,
                {
                  presets: settings2?.border?.radiusSizes,
                  values: borderRadiusValues,
                  onChange: (newValue) => {
                    setBorderRadius(newValue || void 0);
                  }
                }
              )
            }
          ),
          hasShadowControl && /* @__PURE__ */ (0, import_jsx_runtime274.jsxs)(
            import_components140.__experimentalToolsPanelItem,
            {
              label: (0, import_i18n135.__)("Shadow"),
              hasValue: hasShadow,
              onDeselect: resetShadow,
              isShownByDefault: defaultControls.shadow,
              panelId,
              children: [
                hasBorderControl ? /* @__PURE__ */ (0, import_jsx_runtime274.jsx)(import_components140.BaseControl.VisualLabel, { as: "legend", children: (0, import_i18n135.__)("Shadow") }) : null,
                /* @__PURE__ */ (0, import_jsx_runtime274.jsx)(
                  ShadowPopover,
                  {
                    shadow,
                    onShadowChange: setShadow,
                    settings: settings2
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/color-panel.js
  var import_jsx_runtime276 = __toESM(require_jsx_runtime());
  var import_components142 = __toESM(require_components());
  var import_element146 = __toESM(require_element());
  var import_i18n137 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/colors-gradients/control.js
  var import_jsx_runtime275 = __toESM(require_jsx_runtime());
  var import_i18n136 = __toESM(require_i18n());
  var import_components141 = __toESM(require_components());
  var { Tabs: Tabs3 } = unlock(import_components141.privateApis);
  var colorsAndGradientKeys = [
    "colors",
    "disableCustomColors",
    "gradients",
    "disableCustomGradients"
  ];
  var TAB_IDS = { color: "color", gradient: "gradient" };
  function ColorGradientControlInner({
    colors: colors2,
    gradients,
    disableCustomColors,
    disableCustomGradients,
    __experimentalIsRenderedInSidebar,
    className,
    label,
    onColorChange,
    onGradientChange,
    colorValue,
    gradientValue,
    clearable,
    showTitle = true,
    enableAlpha,
    headingLevel
  }) {
    const canChooseAColor = onColorChange && (colors2 && colors2.length > 0 || !disableCustomColors);
    const canChooseAGradient = onGradientChange && (gradients && gradients.length > 0 || !disableCustomGradients);
    if (!canChooseAColor && !canChooseAGradient) {
      return null;
    }
    const tabPanels = {
      [TAB_IDS.color]: /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(
        import_components141.ColorPalette,
        {
          value: colorValue,
          onChange: canChooseAGradient ? (newColor) => {
            onColorChange(newColor);
            onGradientChange();
          } : onColorChange,
          ...{ colors: colors2, disableCustomColors },
          __experimentalIsRenderedInSidebar,
          clearable,
          enableAlpha,
          headingLevel
        }
      ),
      [TAB_IDS.gradient]: /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(
        import_components141.GradientPicker,
        {
          value: gradientValue,
          onChange: canChooseAColor ? (newGradient) => {
            onGradientChange(newGradient);
            onColorChange();
          } : onGradientChange,
          ...{ gradients, disableCustomGradients },
          __experimentalIsRenderedInSidebar,
          clearable,
          headingLevel
        }
      )
    };
    const renderPanelType = (type) => /* @__PURE__ */ (0, import_jsx_runtime275.jsx)("div", { className: "block-editor-color-gradient-control__panel", children: tabPanels[type] });
    return /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(
      import_components141.BaseControl,
      {
        __nextHasNoMarginBottom: true,
        className: clsx_default(
          "block-editor-color-gradient-control",
          className
        ),
        children: /* @__PURE__ */ (0, import_jsx_runtime275.jsx)("fieldset", { className: "block-editor-color-gradient-control__fieldset", children: /* @__PURE__ */ (0, import_jsx_runtime275.jsxs)(import_components141.__experimentalVStack, { spacing: 1, children: [
          showTitle && /* @__PURE__ */ (0, import_jsx_runtime275.jsx)("legend", { children: /* @__PURE__ */ (0, import_jsx_runtime275.jsx)("div", { className: "block-editor-color-gradient-control__color-indicator", children: /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(import_components141.BaseControl.VisualLabel, { children: label }) }) }),
          canChooseAColor && canChooseAGradient && /* @__PURE__ */ (0, import_jsx_runtime275.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime275.jsxs)(
            Tabs3,
            {
              defaultTabId: gradientValue ? TAB_IDS.gradient : !!canChooseAColor && TAB_IDS.color,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime275.jsxs)(Tabs3.TabList, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(Tabs3.Tab, { tabId: TAB_IDS.color, children: (0, import_i18n136.__)("Color") }),
                  /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(Tabs3.Tab, { tabId: TAB_IDS.gradient, children: (0, import_i18n136.__)("Gradient") })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(
                  Tabs3.TabPanel,
                  {
                    tabId: TAB_IDS.color,
                    className: "block-editor-color-gradient-control__panel",
                    focusable: false,
                    children: tabPanels.color
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(
                  Tabs3.TabPanel,
                  {
                    tabId: TAB_IDS.gradient,
                    className: "block-editor-color-gradient-control__panel",
                    focusable: false,
                    children: tabPanels.gradient
                  }
                )
              ]
            }
          ) }),
          !canChooseAGradient && renderPanelType(TAB_IDS.color),
          !canChooseAColor && renderPanelType(TAB_IDS.gradient)
        ] }) })
      }
    );
  }
  function ColorGradientControlSelect(props) {
    const [colors2, gradients, customColors, customGradients] = useSettings(
      "color.palette",
      "color.gradients",
      "color.custom",
      "color.customGradient"
    );
    return /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(
      ColorGradientControlInner,
      {
        colors: colors2,
        gradients,
        disableCustomColors: !customColors,
        disableCustomGradients: !customGradients,
        ...props
      }
    );
  }
  function ColorGradientControl(props) {
    if (colorsAndGradientKeys.every((key) => props.hasOwnProperty(key))) {
      return /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(ColorGradientControlInner, { ...props });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime275.jsx)(ColorGradientControlSelect, { ...props });
  }
  var control_default = ColorGradientControl;

  // packages/block-editor/build-module/components/global-styles/color-panel.js
  function useHasColorPanel(settings2) {
    const hasTextPanel = useHasTextPanel(settings2);
    const hasBackgroundPanel = useHasBackgroundColorPanel(settings2);
    const hasLinkPanel = useHasLinkPanel(settings2);
    const hasHeadingPanel = useHasHeadingPanel(settings2);
    const hasButtonPanel = useHasButtonPanel(settings2);
    const hasCaptionPanel = useHasCaptionPanel(settings2);
    return hasTextPanel || hasBackgroundPanel || hasLinkPanel || hasHeadingPanel || hasButtonPanel || hasCaptionPanel;
  }
  function useHasTextPanel(settings2) {
    const colors2 = useColorsPerOrigin(settings2);
    return settings2?.color?.text && (colors2?.length > 0 || settings2?.color?.custom);
  }
  function useHasLinkPanel(settings2) {
    const colors2 = useColorsPerOrigin(settings2);
    return settings2?.color?.link && (colors2?.length > 0 || settings2?.color?.custom);
  }
  function useHasCaptionPanel(settings2) {
    const colors2 = useColorsPerOrigin(settings2);
    return settings2?.color?.caption && (colors2?.length > 0 || settings2?.color?.custom);
  }
  function useHasHeadingPanel(settings2) {
    const colors2 = useColorsPerOrigin(settings2);
    const gradients = useGradientsPerOrigin(settings2);
    return settings2?.color?.heading && (colors2?.length > 0 || settings2?.color?.custom || gradients?.length > 0 || settings2?.color?.customGradient);
  }
  function useHasButtonPanel(settings2) {
    const colors2 = useColorsPerOrigin(settings2);
    const gradients = useGradientsPerOrigin(settings2);
    return settings2?.color?.button && (colors2?.length > 0 || settings2?.color?.custom || gradients?.length > 0 || settings2?.color?.customGradient);
  }
  function useHasBackgroundColorPanel(settings2) {
    const colors2 = useColorsPerOrigin(settings2);
    const gradients = useGradientsPerOrigin(settings2);
    return settings2?.color?.background && (colors2?.length > 0 || settings2?.color?.custom || gradients?.length > 0 || settings2?.color?.customGradient);
  }
  function ColorToolsPanel({
    resetAllFilter,
    onChange,
    value,
    panelId,
    children
  }) {
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const resetAll = () => {
      const updatedValue = resetAllFilter(value);
      onChange(updatedValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
      import_components142.__experimentalToolsPanel,
      {
        label: (0, import_i18n137.__)("Elements"),
        resetAll,
        panelId,
        hasInnerWrapper: true,
        headingLevel: 3,
        className: "color-block-support-panel",
        __experimentalFirstVisibleItemClass: "first",
        __experimentalLastVisibleItemClass: "last",
        dropdownMenuProps,
        children: /* @__PURE__ */ (0, import_jsx_runtime276.jsx)("div", { className: "color-block-support-panel__inner-wrapper", children })
      }
    );
  }
  var DEFAULT_CONTROLS6 = {
    text: true,
    background: true,
    link: true,
    heading: true,
    button: true,
    caption: true
  };
  var popoverProps = {
    placement: "left-start",
    offset: 36,
    shift: true,
    flip: true,
    resize: false
  };
  var { Tabs: Tabs4 } = unlock(import_components142.privateApis);
  var LabeledColorIndicators = ({ indicators, label }) => /* @__PURE__ */ (0, import_jsx_runtime276.jsxs)(import_components142.__experimentalHStack, { justify: "flex-start", children: [
    /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(import_components142.__experimentalZStack, { isLayered: false, offset: -8, children: indicators.map((indicator, index) => /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(import_components142.Flex, { expanded: false, children: /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(import_components142.ColorIndicator, { colorValue: indicator }) }, index)) }),
    /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(import_components142.FlexItem, { className: "block-editor-panel-color-gradient-settings__color-name", children: label })
  ] });
  function ColorPanelTab({
    isGradient,
    inheritedValue,
    userValue,
    setValue,
    colorGradientControlSettings
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
      control_default,
      {
        ...colorGradientControlSettings,
        showTitle: false,
        enableAlpha: true,
        __experimentalIsRenderedInSidebar: true,
        colorValue: isGradient ? void 0 : inheritedValue,
        gradientValue: isGradient ? inheritedValue : void 0,
        onColorChange: isGradient ? void 0 : setValue,
        onGradientChange: isGradient ? setValue : void 0,
        clearable: inheritedValue === userValue,
        headingLevel: 3
      }
    );
  }
  function ColorPanelDropdown({
    label,
    hasValue,
    resetValue,
    isShownByDefault,
    indicators,
    tabs,
    colorGradientControlSettings,
    panelId
  }) {
    const currentTab = tabs.find((tab) => tab.userValue !== void 0);
    const { key: firstTabKey, ...firstTab } = tabs[0] ?? {};
    const colorGradientDropdownButtonRef = (0, import_element146.useRef)(void 0);
    return /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
      import_components142.__experimentalToolsPanelItem,
      {
        className: "block-editor-tools-panel-color-gradient-settings__item",
        hasValue,
        label,
        onDeselect: resetValue,
        isShownByDefault,
        panelId,
        children: /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
          import_components142.Dropdown,
          {
            popoverProps,
            className: "block-editor-tools-panel-color-gradient-settings__dropdown",
            renderToggle: ({ onToggle, isOpen }) => {
              const toggleProps = {
                onClick: onToggle,
                className: clsx_default(
                  "block-editor-panel-color-gradient-settings__dropdown",
                  { "is-open": isOpen }
                ),
                "aria-expanded": isOpen,
                ref: colorGradientDropdownButtonRef
              };
              return /* @__PURE__ */ (0, import_jsx_runtime276.jsxs)(import_jsx_runtime276.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(import_components142.Button, { ...toggleProps, __next40pxDefaultSize: true, children: /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
                  LabeledColorIndicators,
                  {
                    indicators,
                    label
                  }
                ) }),
                hasValue() && /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
                  import_components142.Button,
                  {
                    __next40pxDefaultSize: true,
                    label: (0, import_i18n137.__)("Reset"),
                    className: "block-editor-panel-color-gradient-settings__reset",
                    size: "small",
                    icon: reset_default,
                    onClick: () => {
                      resetValue();
                      if (isOpen) {
                        onToggle();
                      }
                      colorGradientDropdownButtonRef.current?.focus();
                    }
                  }
                )
              ] });
            },
            renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(import_components142.__experimentalDropdownContentWrapper, { paddingSize: "none", children: /* @__PURE__ */ (0, import_jsx_runtime276.jsxs)("div", { className: "block-editor-panel-color-gradient-settings__dropdown-content", children: [
              tabs.length === 1 && /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
                ColorPanelTab,
                {
                  ...firstTab,
                  colorGradientControlSettings
                },
                firstTabKey
              ),
              tabs.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime276.jsxs)(Tabs4, { defaultTabId: currentTab?.key, children: [
                /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(Tabs4.TabList, { children: tabs.map((tab) => /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
                  Tabs4.Tab,
                  {
                    tabId: tab.key,
                    children: tab.label
                  },
                  tab.key
                )) }),
                tabs.map((tab) => {
                  const { key: tabKey, ...restTabProps } = tab;
                  return /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
                    Tabs4.TabPanel,
                    {
                      tabId: tabKey,
                      focusable: false,
                      children: /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
                        ColorPanelTab,
                        {
                          ...restTabProps,
                          colorGradientControlSettings
                        },
                        tabKey
                      )
                    },
                    tabKey
                  );
                })
              ] })
            ] }) })
          }
        )
      }
    );
  }
  function ColorPanel({
    as: Wrapper = ColorToolsPanel,
    value,
    onChange,
    inheritedValue = value,
    settings: settings2,
    panelId,
    defaultControls = DEFAULT_CONTROLS6,
    children
  }) {
    const colors2 = useColorsPerOrigin(settings2);
    const gradients = useGradientsPerOrigin(settings2);
    const areCustomSolidsEnabled = settings2?.color?.custom;
    const areCustomGradientsEnabled = settings2?.color?.customGradient;
    const hasSolidColors = colors2.length > 0 || areCustomSolidsEnabled;
    const hasGradientColors = gradients.length > 0 || areCustomGradientsEnabled;
    const decodeValue = (rawValue) => getValueFromVariable({ settings: settings2 }, "", rawValue);
    const encodeColorValue = (colorValue) => {
      const allColors = colors2.flatMap(
        ({ colors: originColors }) => originColors
      );
      const colorObject = allColors.find(
        ({ color }) => color === colorValue
      );
      return colorObject ? "var:preset|color|" + colorObject.slug : colorValue;
    };
    const encodeGradientValue = (gradientValue) => {
      const allGradients = gradients.flatMap(
        ({ gradients: originGradients }) => originGradients
      );
      const gradientObject = allGradients.find(
        ({ gradient: gradient2 }) => gradient2 === gradientValue
      );
      return gradientObject ? "var:preset|gradient|" + gradientObject.slug : gradientValue;
    };
    const showBackgroundPanel = useHasBackgroundColorPanel(settings2);
    const backgroundColor = decodeValue(inheritedValue?.color?.background);
    const userBackgroundColor = decodeValue(value?.color?.background);
    const gradient = decodeValue(inheritedValue?.color?.gradient);
    const userGradient = decodeValue(value?.color?.gradient);
    const hasBackground = () => !!userBackgroundColor || !!userGradient;
    const setBackgroundColor = (newColor) => {
      const newValue = setImmutably(
        value,
        ["color", "background"],
        encodeColorValue(newColor)
      );
      newValue.color.gradient = void 0;
      onChange(newValue);
    };
    const setGradient = (newGradient) => {
      const newValue = setImmutably(
        value,
        ["color", "gradient"],
        encodeGradientValue(newGradient)
      );
      newValue.color.background = void 0;
      onChange(newValue);
    };
    const resetBackground = () => {
      const newValue = setImmutably(
        value,
        ["color", "background"],
        void 0
      );
      newValue.color.gradient = void 0;
      onChange(newValue);
    };
    const showLinkPanel = useHasLinkPanel(settings2);
    const linkColor = decodeValue(
      inheritedValue?.elements?.link?.color?.text
    );
    const userLinkColor = decodeValue(value?.elements?.link?.color?.text);
    const setLinkColor = (newColor) => {
      onChange(
        setImmutably(
          value,
          ["elements", "link", "color", "text"],
          encodeColorValue(newColor)
        )
      );
    };
    const hoverLinkColor = decodeValue(
      inheritedValue?.elements?.link?.[":hover"]?.color?.text
    );
    const userHoverLinkColor = decodeValue(
      value?.elements?.link?.[":hover"]?.color?.text
    );
    const setHoverLinkColor = (newColor) => {
      onChange(
        setImmutably(
          value,
          ["elements", "link", ":hover", "color", "text"],
          encodeColorValue(newColor)
        )
      );
    };
    const hasLink = () => !!userLinkColor || !!userHoverLinkColor;
    const resetLink = () => {
      let newValue = setImmutably(
        value,
        ["elements", "link", ":hover", "color", "text"],
        void 0
      );
      newValue = setImmutably(
        newValue,
        ["elements", "link", "color", "text"],
        void 0
      );
      onChange(newValue);
    };
    const showTextPanel = useHasTextPanel(settings2);
    const textColor = decodeValue(inheritedValue?.color?.text);
    const userTextColor = decodeValue(value?.color?.text);
    const hasTextColor = () => !!userTextColor;
    const setTextColor = (newColor) => {
      let changedObject = setImmutably(
        value,
        ["color", "text"],
        encodeColorValue(newColor)
      );
      if (textColor === linkColor) {
        changedObject = setImmutably(
          changedObject,
          ["elements", "link", "color", "text"],
          encodeColorValue(newColor)
        );
      }
      onChange(changedObject);
    };
    const resetTextColor = () => setTextColor(void 0);
    const elements = [
      {
        name: "caption",
        label: (0, import_i18n137.__)("Captions"),
        showPanel: useHasCaptionPanel(settings2)
      },
      {
        name: "button",
        label: (0, import_i18n137.__)("Button"),
        showPanel: useHasButtonPanel(settings2)
      },
      {
        name: "heading",
        label: (0, import_i18n137.__)("Heading"),
        showPanel: useHasHeadingPanel(settings2)
      },
      {
        name: "h1",
        label: (0, import_i18n137.__)("H1"),
        showPanel: useHasHeadingPanel(settings2)
      },
      {
        name: "h2",
        label: (0, import_i18n137.__)("H2"),
        showPanel: useHasHeadingPanel(settings2)
      },
      {
        name: "h3",
        label: (0, import_i18n137.__)("H3"),
        showPanel: useHasHeadingPanel(settings2)
      },
      {
        name: "h4",
        label: (0, import_i18n137.__)("H4"),
        showPanel: useHasHeadingPanel(settings2)
      },
      {
        name: "h5",
        label: (0, import_i18n137.__)("H5"),
        showPanel: useHasHeadingPanel(settings2)
      },
      {
        name: "h6",
        label: (0, import_i18n137.__)("H6"),
        showPanel: useHasHeadingPanel(settings2)
      }
    ];
    const resetAllFilter = (0, import_element146.useCallback)((previousValue) => {
      return {
        ...previousValue,
        color: void 0,
        elements: {
          ...previousValue?.elements,
          link: {
            ...previousValue?.elements?.link,
            color: void 0,
            ":hover": {
              color: void 0
            }
          },
          ...elements.reduce((acc, element) => {
            return {
              ...acc,
              [element.name]: {
                ...previousValue?.elements?.[element.name],
                color: void 0
              }
            };
          }, {})
        }
      };
    }, []);
    const items = [
      showTextPanel && {
        key: "text",
        label: (0, import_i18n137.__)("Text"),
        hasValue: hasTextColor,
        resetValue: resetTextColor,
        isShownByDefault: defaultControls.text,
        indicators: [textColor],
        tabs: [
          {
            key: "text",
            label: (0, import_i18n137.__)("Text"),
            inheritedValue: textColor,
            setValue: setTextColor,
            userValue: userTextColor
          }
        ]
      },
      showBackgroundPanel && {
        key: "background",
        label: (0, import_i18n137.__)("Background"),
        hasValue: hasBackground,
        resetValue: resetBackground,
        isShownByDefault: defaultControls.background,
        indicators: [gradient ?? backgroundColor],
        tabs: [
          hasSolidColors && {
            key: "background",
            label: (0, import_i18n137.__)("Color"),
            inheritedValue: backgroundColor,
            setValue: setBackgroundColor,
            userValue: userBackgroundColor
          },
          hasGradientColors && {
            key: "gradient",
            label: (0, import_i18n137.__)("Gradient"),
            inheritedValue: gradient,
            setValue: setGradient,
            userValue: userGradient,
            isGradient: true
          }
        ].filter(Boolean)
      },
      showLinkPanel && {
        key: "link",
        label: (0, import_i18n137.__)("Link"),
        hasValue: hasLink,
        resetValue: resetLink,
        isShownByDefault: defaultControls.link,
        indicators: [linkColor, hoverLinkColor],
        tabs: [
          {
            key: "link",
            label: (0, import_i18n137.__)("Default"),
            inheritedValue: linkColor,
            setValue: setLinkColor,
            userValue: userLinkColor
          },
          {
            key: "hover",
            label: (0, import_i18n137.__)("Hover"),
            inheritedValue: hoverLinkColor,
            setValue: setHoverLinkColor,
            userValue: userHoverLinkColor
          }
        ]
      }
    ].filter(Boolean);
    elements.forEach(({ name, label, showPanel }) => {
      if (!showPanel) {
        return;
      }
      const elementBackgroundColor = decodeValue(
        inheritedValue?.elements?.[name]?.color?.background
      );
      const elementGradient = decodeValue(
        inheritedValue?.elements?.[name]?.color?.gradient
      );
      const elementTextColor = decodeValue(
        inheritedValue?.elements?.[name]?.color?.text
      );
      const elementBackgroundUserColor = decodeValue(
        value?.elements?.[name]?.color?.background
      );
      const elementGradientUserColor = decodeValue(
        value?.elements?.[name]?.color?.gradient
      );
      const elementTextUserColor = decodeValue(
        value?.elements?.[name]?.color?.text
      );
      const hasElement = () => !!(elementTextUserColor || elementBackgroundUserColor || elementGradientUserColor);
      const resetElement = () => {
        const newValue = setImmutably(
          value,
          ["elements", name, "color", "background"],
          void 0
        );
        newValue.elements[name].color.gradient = void 0;
        newValue.elements[name].color.text = void 0;
        onChange(newValue);
      };
      const setElementTextColor = (newTextColor) => {
        onChange(
          setImmutably(
            value,
            ["elements", name, "color", "text"],
            encodeColorValue(newTextColor)
          )
        );
      };
      const setElementBackgroundColor = (newBackgroundColor) => {
        const newValue = setImmutably(
          value,
          ["elements", name, "color", "background"],
          encodeColorValue(newBackgroundColor)
        );
        newValue.elements[name].color.gradient = void 0;
        onChange(newValue);
      };
      const setElementGradient = (newGradient) => {
        const newValue = setImmutably(
          value,
          ["elements", name, "color", "gradient"],
          encodeGradientValue(newGradient)
        );
        newValue.elements[name].color.background = void 0;
        onChange(newValue);
      };
      const supportsTextColor = true;
      const supportsBackground = name !== "caption";
      items.push({
        key: name,
        label,
        hasValue: hasElement,
        resetValue: resetElement,
        isShownByDefault: defaultControls[name],
        indicators: supportsTextColor && supportsBackground ? [
          elementTextColor,
          elementGradient ?? elementBackgroundColor
        ] : [
          supportsTextColor ? elementTextColor : elementGradient ?? elementBackgroundColor
        ],
        tabs: [
          hasSolidColors && supportsTextColor && {
            key: "text",
            label: (0, import_i18n137.__)("Text"),
            inheritedValue: elementTextColor,
            setValue: setElementTextColor,
            userValue: elementTextUserColor
          },
          hasSolidColors && supportsBackground && {
            key: "background",
            label: (0, import_i18n137.__)("Background"),
            inheritedValue: elementBackgroundColor,
            setValue: setElementBackgroundColor,
            userValue: elementBackgroundUserColor
          },
          hasGradientColors && supportsBackground && {
            key: "gradient",
            label: (0, import_i18n137.__)("Gradient"),
            inheritedValue: elementGradient,
            setValue: setElementGradient,
            userValue: elementGradientUserColor,
            isGradient: true
          }
        ].filter(Boolean)
      });
    });
    return /* @__PURE__ */ (0, import_jsx_runtime276.jsxs)(
      Wrapper,
      {
        resetAllFilter,
        value,
        onChange,
        panelId,
        children: [
          items.map((item) => {
            const { key, ...restItem } = item;
            return /* @__PURE__ */ (0, import_jsx_runtime276.jsx)(
              ColorPanelDropdown,
              {
                ...restItem,
                colorGradientControlSettings: {
                  colors: colors2,
                  disableCustomColors: !areCustomSolidsEnabled,
                  gradients,
                  disableCustomGradients: !areCustomGradientsEnabled
                },
                panelId
              },
              key
            );
          }),
          children
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/filters-panel.js
  var import_jsx_runtime277 = __toESM(require_jsx_runtime());
  var import_components143 = __toESM(require_components());
  var import_i18n138 = __toESM(require_i18n());
  var import_element147 = __toESM(require_element());
  var EMPTY_ARRAY12 = [];
  function useMultiOriginColorPresets(settings2, { presetSetting, defaultSetting }) {
    const disableDefault = !settings2?.color?.[defaultSetting];
    const userPresets = settings2?.color?.[presetSetting]?.custom || EMPTY_ARRAY12;
    const themePresets = settings2?.color?.[presetSetting]?.theme || EMPTY_ARRAY12;
    const defaultPresets = settings2?.color?.[presetSetting]?.default || EMPTY_ARRAY12;
    return (0, import_element147.useMemo)(
      () => [
        ...userPresets,
        ...themePresets,
        ...disableDefault ? EMPTY_ARRAY12 : defaultPresets
      ],
      [disableDefault, userPresets, themePresets, defaultPresets]
    );
  }
  function useHasFiltersPanel(settings2) {
    return useHasDuotoneControl(settings2);
  }
  function useHasDuotoneControl(settings2) {
    return settings2.color.customDuotone || settings2.color.defaultDuotone || settings2.color.duotone.length > 0;
  }
  function FiltersToolsPanel({
    resetAllFilter,
    onChange,
    value,
    panelId,
    children
  }) {
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const resetAll = () => {
      const updatedValue = resetAllFilter(value);
      onChange(updatedValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(
      import_components143.__experimentalToolsPanel,
      {
        label: (0, import_i18n138._x)("Filters", "Name for applying graphical effects"),
        resetAll,
        panelId,
        dropdownMenuProps,
        children
      }
    );
  }
  var DEFAULT_CONTROLS7 = {
    duotone: true
  };
  var popoverProps2 = {
    placement: "left-start",
    offset: 36,
    shift: true,
    className: "block-editor-duotone-control__popover",
    headerTitle: (0, import_i18n138.__)("Duotone")
  };
  var LabeledColorIndicator = ({ indicator, label }) => /* @__PURE__ */ (0, import_jsx_runtime277.jsxs)(import_components143.__experimentalHStack, { justify: "flex-start", children: [
    /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(import_components143.__experimentalZStack, { isLayered: false, offset: -8, children: /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(import_components143.Flex, { expanded: false, children: indicator === "unset" || !indicator ? /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(import_components143.ColorIndicator, { className: "block-editor-duotone-control__unset-indicator" }) : /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(import_components143.DuotoneSwatch, { values: indicator }) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(import_components143.FlexItem, { title: label, children: label })
  ] });
  var renderToggle = (duotone, resetDuotone) => ({ onToggle, isOpen }) => {
    const duotoneButtonRef = (0, import_element147.useRef)(void 0);
    const toggleProps = {
      onClick: onToggle,
      className: clsx_default(
        "block-editor-global-styles-filters-panel__dropdown-toggle",
        { "is-open": isOpen }
      ),
      "aria-expanded": isOpen,
      ref: duotoneButtonRef
    };
    const removeButtonProps = {
      onClick: () => {
        if (isOpen) {
          onToggle();
        }
        resetDuotone();
        duotoneButtonRef.current?.focus();
      },
      className: "block-editor-panel-duotone-settings__reset",
      label: (0, import_i18n138.__)("Reset")
    };
    return /* @__PURE__ */ (0, import_jsx_runtime277.jsxs)(import_jsx_runtime277.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(import_components143.Button, { __next40pxDefaultSize: true, ...toggleProps, children: /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(
        LabeledColorIndicator,
        {
          indicator: duotone,
          label: (0, import_i18n138.__)("Duotone")
        }
      ) }),
      duotone && /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(
        import_components143.Button,
        {
          size: "small",
          icon: reset_default,
          ...removeButtonProps
        }
      )
    ] });
  };
  function FiltersPanel({
    as: Wrapper = FiltersToolsPanel,
    value,
    onChange,
    inheritedValue = value,
    settings: settings2,
    panelId,
    defaultControls = DEFAULT_CONTROLS7
  }) {
    const decodeValue = (rawValue) => getValueFromVariable({ settings: settings2 }, "", rawValue);
    const hasDuotoneEnabled = useHasDuotoneControl(settings2);
    const duotonePalette = useMultiOriginColorPresets(settings2, {
      presetSetting: "duotone",
      defaultSetting: "defaultDuotone"
    });
    const colorPalette = useMultiOriginColorPresets(settings2, {
      presetSetting: "palette",
      defaultSetting: "defaultPalette"
    });
    const duotone = decodeValue(inheritedValue?.filter?.duotone);
    const setDuotone = (newValue) => {
      const duotonePreset = duotonePalette.find(({ colors: colors2 }) => {
        return colors2 === newValue;
      });
      const duotoneValue = duotonePreset ? `var:preset|duotone|${duotonePreset.slug}` : newValue;
      onChange(
        setImmutably(value, ["filter", "duotone"], duotoneValue)
      );
    };
    const hasDuotone = () => !!value?.filter?.duotone;
    const resetDuotone = () => setDuotone(void 0);
    const resetAllFilter = (0, import_element147.useCallback)((previousValue) => {
      return {
        ...previousValue,
        filter: {
          ...previousValue.filter,
          duotone: void 0
        }
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(
      Wrapper,
      {
        resetAllFilter,
        value,
        onChange,
        panelId,
        children: hasDuotoneEnabled && /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(
          import_components143.__experimentalToolsPanelItem,
          {
            label: (0, import_i18n138.__)("Duotone"),
            hasValue: hasDuotone,
            onDeselect: resetDuotone,
            isShownByDefault: defaultControls.duotone,
            panelId,
            children: /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(
              import_components143.Dropdown,
              {
                popoverProps: popoverProps2,
                className: "block-editor-global-styles-filters-panel__dropdown",
                renderToggle: renderToggle(duotone, resetDuotone),
                renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(import_components143.__experimentalDropdownContentWrapper, { paddingSize: "small", children: /* @__PURE__ */ (0, import_jsx_runtime277.jsxs)(import_components143.MenuGroup, { label: (0, import_i18n138.__)("Duotone"), children: [
                  /* @__PURE__ */ (0, import_jsx_runtime277.jsx)("p", { children: (0, import_i18n138.__)(
                    "Create a two-tone color effect without losing your original image."
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime277.jsx)(
                    import_components143.DuotonePicker,
                    {
                      colorPalette,
                      duotonePalette,
                      disableCustomColors: true,
                      disableCustomDuotone: true,
                      value: duotone,
                      onChange: setDuotone
                    }
                  )
                ] }) })
              }
            )
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/global-styles/image-settings-panel.js
  var import_jsx_runtime278 = __toESM(require_jsx_runtime());
  var import_components144 = __toESM(require_components());
  var import_i18n139 = __toESM(require_i18n());
  function useHasImageSettingsPanel(name, value, inheritedValue) {
    return name === "core/image" && inheritedValue?.lightbox?.allowEditing || !!value?.lightbox;
  }
  function ImageSettingsPanel({
    onChange,
    value,
    inheritedValue,
    panelId
  }) {
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    const resetLightbox = () => {
      onChange(void 0);
    };
    const onChangeLightbox = (newSetting) => {
      onChange({
        enabled: newSetting
      });
    };
    let lightboxChecked = false;
    if (inheritedValue?.lightbox?.enabled) {
      lightboxChecked = inheritedValue.lightbox.enabled;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime278.jsx)(import_jsx_runtime278.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime278.jsx)(
      import_components144.__experimentalToolsPanel,
      {
        label: (0, import_i18n139._x)("Settings", "Image settings"),
        resetAll: resetLightbox,
        panelId,
        dropdownMenuProps,
        children: /* @__PURE__ */ (0, import_jsx_runtime278.jsx)(
          import_components144.__experimentalToolsPanelItem,
          {
            hasValue: () => !!value?.lightbox,
            label: (0, import_i18n139.__)("Enlarge on click"),
            onDeselect: resetLightbox,
            isShownByDefault: true,
            panelId,
            children: /* @__PURE__ */ (0, import_jsx_runtime278.jsx)(
              import_components144.ToggleControl,
              {
                __nextHasNoMarginBottom: true,
                label: (0, import_i18n139.__)("Enlarge on click"),
                checked: lightboxChecked,
                onChange: onChangeLightbox
              }
            )
          }
        )
      }
    ) });
  }

  // packages/block-editor/build-module/components/global-styles/advanced-panel.js
  var import_jsx_runtime279 = __toESM(require_jsx_runtime());
  var import_components145 = __toESM(require_components());
  var import_element148 = __toESM(require_element());
  var import_i18n140 = __toESM(require_i18n());
  function AdvancedPanel({
    value,
    onChange,
    inheritedValue = value
  }) {
    const [cssError, setCSSError] = (0, import_element148.useState)(null);
    const customCSS = inheritedValue?.css;
    function handleOnChange(newValue) {
      onChange({
        ...value,
        css: newValue
      });
      if (cssError) {
        const [transformed] = transform_styles_default(
          [{ css: newValue }],
          ".for-validation-only"
        );
        if (transformed) {
          setCSSError(null);
        }
      }
    }
    function handleOnBlur(event) {
      if (!event?.target?.value) {
        setCSSError(null);
        return;
      }
      const [transformed] = transform_styles_default(
        [{ css: event.target.value }],
        ".for-validation-only"
      );
      setCSSError(
        transformed === null ? (0, import_i18n140.__)("There is an error with your CSS structure.") : null
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime279.jsxs)(import_components145.__experimentalVStack, { spacing: 3, children: [
      cssError && /* @__PURE__ */ (0, import_jsx_runtime279.jsx)(import_components145.Notice, { status: "error", onRemove: () => setCSSError(null), children: cssError }),
      /* @__PURE__ */ (0, import_jsx_runtime279.jsx)(
        import_components145.TextareaControl,
        {
          label: (0, import_i18n140.__)("Additional CSS"),
          __nextHasNoMarginBottom: true,
          value: customCSS,
          onChange: (newValue) => handleOnChange(newValue),
          onBlur: handleOnBlur,
          className: "block-editor-global-styles-advanced-panel__custom-css-input",
          spellCheck: false
        }
      )
    ] });
  }

  // node_modules/memize/dist/index.js
  function memize(fn, options) {
    var size = 0;
    var head;
    var tail;
    options = options || {};
    function memoized() {
      var node2 = head, len = arguments.length, args, i2;
      searchCache: while (node2) {
        if (node2.args.length !== arguments.length) {
          node2 = node2.next;
          continue;
        }
        for (i2 = 0; i2 < len; i2++) {
          if (node2.args[i2] !== arguments[i2]) {
            node2 = node2.next;
            continue searchCache;
          }
        }
        if (node2 !== head) {
          if (node2 === tail) {
            tail = node2.prev;
          }
          node2.prev.next = node2.next;
          if (node2.next) {
            node2.next.prev = node2.prev;
          }
          node2.next = head;
          node2.prev = null;
          head.prev = node2;
          head = node2;
        }
        return node2.val;
      }
      args = new Array(len);
      for (i2 = 0; i2 < len; i2++) {
        args[i2] = arguments[i2];
      }
      node2 = {
        args,
        // Generate the result from original function
        val: fn.apply(null, args)
      };
      if (head) {
        head.prev = node2;
        node2.next = head;
      } else {
        tail = node2;
      }
      if (size === /** @type {MemizeOptions} */
      options.maxSize) {
        tail = /** @type {MemizeCacheNode} */
        tail.prev;
        tail.next = null;
      } else {
        size++;
      }
      head = node2;
      return node2.val;
    }
    memoized.clear = function() {
      head = null;
      tail = null;
      size = 0;
    };
    return memoized;
  }

  // packages/block-editor/build-module/components/global-styles/get-global-styles-changes.js
  var import_i18n141 = __toESM(require_i18n());
  var import_blocks70 = __toESM(require_blocks());
  var globalStylesChangesCache = /* @__PURE__ */ new Map();
  var EMPTY_ARRAY13 = [];
  var translationMap = {
    caption: (0, import_i18n141.__)("Caption"),
    link: (0, import_i18n141.__)("Link"),
    button: (0, import_i18n141.__)("Button"),
    heading: (0, import_i18n141.__)("Heading"),
    h1: (0, import_i18n141.__)("H1"),
    h2: (0, import_i18n141.__)("H2"),
    h3: (0, import_i18n141.__)("H3"),
    h4: (0, import_i18n141.__)("H4"),
    h5: (0, import_i18n141.__)("H5"),
    h6: (0, import_i18n141.__)("H6"),
    "settings.color": (0, import_i18n141.__)("Color"),
    "settings.typography": (0, import_i18n141.__)("Typography"),
    "settings.shadow": (0, import_i18n141.__)("Shadow"),
    "settings.layout": (0, import_i18n141.__)("Layout"),
    "styles.color": (0, import_i18n141.__)("Colors"),
    "styles.spacing": (0, import_i18n141.__)("Spacing"),
    "styles.background": (0, import_i18n141.__)("Background"),
    "styles.typography": (0, import_i18n141.__)("Typography")
  };
  var getBlockNames = memize(
    () => (0, import_blocks70.getBlockTypes)().reduce((accumulator, { name, title }) => {
      accumulator[name] = title;
      return accumulator;
    }, {})
  );
  var isObject = (obj) => obj !== null && typeof obj === "object";
  function getTranslation(key) {
    if (translationMap[key]) {
      return translationMap[key];
    }
    const keyArray = key.split(".");
    if (keyArray?.[0] === "blocks") {
      const blockName = getBlockNames()?.[keyArray[1]];
      return blockName || keyArray[1];
    }
    if (keyArray?.[0] === "elements") {
      return translationMap[keyArray[1]] || keyArray[1];
    }
    return void 0;
  }
  function deepCompare(changedObject, originalObject, parentPath = "") {
    if (!isObject(changedObject) && !isObject(originalObject)) {
      return changedObject !== originalObject ? parentPath.split(".").slice(0, 2).join(".") : void 0;
    }
    changedObject = isObject(changedObject) ? changedObject : {};
    originalObject = isObject(originalObject) ? originalObject : {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(changedObject),
      ...Object.keys(originalObject)
    ]);
    let diffs = [];
    for (const key of allKeys) {
      const path = parentPath ? parentPath + "." + key : key;
      const changedPath = deepCompare(
        changedObject[key],
        originalObject[key],
        path
      );
      if (changedPath) {
        diffs = diffs.concat(changedPath);
      }
    }
    return diffs;
  }
  function getGlobalStylesChangelist(next2, previous) {
    const cacheKey2 = JSON.stringify({ next: next2, previous });
    if (globalStylesChangesCache.has(cacheKey2)) {
      return globalStylesChangesCache.get(cacheKey2);
    }
    const changedValueTree = deepCompare(
      {
        styles: {
          background: next2?.styles?.background,
          color: next2?.styles?.color,
          typography: next2?.styles?.typography,
          spacing: next2?.styles?.spacing
        },
        blocks: next2?.styles?.blocks,
        elements: next2?.styles?.elements,
        settings: next2?.settings
      },
      {
        styles: {
          background: previous?.styles?.background,
          color: previous?.styles?.color,
          typography: previous?.styles?.typography,
          spacing: previous?.styles?.spacing
        },
        blocks: previous?.styles?.blocks,
        elements: previous?.styles?.elements,
        settings: previous?.settings
      }
    );
    if (!changedValueTree.length) {
      globalStylesChangesCache.set(cacheKey2, EMPTY_ARRAY13);
      return EMPTY_ARRAY13;
    }
    const result = [...new Set(changedValueTree)].reduce((acc, curr) => {
      const translation = getTranslation(curr);
      if (translation) {
        acc.push([curr.split(".")[0], translation]);
      }
      return acc;
    }, []);
    globalStylesChangesCache.set(cacheKey2, result);
    return result;
  }
  function getGlobalStylesChanges(next2, previous, options = {}) {
    let changeList = getGlobalStylesChangelist(next2, previous);
    const changesLength = changeList.length;
    const { maxResults } = options;
    if (changesLength) {
      if (!!maxResults && changesLength > maxResults) {
        changeList = changeList.slice(0, maxResults);
      }
      return Object.entries(
        changeList.reduce((acc, curr) => {
          const group = acc[curr[0]] || [];
          if (!group.includes(curr[1])) {
            acc[curr[0]] = [...group, curr[1]];
          }
          return acc;
        }, {})
      ).map(([key, changeValues]) => {
        const changeValuesLength = changeValues.length;
        const joinedChangesValue = changeValues.join(
          /* translators: Used between list items, there is a space after the comma. */
          (0, import_i18n141.__)(", ")
          // eslint-disable-line @wordpress/i18n-no-flanking-whitespace
        );
        switch (key) {
          case "blocks": {
            return (0, import_i18n141.sprintf)(
              // translators: %s: a list of block names separated by a comma.
              (0, import_i18n141._n)("%s block.", "%s blocks.", changeValuesLength),
              joinedChangesValue
            );
          }
          case "elements": {
            return (0, import_i18n141.sprintf)(
              // translators: %s: a list of element names separated by a comma.
              (0, import_i18n141._n)("%s element.", "%s elements.", changeValuesLength),
              joinedChangesValue
            );
          }
          case "settings": {
            return (0, import_i18n141.sprintf)(
              // translators: %s: a list of theme.json setting labels separated by a comma.
              (0, import_i18n141.__)("%s settings."),
              joinedChangesValue
            );
          }
          case "styles": {
            return (0, import_i18n141.sprintf)(
              // translators: %s: a list of theme.json top-level styles labels separated by a comma.
              (0, import_i18n141.__)("%s styles."),
              joinedChangesValue
            );
          }
          default: {
            return (0, import_i18n141.sprintf)(
              // translators: %s: a list of global styles changes separated by a comma.
              (0, import_i18n141.__)("%s."),
              joinedChangesValue
            );
          }
        }
      });
    }
    return EMPTY_ARRAY13;
  }

  // packages/block-editor/build-module/hooks/block-style-variation.js
  var import_jsx_runtime280 = __toESM(require_jsx_runtime());
  var import_blocks71 = __toESM(require_blocks());
  var import_data120 = __toESM(require_data());
  var import_element149 = __toESM(require_element());
  var VARIATION_PREFIX = "is-style-";
  function getVariationMatches(className) {
    if (!className) {
      return [];
    }
    return className.split(/\s+/).reduce((matches, name) => {
      if (name.startsWith(VARIATION_PREFIX)) {
        const match2 = name.slice(VARIATION_PREFIX.length);
        if (match2 !== "default") {
          matches.push(match2);
        }
      }
      return matches;
    }, []);
  }
  function getVariationNameFromClass(className, registeredStyles = []) {
    const matches = getVariationMatches(className);
    if (!matches) {
      return null;
    }
    for (const variation of matches) {
      if (registeredStyles.some((style) => style.name === variation)) {
        return variation;
      }
    }
    return null;
  }
  function OverrideStyles({ override }) {
    usePrivateStyleOverride(override);
  }
  function __unstableBlockStyleVariationOverridesWithConfig({ config: config2 }) {
    const { getBlockStyles: getBlockStyles2, overrides } = (0, import_data120.useSelect)(
      (select2) => ({
        getBlockStyles: select2(import_blocks71.store).getBlockStyles,
        overrides: unlock(select2(store)).getStyleOverrides()
      }),
      []
    );
    const { getBlockName: getBlockName2 } = (0, import_data120.useSelect)(store);
    const overridesWithConfig = (0, import_element149.useMemo)(() => {
      if (!overrides?.length) {
        return;
      }
      const newOverrides = [];
      const overriddenClientIds = [];
      for (const [, override] of overrides) {
        if (override?.variation && override?.clientId && /*
        * Because this component overwrites existing style overrides,
        * filter out any overrides that are already present in the store.
        */
        !overriddenClientIds.includes(override.clientId)) {
          const blockName = getBlockName2(override.clientId);
          const configStyles = config2?.styles?.blocks?.[blockName]?.variations?.[override.variation];
          if (configStyles) {
            const variationConfig = {
              settings: config2?.settings,
              // The variation style data is all that is needed to generate
              // the styles for the current application to a block. The variation
              // name is updated to match the instance specific class name.
              styles: {
                blocks: {
                  [blockName]: {
                    variations: {
                      [`${override.variation}-${override.clientId}`]: configStyles
                    }
                  }
                }
              }
            };
            const blockSelectors = getBlockSelectors(
              (0, import_blocks71.getBlockTypes)(),
              getBlockStyles2,
              override.clientId
            );
            const hasBlockGapSupport = false;
            const hasFallbackGapSupport = true;
            const disableLayoutStyles = true;
            const disableRootPadding = true;
            const variationStyles = toStyles(
              variationConfig,
              blockSelectors,
              hasBlockGapSupport,
              hasFallbackGapSupport,
              disableLayoutStyles,
              disableRootPadding,
              {
                blockGap: false,
                blockStyles: true,
                layoutStyles: false,
                marginReset: false,
                presets: false,
                rootPadding: false,
                variationStyles: true
              }
            );
            newOverrides.push({
              id: `${override.variation}-${override.clientId}`,
              css: variationStyles,
              __unstableType: "variation",
              variation: override.variation,
              // The clientId will be stored with the override and used to ensure
              // the order of overrides matches the order of blocks so that the
              // correct CSS cascade is maintained.
              clientId: override.clientId
            });
            overriddenClientIds.push(override.clientId);
          }
        }
      }
      return newOverrides;
    }, [config2, overrides, getBlockStyles2, getBlockName2]);
    if (!overridesWithConfig || !overridesWithConfig.length) {
      return;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime280.jsx)(import_jsx_runtime280.Fragment, { children: overridesWithConfig.map((override) => /* @__PURE__ */ (0, import_jsx_runtime280.jsx)(OverrideStyles, { override }, override.id)) });
  }
  function getVariationStylesWithRefValues(globalStyles, name, variation) {
    if (!globalStyles?.styles?.blocks?.[name]?.variations?.[variation]) {
      return;
    }
    const replaceRefs = (variationStyles) => {
      Object.keys(variationStyles).forEach((key) => {
        const value = variationStyles[key];
        if (typeof value === "object" && value !== null) {
          if (value.ref !== void 0) {
            if (typeof value.ref !== "string" || value.ref.trim() === "") {
              delete variationStyles[key];
            } else {
              const refValue = getValueFromObjectPath(
                globalStyles,
                value.ref
              );
              if (refValue) {
                variationStyles[key] = refValue;
              } else {
                delete variationStyles[key];
              }
            }
          } else {
            replaceRefs(value);
            if (Object.keys(value).length === 0) {
              delete variationStyles[key];
            }
          }
        }
      });
    };
    const styles = JSON.parse(
      JSON.stringify(
        globalStyles.styles.blocks[name].variations[variation]
      )
    );
    replaceRefs(styles);
    return styles;
  }
  function useBlockStyleVariation(name, variation, clientId) {
    const { merged: mergedConfig } = (0, import_element149.useContext)(GlobalStylesContext);
    const { globalSettings, globalStyles } = (0, import_data120.useSelect)((select2) => {
      const settings2 = select2(store).getSettings();
      return {
        globalSettings: settings2.__experimentalFeatures,
        globalStyles: settings2[globalStylesDataKey]
      };
    }, []);
    return (0, import_element149.useMemo)(() => {
      const variationStyles = getVariationStylesWithRefValues(
        {
          settings: mergedConfig?.settings ?? globalSettings,
          styles: mergedConfig?.styles ?? globalStyles
        },
        name,
        variation
      );
      return {
        settings: mergedConfig?.settings ?? globalSettings,
        // The variation style data is all that is needed to generate
        // the styles for the current application to a block. The variation
        // name is updated to match the instance specific class name.
        styles: {
          blocks: {
            [name]: {
              variations: {
                [`${variation}-${clientId}`]: variationStyles
              }
            }
          }
        }
      };
    }, [
      mergedConfig,
      globalSettings,
      globalStyles,
      variation,
      clientId,
      name
    ]);
  }
  function useBlockProps5({ name, className, clientId }) {
    const { getBlockStyles: getBlockStyles2 } = (0, import_data120.useSelect)(import_blocks71.store);
    const registeredStyles = getBlockStyles2(name);
    const variation = getVariationNameFromClass(className, registeredStyles);
    const variationClass = `${VARIATION_PREFIX}${variation}-${clientId}`;
    const { settings: settings2, styles } = useBlockStyleVariation(
      name,
      variation,
      clientId
    );
    const variationStyles = (0, import_element149.useMemo)(() => {
      if (!variation) {
        return;
      }
      const variationConfig = { settings: settings2, styles };
      const blockSelectors = getBlockSelectors(
        (0, import_blocks71.getBlockTypes)(),
        getBlockStyles2,
        clientId
      );
      const hasBlockGapSupport = false;
      const hasFallbackGapSupport = true;
      const disableLayoutStyles = true;
      const disableRootPadding = true;
      return toStyles(
        variationConfig,
        blockSelectors,
        hasBlockGapSupport,
        hasFallbackGapSupport,
        disableLayoutStyles,
        disableRootPadding,
        {
          blockGap: false,
          blockStyles: true,
          layoutStyles: false,
          marginReset: false,
          presets: false,
          rootPadding: false,
          variationStyles: true
        }
      );
    }, [variation, settings2, styles, getBlockStyles2, clientId]);
    usePrivateStyleOverride({
      id: `variation-${clientId}`,
      css: variationStyles,
      __unstableType: "variation",
      variation,
      // The clientId will be stored with the override and used to ensure
      // the order of overrides matches the order of blocks so that the
      // correct CSS cascade is maintained.
      clientId
    });
    return variation ? { className: variationClass } : {};
  }
  var block_style_variation_default = {
    hasSupport: () => true,
    attributeKeys: ["className"],
    isMatch: ({ className }) => getVariationMatches(className).length > 0,
    useBlockProps: useBlockProps5
  };

  // packages/block-editor/build-module/components/block-toolbar/switch-section-style.js
  var styleIcon = /* @__PURE__ */ (0, import_jsx_runtime281.jsxs)(
    import_components146.SVG,
    {
      viewBox: "0 0 24 24",
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      "aria-hidden": "true",
      focusable: "false",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime281.jsx)(import_components146.Path, { d: "M17.2 10.9c-.5-1-1.2-2.1-2.1-3.2-.6-.9-1.3-1.7-2.1-2.6L12 4l-1 1.1c-.6.9-1.3 1.7-2 2.6-.8 1.2-1.5 2.3-2 3.2-.6 1.2-1 2.2-1 3 0 3.4 2.7 6.1 6.1 6.1s6.1-2.7 6.1-6.1c0-.8-.3-1.8-1-3z" }),
        /* @__PURE__ */ (0, import_jsx_runtime281.jsx)(
          import_components146.Path,
          {
            stroke: "currentColor",
            strokeWidth: "1.5",
            d: "M17.2 10.9c-.5-1-1.2-2.1-2.1-3.2-.6-.9-1.3-1.7-2.1-2.6L12 4l-1 1.1c-.6.9-1.3 1.7-2 2.6-.8 1.2-1.5 2.3-2 3.2-.6 1.2-1 2.2-1 3 0 3.4 2.7 6.1 6.1 6.1s6.1-2.7 6.1-6.1c0-.8-.3-1.8-1-3z"
          }
        )
      ]
    }
  );
  function SwitchSectionStyle({ clientId }) {
    const { stylesToRender, activeStyle, className } = useStylesForBlocks({
      clientId
    });
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data121.useDispatch)(store);
    const { merged: mergedConfig } = (0, import_element150.useContext)(GlobalStylesContext);
    const { globalSettings, globalStyles, blockName } = (0, import_data121.useSelect)(
      (select2) => {
        const settings2 = select2(store).getSettings();
        return {
          globalSettings: settings2.__experimentalFeatures,
          globalStyles: settings2[globalStylesDataKey],
          blockName: select2(store).getBlockName(clientId)
        };
      },
      [clientId]
    );
    const activeStyleBackground = activeStyle?.name ? getVariationStylesWithRefValues(
      {
        settings: mergedConfig?.settings ?? globalSettings,
        styles: mergedConfig?.styles ?? globalStyles
      },
      blockName,
      activeStyle.name
    )?.color?.background : void 0;
    if (!stylesToRender || stylesToRender.length === 0) {
      return null;
    }
    const handleStyleSwitch = () => {
      const currentIndex = stylesToRender.findIndex(
        (style) => style.name === activeStyle.name
      );
      const nextIndex = (currentIndex + 1) % stylesToRender.length;
      const nextStyle = stylesToRender[nextIndex];
      const styleClassName = replaceActiveStyle(
        className,
        activeStyle,
        nextStyle
      );
      updateBlockAttributes2(clientId, {
        className: styleClassName
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime281.jsx)(import_components146.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime281.jsx)(
      import_components146.ToolbarButton,
      {
        onClick: handleStyleSwitch,
        label: (0, import_i18n142.__)("Shuffle styles"),
        children: /* @__PURE__ */ (0, import_jsx_runtime281.jsx)(
          import_components146.Icon,
          {
            icon: styleIcon,
            style: {
              fill: activeStyleBackground || "transparent"
            }
          }
        )
      }
    ) });
  }
  var switch_section_style_default = SwitchSectionStyle;

  // packages/block-editor/build-module/components/block-toolbar/index.js
  function PrivateBlockToolbar({
    hideDragHandle,
    focusOnMount,
    __experimentalInitialIndex,
    __experimentalOnIndexChange,
    variant = "unstyled"
  }) {
    const {
      blockClientId,
      blockClientIds,
      isDefaultEditingMode,
      blockType,
      toolbarKey,
      shouldShowVisualToolbar,
      showParentSelector,
      isUsingBindings,
      hasParentPattern,
      hasContentOnlyLocking,
      showShuffleButton,
      showSlots,
      showGroupButtons,
      showLockButtons,
      showBlockVisibilityButton,
      showSwitchSectionStyleButton
    } = (0, import_data122.useSelect)((select2) => {
      const {
        getBlockName: getBlockName2,
        getBlockMode: getBlockMode2,
        getBlockParents: getBlockParents2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        isBlockValid: isBlockValid2,
        getBlockEditingMode: getBlockEditingMode2,
        getBlockAttributes: getBlockAttributes3,
        getBlockParentsByBlockName: getBlockParentsByBlockName2,
        getTemplateLock: getTemplateLock2,
        getParentSectionBlock: getParentSectionBlock2,
        isZoomOut: isZoomOut2,
        isSectionBlock: isSectionBlock2
      } = unlock(select2(store));
      const selectedBlockClientIds = getSelectedBlockClientIds2();
      const selectedBlockClientId = selectedBlockClientIds[0];
      const parents = getBlockParents2(selectedBlockClientId);
      const parentSection = getParentSectionBlock2(selectedBlockClientId);
      const parentClientId = parentSection ?? parents[parents.length - 1];
      const parentBlockName = getBlockName2(parentClientId);
      const parentBlockType = (0, import_blocks72.getBlockType)(parentBlockName);
      const editingMode = getBlockEditingMode2(selectedBlockClientId);
      const _isDefaultEditingMode = editingMode === "default";
      const _blockName = getBlockName2(selectedBlockClientId);
      const isValid = selectedBlockClientIds.every(
        (id) => isBlockValid2(id)
      );
      const isVisual = selectedBlockClientIds.every(
        (id) => getBlockMode2(id) === "visual"
      );
      const _isUsingBindings = selectedBlockClientIds.every(
        (clientId) => !!getBlockAttributes3(clientId)?.metadata?.bindings
      );
      const _hasParentPattern = selectedBlockClientIds.every(
        (clientId) => getBlockParentsByBlockName2(clientId, "core/block", true).length > 0
      );
      const _hasTemplateLock = selectedBlockClientIds.some(
        (id) => getTemplateLock2(id) === "contentOnly"
      );
      const _isZoomOut = isZoomOut2();
      const _showSwitchSectionStyleButton = window?.__experimentalContentOnlyPatternInsertion && (_isZoomOut || isSectionBlock2(selectedBlockClientId));
      return {
        blockClientId: selectedBlockClientId,
        blockClientIds: selectedBlockClientIds,
        isDefaultEditingMode: _isDefaultEditingMode,
        blockType: selectedBlockClientId && (0, import_blocks72.getBlockType)(_blockName),
        shouldShowVisualToolbar: isValid && isVisual,
        toolbarKey: `${selectedBlockClientId}${parentClientId}`,
        showParentSelector: !_isZoomOut && parentBlockType && editingMode !== "contentOnly" && getBlockEditingMode2(parentClientId) !== "disabled" && (0, import_blocks72.hasBlockSupport)(
          parentBlockType,
          "__experimentalParentSelector",
          true
        ) && selectedBlockClientIds.length === 1,
        isUsingBindings: _isUsingBindings,
        hasParentPattern: _hasParentPattern,
        hasContentOnlyLocking: _hasTemplateLock,
        showShuffleButton: _isZoomOut,
        showSlots: !_isZoomOut,
        showGroupButtons: !_isZoomOut,
        showLockButtons: !_isZoomOut,
        showBlockVisibilityButton: !_isZoomOut,
        showSwitchSectionStyleButton: _showSwitchSectionStyleButton
      };
    }, []);
    const toolbarWrapperRef = (0, import_element151.useRef)(null);
    const nodeRef = (0, import_element151.useRef)();
    const showHoveredOrFocusedGestures = useShowHoveredOrFocusedGestures({
      ref: nodeRef
    });
    const isLargeViewport = !(0, import_compose69.useViewportMatch)("medium", "<");
    const hasBlockToolbar = useHasBlockToolbar();
    if (!hasBlockToolbar) {
      return null;
    }
    const isMultiToolbar = blockClientIds.length > 1;
    const isSynced = (0, import_blocks72.isReusableBlock)(blockType) || (0, import_blocks72.isTemplatePart)(blockType);
    const classes = clsx_default("block-editor-block-contextual-toolbar", {
      "has-parent": showParentSelector
    });
    const innerClasses = clsx_default("block-editor-block-toolbar", {
      "is-synced": isSynced,
      "is-connected": isUsingBindings
    });
    return /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
      NavigableToolbar,
      {
        focusEditorOnEscape: true,
        className: classes,
        "aria-label": (0, import_i18n143.__)("Block tools"),
        variant: variant === "toolbar" ? void 0 : variant,
        focusOnMount,
        __experimentalInitialIndex,
        __experimentalOnIndexChange,
        children: /* @__PURE__ */ (0, import_jsx_runtime282.jsxs)("div", { ref: toolbarWrapperRef, className: innerClasses, children: [
          showParentSelector && !isMultiToolbar && isLargeViewport && /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(BlockParentSelector, {}),
          (shouldShowVisualToolbar || isMultiToolbar) && !hasParentPattern && /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
            "div",
            {
              ref: nodeRef,
              ...showHoveredOrFocusedGestures,
              children: /* @__PURE__ */ (0, import_jsx_runtime282.jsxs)(import_components147.ToolbarGroup, { className: "block-editor-block-toolbar__block-controls", children: [
                /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(block_switcher_default, { clientIds: blockClientIds }),
                isDefaultEditingMode && showBlockVisibilityButton && /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
                  BlockVisibilityToolbar,
                  {
                    clientIds: blockClientIds
                  }
                ),
                !isMultiToolbar && isDefaultEditingMode && showLockButtons && /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
                  BlockLockToolbar,
                  {
                    clientId: blockClientId
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
                  block_mover_default,
                  {
                    clientIds: blockClientIds,
                    hideDragHandle
                  }
                )
              ] })
            }
          ),
          !hasContentOnlyLocking && shouldShowVisualToolbar && isMultiToolbar && showGroupButtons && /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(toolbar_default, {}),
          showShuffleButton && /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(ChangeDesign, { clientId: blockClientIds[0] }),
          showSwitchSectionStyleButton && /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(switch_section_style_default, { clientId: blockClientIds[0] }),
          shouldShowVisualToolbar && showSlots && /* @__PURE__ */ (0, import_jsx_runtime282.jsxs)(import_jsx_runtime282.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
              block_controls_default.Slot,
              {
                group: "parent",
                className: "block-editor-block-toolbar__slot"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
              block_controls_default.Slot,
              {
                group: "block",
                className: "block-editor-block-toolbar__slot"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(block_controls_default.Slot, { className: "block-editor-block-toolbar__slot" }),
            /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
              block_controls_default.Slot,
              {
                group: "inline",
                className: "block-editor-block-toolbar__slot"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
              block_controls_default.Slot,
              {
                group: "other",
                className: "block-editor-block-toolbar__slot"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
              block_name_context_default.Provider,
              {
                value: blockType?.name,
                children: /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(block_toolbar_last_item_default.Slot, {})
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(BlockEditVisuallyButton, { clientIds: blockClientIds }),
          /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(block_settings_menu_default, { clientIds: blockClientIds })
        ] })
      },
      toolbarKey
    );
  }
  function BlockToolbar({ hideDragHandle, variant }) {
    return /* @__PURE__ */ (0, import_jsx_runtime282.jsx)(
      PrivateBlockToolbar,
      {
        hideDragHandle,
        variant,
        focusOnMount: void 0,
        __experimentalInitialIndex: void 0,
        __experimentalOnIndexChange: void 0
      }
    );
  }

  // packages/block-editor/build-module/components/block-tools/block-toolbar-popover.js
  function BlockToolbarPopover({
    clientId,
    isTyping: isTyping3,
    __unstableContentRef
  }) {
    const { capturingClientId, isInsertionPointVisible, lastClientId } = useSelectedBlockToolProps(clientId);
    const initialToolbarItemIndexRef = (0, import_element152.useRef)();
    (0, import_element152.useEffect)(() => {
      initialToolbarItemIndexRef.current = void 0;
    }, [clientId]);
    const { stopTyping: stopTyping2 } = (0, import_data123.useDispatch)(store);
    const isToolbarForcedRef = (0, import_element152.useRef)(false);
    (0, import_keyboard_shortcuts7.useShortcut)("core/block-editor/focus-toolbar", () => {
      isToolbarForcedRef.current = true;
      stopTyping2(true);
    });
    (0, import_element152.useEffect)(() => {
      isToolbarForcedRef.current = false;
    });
    const clientIdToPositionOver = capturingClientId || clientId;
    const popoverProps3 = useBlockToolbarPopoverProps({
      contentElement: __unstableContentRef?.current,
      clientId: clientIdToPositionOver
    });
    return !isTyping3 && /* @__PURE__ */ (0, import_jsx_runtime283.jsx)(
      PrivateBlockPopover,
      {
        clientId: clientIdToPositionOver,
        bottomClientId: lastClientId,
        className: clsx_default("block-editor-block-list__block-popover", {
          "is-insertion-point-visible": isInsertionPointVisible
        }),
        resize: false,
        ...popoverProps3,
        __unstableContentRef,
        children: /* @__PURE__ */ (0, import_jsx_runtime283.jsx)(
          PrivateBlockToolbar,
          {
            focusOnMount: isToolbarForcedRef.current,
            __experimentalInitialIndex: initialToolbarItemIndexRef.current,
            __experimentalOnIndexChange: (index) => {
              initialToolbarItemIndexRef.current = index;
            },
            variant: "toolbar"
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/block-tools/zoom-out-mode-inserters.js
  var import_jsx_runtime285 = __toESM(require_jsx_runtime());
  var import_data124 = __toESM(require_data());
  var import_element153 = __toESM(require_element());

  // packages/block-editor/build-module/components/block-tools/zoom-out-mode-inserter-button.js
  var import_jsx_runtime284 = __toESM(require_jsx_runtime());
  var import_components148 = __toESM(require_components());
  var import_i18n144 = __toESM(require_i18n());
  function ZoomOutModeInserterButton({ onClick }) {
    return /* @__PURE__ */ (0, import_jsx_runtime284.jsx)(
      import_components148.Button,
      {
        variant: "primary",
        icon: plus_default,
        size: "compact",
        className: clsx_default(
          "block-editor-button-pattern-inserter__button",
          "block-editor-block-tools__zoom-out-mode-inserter-button"
        ),
        onClick,
        label: (0, import_i18n144._x)(
          "Add pattern",
          "Generic label for pattern inserter button"
        )
      }
    );
  }
  var zoom_out_mode_inserter_button_default = ZoomOutModeInserterButton;

  // packages/block-editor/build-module/components/block-tools/zoom-out-mode-inserters.js
  function ZoomOutModeInserters() {
    const [isReady, setIsReady] = (0, import_element153.useState)(false);
    const {
      hasSelection,
      blockOrder,
      setInserterIsOpened,
      sectionRootClientId,
      selectedBlockClientId,
      blockInsertionPoint,
      insertionPointVisible
    } = (0, import_data124.useSelect)((select2) => {
      const {
        getSettings: getSettings4,
        getBlockOrder: getBlockOrder2,
        getSelectionStart: getSelectionStart2,
        getSelectedBlockClientId: getSelectedBlockClientId2,
        getSectionRootClientId: getSectionRootClientId2,
        getBlockInsertionPoint: getBlockInsertionPoint2,
        isBlockInsertionPointVisible: isBlockInsertionPointVisible2
      } = unlock(select2(store));
      const root = getSectionRootClientId2();
      return {
        hasSelection: !!getSelectionStart2().clientId,
        blockOrder: getBlockOrder2(root),
        sectionRootClientId: root,
        setInserterIsOpened: getSettings4().__experimentalSetIsInserterOpened,
        selectedBlockClientId: getSelectedBlockClientId2(),
        blockInsertionPoint: getBlockInsertionPoint2(),
        insertionPointVisible: isBlockInsertionPointVisible2()
      };
    }, []);
    const { showInsertionPoint: showInsertionPoint2 } = unlock((0, import_data124.useDispatch)(store));
    (0, import_element153.useEffect)(() => {
      const timeout = setTimeout(() => {
        setIsReady(true);
      }, 500);
      return () => {
        clearTimeout(timeout);
      };
    }, []);
    if (!isReady || !hasSelection) {
      return null;
    }
    const previousClientId = selectedBlockClientId;
    const index = blockOrder.findIndex(
      (clientId) => selectedBlockClientId === clientId
    );
    const insertionIndex = index + 1;
    const nextClientId = blockOrder[insertionIndex];
    if (insertionPointVisible && blockInsertionPoint?.index === insertionIndex) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime285.jsx)(
      inbetween_default,
      {
        previousClientId,
        nextClientId,
        children: /* @__PURE__ */ (0, import_jsx_runtime285.jsx)(
          zoom_out_mode_inserter_button_default,
          {
            onClick: () => {
              setInserterIsOpened({
                rootClientId: sectionRootClientId,
                insertionIndex,
                tab: "patterns",
                category: "all"
              });
              showInsertionPoint2(sectionRootClientId, insertionIndex, {
                operation: "insert"
              });
            }
          }
        )
      }
    );
  }
  var zoom_out_mode_inserters_default = ZoomOutModeInserters;

  // packages/block-editor/build-module/components/block-tools/use-show-block-tools.js
  var import_data125 = __toESM(require_data());
  var import_blocks73 = __toESM(require_blocks());
  function useShowBlockTools() {
    return (0, import_data125.useSelect)((select2) => {
      const {
        getSelectedBlockClientId: getSelectedBlockClientId2,
        getFirstMultiSelectedBlockClientId: getFirstMultiSelectedBlockClientId2,
        getBlock: getBlock2,
        getBlockMode: getBlockMode2,
        getSettings: getSettings4,
        isTyping: isTyping3,
        isBlockInterfaceHidden: isBlockInterfaceHidden3
      } = unlock(select2(store));
      const clientId = getSelectedBlockClientId2() || getFirstMultiSelectedBlockClientId2();
      const block = getBlock2(clientId);
      const hasSelectedBlock2 = !!clientId && !!block;
      const isEmptyDefaultBlock = hasSelectedBlock2 && (0, import_blocks73.isUnmodifiedDefaultBlock)(block, "content") && getBlockMode2(clientId) !== "html";
      const _showEmptyBlockSideInserter = clientId && !isTyping3() && isEmptyDefaultBlock;
      const _showBlockToolbarPopover = !isBlockInterfaceHidden3() && !getSettings4().hasFixedToolbar && !_showEmptyBlockSideInserter && hasSelectedBlock2 && !isEmptyDefaultBlock;
      return {
        showEmptyBlockSideInserter: _showEmptyBlockSideInserter,
        showBlockToolbarPopover: _showBlockToolbarPopover
      };
    }, []);
  }

  // packages/block-editor/build-module/components/block-tools/index.js
  function selector2(select2) {
    const {
      getSelectedBlockClientId: getSelectedBlockClientId2,
      getFirstMultiSelectedBlockClientId: getFirstMultiSelectedBlockClientId2,
      getSettings: getSettings4,
      isTyping: isTyping3,
      isDragging: isDragging3,
      isZoomOut: isZoomOut2
    } = unlock(select2(store));
    const clientId = getSelectedBlockClientId2() || getFirstMultiSelectedBlockClientId2();
    return {
      clientId,
      hasFixedToolbar: getSettings4().hasFixedToolbar,
      isTyping: isTyping3(),
      isZoomOutMode: isZoomOut2(),
      isDragging: isDragging3()
    };
  }
  function BlockTools({
    children,
    __unstableContentRef,
    ...props
  }) {
    const { clientId, hasFixedToolbar, isTyping: isTyping3, isZoomOutMode, isDragging: isDragging3 } = (0, import_data126.useSelect)(selector2, []);
    const isMatch = (0, import_keyboard_shortcuts8.__unstableUseShortcutEventMatch)();
    const {
      getBlocksByClientId: getBlocksByClientId2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      getBlockRootClientId: getBlockRootClientId2,
      isGroupable: isGroupable2,
      getBlockName: getBlockName2
    } = (0, import_data126.useSelect)(store);
    const { getGroupingBlockName } = (0, import_data126.useSelect)(import_blocks74.store);
    const { showEmptyBlockSideInserter, showBlockToolbarPopover } = useShowBlockTools();
    const pasteStyles = usePasteStyles();
    const {
      duplicateBlocks: duplicateBlocks2,
      removeBlocks: removeBlocks2,
      replaceBlocks: replaceBlocks2,
      insertAfterBlock: insertAfterBlock2,
      insertBeforeBlock: insertBeforeBlock2,
      selectBlock: selectBlock2,
      moveBlocksUp: moveBlocksUp2,
      moveBlocksDown: moveBlocksDown2,
      expandBlock: expandBlock2,
      updateBlockAttributes: updateBlockAttributes2
    } = unlock((0, import_data126.useDispatch)(store));
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (isMatch("core/block-editor/move-up", event) || isMatch("core/block-editor/move-down", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length) {
          event.preventDefault();
          const rootClientId = getBlockRootClientId2(clientIds[0]);
          const direction = isMatch("core/block-editor/move-up", event) ? "up" : "down";
          if (direction === "up") {
            moveBlocksUp2(clientIds, rootClientId);
          } else {
            moveBlocksDown2(clientIds, rootClientId);
          }
          const blockLength = Array.isArray(clientIds) ? clientIds.length : 1;
          const message = (0, import_i18n145.sprintf)(
            // translators: %d: the name of the block that has been moved
            (0, import_i18n145._n)(
              "%d block moved.",
              "%d blocks moved.",
              clientIds.length
            ),
            blockLength
          );
          (0, import_a11y13.speak)(message);
        }
      } else if (isMatch("core/block-editor/duplicate", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length) {
          event.preventDefault();
          duplicateBlocks2(clientIds);
        }
      } else if (isMatch("core/block-editor/remove", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length) {
          event.preventDefault();
          removeBlocks2(clientIds);
        }
      } else if (isMatch("core/block-editor/paste-styles", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length) {
          event.preventDefault();
          const blocks2 = getBlocksByClientId2(clientIds);
          pasteStyles(blocks2);
        }
      } else if (isMatch("core/block-editor/insert-after", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length) {
          event.preventDefault();
          insertAfterBlock2(clientIds[clientIds.length - 1]);
        }
      } else if (isMatch("core/block-editor/insert-before", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length) {
          event.preventDefault();
          insertBeforeBlock2(clientIds[0]);
        }
      } else if (isMatch("core/block-editor/unselect", event)) {
        if (event.target.closest("[role=toolbar]")) {
          return;
        }
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length > 1) {
          event.preventDefault();
          selectBlock2(clientIds[0]);
        }
      } else if (isMatch("core/block-editor/collapse-list-view", event)) {
        if ((0, import_dom33.isTextField)(event.target) || (0, import_dom33.isTextField)(
          event.target?.contentWindow?.document?.activeElement
        )) {
          return;
        }
        event.preventDefault();
        expandBlock2(clientId);
      } else if (isMatch("core/block-editor/group", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length > 1 && isGroupable2(clientIds)) {
          event.preventDefault();
          const blocks2 = getBlocksByClientId2(clientIds);
          const groupingBlockName = getGroupingBlockName();
          const newBlocks = (0, import_blocks74.switchToBlockType)(
            blocks2,
            groupingBlockName
          );
          replaceBlocks2(clientIds, newBlocks);
          (0, import_a11y13.speak)((0, import_i18n145.__)("Selected blocks are grouped."));
        }
      } else if (isMatch("core/block-editor/toggle-block-visibility", event)) {
        const clientIds = getSelectedBlockClientIds2();
        if (clientIds.length) {
          event.preventDefault();
          const blocks2 = getBlocksByClientId2(clientIds);
          const canToggleBlockVisibility = blocks2.every(
            (block) => (0, import_blocks74.hasBlockSupport)(
              getBlockName2(block.clientId),
              "blockVisibility",
              true
            )
          );
          if (!canToggleBlockVisibility) {
            return;
          }
          const hasHiddenBlock = blocks2.some(
            (block) => block.attributes.metadata?.blockVisibility === false
          );
          const attributesByClientId = Object.fromEntries(
            blocks2.map(({ clientId: mapClientId, attributes }) => [
              mapClientId,
              {
                metadata: cleanEmptyObject({
                  ...attributes?.metadata,
                  blockVisibility: hasHiddenBlock ? void 0 : false
                })
              }
            ])
          );
          updateBlockAttributes2(clientIds, attributesByClientId, {
            uniqueByBlock: true
          });
        }
      }
    }
    const blockToolbarRef = use_popover_scroll_default(__unstableContentRef);
    const blockToolbarAfterRef = use_popover_scroll_default(__unstableContentRef);
    return (
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions
      /* @__PURE__ */ (0, import_jsx_runtime286.jsx)("div", { ...props, onKeyDown, children: /* @__PURE__ */ (0, import_jsx_runtime286.jsxs)(InsertionPointOpenRef.Provider, { value: (0, import_element154.useRef)(false), children: [
        !isTyping3 && !isZoomOutMode && /* @__PURE__ */ (0, import_jsx_runtime286.jsx)(
          InsertionPoint,
          {
            __unstableContentRef
          }
        ),
        showEmptyBlockSideInserter && /* @__PURE__ */ (0, import_jsx_runtime286.jsx)(
          EmptyBlockInserter,
          {
            __unstableContentRef,
            clientId
          }
        ),
        showBlockToolbarPopover && /* @__PURE__ */ (0, import_jsx_runtime286.jsx)(
          BlockToolbarPopover,
          {
            __unstableContentRef,
            clientId,
            isTyping: isTyping3
          }
        ),
        !isZoomOutMode && !hasFixedToolbar && /* @__PURE__ */ (0, import_jsx_runtime286.jsx)(
          import_components149.Popover.Slot,
          {
            name: "block-toolbar",
            ref: blockToolbarRef
          }
        ),
        children,
        /* @__PURE__ */ (0, import_jsx_runtime286.jsx)(
          import_components149.Popover.Slot,
          {
            name: "__unstable-block-tools-after",
            ref: blockToolbarAfterRef
          }
        ),
        isZoomOutMode && !isDragging3 && /* @__PURE__ */ (0, import_jsx_runtime286.jsx)(
          zoom_out_mode_inserters_default,
          {
            __unstableContentRef
          }
        )
      ] }) })
    );
  }

  // packages/block-editor/build-module/components/use-block-commands/index.js
  var import_jsx_runtime287 = __toESM(require_jsx_runtime());
  var import_i18n146 = __toESM(require_i18n());
  var import_blocks75 = __toESM(require_blocks());
  var import_data127 = __toESM(require_data());
  var import_commands = __toESM(require_commands());
  var getTransformCommands = () => function useTransformCommands() {
    const { replaceBlocks: replaceBlocks2, multiSelect: multiSelect2 } = (0, import_data127.useDispatch)(store);
    const {
      blocks: blocks2,
      clientIds,
      canRemove,
      possibleBlockTransformations,
      invalidSelection
    } = (0, import_data127.useSelect)((select2) => {
      const {
        getBlockRootClientId: getBlockRootClientId2,
        getBlockTransformItems: getBlockTransformItems2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        getBlocksByClientId: getBlocksByClientId2,
        canRemoveBlocks: canRemoveBlocks2
      } = select2(store);
      const selectedBlockClientIds = getSelectedBlockClientIds2();
      const selectedBlocks = getBlocksByClientId2(
        selectedBlockClientIds
      );
      if (selectedBlocks.filter((block) => !block).length > 0) {
        return {
          invalidSelection: true
        };
      }
      const rootClientId = getBlockRootClientId2(
        selectedBlockClientIds[0]
      );
      return {
        blocks: selectedBlocks,
        clientIds: selectedBlockClientIds,
        possibleBlockTransformations: getBlockTransformItems2(
          selectedBlocks,
          rootClientId
        ),
        canRemove: canRemoveBlocks2(selectedBlockClientIds),
        invalidSelection: false
      };
    }, []);
    if (invalidSelection) {
      return {
        isLoading: false,
        commands: []
      };
    }
    const isTemplate = blocks2.length === 1 && (0, import_blocks75.isTemplatePart)(blocks2[0]);
    function selectForMultipleBlocks(insertedBlocks) {
      if (insertedBlocks.length > 1) {
        multiSelect2(
          insertedBlocks[0].clientId,
          insertedBlocks[insertedBlocks.length - 1].clientId
        );
      }
    }
    function onBlockTransform(name) {
      const newBlocks = (0, import_blocks75.switchToBlockType)(blocks2, name);
      replaceBlocks2(clientIds, newBlocks);
      selectForMultipleBlocks(newBlocks);
    }
    const hasPossibleBlockTransformations = !!possibleBlockTransformations.length && canRemove && !isTemplate;
    if (!clientIds || clientIds.length < 1 || !hasPossibleBlockTransformations) {
      return { isLoading: false, commands: [] };
    }
    const commands = possibleBlockTransformations.map(
      (transformation) => {
        const { name, title, icon } = transformation;
        return {
          name: "core/block-editor/transform-to-" + name.replace("/", "-"),
          /* translators: %s: Block or block variation name. */
          label: (0, import_i18n146.sprintf)((0, import_i18n146.__)("Transform to %s"), title),
          icon: /* @__PURE__ */ (0, import_jsx_runtime287.jsx)(block_icon_default, { icon }),
          callback: ({ close }) => {
            onBlockTransform(name);
            close();
          }
        };
      }
    );
    return { isLoading: false, commands };
  };
  var getQuickActionsCommands = () => function useQuickActionsCommands() {
    const { clientIds, isUngroupable: isUngroupable2, isGroupable: isGroupable2 } = (0, import_data127.useSelect)(
      (select2) => {
        const {
          getSelectedBlockClientIds: getSelectedBlockClientIds2,
          isUngroupable: _isUngroupable,
          isGroupable: _isGroupable
        } = select2(store);
        const selectedBlockClientIds = getSelectedBlockClientIds2();
        return {
          clientIds: selectedBlockClientIds,
          isUngroupable: _isUngroupable(),
          isGroupable: _isGroupable()
        };
      },
      []
    );
    const {
      canInsertBlockType: canInsertBlockType2,
      getBlockRootClientId: getBlockRootClientId2,
      getBlocksByClientId: getBlocksByClientId2,
      canRemoveBlocks: canRemoveBlocks2,
      getBlockName: getBlockName2
    } = (0, import_data127.useSelect)(store);
    const { getDefaultBlockName: getDefaultBlockName7, getGroupingBlockName } = (0, import_data127.useSelect)(import_blocks75.store);
    const blocks2 = getBlocksByClientId2(clientIds);
    const {
      removeBlocks: removeBlocks2,
      replaceBlocks: replaceBlocks2,
      duplicateBlocks: duplicateBlocks2,
      insertAfterBlock: insertAfterBlock2,
      insertBeforeBlock: insertBeforeBlock2,
      updateBlockAttributes: updateBlockAttributes2
    } = (0, import_data127.useDispatch)(store);
    const onGroup = () => {
      if (!blocks2.length) {
        return;
      }
      const groupingBlockName = getGroupingBlockName();
      const newBlocks = (0, import_blocks75.switchToBlockType)(blocks2, groupingBlockName);
      if (!newBlocks) {
        return;
      }
      replaceBlocks2(clientIds, newBlocks);
    };
    const onUngroup = () => {
      if (!blocks2.length) {
        return;
      }
      const innerBlocks = blocks2[0].innerBlocks;
      if (!innerBlocks.length) {
        return;
      }
      replaceBlocks2(clientIds, innerBlocks);
    };
    if (!clientIds || clientIds.length < 1) {
      return { isLoading: false, commands: [] };
    }
    const rootClientId = getBlockRootClientId2(clientIds[0]);
    const canInsertDefaultBlock = canInsertBlockType2(
      getDefaultBlockName7(),
      rootClientId
    );
    const canDuplicate = blocks2.every((block) => {
      return !!block && (0, import_blocks75.hasBlockSupport)(block.name, "multiple", true) && canInsertBlockType2(block.name, rootClientId);
    });
    const canRemove = canRemoveBlocks2(clientIds);
    const canToggleBlockVisibility = blocks2.every(
      ({ clientId }) => (0, import_blocks75.hasBlockSupport)(getBlockName2(clientId), "blockVisibility", true)
    );
    const commands = [];
    if (canDuplicate) {
      commands.push({
        name: "duplicate",
        label: (0, import_i18n146.__)("Duplicate"),
        callback: () => duplicateBlocks2(clientIds, true),
        icon: copy_default
      });
    }
    if (canInsertDefaultBlock) {
      commands.push(
        {
          name: "add-before",
          label: (0, import_i18n146.__)("Add before"),
          callback: () => {
            const clientId = Array.isArray(clientIds) ? clientIds[0] : clientId;
            insertBeforeBlock2(clientId);
          },
          icon: plus_default
        },
        {
          name: "add-after",
          label: (0, import_i18n146.__)("Add after"),
          callback: () => {
            const clientId = Array.isArray(clientIds) ? clientIds[clientIds.length - 1] : clientId;
            insertAfterBlock2(clientId);
          },
          icon: plus_default
        }
      );
    }
    if (isGroupable2) {
      commands.push({
        name: "Group",
        label: (0, import_i18n146.__)("Group"),
        callback: onGroup,
        icon: group_default
      });
    }
    if (isUngroupable2) {
      commands.push({
        name: "ungroup",
        label: (0, import_i18n146.__)("Ungroup"),
        callback: onUngroup,
        icon: ungroup_default
      });
    }
    if (canRemove) {
      commands.push({
        name: "remove",
        label: (0, import_i18n146.__)("Delete"),
        callback: () => removeBlocks2(clientIds, true),
        icon: trash_default
      });
    }
    if (canToggleBlockVisibility) {
      const hasHiddenBlock = blocks2.some(
        (block) => block.attributes.metadata?.blockVisibility === false
      );
      commands.push({
        name: "core/toggle-block-visibility",
        label: hasHiddenBlock ? (0, import_i18n146.__)("Show") : (0, import_i18n146.__)("Hide"),
        callback: () => {
          const attributesByClientId = Object.fromEntries(
            blocks2?.map(({ clientId, attributes }) => [
              clientId,
              {
                metadata: cleanEmptyObject({
                  ...attributes?.metadata,
                  blockVisibility: hasHiddenBlock ? void 0 : false
                })
              }
            ])
          );
          updateBlockAttributes2(clientIds, attributesByClientId, {
            uniqueByBlock: true
          });
        },
        icon: hasHiddenBlock ? seen_default : unseen_default
      });
    }
    return {
      isLoading: false,
      commands: commands.map((command) => ({
        ...command,
        name: "core/block-editor/action-" + command.name,
        callback: ({ close }) => {
          command.callback();
          close();
        }
      }))
    };
  };
  var useBlockCommands = () => {
    (0, import_commands.useCommandLoader)({
      name: "core/block-editor/blockTransforms",
      hook: getTransformCommands()
    });
    (0, import_commands.useCommandLoader)({
      name: "core/block-editor/blockQuickActions",
      hook: getQuickActionsCommands(),
      context: "block-selection-edit"
    });
  };

  // packages/block-editor/build-module/components/block-canvas/index.js
  var EDITOR_STYLE_TRANSFORM_OPTIONS = {
    // Don't transform selectors that already specify `.editor-styles-wrapper`.
    ignoredSelectors: [/\.editor-styles-wrapper/gi]
  };
  function ExperimentalBlockCanvas({
    shouldIframe = true,
    height = "300px",
    children = /* @__PURE__ */ (0, import_jsx_runtime288.jsx)(BlockList, {}),
    styles,
    contentRef: contentRefProp,
    iframeProps
  }) {
    useBlockCommands();
    const isTabletViewport = (0, import_compose70.useViewportMatch)("medium", "<");
    const resetTypingRef = useMouseMoveTypingReset();
    const clearerRef = useBlockSelectionClearer();
    const localRef = (0, import_element155.useRef)();
    const contentRef = (0, import_compose70.useMergeRefs)([contentRefProp, clearerRef, localRef]);
    const zoomLevel2 = (0, import_data128.useSelect)(
      (select2) => unlock(select2(store)).getZoomLevel(),
      []
    );
    const zoomOutIframeProps = zoomLevel2 !== 100 && !isTabletViewport ? {
      scale: zoomLevel2,
      frameSize: "40px"
    } : {};
    if (!shouldIframe) {
      return /* @__PURE__ */ (0, import_jsx_runtime288.jsxs)(
        BlockTools,
        {
          __unstableContentRef: localRef,
          style: { height, display: "flex" },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime288.jsx)(
              editor_styles_default,
              {
                styles,
                scope: ":where(.editor-styles-wrapper)",
                transformOptions: EDITOR_STYLE_TRANSFORM_OPTIONS
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime288.jsx)(
              writing_flow_default,
              {
                ref: contentRef,
                className: "editor-styles-wrapper",
                tabIndex: -1,
                style: {
                  height: "100%",
                  width: "100%"
                },
                children
              }
            )
          ]
        }
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime288.jsx)(
      BlockTools,
      {
        __unstableContentRef: localRef,
        style: { height, display: "flex" },
        children: /* @__PURE__ */ (0, import_jsx_runtime288.jsxs)(
          iframe_default,
          {
            ...iframeProps,
            ...zoomOutIframeProps,
            ref: resetTypingRef,
            contentRef,
            style: {
              ...iframeProps?.style
            },
            name: "editor-canvas",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime288.jsx)(editor_styles_default, { styles }),
              children
            ]
          }
        )
      }
    );
  }
  function BlockCanvas({ children, height, styles }) {
    return /* @__PURE__ */ (0, import_jsx_runtime288.jsx)(ExperimentalBlockCanvas, { height, styles, children });
  }
  var block_canvas_default = BlockCanvas;

  // packages/block-editor/build-module/components/color-style-selector/index.js
  var import_jsx_runtime289 = __toESM(require_jsx_runtime());
  var import_components150 = __toESM(require_components());
  var import_i18n147 = __toESM(require_i18n());
  var import_keycodes13 = __toESM(require_keycodes());
  var import_deprecated21 = __toESM(require_deprecated());
  var ColorSelectorSVGIcon = () => /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(import_components150.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", children: /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(import_components150.Path, { d: "M7.434 5l3.18 9.16H8.538l-.692-2.184H4.628l-.705 2.184H2L5.18 5h2.254zm-1.13 1.904h-.115l-1.148 3.593H7.44L6.304 6.904zM14.348 7.006c1.853 0 2.9.876 2.9 2.374v4.78h-1.79v-.914h-.114c-.362.64-1.123 1.022-2.031 1.022-1.346 0-2.292-.826-2.292-2.108 0-1.27.972-2.006 2.71-2.107l1.696-.102V9.38c0-.584-.42-.914-1.18-.914-.667 0-1.112.228-1.264.647h-1.701c.12-1.295 1.307-2.107 3.066-2.107zm1.079 4.1l-1.416.09c-.793.056-1.18.342-1.18.844 0 .52.45.837 1.091.837.857 0 1.505-.545 1.505-1.256v-.515z" }) });
  var ColorSelectorIcon = ({ style, className }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime289.jsx)("div", { className: "block-library-colors-selector__icon-container", children: /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(
      "div",
      {
        className: `${className} block-library-colors-selector__state-selection`,
        style,
        children: /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(ColorSelectorSVGIcon, {})
      }
    ) });
  };
  var renderToggleComponent = ({ TextColor, BackgroundColor }) => ({ onToggle, isOpen }) => {
    const openOnArrowDown = (event) => {
      if (!isOpen && event.keyCode === import_keycodes13.DOWN) {
        event.preventDefault();
        onToggle();
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(import_components150.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(
      import_components150.ToolbarButton,
      {
        className: "components-toolbar__control block-library-colors-selector__toggle",
        label: (0, import_i18n147.__)("Open Colors Selector"),
        onClick: onToggle,
        onKeyDown: openOnArrowDown,
        icon: /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(BackgroundColor, { children: /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(TextColor, { children: /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(ColorSelectorIcon, {}) }) })
      }
    ) });
  };
  var BlockColorsStyleSelector = ({ children, ...other }) => {
    (0, import_deprecated21.default)(`wp.blockEditor.BlockColorsStyleSelector`, {
      alternative: "block supports API",
      since: "6.1",
      version: "6.3"
    });
    return /* @__PURE__ */ (0, import_jsx_runtime289.jsx)(
      import_components150.Dropdown,
      {
        popoverProps: { placement: "bottom-start" },
        className: "block-library-colors-selector",
        contentClassName: "block-library-colors-selector__popover",
        renderToggle: renderToggleComponent(other),
        renderContent: () => children
      }
    );
  };
  var color_style_selector_default = BlockColorsStyleSelector;

  // packages/block-editor/build-module/components/block-navigation/dropdown.js
  var import_jsx_runtime300 = __toESM(require_jsx_runtime());
  var import_deprecated23 = __toESM(require_deprecated());
  var import_components157 = __toESM(require_components());
  var import_i18n156 = __toESM(require_i18n());
  var import_data141 = __toESM(require_data());
  var import_element173 = __toESM(require_element());

  // packages/block-editor/build-module/components/list-view/index.js
  var import_jsx_runtime299 = __toESM(require_jsx_runtime());
  var import_compose76 = __toESM(require_compose());
  var import_components156 = __toESM(require_components());
  var import_data140 = __toESM(require_data());
  var import_deprecated22 = __toESM(require_deprecated());
  var import_element172 = __toESM(require_element());
  var import_i18n155 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/list-view/branch.js
  var import_jsx_runtime297 = __toESM(require_jsx_runtime());
  var import_components154 = __toESM(require_components());
  var import_element165 = __toESM(require_element());
  var import_data133 = __toESM(require_data());

  // packages/block-editor/build-module/components/list-view/appender.js
  var import_jsx_runtime291 = __toESM(require_jsx_runtime());
  var import_compose71 = __toESM(require_compose());
  var import_a11y14 = __toESM(require_a11y());
  var import_data129 = __toESM(require_data());
  var import_element158 = __toESM(require_element());
  var import_i18n148 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/list-view/context.js
  var import_element156 = __toESM(require_element());
  var ListViewContext = (0, import_element156.createContext)({});
  ListViewContext.displayName = "ListViewContext";
  var useListViewContext = () => (0, import_element156.useContext)(ListViewContext);

  // packages/block-editor/build-module/components/list-view/aria-referenced-text.js
  var import_jsx_runtime290 = __toESM(require_jsx_runtime());
  var import_element157 = __toESM(require_element());
  function AriaReferencedText({ children, ...props }) {
    const ref = (0, import_element157.useRef)();
    (0, import_element157.useEffect)(() => {
      if (ref.current) {
        ref.current.textContent = ref.current.textContent;
      }
    }, [children]);
    return /* @__PURE__ */ (0, import_jsx_runtime290.jsx)("div", { hidden: true, ...props, ref, children });
  }

  // packages/block-editor/build-module/components/list-view/appender.js
  var Appender = (0, import_element158.forwardRef)(
    ({ nestingLevel, blockCount, clientId, ...props }, ref) => {
      const { insertedBlock, setInsertedBlock } = useListViewContext();
      const instanceId = (0, import_compose71.useInstanceId)(Appender);
      const { directInsert, hideInserter } = (0, import_data129.useSelect)(
        (select2) => {
          const { getBlockListSettings: getBlockListSettings2, getTemplateLock: getTemplateLock2, isZoomOut: isZoomOut2 } = unlock(select2(store));
          const settings2 = getBlockListSettings2(clientId);
          const directInsertValue = settings2?.directInsert || false;
          const hideInserterValue = !!getTemplateLock2(clientId) || isZoomOut2();
          return {
            directInsert: directInsertValue,
            hideInserter: hideInserterValue
          };
        },
        [clientId]
      );
      const blockTitle = useBlockDisplayTitle({
        clientId,
        context: "list-view"
      });
      const insertedBlockTitle = useBlockDisplayTitle({
        clientId: insertedBlock?.clientId,
        context: "list-view"
      });
      (0, import_element158.useEffect)(() => {
        if (!insertedBlockTitle?.length) {
          return;
        }
        (0, import_a11y14.speak)(
          (0, import_i18n148.sprintf)(
            // translators: %s: name of block being inserted (i.e. Paragraph, Image, Group etc)
            (0, import_i18n148.__)("%s block inserted"),
            insertedBlockTitle
          ),
          "assertive"
        );
      }, [insertedBlockTitle]);
      if (hideInserter) {
        return null;
      }
      const descriptionId = `list-view-appender__${instanceId}`;
      const description = (0, import_i18n148.sprintf)(
        /* translators: 1: The name of the block. 2: The numerical position of the block. 3: The level of nesting for the block. */
        (0, import_i18n148.__)("Append to %1$s block at position %2$d, Level %3$d"),
        blockTitle,
        blockCount + 1,
        nestingLevel
      );
      return /* @__PURE__ */ (0, import_jsx_runtime291.jsxs)("div", { className: "list-view-appender", children: [
        /* @__PURE__ */ (0, import_jsx_runtime291.jsx)(
          inserter_default,
          {
            ref,
            rootClientId: clientId,
            position: "bottom right",
            isAppender: true,
            selectBlockOnInsert: false,
            shouldDirectInsert: directInsert,
            __experimentalIsQuick: true,
            ...props,
            toggleProps: { "aria-describedby": descriptionId },
            onSelectOrClose: (maybeInsertedBlock) => {
              if (maybeInsertedBlock?.clientId) {
                setInsertedBlock(maybeInsertedBlock);
              }
            }
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime291.jsx)(AriaReferencedText, { id: descriptionId, children: description })
      ] });
    }
  );

  // packages/block-editor/build-module/components/list-view/block.js
  var import_jsx_runtime296 = __toESM(require_jsx_runtime());
  var import_blocks77 = __toESM(require_blocks());
  var import_components153 = __toESM(require_components());
  var import_compose73 = __toESM(require_compose());
  var import_element164 = __toESM(require_element());
  var import_data132 = __toESM(require_data());
  var import_i18n151 = __toESM(require_i18n());
  var import_keycodes15 = __toESM(require_keycodes());
  var import_is_shallow_equal3 = __toESM(require_is_shallow_equal());
  var import_keyboard_shortcuts9 = __toESM(require_keyboard_shortcuts());
  var import_a11y15 = __toESM(require_a11y());

  // packages/block-editor/build-module/components/list-view/leaf.js
  var import_jsx_runtime292 = __toESM(require_jsx_runtime());
  var import_components151 = __toESM(require_components());
  var import_compose72 = __toESM(require_compose());
  var import_element159 = __toESM(require_element());
  var AnimatedTreeGridRow = animated(import_components151.__experimentalTreeGridRow);
  var ListViewLeaf = (0, import_element159.forwardRef)(
    ({
      isDragged,
      isSelected,
      position: position2,
      level,
      rowCount,
      children,
      className,
      path,
      ...props
    }, ref) => {
      const animationRef = use_moving_animation_default({
        clientId: props["data-block"],
        enableAnimation: true,
        triggerAnimationOnChange: path
      });
      const mergedRef = (0, import_compose72.useMergeRefs)([ref, animationRef]);
      return /* @__PURE__ */ (0, import_jsx_runtime292.jsx)(
        AnimatedTreeGridRow,
        {
          ref: mergedRef,
          className: clsx_default("block-editor-list-view-leaf", className),
          level,
          positionInSet: position2,
          setSize: rowCount,
          isExpanded: void 0,
          ...props,
          children
        }
      );
    }
  );
  var leaf_default = ListViewLeaf;

  // packages/block-editor/build-module/components/list-view/use-list-view-scroll-into-view.js
  var import_dom34 = __toESM(require_dom());
  var import_element160 = __toESM(require_element());
  function useListViewScrollIntoView({
    isSelected,
    selectedClientIds,
    rowItemRef
  }) {
    const isSingleSelection = selectedClientIds.length === 1;
    (0, import_element160.useLayoutEffect)(() => {
      if (!isSelected || !isSingleSelection || !rowItemRef.current) {
        return;
      }
      const scrollContainer = (0, import_dom34.getScrollContainer)(rowItemRef.current);
      const { ownerDocument } = rowItemRef.current;
      const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
      if (windowScroll || !scrollContainer) {
        return;
      }
      const rowRect = rowItemRef.current.getBoundingClientRect();
      const scrollContainerRect = scrollContainer.getBoundingClientRect();
      if (rowRect.top < scrollContainerRect.top || rowRect.bottom > scrollContainerRect.bottom) {
        rowItemRef.current.scrollIntoView();
      }
    }, [isSelected, isSingleSelection, rowItemRef]);
  }

  // packages/block-editor/build-module/components/list-view/block-contents.js
  var import_jsx_runtime295 = __toESM(require_jsx_runtime());
  var import_element163 = __toESM(require_element());

  // packages/block-editor/build-module/components/list-view/block-select-button.js
  var import_jsx_runtime294 = __toESM(require_jsx_runtime());
  var import_components152 = __toESM(require_components());
  var import_element162 = __toESM(require_element());
  var import_keycodes14 = __toESM(require_keycodes());
  var import_data131 = __toESM(require_data());
  var import_blocks76 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/list-view/expander.js
  var import_jsx_runtime293 = __toESM(require_jsx_runtime());
  var import_i18n149 = __toESM(require_i18n());
  function ListViewExpander({ onClick }) {
    return (
      // Keyboard events are handled by TreeGrid see: components/src/tree-grid/index.js
      //
      // The expander component is implemented as a pseudo element in the w3 example
      // https://www.w3.org/TR/wai-aria-practices/examples/treegrid/treegrid-1.html
      //
      // We've mimicked this by adding an icon with aria-hidden set to true to hide this from the accessibility tree.
      // For the current tree grid implementation, please do not try to make this a button.
      //
      // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
      /* @__PURE__ */ (0, import_jsx_runtime293.jsx)(
        "span",
        {
          className: "block-editor-list-view__expander",
          onClick: (event) => onClick(event, { forceToggle: true }),
          "aria-hidden": "true",
          "data-testid": "list-view-expander",
          children: /* @__PURE__ */ (0, import_jsx_runtime293.jsx)(icon_default, { icon: (0, import_i18n149.isRTL)() ? chevron_left_small_default : chevron_right_small_default })
        }
      )
    );
  }

  // packages/block-editor/build-module/components/list-view/use-list-view-images.js
  var import_element161 = __toESM(require_element());
  var import_data130 = __toESM(require_data());
  var MAX_IMAGES = 3;
  var IMAGE_GETTERS = {
    "core/image": ({ clientId, attributes }) => {
      if (attributes.url) {
        return {
          url: attributes.url,
          alt: attributes.alt || "",
          clientId
        };
      }
    },
    "core/cover": ({ clientId, attributes }) => {
      if (attributes.backgroundType === "image" && attributes.url) {
        return {
          url: attributes.url,
          alt: attributes.alt || "",
          clientId
        };
      }
    },
    "core/media-text": ({ clientId, attributes }) => {
      if (attributes.mediaType === "image" && attributes.mediaUrl) {
        return {
          url: attributes.mediaUrl,
          alt: attributes.mediaAlt || "",
          clientId
        };
      }
    },
    "core/gallery": ({ innerBlocks }) => {
      const images = [];
      const getValues = !!innerBlocks?.length ? IMAGE_GETTERS[innerBlocks[0].name] : void 0;
      if (!getValues) {
        return images;
      }
      for (const innerBlock of innerBlocks) {
        const img = getValues(innerBlock);
        if (img) {
          images.push(img);
        }
        if (images.length >= MAX_IMAGES) {
          return images;
        }
      }
      return images;
    }
  };
  function getImagesFromBlock(block, isExpanded) {
    const getImages = IMAGE_GETTERS[block.name];
    const images = !!getImages ? getImages(block) : void 0;
    if (!images) {
      return [];
    }
    if (!Array.isArray(images)) {
      return [images];
    }
    return isExpanded ? [] : images;
  }
  function useListViewImages({ clientId, isExpanded }) {
    const { block } = (0, import_data130.useSelect)(
      (select2) => {
        return { block: select2(store).getBlock(clientId) };
      },
      [clientId]
    );
    const images = (0, import_element161.useMemo)(() => {
      return getImagesFromBlock(block, isExpanded);
    }, [block, isExpanded]);
    return images;
  }

  // packages/block-editor/build-module/components/list-view/block-select-button.js
  var { Badge: Badge2 } = unlock(import_components152.privateApis);
  function ListViewBlockSelectButton({
    className,
    block: { clientId },
    onClick,
    onContextMenu,
    onMouseDown,
    onToggleExpanded,
    tabIndex,
    onFocus,
    onDragStart,
    onDragEnd,
    draggable,
    isExpanded,
    ariaDescribedBy
  }, ref) {
    const blockInformation = useBlockDisplayInformation(clientId);
    const blockTitle = useBlockDisplayTitle({
      clientId,
      context: "list-view"
    });
    const { isLocked } = useBlockLock(clientId);
    const { canToggleBlockVisibility, isBlockHidden: isBlockHidden2, isContentOnly } = (0, import_data131.useSelect)(
      (select2) => {
        const { getBlockName: getBlockName2 } = select2(store);
        const { isBlockHidden: _isBlockHidden } = unlock(
          select2(store)
        );
        return {
          canToggleBlockVisibility: (0, import_blocks76.hasBlockSupport)(
            getBlockName2(clientId),
            "blockVisibility",
            true
          ),
          isBlockHidden: _isBlockHidden(clientId),
          isContentOnly: select2(store).getBlockEditingMode(
            clientId
          ) === "contentOnly"
        };
      },
      [clientId]
    );
    const shouldShowLockIcon = isLocked && !isContentOnly;
    const shouldShowBlockVisibilityIcon = canToggleBlockVisibility && isBlockHidden2;
    const isSticky = blockInformation?.positionType === "sticky";
    const images = useListViewImages({ clientId, isExpanded });
    const onDragStartHandler = (event) => {
      event.dataTransfer.clearData();
      onDragStart?.(event);
    };
    function onKeyDown(event) {
      if (event.keyCode === import_keycodes14.ENTER || event.keyCode === import_keycodes14.SPACE) {
        onClick(event);
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime294.jsxs)(
      "a",
      {
        className: clsx_default(
          "block-editor-list-view-block-select-button",
          className
        ),
        onClick,
        onContextMenu,
        onKeyDown,
        onMouseDown,
        ref,
        tabIndex,
        onFocus,
        onDragStart: onDragStartHandler,
        onDragEnd,
        draggable,
        href: `#block-${clientId}`,
        "aria-describedby": ariaDescribedBy,
        "aria-expanded": isExpanded,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(ListViewExpander, { onClick: onToggleExpanded }),
          /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(
            block_icon_default,
            {
              icon: blockInformation?.icon,
              showColors: true,
              context: "list-view"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime294.jsxs)(
            import_components152.__experimentalHStack,
            {
              alignment: "center",
              className: "block-editor-list-view-block-select-button__label-wrapper",
              justify: "flex-start",
              spacing: 1,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime294.jsx)("span", { className: "block-editor-list-view-block-select-button__title", children: /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(import_components152.__experimentalTruncate, { ellipsizeMode: "auto", children: blockTitle }) }),
                blockInformation?.anchor && /* @__PURE__ */ (0, import_jsx_runtime294.jsx)("span", { className: "block-editor-list-view-block-select-button__anchor-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(Badge2, { className: "block-editor-list-view-block-select-button__anchor", children: blockInformation.anchor }) }),
                isSticky && /* @__PURE__ */ (0, import_jsx_runtime294.jsx)("span", { className: "block-editor-list-view-block-select-button__sticky", children: /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(icon_default, { icon: pin_small_default }) }),
                images.length ? /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(
                  "span",
                  {
                    className: "block-editor-list-view-block-select-button__images",
                    "aria-hidden": true,
                    children: images.map((image, index) => /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(
                      "span",
                      {
                        className: "block-editor-list-view-block-select-button__image",
                        style: {
                          backgroundImage: `url(${image.url})`,
                          zIndex: images.length - index
                          // Ensure the first image is on top, and subsequent images are behind.
                        }
                      },
                      image.clientId
                    ))
                  }
                ) : null,
                shouldShowBlockVisibilityIcon && /* @__PURE__ */ (0, import_jsx_runtime294.jsx)("span", { className: "block-editor-list-view-block-select-button__block-visibility", children: /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(icon_default, { icon: unseen_default }) }),
                shouldShowLockIcon && /* @__PURE__ */ (0, import_jsx_runtime294.jsx)("span", { className: "block-editor-list-view-block-select-button__lock", children: /* @__PURE__ */ (0, import_jsx_runtime294.jsx)(icon_default, { icon: lock_small_default }) })
              ]
            }
          )
        ]
      }
    );
  }
  var block_select_button_default = (0, import_element162.forwardRef)(ListViewBlockSelectButton);

  // packages/block-editor/build-module/components/list-view/block-contents.js
  var ListViewBlockContents = (0, import_element163.forwardRef)(
    ({
      onClick,
      onToggleExpanded,
      block,
      isSelected,
      position: position2,
      siblingBlockCount,
      level,
      isExpanded,
      selectedClientIds,
      ...props
    }, ref) => {
      const { clientId } = block;
      const { AdditionalBlockContent, insertedBlock, setInsertedBlock } = useListViewContext();
      const draggableClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId];
      return /* @__PURE__ */ (0, import_jsx_runtime295.jsxs)(import_jsx_runtime295.Fragment, { children: [
        AdditionalBlockContent && /* @__PURE__ */ (0, import_jsx_runtime295.jsx)(
          AdditionalBlockContent,
          {
            block,
            insertedBlock,
            setInsertedBlock
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime295.jsx)(
          block_draggable_default,
          {
            appendToOwnerDocument: true,
            clientIds: draggableClientIds,
            cloneClassname: "block-editor-list-view-draggable-chip",
            children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0, import_jsx_runtime295.jsx)(
              block_select_button_default,
              {
                ref,
                className: "block-editor-list-view-block-contents",
                block,
                onClick,
                onToggleExpanded,
                isSelected,
                position: position2,
                siblingBlockCount,
                level,
                draggable,
                onDragStart,
                onDragEnd,
                isExpanded,
                ...props
              }
            )
          }
        )
      ] });
    }
  );
  var block_contents_default = ListViewBlockContents;

  // packages/block-editor/build-module/components/list-view/utils.js
  var import_i18n150 = __toESM(require_i18n());
  var import_dom35 = __toESM(require_dom());
  var getBlockPositionDescription = (position2, siblingCount, level) => (0, import_i18n150.sprintf)(
    /* translators: 1: The numerical position of the block. 2: The total number of blocks. 3. The level of nesting for the block. */
    (0, import_i18n150.__)("Block %1$d of %2$d, Level %3$d."),
    position2,
    siblingCount,
    level
  );
  var getBlockPropertiesDescription = (blockInformation, isLocked) => [
    blockInformation?.positionLabel ? `${(0, import_i18n150.sprintf)(
      // translators: %s: Position of selected block, e.g. "Sticky" or "Fixed".
      (0, import_i18n150.__)("Position: %s"),
      blockInformation.positionLabel
    )}.` : void 0,
    isLocked ? (0, import_i18n150.__)("This block is locked.") : void 0
  ].filter(Boolean).join(" ");
  var isClientIdSelected = (clientId, selectedBlockClientIds) => Array.isArray(selectedBlockClientIds) && selectedBlockClientIds.length ? selectedBlockClientIds.indexOf(clientId) !== -1 : selectedBlockClientIds === clientId;
  function getCommonDepthClientIds(startId, endId, startParents, endParents) {
    const startPath = [...startParents, startId];
    const endPath = [...endParents, endId];
    const depth = Math.min(startPath.length, endPath.length) - 1;
    const start2 = startPath[depth];
    const end = endPath[depth];
    return {
      start: start2,
      end
    };
  }
  function focusListItem(focusClientId, treeGridElement) {
    const getFocusElement = () => {
      const row = treeGridElement?.querySelector(
        `[role=row][data-block="${focusClientId}"]`
      );
      if (!row) {
        return null;
      }
      return import_dom35.focus.focusable.find(row)[0];
    };
    let focusElement = getFocusElement();
    if (focusElement) {
      focusElement.focus();
    } else {
      window.requestAnimationFrame(() => {
        focusElement = getFocusElement();
        if (focusElement) {
          focusElement.focus();
        }
      });
    }
  }
  function getDragDisplacementValues({
    blockIndexes,
    blockDropTargetIndex,
    blockDropPosition,
    clientId,
    firstDraggedBlockIndex,
    isDragged
  }) {
    let displacement;
    let isNesting;
    let isAfterDraggedBlocks;
    if (!isDragged) {
      isNesting = false;
      const thisBlockIndex = blockIndexes[clientId];
      isAfterDraggedBlocks = thisBlockIndex > firstDraggedBlockIndex;
      if (blockDropTargetIndex !== void 0 && blockDropTargetIndex !== null && firstDraggedBlockIndex !== void 0) {
        if (thisBlockIndex !== void 0) {
          if (thisBlockIndex >= firstDraggedBlockIndex && thisBlockIndex < blockDropTargetIndex) {
            displacement = "up";
          } else if (thisBlockIndex < firstDraggedBlockIndex && thisBlockIndex >= blockDropTargetIndex) {
            displacement = "down";
          } else {
            displacement = "normal";
          }
          isNesting = typeof blockDropTargetIndex === "number" && blockDropTargetIndex - 1 === thisBlockIndex && blockDropPosition === "inside";
        }
      } else if (blockDropTargetIndex === null && firstDraggedBlockIndex !== void 0) {
        if (thisBlockIndex !== void 0 && thisBlockIndex >= firstDraggedBlockIndex) {
          displacement = "up";
        } else {
          displacement = "normal";
        }
      } else if (blockDropTargetIndex !== void 0 && blockDropTargetIndex !== null && firstDraggedBlockIndex === void 0) {
        if (thisBlockIndex !== void 0) {
          if (thisBlockIndex < blockDropTargetIndex) {
            displacement = "normal";
          } else {
            displacement = "down";
          }
        }
      } else if (blockDropTargetIndex === null) {
        displacement = "normal";
      }
    }
    return {
      displacement,
      isNesting,
      isAfterDraggedBlocks
    };
  }

  // packages/block-editor/build-module/components/list-view/block.js
  function ListViewBlock({
    block: { clientId },
    displacement,
    isAfterDraggedBlocks,
    isDragged,
    isNesting,
    isSelected,
    isBranchSelected,
    selectBlock: selectBlock2,
    position: position2,
    level,
    rowCount,
    siblingBlockCount,
    showBlockMovers,
    path,
    isExpanded,
    selectedClientIds,
    isSyncedBranch
  }) {
    const cellRef = (0, import_element164.useRef)(null);
    const rowRef = (0, import_element164.useRef)(null);
    const settingsRef = (0, import_element164.useRef)(null);
    const [isHovered, setIsHovered] = (0, import_element164.useState)(false);
    const [settingsAnchorRect, setSettingsAnchorRect] = (0, import_element164.useState)();
    const { isLocked, canEdit, canMove } = useBlockLock(clientId);
    const isFirstSelectedBlock = isSelected && selectedClientIds[0] === clientId;
    const isLastSelectedBlock = isSelected && selectedClientIds[selectedClientIds.length - 1] === clientId;
    const {
      toggleBlockHighlight: toggleBlockHighlight2,
      duplicateBlocks: duplicateBlocks2,
      multiSelect: multiSelect2,
      replaceBlocks: replaceBlocks2,
      removeBlocks: removeBlocks2,
      insertAfterBlock: insertAfterBlock2,
      insertBeforeBlock: insertBeforeBlock2,
      setOpenedBlockSettingsMenu: setOpenedBlockSettingsMenu2,
      updateBlockAttributes: updateBlockAttributes2
    } = unlock((0, import_data132.useDispatch)(store));
    const debouncedToggleBlockHighlight = (0, import_compose73.useDebounce)(
      toggleBlockHighlight2,
      50
    );
    const {
      canInsertBlockType: canInsertBlockType2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      getPreviousBlockClientId: getPreviousBlockClientId2,
      getBlockRootClientId: getBlockRootClientId2,
      getBlockOrder: getBlockOrder2,
      getBlockParents: getBlockParents2,
      getBlocksByClientId: getBlocksByClientId2,
      canRemoveBlocks: canRemoveBlocks2,
      isGroupable: isGroupable2
    } = (0, import_data132.useSelect)(store);
    const { getGroupingBlockName } = (0, import_data132.useSelect)(import_blocks77.store);
    const blockInformation = useBlockDisplayInformation(clientId);
    const pasteStyles = usePasteStyles();
    const { block, blockName, allowRightClickOverrides, isBlockHidden: isBlockHidden2 } = (0, import_data132.useSelect)(
      (select2) => {
        const { getBlock: getBlock2, getBlockName: getBlockName2, getSettings: getSettings4 } = select2(store);
        const { isBlockHidden: _isBlockHidden } = unlock(
          select2(store)
        );
        return {
          block: getBlock2(clientId),
          blockName: getBlockName2(clientId),
          allowRightClickOverrides: getSettings4().allowRightClickOverrides,
          isBlockHidden: _isBlockHidden(clientId)
        };
      },
      [clientId]
    );
    const showBlockActions = (
      // When a block hides its toolbar it also hides the block settings menu,
      // since that menu is part of the toolbar in the editor canvas.
      // List View respects this by also hiding the block settings menu.
      (0, import_blocks77.hasBlockSupport)(blockName, "__experimentalToolbar", true)
    );
    const instanceId = (0, import_compose73.useInstanceId)(ListViewBlock);
    const descriptionId = `list-view-block-select-button__description-${instanceId}`;
    const {
      expand,
      collapse,
      collapseAll,
      BlockSettingsMenu: BlockSettingsMenu2,
      listViewInstanceId,
      expandedState,
      setInsertedBlock,
      treeGridElementRef,
      rootClientId
    } = useListViewContext();
    const isMatch = (0, import_keyboard_shortcuts9.__unstableUseShortcutEventMatch)();
    function getBlocksToUpdate() {
      const selectedBlockClientIds = getSelectedBlockClientIds2();
      const isUpdatingSelectedBlocks = selectedBlockClientIds.includes(clientId);
      const firstBlockClientId = isUpdatingSelectedBlocks ? selectedBlockClientIds[0] : clientId;
      const firstBlockRootClientId = getBlockRootClientId2(firstBlockClientId);
      const blocksToUpdate = isUpdatingSelectedBlocks ? selectedBlockClientIds : [clientId];
      return {
        blocksToUpdate,
        firstBlockClientId,
        firstBlockRootClientId,
        selectedBlockClientIds
      };
    }
    async function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.target.closest("[role=dialog]")) {
        return;
      }
      const isDeleteKey = [import_keycodes15.BACKSPACE, import_keycodes15.DELETE].includes(event.keyCode);
      if (isMatch("core/block-editor/unselect", event) && selectedClientIds.length > 0) {
        event.stopPropagation();
        event.preventDefault();
        selectBlock2(event, void 0);
      } else if (isDeleteKey || isMatch("core/block-editor/remove", event)) {
        const {
          blocksToUpdate: blocksToDelete,
          firstBlockClientId,
          firstBlockRootClientId,
          selectedBlockClientIds
        } = getBlocksToUpdate();
        if (!canRemoveBlocks2(blocksToDelete)) {
          return;
        }
        let blockToFocus = getPreviousBlockClientId2(firstBlockClientId) ?? // If the previous block is not found (when the first block is deleted),
        // fallback to focus the parent block.
        firstBlockRootClientId;
        removeBlocks2(blocksToDelete, false);
        const shouldUpdateSelection = selectedBlockClientIds.length > 0 && getSelectedBlockClientIds2().length === 0;
        if (!blockToFocus) {
          blockToFocus = getBlockOrder2()[0];
        }
        updateFocusAndSelection(blockToFocus, shouldUpdateSelection);
      } else if (isMatch("core/block-editor/paste-styles", event)) {
        event.preventDefault();
        const { blocksToUpdate } = getBlocksToUpdate();
        const blocks2 = getBlocksByClientId2(blocksToUpdate);
        pasteStyles(blocks2);
      } else if (isMatch("core/block-editor/duplicate", event)) {
        event.preventDefault();
        const { blocksToUpdate, firstBlockRootClientId } = getBlocksToUpdate();
        const canDuplicate = getBlocksByClientId2(blocksToUpdate).every(
          (blockToUpdate) => {
            return !!blockToUpdate && (0, import_blocks77.hasBlockSupport)(
              blockToUpdate.name,
              "multiple",
              true
            ) && canInsertBlockType2(
              blockToUpdate.name,
              firstBlockRootClientId
            );
          }
        );
        if (canDuplicate) {
          const updatedBlocks = await duplicateBlocks2(
            blocksToUpdate,
            false
          );
          if (updatedBlocks?.length) {
            updateFocusAndSelection(updatedBlocks[0], false);
          }
        }
      } else if (isMatch("core/block-editor/insert-before", event)) {
        event.preventDefault();
        const { blocksToUpdate } = getBlocksToUpdate();
        await insertBeforeBlock2(blocksToUpdate[0]);
        const newlySelectedBlocks = getSelectedBlockClientIds2();
        setOpenedBlockSettingsMenu2(void 0);
        updateFocusAndSelection(newlySelectedBlocks[0], false);
      } else if (isMatch("core/block-editor/insert-after", event)) {
        event.preventDefault();
        const { blocksToUpdate } = getBlocksToUpdate();
        await insertAfterBlock2(blocksToUpdate.at(-1));
        const newlySelectedBlocks = getSelectedBlockClientIds2();
        setOpenedBlockSettingsMenu2(void 0);
        updateFocusAndSelection(newlySelectedBlocks[0], false);
      } else if (isMatch("core/block-editor/select-all", event)) {
        event.preventDefault();
        const { firstBlockRootClientId, selectedBlockClientIds } = getBlocksToUpdate();
        const blockClientIds = getBlockOrder2(firstBlockRootClientId);
        if (!blockClientIds.length) {
          return;
        }
        if ((0, import_is_shallow_equal3.default)(selectedBlockClientIds, blockClientIds)) {
          if (firstBlockRootClientId && firstBlockRootClientId !== rootClientId) {
            updateFocusAndSelection(firstBlockRootClientId, true);
            return;
          }
        }
        multiSelect2(
          blockClientIds[0],
          blockClientIds[blockClientIds.length - 1],
          null
        );
      } else if (isMatch("core/block-editor/collapse-list-view", event)) {
        event.preventDefault();
        const { firstBlockClientId } = getBlocksToUpdate();
        const blockParents = getBlockParents2(firstBlockClientId, false);
        collapseAll();
        expand(blockParents);
      } else if (isMatch("core/block-editor/group", event)) {
        const { blocksToUpdate } = getBlocksToUpdate();
        if (blocksToUpdate.length > 1 && isGroupable2(blocksToUpdate)) {
          event.preventDefault();
          const blocks2 = getBlocksByClientId2(blocksToUpdate);
          const groupingBlockName = getGroupingBlockName();
          const newBlocks = (0, import_blocks77.switchToBlockType)(
            blocks2,
            groupingBlockName
          );
          replaceBlocks2(blocksToUpdate, newBlocks);
          (0, import_a11y15.speak)((0, import_i18n151.__)("Selected blocks are grouped."));
          const newlySelectedBlocks = getSelectedBlockClientIds2();
          setOpenedBlockSettingsMenu2(void 0);
          updateFocusAndSelection(newlySelectedBlocks[0], false);
        }
      } else if (isMatch("core/block-editor/toggle-block-visibility", event)) {
        event.preventDefault();
        const { blocksToUpdate } = getBlocksToUpdate();
        const blocks2 = getBlocksByClientId2(blocksToUpdate);
        const canToggleBlockVisibility = blocks2.every(
          (blockToUpdate) => (0, import_blocks77.hasBlockSupport)(blockToUpdate.name, "blockVisibility", true)
        );
        if (!canToggleBlockVisibility) {
          return;
        }
        const hasHiddenBlock = blocks2.some(
          (blockToUpdate) => blockToUpdate.attributes.metadata?.blockVisibility === false
        );
        const attributesByClientId = Object.fromEntries(
          blocks2.map(({ clientId: mapClientId, attributes }) => [
            mapClientId,
            {
              metadata: cleanEmptyObject({
                ...attributes?.metadata,
                blockVisibility: hasHiddenBlock ? void 0 : false
              })
            }
          ])
        );
        updateBlockAttributes2(blocksToUpdate, attributesByClientId, {
          uniqueByBlock: true
        });
      }
    }
    const onMouseEnter = (0, import_element164.useCallback)(() => {
      setIsHovered(true);
      debouncedToggleBlockHighlight(clientId, true);
    }, [clientId, setIsHovered, debouncedToggleBlockHighlight]);
    const onMouseLeave = (0, import_element164.useCallback)(() => {
      setIsHovered(false);
      debouncedToggleBlockHighlight(clientId, false);
    }, [clientId, setIsHovered, debouncedToggleBlockHighlight]);
    const selectEditorBlock = (0, import_element164.useCallback)(
      (event) => {
        selectBlock2(event, clientId);
        event.preventDefault();
      },
      [clientId, selectBlock2]
    );
    const updateFocusAndSelection = (0, import_element164.useCallback)(
      (focusClientId, shouldSelectBlock) => {
        if (shouldSelectBlock) {
          selectBlock2(void 0, focusClientId, null, null);
        }
        focusListItem(focusClientId, treeGridElementRef?.current);
      },
      [selectBlock2, treeGridElementRef]
    );
    const toggleExpanded = (0, import_element164.useCallback)(
      (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (isExpanded === true) {
          collapse(clientId);
        } else if (isExpanded === false) {
          expand(clientId);
        }
      },
      [clientId, expand, collapse, isExpanded]
    );
    const onContextMenu = (0, import_element164.useCallback)(
      (event) => {
        if (showBlockActions && allowRightClickOverrides) {
          settingsRef.current?.click();
          setSettingsAnchorRect(
            new window.DOMRect(event.clientX, event.clientY, 0, 0)
          );
          event.preventDefault();
        }
      },
      [allowRightClickOverrides, settingsRef, showBlockActions]
    );
    const onMouseDown = (0, import_element164.useCallback)(
      (event) => {
        if (allowRightClickOverrides && event.button === 2) {
          event.preventDefault();
        }
      },
      [allowRightClickOverrides]
    );
    const settingsPopoverAnchor = (0, import_element164.useMemo)(() => {
      const { ownerDocument } = rowRef?.current || {};
      if (!settingsAnchorRect || !ownerDocument) {
        return void 0;
      }
      return {
        ownerDocument,
        getBoundingClientRect() {
          return settingsAnchorRect;
        }
      };
    }, [settingsAnchorRect]);
    const clearSettingsAnchorRect = (0, import_element164.useCallback)(() => {
      setSettingsAnchorRect(void 0);
    }, [setSettingsAnchorRect]);
    useListViewScrollIntoView({
      isSelected,
      rowItemRef: rowRef,
      selectedClientIds
    });
    if (!block) {
      return null;
    }
    const blockPositionDescription = getBlockPositionDescription(
      position2,
      siblingBlockCount,
      level
    );
    const blockPropertiesDescription = getBlockPropertiesDescription(
      blockInformation,
      isLocked
    );
    const blockVisibilityDescription = isBlockHidden2 ? (0, import_i18n151.__)("Block is hidden.") : null;
    const hasSiblings = siblingBlockCount > 0;
    const hasRenderedMovers = showBlockMovers && hasSiblings;
    const moverCellClassName = clsx_default(
      "block-editor-list-view-block__mover-cell",
      { "is-visible": isHovered || isSelected }
    );
    const listViewBlockSettingsClassName = clsx_default(
      "block-editor-list-view-block__menu-cell",
      { "is-visible": isHovered || isFirstSelectedBlock }
    );
    let colSpan;
    if (hasRenderedMovers) {
      colSpan = 2;
    } else if (!showBlockActions) {
      colSpan = 3;
    }
    const classes = clsx_default({
      "is-selected": isSelected,
      "is-first-selected": isFirstSelectedBlock,
      "is-last-selected": isLastSelectedBlock,
      "is-branch-selected": isBranchSelected,
      "is-synced-branch": isSyncedBranch,
      "is-dragging": isDragged,
      "has-single-cell": !showBlockActions,
      "is-synced": blockInformation?.isSynced,
      "is-draggable": canMove,
      "is-displacement-normal": displacement === "normal",
      "is-displacement-up": displacement === "up",
      "is-displacement-down": displacement === "down",
      "is-after-dragged-blocks": isAfterDraggedBlocks,
      "is-nesting": isNesting
    });
    const dropdownClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId];
    const currentlyEditingBlockInCanvas = isSelected && selectedClientIds.length === 1;
    return /* @__PURE__ */ (0, import_jsx_runtime296.jsxs)(
      leaf_default,
      {
        className: classes,
        isDragged,
        onKeyDown,
        onMouseEnter,
        onMouseLeave,
        onFocus: onMouseEnter,
        onBlur: onMouseLeave,
        level,
        position: position2,
        rowCount,
        path,
        id: `list-view-${listViewInstanceId}-block-${clientId}`,
        "data-block": clientId,
        "data-expanded": canEdit ? isExpanded : void 0,
        ref: rowRef,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(
            import_components153.__experimentalTreeGridCell,
            {
              className: "block-editor-list-view-block__contents-cell",
              colSpan,
              ref: cellRef,
              "aria-selected": !!isSelected,
              children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0, import_jsx_runtime296.jsxs)("div", { className: "block-editor-list-view-block__contents-container", children: [
                /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(
                  block_contents_default,
                  {
                    block,
                    onClick: selectEditorBlock,
                    onContextMenu,
                    onMouseDown,
                    onToggleExpanded: toggleExpanded,
                    isSelected,
                    position: position2,
                    siblingBlockCount,
                    level,
                    ref,
                    tabIndex: currentlyEditingBlockInCanvas ? 0 : tabIndex,
                    onFocus,
                    isExpanded: canEdit ? isExpanded : void 0,
                    selectedClientIds,
                    ariaDescribedBy: descriptionId
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(AriaReferencedText, { id: descriptionId, children: [
                  blockPositionDescription,
                  blockPropertiesDescription,
                  blockVisibilityDescription
                ].filter(Boolean).join(" ") })
              ] })
            }
          ),
          hasRenderedMovers && /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(import_jsx_runtime296.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime296.jsxs)(
            import_components153.__experimentalTreeGridCell,
            {
              className: moverCellClassName,
              withoutGridItem: true,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(import_components153.__experimentalTreeGridItem, { children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(
                  BlockMoverUpButton,
                  {
                    orientation: "vertical",
                    clientIds: [clientId],
                    ref,
                    tabIndex,
                    onFocus
                  }
                ) }),
                /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(import_components153.__experimentalTreeGridItem, { children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(
                  BlockMoverDownButton,
                  {
                    orientation: "vertical",
                    clientIds: [clientId],
                    ref,
                    tabIndex,
                    onFocus
                  }
                ) })
              ]
            }
          ) }),
          showBlockActions && BlockSettingsMenu2 && /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(
            import_components153.__experimentalTreeGridCell,
            {
              className: listViewBlockSettingsClassName,
              "aria-selected": !!isSelected,
              ref: settingsRef,
              children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0, import_jsx_runtime296.jsx)(
                BlockSettingsMenu2,
                {
                  clientIds: dropdownClientIds,
                  block,
                  icon: more_vertical_default,
                  label: (0, import_i18n151.__)("Options"),
                  popoverProps: {
                    anchor: settingsPopoverAnchor
                    // Used to position the settings at the cursor on right-click.
                  },
                  toggleProps: {
                    ref,
                    className: "block-editor-list-view-block__menu",
                    tabIndex,
                    onClick: clearSettingsAnchorRect,
                    onFocus,
                    size: "small"
                  },
                  disableOpenOnArrowDown: true,
                  expand,
                  expandedState,
                  setInsertedBlock,
                  __experimentalSelectBlock: updateFocusAndSelection
                }
              )
            }
          )
        ]
      }
    );
  }
  var block_default3 = (0, import_element164.memo)(ListViewBlock);

  // packages/block-editor/build-module/components/list-view/branch.js
  function countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault) {
    const isDragged = draggedClientIds?.includes(block.clientId);
    if (isDragged) {
      return 0;
    }
    const isExpanded = expandedState[block.clientId] ?? isExpandedByDefault;
    if (isExpanded) {
      return 1 + block.innerBlocks.reduce(
        countReducer(
          expandedState,
          draggedClientIds,
          isExpandedByDefault
        ),
        0
      );
    }
    return 1;
  }
  var countReducer = (expandedState, draggedClientIds, isExpandedByDefault) => (count, block) => {
    const isDragged = draggedClientIds?.includes(block.clientId);
    if (isDragged) {
      return count;
    }
    const isExpanded = expandedState[block.clientId] ?? isExpandedByDefault;
    if (isExpanded && block.innerBlocks.length > 0) {
      return count + countBlocks(
        block,
        expandedState,
        draggedClientIds,
        isExpandedByDefault
      );
    }
    return count + 1;
  };
  var noop15 = () => {
  };
  function ListViewBranch(props) {
    const {
      blocks: blocks2,
      selectBlock: selectBlock2 = noop15,
      showBlockMovers,
      selectedClientIds,
      level = 1,
      path = "",
      isBranchSelected = false,
      listPosition = 0,
      fixedListWindow,
      isExpanded,
      parentId,
      shouldShowInnerBlocks = true,
      isSyncedBranch = false,
      showAppender: showAppenderProp = true
    } = props;
    const parentBlockInformation = useBlockDisplayInformation(parentId);
    const syncedBranch = isSyncedBranch || !!parentBlockInformation?.isSynced;
    const canParentExpand = (0, import_data133.useSelect)(
      (select2) => {
        if (!parentId) {
          return true;
        }
        return select2(store).canEditBlock(parentId);
      },
      [parentId]
    );
    const {
      blockDropPosition,
      blockDropTargetIndex,
      firstDraggedBlockIndex,
      blockIndexes,
      expandedState,
      draggedClientIds
    } = useListViewContext();
    const nextPositionRef = (0, import_element165.useRef)();
    if (!canParentExpand) {
      return null;
    }
    const showAppender = showAppenderProp && level === 1;
    const filteredBlocks = blocks2.filter(Boolean);
    const blockCount = filteredBlocks.length;
    const rowCount = showAppender ? blockCount + 1 : blockCount;
    nextPositionRef.current = listPosition;
    return /* @__PURE__ */ (0, import_jsx_runtime297.jsxs)(import_jsx_runtime297.Fragment, { children: [
      filteredBlocks.map((block, index) => {
        const { clientId, innerBlocks } = block;
        if (index > 0) {
          nextPositionRef.current += countBlocks(
            filteredBlocks[index - 1],
            expandedState,
            draggedClientIds,
            isExpanded
          );
        }
        const isDragged = !!draggedClientIds?.includes(clientId);
        const { displacement, isAfterDraggedBlocks, isNesting } = getDragDisplacementValues({
          blockIndexes,
          blockDropTargetIndex,
          blockDropPosition,
          clientId,
          firstDraggedBlockIndex,
          isDragged
        });
        const { itemInView } = fixedListWindow;
        const blockInView = itemInView(nextPositionRef.current);
        const position2 = index + 1;
        const updatedPath = path.length > 0 ? `${path}_${position2}` : `${position2}`;
        const hasNestedBlocks = !!innerBlocks?.length;
        const shouldExpand = hasNestedBlocks && shouldShowInnerBlocks ? expandedState[clientId] ?? isExpanded : void 0;
        const isSelected = isClientIdSelected(
          clientId,
          selectedClientIds
        );
        const isSelectedBranch = isBranchSelected || isSelected && hasNestedBlocks;
        const showBlock = isDragged || blockInView || isSelected && clientId === selectedClientIds[0] || index === 0 || index === blockCount - 1;
        return /* @__PURE__ */ (0, import_jsx_runtime297.jsxs)(import_data133.AsyncModeProvider, { value: !isSelected, children: [
          showBlock && /* @__PURE__ */ (0, import_jsx_runtime297.jsx)(
            block_default3,
            {
              block,
              selectBlock: selectBlock2,
              isSelected,
              isBranchSelected: isSelectedBranch,
              isDragged,
              level,
              position: position2,
              rowCount,
              siblingBlockCount: blockCount,
              showBlockMovers,
              path: updatedPath,
              isExpanded: isDragged ? false : shouldExpand,
              listPosition: nextPositionRef.current,
              selectedClientIds,
              isSyncedBranch: syncedBranch,
              displacement,
              isAfterDraggedBlocks,
              isNesting
            }
          ),
          !showBlock && /* @__PURE__ */ (0, import_jsx_runtime297.jsx)("tr", { children: /* @__PURE__ */ (0, import_jsx_runtime297.jsx)("td", { className: "block-editor-list-view-placeholder" }) }),
          hasNestedBlocks && shouldExpand && !isDragged && /* @__PURE__ */ (0, import_jsx_runtime297.jsx)(
            ListViewBranch,
            {
              parentId: clientId,
              blocks: innerBlocks,
              selectBlock: selectBlock2,
              showBlockMovers,
              level: level + 1,
              path: updatedPath,
              listPosition: nextPositionRef.current + 1,
              fixedListWindow,
              isBranchSelected: isSelectedBranch,
              selectedClientIds,
              isExpanded,
              isSyncedBranch: syncedBranch
            }
          )
        ] }, clientId);
      }),
      showAppender && /* @__PURE__ */ (0, import_jsx_runtime297.jsx)(
        import_components154.__experimentalTreeGridRow,
        {
          level,
          setSize: rowCount,
          positionInSet: rowCount,
          isExpanded: true,
          children: /* @__PURE__ */ (0, import_jsx_runtime297.jsx)(import_components154.__experimentalTreeGridCell, { children: (treeGridCellProps) => /* @__PURE__ */ (0, import_jsx_runtime297.jsx)(
            Appender,
            {
              clientId: parentId,
              nestingLevel: level,
              blockCount,
              ...treeGridCellProps
            }
          ) })
        }
      )
    ] });
  }
  var branch_default = (0, import_element165.memo)(ListViewBranch);

  // packages/block-editor/build-module/components/list-view/drop-indicator.js
  var import_jsx_runtime298 = __toESM(require_jsx_runtime());
  var import_components155 = __toESM(require_components());
  var import_dom36 = __toESM(require_dom());
  var import_element166 = __toESM(require_element());
  var import_i18n152 = __toESM(require_i18n());
  function ListViewDropIndicatorPreview({
    draggedBlockClientId,
    listViewRef,
    blockDropTarget
  }) {
    const blockInformation = useBlockDisplayInformation(draggedBlockClientId);
    const blockTitle = useBlockDisplayTitle({
      clientId: draggedBlockClientId,
      context: "list-view"
    });
    const { rootClientId, clientId, dropPosition } = blockDropTarget || {};
    const [rootBlockElement, blockElement] = (0, import_element166.useMemo)(() => {
      if (!listViewRef.current) {
        return [];
      }
      const _rootBlockElement = rootClientId ? listViewRef.current.querySelector(
        `[data-block="${rootClientId}"]`
      ) : void 0;
      const _blockElement = clientId ? listViewRef.current.querySelector(
        `[data-block="${clientId}"]`
      ) : void 0;
      return [_rootBlockElement, _blockElement];
    }, [listViewRef, rootClientId, clientId]);
    const targetElement = blockElement || rootBlockElement;
    const rtl = (0, import_i18n152.isRTL)();
    const getDropIndicatorWidth = (0, import_element166.useCallback)(
      (targetElementRect, indent) => {
        if (!targetElement) {
          return 0;
        }
        let width = targetElement.offsetWidth;
        const scrollContainer = (0, import_dom36.getScrollContainer)(
          targetElement,
          "horizontal"
        );
        const ownerDocument = targetElement.ownerDocument;
        const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
        if (scrollContainer && !windowScroll) {
          const scrollContainerRect = scrollContainer.getBoundingClientRect();
          const distanceBetweenContainerAndTarget = (0, import_i18n152.isRTL)() ? scrollContainerRect.right - targetElementRect.right : targetElementRect.left - scrollContainerRect.left;
          const scrollContainerWidth = scrollContainer.clientWidth;
          if (scrollContainerWidth < width + distanceBetweenContainerAndTarget) {
            width = scrollContainerWidth - distanceBetweenContainerAndTarget;
          }
          if (!rtl && targetElementRect.left + indent < scrollContainerRect.left) {
            width -= scrollContainerRect.left - targetElementRect.left;
            return width;
          }
          if (rtl && targetElementRect.right - indent > scrollContainerRect.right) {
            width -= targetElementRect.right - scrollContainerRect.right;
            return width;
          }
        }
        return width - indent;
      },
      [rtl, targetElement]
    );
    const style = (0, import_element166.useMemo)(() => {
      if (!targetElement) {
        return {};
      }
      const targetElementRect = targetElement.getBoundingClientRect();
      return {
        width: getDropIndicatorWidth(targetElementRect, 0)
      };
    }, [getDropIndicatorWidth, targetElement]);
    const horizontalScrollOffsetStyle = (0, import_element166.useMemo)(() => {
      if (!targetElement) {
        return {};
      }
      const scrollContainer = (0, import_dom36.getScrollContainer)(targetElement);
      const ownerDocument = targetElement.ownerDocument;
      const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
      if (scrollContainer && !windowScroll) {
        const scrollContainerRect = scrollContainer.getBoundingClientRect();
        const targetElementRect = targetElement.getBoundingClientRect();
        const distanceBetweenContainerAndTarget = rtl ? scrollContainerRect.right - targetElementRect.right : targetElementRect.left - scrollContainerRect.left;
        if (!rtl && scrollContainerRect.left > targetElementRect.left) {
          return {
            transform: `translateX( ${distanceBetweenContainerAndTarget}px )`
          };
        }
        if (rtl && scrollContainerRect.right < targetElementRect.right) {
          return {
            transform: `translateX( ${distanceBetweenContainerAndTarget * -1}px )`
          };
        }
      }
      return {};
    }, [rtl, targetElement]);
    const ariaLevel = (0, import_element166.useMemo)(() => {
      if (!rootBlockElement) {
        return 1;
      }
      const _ariaLevel = parseInt(
        rootBlockElement.getAttribute("aria-level"),
        10
      );
      return _ariaLevel ? _ariaLevel + 1 : 1;
    }, [rootBlockElement]);
    const hasAdjacentSelectedBranch = (0, import_element166.useMemo)(() => {
      if (!targetElement) {
        return false;
      }
      return targetElement.classList.contains("is-branch-selected");
    }, [targetElement]);
    const popoverAnchor = (0, import_element166.useMemo)(() => {
      const isValidDropPosition = dropPosition === "top" || dropPosition === "bottom" || dropPosition === "inside";
      if (!targetElement || !isValidDropPosition) {
        return void 0;
      }
      return {
        contextElement: targetElement,
        getBoundingClientRect() {
          const rect = targetElement.getBoundingClientRect();
          let left = rect.left;
          let top = 0;
          const scrollContainer = (0, import_dom36.getScrollContainer)(
            targetElement,
            "horizontal"
          );
          const doc = targetElement.ownerDocument;
          const windowScroll = scrollContainer === doc.body || scrollContainer === doc.documentElement;
          if (scrollContainer && !windowScroll) {
            const scrollContainerRect = scrollContainer.getBoundingClientRect();
            const scrollbarWidth = rtl ? scrollContainer.offsetWidth - scrollContainer.clientWidth : 0;
            if (left < scrollContainerRect.left + scrollbarWidth) {
              left = scrollContainerRect.left + scrollbarWidth;
            }
          }
          if (dropPosition === "top") {
            top = rect.top - rect.height * 2;
          } else {
            top = rect.top;
          }
          const width = getDropIndicatorWidth(rect, 0);
          const height = rect.height;
          return new window.DOMRect(left, top, width, height);
        }
      };
    }, [targetElement, dropPosition, getDropIndicatorWidth, rtl]);
    if (!targetElement) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime298.jsx)(
      import_components155.Popover,
      {
        animate: false,
        anchor: popoverAnchor,
        focusOnMount: false,
        className: "block-editor-list-view-drop-indicator--preview",
        variant: "unstyled",
        flip: false,
        resize: true,
        children: /* @__PURE__ */ (0, import_jsx_runtime298.jsx)(
          "div",
          {
            style,
            className: clsx_default(
              "block-editor-list-view-drop-indicator__line",
              {
                "block-editor-list-view-drop-indicator__line--darker": hasAdjacentSelectedBranch
              }
            ),
            children: /* @__PURE__ */ (0, import_jsx_runtime298.jsxs)(
              "div",
              {
                className: "block-editor-list-view-leaf",
                "aria-level": ariaLevel,
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime298.jsxs)(
                    "div",
                    {
                      className: clsx_default(
                        "block-editor-list-view-block-select-button",
                        "block-editor-list-view-block-contents"
                      ),
                      style: horizontalScrollOffsetStyle,
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime298.jsx)(ListViewExpander, { onClick: () => {
                        } }),
                        /* @__PURE__ */ (0, import_jsx_runtime298.jsx)(
                          block_icon_default,
                          {
                            icon: blockInformation?.icon,
                            showColors: true,
                            context: "list-view"
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime298.jsx)(
                          import_components155.__experimentalHStack,
                          {
                            alignment: "center",
                            className: "block-editor-list-view-block-select-button__label-wrapper",
                            justify: "flex-start",
                            spacing: 1,
                            children: /* @__PURE__ */ (0, import_jsx_runtime298.jsx)("span", { className: "block-editor-list-view-block-select-button__title", children: /* @__PURE__ */ (0, import_jsx_runtime298.jsx)(import_components155.__experimentalTruncate, { ellipsizeMode: "auto", children: blockTitle }) })
                          }
                        )
                      ]
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime298.jsx)("div", { className: "block-editor-list-view-block__menu-cell" })
                ]
              }
            )
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/list-view/use-block-selection.js
  var import_a11y16 = __toESM(require_a11y());
  var import_i18n153 = __toESM(require_i18n());
  var import_data134 = __toESM(require_data());
  var import_element167 = __toESM(require_element());
  var import_keycodes16 = __toESM(require_keycodes());
  var import_blocks78 = __toESM(require_blocks());
  function useBlockSelection() {
    const { clearSelectedBlock: clearSelectedBlock2, multiSelect: multiSelect2, selectBlock: selectBlock2 } = (0, import_data134.useDispatch)(store);
    const {
      getBlockName: getBlockName2,
      getBlockParents: getBlockParents2,
      getBlockSelectionStart: getBlockSelectionStart2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      hasMultiSelection: hasMultiSelection2,
      hasSelectedBlock: hasSelectedBlock2
    } = (0, import_data134.useSelect)(store);
    const { getBlockType: getBlockType21 } = (0, import_data134.useSelect)(import_blocks78.store);
    const updateBlockSelection = (0, import_element167.useCallback)(
      async (event, clientId, destinationClientId, focusPosition) => {
        if (!event?.shiftKey && event?.keyCode !== import_keycodes16.ESCAPE) {
          selectBlock2(clientId, focusPosition);
          return;
        }
        event.preventDefault();
        const isOnlyDeselection = event.type === "keydown" && event.keyCode === import_keycodes16.ESCAPE;
        const isKeyPress = event.type === "keydown" && (event.keyCode === import_keycodes16.UP || event.keyCode === import_keycodes16.DOWN || event.keyCode === import_keycodes16.HOME || event.keyCode === import_keycodes16.END);
        if (!isKeyPress && !hasSelectedBlock2() && !hasMultiSelection2()) {
          selectBlock2(clientId, null);
          return;
        }
        const selectedBlocks = getSelectedBlockClientIds2();
        const clientIdWithParents = [
          ...getBlockParents2(clientId),
          clientId
        ];
        if (isOnlyDeselection || isKeyPress && !selectedBlocks.some(
          (blockId) => clientIdWithParents.includes(blockId)
        )) {
          await clearSelectedBlock2();
        }
        if (!isOnlyDeselection) {
          let startTarget = getBlockSelectionStart2();
          let endTarget = clientId;
          if (isKeyPress) {
            if (!hasSelectedBlock2() && !hasMultiSelection2()) {
              startTarget = clientId;
            }
            if (destinationClientId) {
              endTarget = destinationClientId;
            }
          }
          const startParents = getBlockParents2(startTarget);
          const endParents = getBlockParents2(endTarget);
          const { start: start2, end } = getCommonDepthClientIds(
            startTarget,
            endTarget,
            startParents,
            endParents
          );
          await multiSelect2(start2, end, null);
        }
        const updatedSelectedBlocks = getSelectedBlockClientIds2();
        if ((event.keyCode === import_keycodes16.HOME || event.keyCode === import_keycodes16.END) && updatedSelectedBlocks.length > 1) {
          return;
        }
        const selectionDiff = selectedBlocks.filter(
          (blockId) => !updatedSelectedBlocks.includes(blockId)
        );
        let label;
        if (selectionDiff.length === 1) {
          const title = getBlockType21(
            getBlockName2(selectionDiff[0])
          )?.title;
          if (title) {
            label = (0, import_i18n153.sprintf)(
              /* translators: %s: block name */
              (0, import_i18n153.__)("%s deselected."),
              title
            );
          }
        } else if (selectionDiff.length > 1) {
          label = (0, import_i18n153.sprintf)(
            /* translators: %s: number of deselected blocks */
            (0, import_i18n153.__)("%s blocks deselected."),
            selectionDiff.length
          );
        }
        if (label) {
          (0, import_a11y16.speak)(label, "assertive");
        }
      },
      [
        clearSelectedBlock2,
        getBlockName2,
        getBlockType21,
        getBlockParents2,
        getBlockSelectionStart2,
        getSelectedBlockClientIds2,
        hasMultiSelection2,
        hasSelectedBlock2,
        multiSelect2,
        selectBlock2
      ]
    );
    return {
      updateBlockSelection
    };
  }

  // packages/block-editor/build-module/components/list-view/use-list-view-block-indexes.js
  var import_element168 = __toESM(require_element());
  function useListViewBlockIndexes(blocks2) {
    const blockIndexes = (0, import_element168.useMemo)(() => {
      const indexes = {};
      let currentGlobalIndex = 0;
      const traverseBlocks = (blockList) => {
        blockList.forEach((block) => {
          indexes[block.clientId] = currentGlobalIndex;
          currentGlobalIndex++;
          if (block.innerBlocks.length > 0) {
            traverseBlocks(block.innerBlocks);
          }
        });
      };
      traverseBlocks(blocks2);
      return indexes;
    }, [blocks2]);
    return blockIndexes;
  }

  // packages/block-editor/build-module/components/list-view/use-list-view-client-ids.js
  var import_data135 = __toESM(require_data());
  function useListViewClientIds({ blocks: blocks2, rootClientId }) {
    return (0, import_data135.useSelect)(
      (select2) => {
        const {
          getDraggedBlockClientIds: getDraggedBlockClientIds2,
          getSelectedBlockClientIds: getSelectedBlockClientIds2,
          getEnabledClientIdsTree: getEnabledClientIdsTree2
        } = unlock(select2(store));
        return {
          selectedClientIds: getSelectedBlockClientIds2(),
          draggedClientIds: getDraggedBlockClientIds2(),
          clientIdsTree: blocks2 ?? getEnabledClientIdsTree2(rootClientId)
        };
      },
      [blocks2, rootClientId]
    );
  }

  // packages/block-editor/build-module/components/list-view/use-list-view-collapse-items.js
  var import_element169 = __toESM(require_element());
  var import_data136 = __toESM(require_data());
  function useListViewCollapseItems({ collapseAll, expand }) {
    const { expandedBlock: expandedBlock2, getBlockParents: getBlockParents2 } = (0, import_data136.useSelect)((select2) => {
      const { getBlockParents: _getBlockParents, getExpandedBlock: getExpandedBlock2 } = unlock(
        select2(store)
      );
      return {
        expandedBlock: getExpandedBlock2(),
        getBlockParents: _getBlockParents
      };
    }, []);
    (0, import_element169.useEffect)(() => {
      if (expandedBlock2) {
        const blockParents = getBlockParents2(expandedBlock2, false);
        collapseAll();
        expand(blockParents);
      }
    }, [collapseAll, expand, expandedBlock2, getBlockParents2]);
  }

  // packages/block-editor/build-module/components/list-view/use-list-view-drop-zone.js
  var import_data137 = __toESM(require_data());
  var import_element170 = __toESM(require_element());
  var import_compose74 = __toESM(require_compose());
  var import_i18n154 = __toESM(require_i18n());
  var NESTING_LEVEL_INDENTATION = 24;
  function isUpGesture(point, rect, nestingLevel = 1, rtl = false) {
    const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
    return rtl ? point.x > blockIndentPosition : point.x < blockIndentPosition;
  }
  function getDesiredRelativeParentLevel(point, rect, nestingLevel = 1, rtl = false) {
    const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
    const distanceBetweenPointAndBlockIndentPosition = rtl ? blockIndentPosition - point.x : point.x - blockIndentPosition;
    const desiredParentLevel = Math.round(
      distanceBetweenPointAndBlockIndentPosition / NESTING_LEVEL_INDENTATION
    );
    return Math.abs(desiredParentLevel);
  }
  function getCandidateBlockParents(candidateBlockData, blocksData) {
    const candidateBlockParents = [];
    let currentBlockData = candidateBlockData;
    while (currentBlockData) {
      candidateBlockParents.push({ ...currentBlockData });
      currentBlockData = blocksData.find(
        (blockData) => blockData.clientId === currentBlockData.rootClientId
      );
    }
    return candidateBlockParents;
  }
  function getNextNonDraggedBlock(blocksData, index) {
    const nextBlockData = blocksData[index + 1];
    if (nextBlockData && nextBlockData.isDraggedBlock) {
      return getNextNonDraggedBlock(blocksData, index + 1);
    }
    return nextBlockData;
  }
  function isNestingGesture(point, rect, nestingLevel = 1, rtl = false) {
    const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
    const isNestingHorizontalGesture = rtl ? point.x < blockIndentPosition - NESTING_LEVEL_INDENTATION : point.x > blockIndentPosition + NESTING_LEVEL_INDENTATION;
    return isNestingHorizontalGesture && point.y < rect.bottom;
  }
  var ALLOWED_DROP_EDGES = ["top", "bottom"];
  function getListViewDropTarget(blocksData, position2, rtl = false) {
    let candidateEdge;
    let candidateBlockData;
    let candidateDistance;
    let candidateRect;
    let candidateBlockIndex;
    for (let i2 = 0; i2 < blocksData.length; i2++) {
      const blockData = blocksData[i2];
      if (blockData.isDraggedBlock) {
        continue;
      }
      const rect = blockData.element.getBoundingClientRect();
      const [distance, edge] = getDistanceToNearestEdge(
        position2,
        rect,
        ALLOWED_DROP_EDGES
      );
      const isCursorWithinBlock = isPointContainedByRect(position2, rect);
      if (candidateDistance === void 0 || distance < candidateDistance || isCursorWithinBlock) {
        candidateDistance = distance;
        const index = blocksData.indexOf(blockData);
        const previousBlockData = blocksData[index - 1];
        if (edge === "top" && previousBlockData && previousBlockData.rootClientId === blockData.rootClientId && !previousBlockData.isDraggedBlock) {
          candidateBlockData = previousBlockData;
          candidateEdge = "bottom";
          candidateRect = previousBlockData.element.getBoundingClientRect();
          candidateBlockIndex = index - 1;
        } else {
          candidateBlockData = blockData;
          candidateEdge = edge;
          candidateRect = rect;
          candidateBlockIndex = index;
        }
        if (isCursorWithinBlock) {
          break;
        }
      }
    }
    if (!candidateBlockData) {
      return;
    }
    const candidateBlockParents = getCandidateBlockParents(
      candidateBlockData,
      blocksData
    );
    const isDraggingBelow = candidateEdge === "bottom";
    if (isDraggingBelow && candidateBlockData.canInsertDraggedBlocksAsChild && (candidateBlockData.innerBlockCount > 0 && candidateBlockData.isExpanded || isNestingGesture(
      position2,
      candidateRect,
      candidateBlockParents.length,
      rtl
    ))) {
      const newBlockIndex = candidateBlockData.isExpanded ? 0 : candidateBlockData.innerBlockCount || 0;
      return {
        rootClientId: candidateBlockData.clientId,
        clientId: candidateBlockData.clientId,
        blockIndex: newBlockIndex,
        dropPosition: "inside"
      };
    }
    if (isDraggingBelow && candidateBlockData.rootClientId && isUpGesture(
      position2,
      candidateRect,
      candidateBlockParents.length,
      rtl
    )) {
      const nextBlock = getNextNonDraggedBlock(
        blocksData,
        candidateBlockIndex
      );
      const currentLevel = candidateBlockData.nestingLevel;
      const nextLevel = nextBlock ? nextBlock.nestingLevel : 1;
      if (currentLevel && nextLevel) {
        const desiredRelativeLevel = getDesiredRelativeParentLevel(
          position2,
          candidateRect,
          candidateBlockParents.length,
          rtl
        );
        const targetParentIndex = Math.max(
          Math.min(desiredRelativeLevel, currentLevel - nextLevel),
          0
        );
        if (candidateBlockParents[targetParentIndex]) {
          let newBlockIndex = candidateBlockData.blockIndex;
          if (candidateBlockParents[targetParentIndex].nestingLevel === nextBlock?.nestingLevel) {
            newBlockIndex = nextBlock?.blockIndex;
          } else {
            for (let i2 = candidateBlockIndex; i2 >= 0; i2--) {
              const blockData = blocksData[i2];
              if (blockData.rootClientId === candidateBlockParents[targetParentIndex].rootClientId) {
                newBlockIndex = blockData.blockIndex + 1;
                break;
              }
            }
          }
          return {
            rootClientId: candidateBlockParents[targetParentIndex].rootClientId,
            clientId: candidateBlockData.clientId,
            blockIndex: newBlockIndex,
            dropPosition: candidateEdge
          };
        }
      }
    }
    if (!candidateBlockData.canInsertDraggedBlocksAsSibling) {
      return;
    }
    const offset = isDraggingBelow ? 1 : 0;
    return {
      rootClientId: candidateBlockData.rootClientId,
      clientId: candidateBlockData.clientId,
      blockIndex: candidateBlockData.blockIndex + offset,
      dropPosition: candidateEdge
    };
  }
  var EXPAND_THROTTLE_OPTIONS = {
    leading: false,
    // Don't call the function immediately on the first call.
    trailing: true
    // Do call the function on the last call.
  };
  function useListViewDropZone({
    dropZoneElement,
    expandedState,
    setExpandedState
  }) {
    const {
      getBlockRootClientId: getBlockRootClientId2,
      getBlockIndex: getBlockIndex2,
      getBlockCount: getBlockCount2,
      getDraggedBlockClientIds: getDraggedBlockClientIds2,
      canInsertBlocks: canInsertBlocks2
    } = (0, import_data137.useSelect)(store);
    const [target, setTarget] = (0, import_element170.useState)();
    const { rootClientId: targetRootClientId, blockIndex: targetBlockIndex } = target || {};
    const onBlockDrop2 = useOnBlockDrop(targetRootClientId, targetBlockIndex);
    const rtl = (0, import_i18n154.isRTL)();
    const previousRootClientId = (0, import_compose74.usePrevious)(targetRootClientId);
    const maybeExpandBlock = (0, import_element170.useCallback)(
      (_expandedState, _target) => {
        const { rootClientId } = _target || {};
        if (!rootClientId) {
          return;
        }
        if (_target?.dropPosition === "inside" && !_expandedState[rootClientId]) {
          setExpandedState({
            type: "expand",
            clientIds: [rootClientId]
          });
        }
      },
      [setExpandedState]
    );
    const throttledMaybeExpandBlock = (0, import_compose74.useThrottle)(
      maybeExpandBlock,
      500,
      EXPAND_THROTTLE_OPTIONS
    );
    (0, import_element170.useEffect)(() => {
      if (target?.dropPosition !== "inside" || previousRootClientId !== target?.rootClientId) {
        throttledMaybeExpandBlock.cancel();
        return;
      }
      throttledMaybeExpandBlock(expandedState, target);
    }, [
      expandedState,
      previousRootClientId,
      target,
      throttledMaybeExpandBlock
    ]);
    const draggedBlockClientIds = getDraggedBlockClientIds2();
    const throttled = (0, import_compose74.useThrottle)(
      (0, import_element170.useCallback)(
        (event, currentTarget) => {
          const position2 = { x: event.clientX, y: event.clientY };
          const isBlockDrag = !!draggedBlockClientIds?.length;
          const blockElements = Array.from(
            currentTarget.querySelectorAll("[data-block]")
          );
          const blocksData = blockElements.map((blockElement) => {
            const clientId = blockElement.dataset.block;
            const isExpanded = blockElement.dataset.expanded === "true";
            const isDraggedBlock = blockElement.classList.contains("is-dragging");
            const nestingLevel = parseInt(
              blockElement.getAttribute("aria-level"),
              10
            );
            const rootClientId = getBlockRootClientId2(clientId);
            return {
              clientId,
              isExpanded,
              rootClientId,
              blockIndex: getBlockIndex2(clientId),
              element: blockElement,
              nestingLevel: nestingLevel || void 0,
              isDraggedBlock: isBlockDrag ? isDraggedBlock : false,
              innerBlockCount: getBlockCount2(clientId),
              canInsertDraggedBlocksAsSibling: isBlockDrag ? canInsertBlocks2(
                draggedBlockClientIds,
                rootClientId
              ) : true,
              canInsertDraggedBlocksAsChild: isBlockDrag ? canInsertBlocks2(draggedBlockClientIds, clientId) : true
            };
          });
          const newTarget = getListViewDropTarget(
            blocksData,
            position2,
            rtl
          );
          if (newTarget) {
            setTarget(newTarget);
          }
        },
        [
          canInsertBlocks2,
          draggedBlockClientIds,
          getBlockCount2,
          getBlockIndex2,
          getBlockRootClientId2,
          rtl
        ]
      ),
      50
    );
    const ref = (0, import_compose74.__experimentalUseDropZone)({
      dropZoneElement,
      onDrop(event) {
        throttled.cancel();
        if (target) {
          onBlockDrop2(event);
        }
        setTarget(void 0);
      },
      onDragLeave() {
        throttled.cancel();
        setTarget(null);
      },
      onDragOver(event) {
        throttled(event, event.currentTarget);
      },
      onDragEnd() {
        throttled.cancel();
        setTarget(void 0);
      }
    });
    return { ref, target };
  }

  // packages/block-editor/build-module/components/list-view/use-list-view-expand-selected-item.js
  var import_element171 = __toESM(require_element());
  var import_data138 = __toESM(require_data());
  function useListViewExpandSelectedItem({
    firstSelectedBlockClientId,
    setExpandedState
  }) {
    const [selectedTreeId, setSelectedTreeId] = (0, import_element171.useState)(null);
    const { selectedBlockParentClientIds } = (0, import_data138.useSelect)(
      (select2) => {
        const { getBlockParents: getBlockParents2 } = select2(store);
        return {
          selectedBlockParentClientIds: getBlockParents2(
            firstSelectedBlockClientId,
            false
          )
        };
      },
      [firstSelectedBlockClientId]
    );
    (0, import_element171.useEffect)(() => {
      if (selectedTreeId === firstSelectedBlockClientId) {
        return;
      }
      if (selectedBlockParentClientIds?.length) {
        setExpandedState({
          type: "expand",
          clientIds: selectedBlockParentClientIds
        });
      }
    }, [
      firstSelectedBlockClientId,
      selectedBlockParentClientIds,
      selectedTreeId,
      setExpandedState
    ]);
    return {
      setSelectedTreeId
    };
  }

  // packages/block-editor/build-module/components/list-view/use-clipboard-handler.js
  var import_data139 = __toESM(require_data());
  var import_compose75 = __toESM(require_compose());
  function useClipboardHandler2({ selectBlock: selectBlock2 }) {
    const registry = (0, import_data139.useRegistry)();
    const {
      getBlockOrder: getBlockOrder2,
      getBlockRootClientId: getBlockRootClientId2,
      getBlocksByClientId: getBlocksByClientId2,
      getPreviousBlockClientId: getPreviousBlockClientId2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      getSettings: getSettings4,
      canInsertBlockType: canInsertBlockType2,
      canRemoveBlocks: canRemoveBlocks2
    } = (0, import_data139.useSelect)(store);
    const { flashBlock: flashBlock2, removeBlocks: removeBlocks2, replaceBlocks: replaceBlocks2, insertBlocks: insertBlocks2 } = (0, import_data139.useDispatch)(store);
    const notifyCopy = useNotifyCopy();
    return (0, import_compose75.useRefEffect)((node2) => {
      function updateFocusAndSelection(focusClientId, shouldSelectBlock) {
        if (shouldSelectBlock) {
          selectBlock2(void 0, focusClientId, null, null);
        }
        focusListItem(focusClientId, node2);
      }
      function getBlocksToUpdate(clientId) {
        const selectedBlockClientIds = getSelectedBlockClientIds2();
        const isUpdatingSelectedBlocks = selectedBlockClientIds.includes(clientId);
        const firstBlockClientId = isUpdatingSelectedBlocks ? selectedBlockClientIds[0] : clientId;
        const firstBlockRootClientId = getBlockRootClientId2(firstBlockClientId);
        const blocksToUpdate = isUpdatingSelectedBlocks ? selectedBlockClientIds : [clientId];
        return {
          blocksToUpdate,
          firstBlockClientId,
          firstBlockRootClientId,
          originallySelectedBlockClientIds: selectedBlockClientIds
        };
      }
      function handler(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (!node2.contains(event.target.ownerDocument.activeElement)) {
          return;
        }
        const listViewRow = event.target.ownerDocument.activeElement?.closest(
          "[role=row]"
        );
        const clientId = listViewRow?.dataset?.block;
        if (!clientId) {
          return;
        }
        const {
          blocksToUpdate: selectedBlockClientIds,
          firstBlockClientId,
          firstBlockRootClientId,
          originallySelectedBlockClientIds
        } = getBlocksToUpdate(clientId);
        if (selectedBlockClientIds.length === 0) {
          return;
        }
        event.preventDefault();
        if (event.type === "copy" || event.type === "cut") {
          if (selectedBlockClientIds.length === 1) {
            flashBlock2(selectedBlockClientIds[0]);
          }
          notifyCopy(event.type, selectedBlockClientIds);
          const blocks2 = getBlocksByClientId2(selectedBlockClientIds);
          setClipboardBlocks(event, blocks2, registry);
        }
        if (event.type === "cut") {
          if (!canRemoveBlocks2(selectedBlockClientIds)) {
            return;
          }
          let blockToFocus = getPreviousBlockClientId2(firstBlockClientId) ?? // If the previous block is not found (when the first block is deleted),
          // fallback to focus the parent block.
          firstBlockRootClientId;
          removeBlocks2(selectedBlockClientIds, false);
          const shouldUpdateSelection = originallySelectedBlockClientIds.length > 0 && getSelectedBlockClientIds2().length === 0;
          if (!blockToFocus) {
            blockToFocus = getBlockOrder2()[0];
          }
          updateFocusAndSelection(blockToFocus, shouldUpdateSelection);
        } else if (event.type === "paste") {
          const {
            __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML
          } = getSettings4();
          const blocks2 = getPasteBlocks(
            event,
            canUserUseUnfilteredHTML
          );
          if (selectedBlockClientIds.length === 1) {
            const [selectedBlockClientId] = selectedBlockClientIds;
            if (blocks2.every(
              (block) => canInsertBlockType2(
                block.name,
                selectedBlockClientId
              )
            )) {
              insertBlocks2(
                blocks2,
                void 0,
                selectedBlockClientId
              );
              updateFocusAndSelection(blocks2[0]?.clientId, false);
              return;
            }
          }
          replaceBlocks2(
            selectedBlockClientIds,
            blocks2,
            blocks2.length - 1,
            -1
          );
          updateFocusAndSelection(blocks2[0]?.clientId, false);
        }
      }
      node2.ownerDocument.addEventListener("copy", handler);
      node2.ownerDocument.addEventListener("cut", handler);
      node2.ownerDocument.addEventListener("paste", handler);
      return () => {
        node2.ownerDocument.removeEventListener("copy", handler);
        node2.ownerDocument.removeEventListener("cut", handler);
        node2.ownerDocument.removeEventListener("paste", handler);
      };
    }, []);
  }

  // packages/block-editor/build-module/components/list-view/index.js
  var expanded = (state, action) => {
    if (action.type === "clear") {
      return {};
    }
    if (Array.isArray(action.clientIds)) {
      return {
        ...state,
        ...action.clientIds.reduce(
          (newState, id) => ({
            ...newState,
            [id]: action.type === "expand"
          }),
          {}
        )
      };
    }
    return state;
  };
  var BLOCK_LIST_ITEM_HEIGHT = 32;
  function ListViewComponent({
    id,
    blocks: blocks2,
    dropZoneElement,
    showBlockMovers = false,
    isExpanded = false,
    showAppender = false,
    blockSettingsMenu: BlockSettingsMenu2 = BlockSettingsDropdown,
    rootClientId,
    description,
    onSelect,
    additionalBlockContent: AdditionalBlockContent
  }, ref) {
    if (blocks2) {
      (0, import_deprecated22.default)(
        "`blocks` property in `wp.blockEditor.__experimentalListView`",
        {
          since: "6.3",
          alternative: "`rootClientId` property"
        }
      );
    }
    const instanceId = (0, import_compose76.useInstanceId)(ListViewComponent);
    const { clientIdsTree, draggedClientIds, selectedClientIds } = useListViewClientIds({ blocks: blocks2, rootClientId });
    const blockIndexes = useListViewBlockIndexes(clientIdsTree);
    const { getBlock: getBlock2 } = (0, import_data140.useSelect)(store);
    const { visibleBlockCount } = (0, import_data140.useSelect)(
      (select2) => {
        const { getGlobalBlockCount: getGlobalBlockCount2, getClientIdsOfDescendants: getClientIdsOfDescendants2 } = select2(store);
        const draggedBlockCount = draggedClientIds?.length > 0 ? getClientIdsOfDescendants2(draggedClientIds).length + 1 : 0;
        return {
          visibleBlockCount: getGlobalBlockCount2() - draggedBlockCount
        };
      },
      [draggedClientIds]
    );
    const { updateBlockSelection } = useBlockSelection();
    const [expandedState, setExpandedState] = (0, import_element172.useReducer)(expanded, {});
    const [insertedBlock, setInsertedBlock] = (0, import_element172.useState)(null);
    const { setSelectedTreeId } = useListViewExpandSelectedItem({
      firstSelectedBlockClientId: selectedClientIds[0],
      setExpandedState
    });
    const selectEditorBlock = (0, import_element172.useCallback)(
      /**
       * @param {MouseEvent | KeyboardEvent | undefined} event
       * @param {string}                                 blockClientId
       * @param {null | undefined | -1 | 1}              focusPosition
       */
      (event, blockClientId, focusPosition) => {
        updateBlockSelection(event, blockClientId, null, focusPosition);
        setSelectedTreeId(blockClientId);
        if (onSelect) {
          onSelect(getBlock2(blockClientId));
        }
      },
      [setSelectedTreeId, updateBlockSelection, onSelect, getBlock2]
    );
    const { ref: dropZoneRef, target: blockDropTarget } = useListViewDropZone({
      dropZoneElement,
      expandedState,
      setExpandedState
    });
    const elementRef = (0, import_element172.useRef)();
    const clipBoardRef = useClipboardHandler2({
      selectBlock: selectEditorBlock
    });
    const treeGridRef = (0, import_compose76.useMergeRefs)([
      clipBoardRef,
      elementRef,
      dropZoneRef,
      ref
    ]);
    (0, import_element172.useEffect)(() => {
      if (selectedClientIds?.length) {
        focusListItem(selectedClientIds[0], elementRef?.current);
      }
    }, []);
    const expand = (0, import_element172.useCallback)(
      (clientId) => {
        if (!clientId) {
          return;
        }
        const clientIds = Array.isArray(clientId) ? clientId : [clientId];
        setExpandedState({ type: "expand", clientIds });
      },
      [setExpandedState]
    );
    const collapse = (0, import_element172.useCallback)(
      (clientId) => {
        if (!clientId) {
          return;
        }
        setExpandedState({ type: "collapse", clientIds: [clientId] });
      },
      [setExpandedState]
    );
    const collapseAll = (0, import_element172.useCallback)(() => {
      setExpandedState({ type: "clear" });
    }, [setExpandedState]);
    const expandRow = (0, import_element172.useCallback)(
      (row) => {
        expand(row?.dataset?.block);
      },
      [expand]
    );
    const collapseRow = (0, import_element172.useCallback)(
      (row) => {
        collapse(row?.dataset?.block);
      },
      [collapse]
    );
    const focusRow = (0, import_element172.useCallback)(
      (event, startRow, endRow) => {
        if (event.shiftKey) {
          updateBlockSelection(
            event,
            startRow?.dataset?.block,
            endRow?.dataset?.block
          );
        }
      },
      [updateBlockSelection]
    );
    useListViewCollapseItems({
      collapseAll,
      expand
    });
    const firstDraggedBlockClientId = draggedClientIds?.[0];
    const { blockDropTargetIndex, blockDropPosition, firstDraggedBlockIndex } = (0, import_element172.useMemo)(() => {
      let _blockDropTargetIndex, _firstDraggedBlockIndex;
      if (blockDropTarget?.clientId) {
        const foundBlockIndex = blockIndexes[blockDropTarget.clientId];
        _blockDropTargetIndex = foundBlockIndex === void 0 || blockDropTarget?.dropPosition === "top" ? foundBlockIndex : foundBlockIndex + 1;
      } else if (blockDropTarget === null) {
        _blockDropTargetIndex = null;
      }
      if (firstDraggedBlockClientId) {
        const foundBlockIndex = blockIndexes[firstDraggedBlockClientId];
        _firstDraggedBlockIndex = foundBlockIndex === void 0 || blockDropTarget?.dropPosition === "top" ? foundBlockIndex : foundBlockIndex + 1;
      }
      return {
        blockDropTargetIndex: _blockDropTargetIndex,
        blockDropPosition: blockDropTarget?.dropPosition,
        firstDraggedBlockIndex: _firstDraggedBlockIndex
      };
    }, [blockDropTarget, blockIndexes, firstDraggedBlockClientId]);
    const contextValue = (0, import_element172.useMemo)(
      () => ({
        blockDropPosition,
        blockDropTargetIndex,
        blockIndexes,
        draggedClientIds,
        expandedState,
        expand,
        firstDraggedBlockIndex,
        collapse,
        collapseAll,
        BlockSettingsMenu: BlockSettingsMenu2,
        listViewInstanceId: instanceId,
        AdditionalBlockContent,
        insertedBlock,
        setInsertedBlock,
        treeGridElementRef: elementRef,
        rootClientId
      }),
      [
        blockDropPosition,
        blockDropTargetIndex,
        blockIndexes,
        draggedClientIds,
        expandedState,
        expand,
        firstDraggedBlockIndex,
        collapse,
        collapseAll,
        BlockSettingsMenu2,
        instanceId,
        AdditionalBlockContent,
        insertedBlock,
        setInsertedBlock,
        rootClientId
      ]
    );
    const [fixedListWindow] = (0, import_compose76.__experimentalUseFixedWindowList)(
      elementRef,
      BLOCK_LIST_ITEM_HEIGHT,
      visibleBlockCount,
      {
        // Ensure that the windowing logic is recalculated when the expanded state changes.
        // This is necessary because expanding a collapsed block in a short list view can
        // switch the list view to a tall list view with a scrollbar, and vice versa.
        // When this happens, the windowing logic needs to be recalculated to ensure that
        // the correct number of blocks are rendered, by rechecking for a scroll container.
        expandedState,
        useWindowing: true,
        windowOverscan: 40
      }
    );
    if (!clientIdsTree.length && !showAppender) {
      return null;
    }
    const describedById = description && `block-editor-list-view-description-${instanceId}`;
    return /* @__PURE__ */ (0, import_jsx_runtime299.jsxs)(import_data140.AsyncModeProvider, { value: true, children: [
      /* @__PURE__ */ (0, import_jsx_runtime299.jsx)(
        ListViewDropIndicatorPreview,
        {
          draggedBlockClientId: firstDraggedBlockClientId,
          listViewRef: elementRef,
          blockDropTarget
        }
      ),
      description && /* @__PURE__ */ (0, import_jsx_runtime299.jsx)(import_components156.VisuallyHidden, { id: describedById, children: description }),
      /* @__PURE__ */ (0, import_jsx_runtime299.jsx)(
        import_components156.__experimentalTreeGrid,
        {
          id,
          className: clsx_default("block-editor-list-view-tree", {
            "is-dragging": draggedClientIds?.length > 0 && blockDropTargetIndex !== void 0
          }),
          "aria-label": (0, import_i18n155.__)("Block navigation structure"),
          ref: treeGridRef,
          onCollapseRow: collapseRow,
          onExpandRow: expandRow,
          onFocusRow: focusRow,
          applicationAriaLabel: (0, import_i18n155.__)("Block navigation structure"),
          "aria-describedby": describedById,
          style: {
            "--wp-admin--list-view-dragged-items-height": draggedClientIds?.length ? `${BLOCK_LIST_ITEM_HEIGHT * (draggedClientIds.length - 1)}px` : null
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime299.jsx)(ListViewContext.Provider, { value: contextValue, children: /* @__PURE__ */ (0, import_jsx_runtime299.jsx)(
            branch_default,
            {
              blocks: clientIdsTree,
              parentId: rootClientId,
              selectBlock: selectEditorBlock,
              showBlockMovers,
              fixedListWindow,
              selectedClientIds,
              isExpanded,
              showAppender
            }
          ) })
        }
      )
    ] });
  }
  var PrivateListView = (0, import_element172.forwardRef)(ListViewComponent);
  var list_view_default2 = (0, import_element172.forwardRef)((props, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime299.jsx)(
      PrivateListView,
      {
        ref,
        ...props,
        showAppender: false,
        rootClientId: null,
        onSelect: null,
        additionalBlockContent: null,
        blockSettingsMenu: void 0
      }
    );
  });

  // packages/block-editor/build-module/components/block-navigation/dropdown.js
  function BlockNavigationDropdownToggle({
    isEnabled,
    onToggle,
    isOpen,
    innerRef,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime300.jsx)(
      import_components157.Button,
      {
        __next40pxDefaultSize: true,
        ...props,
        ref: innerRef,
        icon: list_view_default,
        "aria-expanded": isOpen,
        "aria-haspopup": "true",
        onClick: isEnabled ? onToggle : void 0,
        label: (0, import_i18n156.__)("List view"),
        className: "block-editor-block-navigation",
        "aria-disabled": !isEnabled
      }
    );
  }
  function BlockNavigationDropdown({ isDisabled, ...props }, ref) {
    (0, import_deprecated23.default)("wp.blockEditor.BlockNavigationDropdown", {
      since: "6.1",
      alternative: "wp.components.Dropdown and wp.blockEditor.ListView"
    });
    const hasBlocks = (0, import_data141.useSelect)(
      (select2) => !!select2(store).getBlockCount(),
      []
    );
    const isEnabled = hasBlocks && !isDisabled;
    return /* @__PURE__ */ (0, import_jsx_runtime300.jsx)(
      import_components157.Dropdown,
      {
        contentClassName: "block-editor-block-navigation__popover",
        popoverProps: { placement: "bottom-start" },
        renderToggle: ({ isOpen, onToggle }) => /* @__PURE__ */ (0, import_jsx_runtime300.jsx)(
          BlockNavigationDropdownToggle,
          {
            ...props,
            innerRef: ref,
            isOpen,
            onToggle,
            isEnabled
          }
        ),
        renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime300.jsxs)("div", { className: "block-editor-block-navigation__container", children: [
          /* @__PURE__ */ (0, import_jsx_runtime300.jsx)("p", { className: "block-editor-block-navigation__label", children: (0, import_i18n156.__)("List view") }),
          /* @__PURE__ */ (0, import_jsx_runtime300.jsx)(list_view_default2, {})
        ] })
      }
    );
  }
  var dropdown_default = (0, import_element173.forwardRef)(BlockNavigationDropdown);

  // packages/block-editor/build-module/components/block-styles/index.js
  var import_jsx_runtime302 = __toESM(require_jsx_runtime());
  var import_element175 = __toESM(require_element());
  var import_compose77 = __toESM(require_compose());
  var import_components158 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-styles/preview-panel.js
  var import_jsx_runtime301 = __toESM(require_jsx_runtime());
  var import_blocks79 = __toESM(require_blocks());
  var import_element174 = __toESM(require_element());
  function BlockStylesPreviewPanel({
    genericPreviewBlock,
    style,
    className,
    activeStyle
  }) {
    const example = (0, import_blocks79.getBlockType)(genericPreviewBlock.name)?.example;
    const styleClassName = replaceActiveStyle(className, activeStyle, style);
    const previewBlocks = (0, import_element174.useMemo)(() => {
      return {
        ...genericPreviewBlock,
        title: style.label || style.name,
        description: style.description,
        initialAttributes: {
          ...genericPreviewBlock.attributes,
          className: styleClassName + " block-editor-block-styles__block-preview-container"
        },
        example
      };
    }, [genericPreviewBlock, styleClassName]);
    return /* @__PURE__ */ (0, import_jsx_runtime301.jsx)(preview_panel_default, { item: previewBlocks });
  }

  // packages/block-editor/build-module/components/block-styles/index.js
  var noop16 = () => {
  };
  function BlockStyles({ clientId, onSwitch = noop16, onHoverClassName = noop16 }) {
    const {
      onSelect,
      stylesToRender,
      activeStyle,
      genericPreviewBlock,
      className: previewClassName
    } = useStylesForBlocks({
      clientId,
      onSwitch
    });
    const [hoveredStyle, setHoveredStyle] = (0, import_element175.useState)(null);
    const isMobileViewport = (0, import_compose77.useViewportMatch)("medium", "<");
    if (!stylesToRender || stylesToRender.length === 0) {
      return null;
    }
    const debouncedSetHoveredStyle = (0, import_compose77.debounce)(setHoveredStyle, 250);
    const onSelectStylePreview = (style) => {
      onSelect(style);
      onHoverClassName(null);
      setHoveredStyle(null);
      debouncedSetHoveredStyle.cancel();
    };
    const styleItemHandler = (item) => {
      if (hoveredStyle === item) {
        debouncedSetHoveredStyle.cancel();
        return;
      }
      debouncedSetHoveredStyle(item);
      onHoverClassName(item?.name ?? null);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime302.jsxs)("div", { className: "block-editor-block-styles", children: [
      /* @__PURE__ */ (0, import_jsx_runtime302.jsx)("div", { className: "block-editor-block-styles__variants", children: stylesToRender.map((style) => {
        const buttonText = style.label || style.name;
        return /* @__PURE__ */ (0, import_jsx_runtime302.jsx)(
          import_components158.Button,
          {
            __next40pxDefaultSize: true,
            className: clsx_default(
              "block-editor-block-styles__item",
              {
                "is-active": activeStyle.name === style.name
              }
            ),
            variant: "secondary",
            label: buttonText,
            onMouseEnter: () => styleItemHandler(style),
            onFocus: () => styleItemHandler(style),
            onMouseLeave: () => styleItemHandler(null),
            onBlur: () => styleItemHandler(null),
            onClick: () => onSelectStylePreview(style),
            "aria-current": activeStyle.name === style.name,
            children: /* @__PURE__ */ (0, import_jsx_runtime302.jsx)(
              import_components158.__experimentalTruncate,
              {
                numberOfLines: 1,
                className: "block-editor-block-styles__item-text",
                children: buttonText
              }
            )
          },
          style.name
        );
      }) }),
      hoveredStyle && !isMobileViewport && /* @__PURE__ */ (0, import_jsx_runtime302.jsx)(
        import_components158.Popover,
        {
          placement: "left-start",
          offset: 34,
          focusOnMount: false,
          children: /* @__PURE__ */ (0, import_jsx_runtime302.jsx)(
            "div",
            {
              className: "block-editor-block-styles__preview-panel",
              onMouseLeave: () => styleItemHandler(null),
              children: /* @__PURE__ */ (0, import_jsx_runtime302.jsx)(
                BlockStylesPreviewPanel,
                {
                  activeStyle,
                  className: previewClassName,
                  genericPreviewBlock,
                  style: hoveredStyle
                }
              )
            }
          )
        }
      )
    ] });
  }
  var block_styles_default = BlockStyles;

  // packages/block-editor/build-module/components/block-heading-level-dropdown/index.js
  var import_jsx_runtime304 = __toESM(require_jsx_runtime());
  var import_components160 = __toESM(require_components());
  var import_i18n157 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-heading-level-dropdown/heading-level-icon.js
  var import_jsx_runtime303 = __toESM(require_jsx_runtime());
  var import_components159 = __toESM(require_components());
  var LEVEL_TO_PATH = {
    0: paragraph_default,
    1: heading_level_1_default,
    2: heading_level_2_default,
    3: heading_level_3_default,
    4: heading_level_4_default,
    5: heading_level_5_default,
    6: heading_level_6_default
  };
  function HeadingLevelIcon({ level }) {
    if (LEVEL_TO_PATH[level]) {
      return /* @__PURE__ */ (0, import_jsx_runtime303.jsx)(import_components159.Icon, { icon: LEVEL_TO_PATH[level] });
    }
    return null;
  }

  // packages/block-editor/build-module/components/block-heading-level-dropdown/index.js
  var HEADING_LEVELS = [1, 2, 3, 4, 5, 6];
  var POPOVER_PROPS6 = {
    className: "block-library-heading-level-dropdown"
  };
  function HeadingLevelDropdown({
    options = HEADING_LEVELS,
    value,
    onChange
  }) {
    const validOptions = options.filter(
      (option) => option === 0 || HEADING_LEVELS.includes(option)
    ).sort((a2, b2) => a2 - b2);
    return /* @__PURE__ */ (0, import_jsx_runtime304.jsx)(
      import_components160.ToolbarDropdownMenu,
      {
        popoverProps: POPOVER_PROPS6,
        icon: /* @__PURE__ */ (0, import_jsx_runtime304.jsx)(HeadingLevelIcon, { level: value }),
        label: (0, import_i18n157.__)("Change level"),
        controls: validOptions.map((targetLevel) => {
          const isActive = targetLevel === value;
          return {
            icon: /* @__PURE__ */ (0, import_jsx_runtime304.jsx)(HeadingLevelIcon, { level: targetLevel }),
            title: targetLevel === 0 ? (0, import_i18n157.__)("Paragraph") : (0, import_i18n157.sprintf)(
              // translators: %d: heading level e.g: "1", "2", "3"
              (0, import_i18n157.__)("Heading %d"),
              targetLevel
            ),
            isActive,
            onClick() {
              onChange(targetLevel);
            },
            role: "menuitemradio"
          };
        })
      }
    );
  }

  // packages/block-editor/build-module/components/block-variation-picker/index.js
  var import_jsx_runtime305 = __toESM(require_jsx_runtime());
  var import_i18n158 = __toESM(require_i18n());
  var import_components161 = __toESM(require_components());
  function BlockVariationPicker({
    icon = layout_default,
    label = (0, import_i18n158.__)("Choose variation"),
    instructions = (0, import_i18n158.__)("Select a variation to start with:"),
    variations,
    onSelect,
    allowSkip
  }) {
    const classes = clsx_default("block-editor-block-variation-picker", {
      "has-many-variations": variations.length > 4
    });
    return /* @__PURE__ */ (0, import_jsx_runtime305.jsxs)(
      import_components161.Placeholder,
      {
        icon,
        label,
        instructions,
        className: classes,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime305.jsx)(
            "ul",
            {
              className: "block-editor-block-variation-picker__variations",
              role: "list",
              "aria-label": (0, import_i18n158.__)("Block variations"),
              children: variations.map((variation) => /* @__PURE__ */ (0, import_jsx_runtime305.jsxs)("li", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime305.jsx)(
                  import_components161.Button,
                  {
                    __next40pxDefaultSize: true,
                    variant: "tertiary",
                    icon: variation.icon && variation.icon.src ? variation.icon.src : variation.icon,
                    iconSize: 48,
                    onClick: () => onSelect(variation),
                    className: "block-editor-block-variation-picker__variation",
                    label: variation.description || variation.title
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime305.jsx)("span", { className: "block-editor-block-variation-picker__variation-label", children: variation.title })
              ] }, variation.name))
            }
          ),
          allowSkip && /* @__PURE__ */ (0, import_jsx_runtime305.jsx)("div", { className: "block-editor-block-variation-picker__skip", children: /* @__PURE__ */ (0, import_jsx_runtime305.jsx)(
            import_components161.Button,
            {
              __next40pxDefaultSize: true,
              variant: "link",
              onClick: () => onSelect(),
              children: (0, import_i18n158.__)("Skip")
            }
          ) })
        ]
      }
    );
  }
  var block_variation_picker_default = BlockVariationPicker;

  // packages/block-editor/build-module/components/block-pattern-setup/index.js
  var import_jsx_runtime307 = __toESM(require_jsx_runtime());
  var import_data143 = __toESM(require_data());
  var import_blocks80 = __toESM(require_blocks());
  var import_components163 = __toESM(require_components());
  var import_element176 = __toESM(require_element());
  var import_compose78 = __toESM(require_compose());
  var import_i18n160 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-pattern-setup/setup-toolbar.js
  var import_jsx_runtime306 = __toESM(require_jsx_runtime());
  var import_i18n159 = __toESM(require_i18n());
  var import_components162 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-pattern-setup/constants.js
  var VIEWMODES = {
    carousel: "carousel",
    grid: "grid"
  };

  // packages/block-editor/build-module/components/block-pattern-setup/setup-toolbar.js
  var Actions = ({ onBlockPatternSelect }) => /* @__PURE__ */ (0, import_jsx_runtime306.jsx)("div", { className: "block-editor-block-pattern-setup__actions", children: /* @__PURE__ */ (0, import_jsx_runtime306.jsx)(
    import_components162.Button,
    {
      __next40pxDefaultSize: true,
      variant: "primary",
      onClick: onBlockPatternSelect,
      children: (0, import_i18n159.__)("Choose")
    }
  ) });
  var CarouselNavigation = ({
    handlePrevious,
    handleNext,
    activeSlide,
    totalSlides
  }) => /* @__PURE__ */ (0, import_jsx_runtime306.jsxs)("div", { className: "block-editor-block-pattern-setup__navigation", children: [
    /* @__PURE__ */ (0, import_jsx_runtime306.jsx)(
      import_components162.Button,
      {
        size: "compact",
        icon: (0, import_i18n159.isRTL)() ? chevron_right_default : chevron_left_default,
        label: (0, import_i18n159.__)("Previous pattern"),
        onClick: handlePrevious,
        disabled: activeSlide === 0,
        accessibleWhenDisabled: true
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime306.jsx)(
      import_components162.Button,
      {
        size: "compact",
        icon: (0, import_i18n159.isRTL)() ? chevron_left_default : chevron_right_default,
        label: (0, import_i18n159.__)("Next pattern"),
        onClick: handleNext,
        disabled: activeSlide === totalSlides - 1,
        accessibleWhenDisabled: true
      }
    )
  ] });
  var SetupToolbar = ({
    viewMode,
    setViewMode,
    handlePrevious,
    handleNext,
    activeSlide,
    totalSlides,
    onBlockPatternSelect
  }) => {
    const isCarouselView = viewMode === VIEWMODES.carousel;
    const displayControls = /* @__PURE__ */ (0, import_jsx_runtime306.jsxs)("div", { className: "block-editor-block-pattern-setup__display-controls", children: [
      /* @__PURE__ */ (0, import_jsx_runtime306.jsx)(
        import_components162.Button,
        {
          size: "compact",
          icon: stretch_full_width_default,
          label: (0, import_i18n159.__)("Carousel view"),
          onClick: () => setViewMode(VIEWMODES.carousel),
          isPressed: isCarouselView
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime306.jsx)(
        import_components162.Button,
        {
          size: "compact",
          icon: grid_default,
          label: (0, import_i18n159.__)("Grid view"),
          onClick: () => setViewMode(VIEWMODES.grid),
          isPressed: viewMode === VIEWMODES.grid
        }
      )
    ] });
    return /* @__PURE__ */ (0, import_jsx_runtime306.jsxs)("div", { className: "block-editor-block-pattern-setup__toolbar", children: [
      isCarouselView && /* @__PURE__ */ (0, import_jsx_runtime306.jsx)(
        CarouselNavigation,
        {
          handlePrevious,
          handleNext,
          activeSlide,
          totalSlides
        }
      ),
      displayControls,
      isCarouselView && /* @__PURE__ */ (0, import_jsx_runtime306.jsx)(Actions, { onBlockPatternSelect })
    ] });
  };
  var setup_toolbar_default = SetupToolbar;

  // packages/block-editor/build-module/components/block-pattern-setup/use-patterns-setup.js
  var import_data142 = __toESM(require_data());
  function usePatternsSetup(clientId, blockName, filterPatternsFn) {
    return (0, import_data142.useSelect)(
      (select2) => {
        const {
          getBlockRootClientId: getBlockRootClientId2,
          getPatternsByBlockTypes: getPatternsByBlockTypes2,
          __experimentalGetAllowedPatterns: __experimentalGetAllowedPatterns2
        } = select2(store);
        const rootClientId = getBlockRootClientId2(clientId);
        if (filterPatternsFn) {
          return __experimentalGetAllowedPatterns2(rootClientId).filter(
            filterPatternsFn
          );
        }
        return getPatternsByBlockTypes2(blockName, rootClientId);
      },
      [clientId, blockName, filterPatternsFn]
    );
  }
  var use_patterns_setup_default = usePatternsSetup;

  // packages/block-editor/build-module/components/block-pattern-setup/index.js
  var SetupContent = ({
    viewMode,
    activeSlide,
    patterns,
    onBlockPatternSelect,
    showTitles
  }) => {
    const containerClass = "block-editor-block-pattern-setup__container";
    if (viewMode === VIEWMODES.carousel) {
      const slideClass = /* @__PURE__ */ new Map([
        [activeSlide, "active-slide"],
        [activeSlide - 1, "previous-slide"],
        [activeSlide + 1, "next-slide"]
      ]);
      return /* @__PURE__ */ (0, import_jsx_runtime307.jsx)("div", { className: "block-editor-block-pattern-setup__carousel", children: /* @__PURE__ */ (0, import_jsx_runtime307.jsx)("div", { className: containerClass, children: /* @__PURE__ */ (0, import_jsx_runtime307.jsx)("div", { className: "carousel-container", children: patterns.map((pattern, index) => /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(
        BlockPatternSlide,
        {
          active: index === activeSlide,
          className: slideClass.get(index) || "",
          pattern
        },
        pattern.name
      )) }) }) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime307.jsx)("div", { className: "block-editor-block-pattern-setup__grid", children: /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(
      import_components163.Composite,
      {
        role: "listbox",
        className: containerClass,
        "aria-label": (0, import_i18n160.__)("Patterns list"),
        children: patterns.map((pattern) => /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(
          BlockPattern3,
          {
            pattern,
            onSelect: onBlockPatternSelect,
            showTitles
          },
          pattern.name
        ))
      }
    ) });
  };
  function BlockPattern3({ pattern, onSelect, showTitles }) {
    const baseClassName = "block-editor-block-pattern-setup-list";
    const { blocks: blocks2, description, viewportWidth = 700 } = pattern;
    const descriptionId = (0, import_compose78.useInstanceId)(
      BlockPattern3,
      `${baseClassName}__item-description`
    );
    return /* @__PURE__ */ (0, import_jsx_runtime307.jsx)("div", { className: `${baseClassName}__list-item`, children: /* @__PURE__ */ (0, import_jsx_runtime307.jsxs)(
      import_components163.Composite.Item,
      {
        render: /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(
          "div",
          {
            "aria-describedby": description ? descriptionId : void 0,
            "aria-label": pattern.title,
            className: `${baseClassName}__item`
          }
        ),
        id: `${baseClassName}__pattern__${pattern.name}`,
        role: "option",
        onClick: () => onSelect(blocks2),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(
            block_preview_default,
            {
              blocks: blocks2,
              viewportWidth
            }
          ),
          showTitles && /* @__PURE__ */ (0, import_jsx_runtime307.jsx)("div", { className: `${baseClassName}__item-title`, children: pattern.title }),
          !!description && /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(import_components163.VisuallyHidden, { id: descriptionId, children: description })
        ]
      }
    ) });
  }
  function BlockPatternSlide({ active, className, pattern, minHeight }) {
    const { blocks: blocks2, title, description } = pattern;
    const descriptionId = (0, import_compose78.useInstanceId)(
      BlockPatternSlide,
      "block-editor-block-pattern-setup-list__item-description"
    );
    return /* @__PURE__ */ (0, import_jsx_runtime307.jsxs)(
      "div",
      {
        "aria-hidden": !active,
        role: "img",
        className: `pattern-slide ${className}`,
        "aria-label": title,
        "aria-describedby": description ? descriptionId : void 0,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(block_preview_default, { blocks: blocks2, minHeight }),
          !!description && /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(import_components163.VisuallyHidden, { id: descriptionId, children: description })
        ]
      }
    );
  }
  var BlockPatternSetup = ({
    clientId,
    blockName,
    filterPatternsFn,
    onBlockPatternSelect,
    initialViewMode = VIEWMODES.carousel,
    showTitles = false
  }) => {
    const [viewMode, setViewMode] = (0, import_element176.useState)(initialViewMode);
    const [activeSlide, setActiveSlide] = (0, import_element176.useState)(0);
    const { replaceBlock: replaceBlock2 } = (0, import_data143.useDispatch)(store);
    const patterns = use_patterns_setup_default(clientId, blockName, filterPatternsFn);
    if (!patterns?.length) {
      return null;
    }
    const onBlockPatternSelectDefault = (blocks2) => {
      const clonedBlocks = blocks2.map((block) => (0, import_blocks80.cloneBlock)(block));
      replaceBlock2(clientId, clonedBlocks);
    };
    const onPatternSelectCallback = onBlockPatternSelect || onBlockPatternSelectDefault;
    return /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(import_jsx_runtime307.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime307.jsxs)(
      "div",
      {
        className: `block-editor-block-pattern-setup view-mode-${viewMode}`,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(
            SetupContent,
            {
              viewMode,
              activeSlide,
              patterns,
              onBlockPatternSelect: onPatternSelectCallback,
              showTitles
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime307.jsx)(
            setup_toolbar_default,
            {
              viewMode,
              setViewMode,
              activeSlide,
              totalSlides: patterns.length,
              handleNext: () => {
                setActiveSlide(
                  (active) => Math.min(active + 1, patterns.length - 1)
                );
              },
              handlePrevious: () => {
                setActiveSlide(
                  (active) => Math.max(active - 1, 0)
                );
              },
              onBlockPatternSelect: () => {
                onPatternSelectCallback(
                  patterns[activeSlide].blocks
                );
              }
            }
          )
        ]
      }
    ) });
  };
  var block_pattern_setup_default = BlockPatternSetup;

  // packages/block-editor/build-module/components/block-variation-transforms/index.js
  var import_jsx_runtime308 = __toESM(require_jsx_runtime());
  var import_blocks81 = __toESM(require_blocks());
  var import_i18n161 = __toESM(require_i18n());
  var import_components164 = __toESM(require_components());
  var import_data144 = __toESM(require_data());
  var import_element177 = __toESM(require_element());
  function VariationsButtons({
    className,
    onSelectVariation,
    selectedValue,
    variations
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime308.jsxs)("fieldset", { className, children: [
      /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(import_components164.VisuallyHidden, { as: "legend", children: (0, import_i18n161.__)("Transform to variation") }),
      variations.map((variation) => /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(
        import_components164.Button,
        {
          __next40pxDefaultSize: true,
          size: "compact",
          icon: /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(block_icon_default, { icon: variation.icon, showColors: true }),
          isPressed: selectedValue === variation.name,
          label: selectedValue === variation.name ? variation.title : (0, import_i18n161.sprintf)(
            /* translators: %s: Block or block variation name. */
            (0, import_i18n161.__)("Transform to %s"),
            variation.title
          ),
          onClick: () => onSelectVariation(variation.name),
          "aria-label": variation.title,
          showTooltip: true
        },
        variation.name
      ))
    ] });
  }
  function VariationsDropdown({
    className,
    onSelectVariation,
    selectedValue,
    variations
  }) {
    const selectOptions = variations.map(
      ({ name, title, description }) => ({
        value: name,
        label: title,
        info: description
      })
    );
    return /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(
      import_components164.DropdownMenu,
      {
        className,
        label: (0, import_i18n161.__)("Transform to variation"),
        text: (0, import_i18n161.__)("Transform to variation"),
        popoverProps: {
          position: "bottom center",
          className: `${className}__popover`
        },
        icon: chevron_down_default,
        toggleProps: { iconPosition: "right" },
        children: () => /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(import_components164.MenuGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(
          import_components164.MenuItemsChoice,
          {
            choices: selectOptions,
            value: selectedValue,
            onSelect: onSelectVariation
          }
        ) })
      }
    );
  }
  function VariationsToggleGroupControl({
    className,
    onSelectVariation,
    selectedValue,
    variations
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime308.jsx)("div", { className, children: /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(
      import_components164.__experimentalToggleGroupControl,
      {
        label: (0, import_i18n161.__)("Transform to variation"),
        value: selectedValue,
        hideLabelFromVision: true,
        onChange: onSelectVariation,
        __next40pxDefaultSize: true,
        __nextHasNoMarginBottom: true,
        children: variations.map((variation) => /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(
          import_components164.__experimentalToggleGroupControlOptionIcon,
          {
            icon: /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(block_icon_default, { icon: variation.icon, showColors: true }),
            value: variation.name,
            label: selectedValue === variation.name ? variation.title : (0, import_i18n161.sprintf)(
              /* translators: %s: Block or block variation name. */
              (0, import_i18n161.__)("Transform to %s"),
              variation.title
            )
          },
          variation.name
        ))
      }
    ) });
  }
  function __experimentalBlockVariationTransforms({ blockClientId }) {
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data144.useDispatch)(store);
    const { activeBlockVariation, variations, isContentOnly, isSection } = (0, import_data144.useSelect)(
      (select2) => {
        const { getActiveBlockVariation, getBlockVariations: getBlockVariations2 } = select2(import_blocks81.store);
        const {
          getBlockName: getBlockName2,
          getBlockAttributes: getBlockAttributes3,
          getBlockEditingMode: getBlockEditingMode2,
          isSectionBlock: isSectionBlock2
        } = unlock(select2(store));
        const name = blockClientId && getBlockName2(blockClientId);
        const { hasContentRoleAttribute } = unlock(
          select2(import_blocks81.store)
        );
        const isContentBlock4 = hasContentRoleAttribute(name);
        return {
          activeBlockVariation: getActiveBlockVariation(
            name,
            getBlockAttributes3(blockClientId),
            "transform"
          ),
          variations: name && getBlockVariations2(name, "transform"),
          isContentOnly: getBlockEditingMode2(blockClientId) === "contentOnly" && !isContentBlock4,
          isSection: isSectionBlock2(blockClientId)
        };
      },
      [blockClientId]
    );
    const selectedValue = activeBlockVariation?.name;
    const hasUniqueIcons = (0, import_element177.useMemo)(() => {
      const variationIcons = /* @__PURE__ */ new Set();
      if (!variations) {
        return false;
      }
      variations.forEach((variation) => {
        if (variation.icon) {
          variationIcons.add(variation.icon?.src || variation.icon);
        }
      });
      return variationIcons.size === variations.length;
    }, [variations]);
    const onSelectVariation = (variationName) => {
      updateBlockAttributes2(blockClientId, {
        ...variations.find(({ name }) => name === variationName).attributes
      });
    };
    const hideVariationsForSections = window?.__experimentalContentOnlyPatternInsertion && isSection;
    if (!variations?.length || isContentOnly || hideVariationsForSections) {
      return null;
    }
    const baseClass = "block-editor-block-variation-transforms";
    const showButtons = variations.length > 5;
    const ButtonComponent = showButtons ? VariationsButtons : VariationsToggleGroupControl;
    const Component7 = hasUniqueIcons ? ButtonComponent : VariationsDropdown;
    return /* @__PURE__ */ (0, import_jsx_runtime308.jsx)(
      Component7,
      {
        className: baseClass,
        onSelectVariation,
        selectedValue,
        variations
      }
    );
  }
  var block_variation_transforms_default = __experimentalBlockVariationTransforms;

  // packages/block-editor/build-module/components/block-vertical-alignment-control/index.js
  var import_jsx_runtime310 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/block-vertical-alignment-control/ui.js
  var import_jsx_runtime309 = __toESM(require_jsx_runtime());
  var import_i18n162 = __toESM(require_i18n());
  var import_components165 = __toESM(require_components());
  var BLOCK_ALIGNMENTS_CONTROLS2 = {
    top: {
      icon: justify_top_default,
      title: (0, import_i18n162._x)("Align top", "Block vertical alignment setting")
    },
    center: {
      icon: justify_center_vertical_default,
      title: (0, import_i18n162._x)("Align middle", "Block vertical alignment setting")
    },
    bottom: {
      icon: justify_bottom_default,
      title: (0, import_i18n162._x)("Align bottom", "Block vertical alignment setting")
    },
    stretch: {
      icon: justify_stretch_vertical_default,
      title: (0, import_i18n162._x)("Stretch to fill", "Block vertical alignment setting")
    },
    "space-between": {
      icon: justify_space_between_vertical_default,
      title: (0, import_i18n162._x)("Space between", "Block vertical alignment setting")
    }
  };
  var DEFAULT_CONTROLS8 = ["top", "center", "bottom"];
  var DEFAULT_CONTROL2 = "top";
  function BlockVerticalAlignmentUI({
    value,
    onChange,
    controls = DEFAULT_CONTROLS8,
    isCollapsed: isCollapsed3 = true,
    isToolbar
  }) {
    function applyOrUnset(align) {
      return () => onChange(value === align ? void 0 : align);
    }
    const activeAlignment = BLOCK_ALIGNMENTS_CONTROLS2[value];
    const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS2[DEFAULT_CONTROL2];
    const UIComponent = isToolbar ? import_components165.ToolbarGroup : import_components165.ToolbarDropdownMenu;
    const extraProps = isToolbar ? { isCollapsed: isCollapsed3 } : {};
    return /* @__PURE__ */ (0, import_jsx_runtime309.jsx)(
      UIComponent,
      {
        icon: activeAlignment ? activeAlignment.icon : defaultAlignmentControl.icon,
        label: (0, import_i18n162._x)(
          "Change vertical alignment",
          "Block vertical alignment setting label"
        ),
        controls: controls.map((control) => {
          return {
            ...BLOCK_ALIGNMENTS_CONTROLS2[control],
            isActive: value === control,
            role: isCollapsed3 ? "menuitemradio" : void 0,
            onClick: applyOrUnset(control)
          };
        }),
        ...extraProps
      }
    );
  }
  var ui_default3 = BlockVerticalAlignmentUI;

  // packages/block-editor/build-module/components/block-vertical-alignment-control/index.js
  var BlockVerticalAlignmentControl = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime310.jsx)(ui_default3, { ...props, isToolbar: false });
  };
  var BlockVerticalAlignmentToolbar = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime310.jsx)(ui_default3, { ...props, isToolbar: true });
  };

  // packages/block-editor/build-module/components/color-palette/index.js
  var import_components166 = __toESM(require_components());

  // packages/block-editor/build-module/components/color-palette/with-color-context.js
  var import_jsx_runtime311 = __toESM(require_jsx_runtime());
  var import_compose79 = __toESM(require_compose());
  var with_color_context_default = (0, import_compose79.createHigherOrderComponent)((WrappedComponent) => {
    return (props) => {
      const [
        defaultColors,
        themeColors,
        customColors,
        enableCustomColors,
        enableDefaultColors
      ] = useSettings(
        "color.palette.default",
        "color.palette.theme",
        "color.palette.custom",
        "color.custom",
        "color.defaultPalette"
      );
      const _colors = enableDefaultColors ? [
        ...themeColors || [],
        ...defaultColors || [],
        ...customColors || []
      ] : [...themeColors || [], ...customColors || []];
      const { colors: colors2 = _colors, disableCustomColors = !enableCustomColors } = props;
      const hasColorsToChoose = colors2 && colors2.length > 0 || !disableCustomColors;
      return /* @__PURE__ */ (0, import_jsx_runtime311.jsx)(
        WrappedComponent,
        {
          ...{
            ...props,
            colors: colors2,
            disableCustomColors,
            hasColorsToChoose
          }
        }
      );
    };
  }, "withColorContext");

  // packages/block-editor/build-module/components/color-palette/index.js
  var color_palette_default = with_color_context_default(import_components166.ColorPalette);

  // packages/block-editor/build-module/components/color-palette/control.js
  var import_jsx_runtime312 = __toESM(require_jsx_runtime());
  function ColorPaletteControl({
    onChange,
    value,
    ...otherProps
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime312.jsx)(
      control_default,
      {
        ...otherProps,
        onColorChange: onChange,
        colorValue: value,
        gradients: [],
        disableCustomGradients: true
      }
    );
  }

  // packages/block-editor/build-module/components/contrast-checker/index.js
  var import_jsx_runtime313 = __toESM(require_jsx_runtime());
  var import_i18n163 = __toESM(require_i18n());
  var import_components167 = __toESM(require_components());
  var import_a11y18 = __toESM(require_a11y());
  k([names_default, a11y_default]);
  function ContrastChecker({
    backgroundColor,
    fallbackBackgroundColor,
    fallbackTextColor,
    fallbackLinkColor,
    fontSize,
    // Font size value in pixels.
    isLargeText,
    textColor,
    linkColor,
    enableAlphaChecker = false
  }) {
    const currentBackgroundColor = backgroundColor || fallbackBackgroundColor;
    if (!currentBackgroundColor) {
      return null;
    }
    const currentTextColor = textColor || fallbackTextColor;
    const currentLinkColor = linkColor || fallbackLinkColor;
    if (!currentTextColor && !currentLinkColor) {
      return null;
    }
    const textColors = [
      {
        color: currentTextColor,
        description: (0, import_i18n163.__)("text color")
      },
      {
        color: currentLinkColor,
        description: (0, import_i18n163.__)("link color")
      }
    ];
    const colordBackgroundColor = w(currentBackgroundColor);
    const backgroundColorHasTransparency = colordBackgroundColor.alpha() < 1;
    const backgroundColorBrightness = colordBackgroundColor.brightness();
    const isReadableOptions = {
      level: "AA",
      size: isLargeText || isLargeText !== false && fontSize >= 24 ? "large" : "small"
    };
    let message = "";
    let speakMessage = "";
    for (const item of textColors) {
      if (!item.color) {
        continue;
      }
      const colordTextColor = w(item.color);
      const isColordTextReadable = colordTextColor.isReadable(
        colordBackgroundColor,
        isReadableOptions
      );
      const textHasTransparency = colordTextColor.alpha() < 1;
      if (!isColordTextReadable) {
        if (backgroundColorHasTransparency || textHasTransparency) {
          continue;
        }
        message = backgroundColorBrightness < colordTextColor.brightness() ? (0, import_i18n163.sprintf)(
          // translators: %s is a type of text color, e.g., "text color" or "link color".
          (0, import_i18n163.__)(
            "This color combination may be hard for people to read. Try using a darker background color and/or a brighter %s."
          ),
          item.description
        ) : (0, import_i18n163.sprintf)(
          // translators: %s is a type of text color, e.g., "text color" or "link color".
          (0, import_i18n163.__)(
            "This color combination may be hard for people to read. Try using a brighter background color and/or a darker %s."
          ),
          item.description
        );
        speakMessage = (0, import_i18n163.__)(
          "This color combination may be hard for people to read."
        );
        break;
      }
      if (textHasTransparency && enableAlphaChecker) {
        message = (0, import_i18n163.__)("Transparent text may be hard for people to read.");
        speakMessage = (0, import_i18n163.__)(
          "Transparent text may be hard for people to read."
        );
      }
    }
    if (!message) {
      return null;
    }
    (0, import_a11y18.speak)(speakMessage);
    return /* @__PURE__ */ (0, import_jsx_runtime313.jsx)("div", { className: "block-editor-contrast-checker", children: /* @__PURE__ */ (0, import_jsx_runtime313.jsx)(
      import_components167.Notice,
      {
        spokenMessage: null,
        status: "warning",
        isDismissible: false,
        children: message
      }
    ) });
  }
  var contrast_checker_default = ContrastChecker;

  // packages/block-editor/build-module/components/date-format-picker/index.js
  var import_jsx_runtime314 = __toESM(require_jsx_runtime());
  var import_i18n164 = __toESM(require_i18n());
  var import_date = __toESM(require_date());
  var import_element178 = __toESM(require_element());
  var import_components168 = __toESM(require_components());
  var exampleDate = /* @__PURE__ */ new Date();
  exampleDate.setDate(20);
  exampleDate.setMonth(exampleDate.getMonth() - 3);
  if (exampleDate.getMonth() === 4) {
    exampleDate.setMonth(3);
  }
  function DateFormatPicker({
    format,
    defaultFormat,
    onChange
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime314.jsxs)(
      import_components168.__experimentalVStack,
      {
        as: "fieldset",
        spacing: 4,
        className: "block-editor-date-format-picker",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime314.jsx)(import_components168.VisuallyHidden, { as: "legend", children: (0, import_i18n164.__)("Date format") }),
          /* @__PURE__ */ (0, import_jsx_runtime314.jsx)(
            import_components168.ToggleControl,
            {
              __nextHasNoMarginBottom: true,
              label: (0, import_i18n164.__)("Default format"),
              help: `${(0, import_i18n164.__)("Example:")}  ${(0, import_date.dateI18n)(
                defaultFormat,
                exampleDate
              )}`,
              checked: !format,
              onChange: (checked) => onChange(checked ? null : defaultFormat)
            }
          ),
          format && /* @__PURE__ */ (0, import_jsx_runtime314.jsx)(NonDefaultControls, { format, onChange })
        ]
      }
    );
  }
  function NonDefaultControls({ format, onChange }) {
    const suggestedFormats = [
      .../* @__PURE__ */ new Set([
        /* translators: See https://www.php.net/manual/datetime.format.php */
        "Y-m-d",
        /* translators: See https://www.php.net/manual/datetime.format.php */
        (0, import_i18n164._x)("n/j/Y", "short date format"),
        /* translators: See https://www.php.net/manual/datetime.format.php */
        (0, import_i18n164._x)("n/j/Y g:i A", "short date format with time"),
        /* translators: See https://www.php.net/manual/datetime.format.php */
        (0, import_i18n164._x)("M j, Y", "medium date format"),
        /* translators: See https://www.php.net/manual/datetime.format.php */
        (0, import_i18n164._x)("M j, Y g:i A", "medium date format with time"),
        /* translators: See https://www.php.net/manual/datetime.format.php */
        (0, import_i18n164._x)("F j, Y", "long date format"),
        /* translators: See https://www.php.net/manual/datetime.format.php */
        (0, import_i18n164._x)("M j", "short date format without the year")
      ])
    ];
    const suggestedOptions = [
      ...suggestedFormats.map((suggestedFormat, index) => ({
        key: `suggested-${index}`,
        name: (0, import_date.dateI18n)(suggestedFormat, exampleDate),
        format: suggestedFormat
      })),
      {
        key: "human-diff",
        name: (0, import_date.humanTimeDiff)(exampleDate),
        format: "human-diff"
      }
    ];
    const customOption = {
      key: "custom",
      name: (0, import_i18n164.__)("Custom"),
      className: "block-editor-date-format-picker__custom-format-select-control__custom-option",
      hint: (0, import_i18n164.__)("Enter your own date format")
    };
    const [isCustom, setIsCustom] = (0, import_element178.useState)(
      () => !!format && !suggestedOptions.some((option) => option.format === format)
    );
    return /* @__PURE__ */ (0, import_jsx_runtime314.jsxs)(import_components168.__experimentalVStack, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime314.jsx)(
        import_components168.CustomSelectControl,
        {
          __next40pxDefaultSize: true,
          label: (0, import_i18n164.__)("Choose a format"),
          options: [...suggestedOptions, customOption],
          value: isCustom ? customOption : suggestedOptions.find(
            (option) => option.format === format
          ) ?? customOption,
          onChange: ({ selectedItem }) => {
            if (selectedItem === customOption) {
              setIsCustom(true);
            } else {
              setIsCustom(false);
              onChange(selectedItem.format);
            }
          }
        }
      ),
      isCustom && /* @__PURE__ */ (0, import_jsx_runtime314.jsx)(
        import_components168.TextControl,
        {
          __next40pxDefaultSize: true,
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n164.__)("Custom format"),
          hideLabelFromVision: true,
          help: (0, import_element178.createInterpolateElement)(
            (0, import_i18n164.__)(
              "Enter a date or time <Link>format string</Link>."
            ),
            {
              Link: /* @__PURE__ */ (0, import_jsx_runtime314.jsx)(
                import_components168.ExternalLink,
                {
                  href: (0, import_i18n164.__)(
                    "https://wordpress.org/documentation/article/customize-date-and-time-format/"
                  )
                }
              )
            }
          ),
          value: format,
          onChange: (value) => onChange(value)
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/duotone-control/index.js
  var import_jsx_runtime315 = __toESM(require_jsx_runtime());
  var import_components169 = __toESM(require_components());
  var import_i18n165 = __toESM(require_i18n());
  var import_keycodes17 = __toESM(require_keycodes());
  var import_compose80 = __toESM(require_compose());
  function DuotoneControl({
    id: idProp,
    colorPalette,
    duotonePalette,
    disableCustomColors,
    disableCustomDuotone,
    value,
    onChange
  }) {
    let toolbarIcon;
    if (value === "unset") {
      toolbarIcon = /* @__PURE__ */ (0, import_jsx_runtime315.jsx)(import_components169.ColorIndicator, { className: "block-editor-duotone-control__unset-indicator" });
    } else if (value) {
      toolbarIcon = /* @__PURE__ */ (0, import_jsx_runtime315.jsx)(import_components169.DuotoneSwatch, { values: value });
    } else {
      toolbarIcon = /* @__PURE__ */ (0, import_jsx_runtime315.jsx)(icon_default, { icon: filter_default });
    }
    const actionLabel = (0, import_i18n165.__)("Apply duotone filter");
    const id = (0, import_compose80.useInstanceId)(DuotoneControl, "duotone-control", idProp);
    const descriptionId = `${id}__description`;
    return /* @__PURE__ */ (0, import_jsx_runtime315.jsx)(
      import_components169.Dropdown,
      {
        popoverProps: {
          className: "block-editor-duotone-control__popover",
          headerTitle: (0, import_i18n165.__)("Duotone")
        },
        renderToggle: ({ isOpen, onToggle }) => {
          const openOnArrowDown = (event) => {
            if (!isOpen && event.keyCode === import_keycodes17.DOWN) {
              event.preventDefault();
              onToggle();
            }
          };
          return /* @__PURE__ */ (0, import_jsx_runtime315.jsx)(
            import_components169.ToolbarButton,
            {
              showTooltip: true,
              onClick: onToggle,
              "aria-haspopup": "true",
              "aria-expanded": isOpen,
              onKeyDown: openOnArrowDown,
              label: actionLabel,
              icon: toolbarIcon
            }
          );
        },
        renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime315.jsxs)(import_components169.MenuGroup, { label: (0, import_i18n165.__)("Duotone"), children: [
          /* @__PURE__ */ (0, import_jsx_runtime315.jsx)("p", { children: (0, import_i18n165.__)(
            "Create a two-tone color effect without losing your original image."
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime315.jsx)(
            import_components169.DuotonePicker,
            {
              "aria-label": actionLabel,
              "aria-describedby": descriptionId,
              colorPalette,
              duotonePalette,
              disableCustomColors,
              disableCustomDuotone,
              value,
              onChange
            }
          )
        ] })
      }
    );
  }
  var duotone_control_default = DuotoneControl;

  // packages/block-editor/build-module/components/colors-gradients/dropdown.js
  var import_jsx_runtime316 = __toESM(require_jsx_runtime());
  var import_components170 = __toESM(require_components());
  var import_element179 = __toESM(require_element());
  var import_i18n166 = __toESM(require_i18n());
  var WithToolsPanelItem = ({ setting, children, panelId, ...props }) => {
    const clearValue = () => {
      if (setting.colorValue) {
        setting.onColorChange();
      } else if (setting.gradientValue) {
        setting.onGradientChange();
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
      import_components170.__experimentalToolsPanelItem,
      {
        hasValue: () => {
          return !!setting.colorValue || !!setting.gradientValue;
        },
        label: setting.label,
        onDeselect: clearValue,
        isShownByDefault: setting.isShownByDefault !== void 0 ? setting.isShownByDefault : true,
        ...props,
        className: "block-editor-tools-panel-color-gradient-settings__item",
        panelId,
        resetAllFilter: setting.resetAllFilter,
        children
      }
    );
  };
  var LabeledColorIndicator2 = ({ colorValue, label }) => /* @__PURE__ */ (0, import_jsx_runtime316.jsxs)(import_components170.__experimentalHStack, { justify: "flex-start", children: [
    /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
      import_components170.ColorIndicator,
      {
        className: "block-editor-panel-color-gradient-settings__color-indicator",
        colorValue
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
      import_components170.FlexItem,
      {
        className: "block-editor-panel-color-gradient-settings__color-name",
        title: label,
        children: label
      }
    )
  ] });
  var renderToggle2 = (settings2) => ({ onToggle, isOpen }) => {
    const {
      clearable,
      colorValue,
      gradientValue,
      onColorChange,
      onGradientChange,
      label
    } = settings2;
    const colorButtonRef = (0, import_element179.useRef)(void 0);
    const toggleProps = {
      onClick: onToggle,
      className: clsx_default(
        "block-editor-panel-color-gradient-settings__dropdown",
        { "is-open": isOpen }
      ),
      "aria-expanded": isOpen,
      ref: colorButtonRef
    };
    const clearValue = () => {
      if (colorValue) {
        onColorChange();
      } else if (gradientValue) {
        onGradientChange();
      }
    };
    const value = colorValue ?? gradientValue;
    return /* @__PURE__ */ (0, import_jsx_runtime316.jsxs)(import_jsx_runtime316.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(import_components170.Button, { __next40pxDefaultSize: true, ...toggleProps, children: /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
        LabeledColorIndicator2,
        {
          colorValue: value,
          label
        }
      ) }),
      clearable && value && /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
        import_components170.Button,
        {
          __next40pxDefaultSize: true,
          label: (0, import_i18n166.__)("Reset"),
          className: "block-editor-panel-color-gradient-settings__reset",
          size: "small",
          icon: reset_default,
          onClick: () => {
            clearValue();
            if (isOpen) {
              onToggle();
            }
            colorButtonRef.current?.focus();
          }
        }
      )
    ] });
  };
  function ColorGradientSettingsDropdown({
    colors: colors2,
    disableCustomColors,
    disableCustomGradients,
    enableAlpha,
    gradients,
    settings: settings2,
    __experimentalIsRenderedInSidebar,
    ...props
  }) {
    let popoverProps3;
    if (__experimentalIsRenderedInSidebar) {
      popoverProps3 = {
        placement: "left-start",
        offset: 36,
        shift: true
      };
    }
    return /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(import_jsx_runtime316.Fragment, { children: settings2.map((setting, index) => {
      const controlProps = {
        clearable: false,
        colorValue: setting.colorValue,
        colors: colors2,
        disableCustomColors,
        disableCustomGradients,
        enableAlpha,
        gradientValue: setting.gradientValue,
        gradients,
        label: setting.label,
        onColorChange: setting.onColorChange,
        onGradientChange: setting.onGradientChange,
        showTitle: false,
        __experimentalIsRenderedInSidebar,
        ...setting
      };
      const toggleSettings = {
        clearable: setting.clearable,
        label: setting.label,
        colorValue: setting.colorValue,
        gradientValue: setting.gradientValue,
        onColorChange: setting.onColorChange,
        onGradientChange: setting.onGradientChange
      };
      return setting && // If not in an `ItemGroup` wrap the dropdown in a
      // `ToolsPanelItem`
      /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
        WithToolsPanelItem,
        {
          setting,
          ...props,
          children: /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
            import_components170.Dropdown,
            {
              popoverProps: popoverProps3,
              className: "block-editor-tools-panel-color-gradient-settings__dropdown",
              renderToggle: renderToggle2(toggleSettings),
              renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(import_components170.__experimentalDropdownContentWrapper, { paddingSize: "none", children: /* @__PURE__ */ (0, import_jsx_runtime316.jsx)("div", { className: "block-editor-panel-color-gradient-settings__dropdown-content", children: /* @__PURE__ */ (0, import_jsx_runtime316.jsx)(
                control_default,
                {
                  ...controlProps
                }
              ) }) })
            }
          )
        },
        index
      );
    }) });
  }

  // packages/block-editor/build-module/components/colors-gradients/panel-color-gradient-settings.js
  var import_jsx_runtime317 = __toESM(require_jsx_runtime());
  var import_components171 = __toESM(require_components());
  var import_data145 = __toESM(require_data());
  var import_compose81 = __toESM(require_compose());
  var colorsAndGradientKeys2 = [
    "colors",
    "disableCustomColors",
    "gradients",
    "disableCustomGradients"
  ];
  var PanelColorGradientSettingsInner = ({
    className,
    colors: colors2,
    gradients,
    disableCustomColors,
    disableCustomGradients,
    children,
    settings: settings2,
    title,
    showTitle = true,
    __experimentalIsRenderedInSidebar,
    enableAlpha
  }) => {
    const panelId = (0, import_compose81.useInstanceId)(PanelColorGradientSettingsInner);
    const { batch } = (0, import_data145.useRegistry)();
    if ((!colors2 || colors2.length === 0) && (!gradients || gradients.length === 0) && disableCustomColors && disableCustomGradients && settings2?.every(
      (setting) => (!setting.colors || setting.colors.length === 0) && (!setting.gradients || setting.gradients.length === 0) && (setting.disableCustomColors === void 0 || setting.disableCustomColors) && (setting.disableCustomGradients === void 0 || setting.disableCustomGradients)
    )) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime317.jsxs)(
      import_components171.__experimentalToolsPanel,
      {
        className: clsx_default(
          "block-editor-panel-color-gradient-settings",
          className
        ),
        label: showTitle ? title : void 0,
        resetAll: () => {
          batch(() => {
            settings2.forEach(
              ({
                colorValue,
                gradientValue,
                onColorChange,
                onGradientChange
              }) => {
                if (colorValue) {
                  onColorChange();
                } else if (gradientValue) {
                  onGradientChange();
                }
              }
            );
          });
        },
        panelId,
        __experimentalFirstVisibleItemClass: "first",
        __experimentalLastVisibleItemClass: "last",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime317.jsx)(
            ColorGradientSettingsDropdown,
            {
              settings: settings2,
              panelId,
              ...{
                colors: colors2,
                gradients,
                disableCustomColors,
                disableCustomGradients,
                __experimentalIsRenderedInSidebar,
                enableAlpha
              }
            }
          ),
          !!children && /* @__PURE__ */ (0, import_jsx_runtime317.jsxs)(import_jsx_runtime317.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime317.jsx)(import_components171.__experimentalSpacer, { marginY: 4 }),
            " ",
            children
          ] })
        ]
      }
    );
  };
  var PanelColorGradientSettingsSelect = (props) => {
    const colorGradientSettings = useMultipleOriginColorsAndGradients();
    return /* @__PURE__ */ (0, import_jsx_runtime317.jsx)(
      PanelColorGradientSettingsInner,
      {
        ...{ ...colorGradientSettings, ...props }
      }
    );
  };
  var PanelColorGradientSettings = (props) => {
    if (colorsAndGradientKeys2.every((key) => props.hasOwnProperty(key))) {
      return /* @__PURE__ */ (0, import_jsx_runtime317.jsx)(PanelColorGradientSettingsInner, { ...props });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime317.jsx)(PanelColorGradientSettingsSelect, { ...props });
  };
  var panel_color_gradient_settings_default = PanelColorGradientSettings;

  // packages/block-editor/build-module/components/image-editor/index.js
  var import_jsx_runtime324 = __toESM(require_jsx_runtime());
  var import_components177 = __toESM(require_components());

  // packages/block-editor/build-module/components/image-editor/aspect-ratio-dropdown.js
  var import_jsx_runtime319 = __toESM(require_jsx_runtime());
  var import_components172 = __toESM(require_components());
  var import_i18n168 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/image-editor/constants.js
  var MIN_ZOOM = 100;
  var MAX_ZOOM = 300;
  var POPOVER_PROPS7 = {
    placement: "bottom-start"
  };

  // packages/block-editor/build-module/components/image-editor/context.js
  var import_jsx_runtime318 = __toESM(require_jsx_runtime());
  var import_element182 = __toESM(require_element());

  // packages/block-editor/build-module/components/image-editor/use-save-image.js
  var import_data146 = __toESM(require_data());
  var import_element180 = __toESM(require_element());
  var import_i18n167 = __toESM(require_i18n());
  var import_notices11 = __toESM(require_notices());
  var import_dom37 = __toESM(require_dom());
  var messages = {
    crop: (0, import_i18n167.__)("Image cropped."),
    rotate: (0, import_i18n167.__)("Image rotated."),
    cropAndRotate: (0, import_i18n167.__)("Image cropped and rotated.")
  };
  function useSaveImage({
    crop,
    rotation,
    url,
    id,
    onSaveImage,
    onFinishEditing
  }) {
    const { createErrorNotice, createSuccessNotice } = (0, import_data146.useDispatch)(import_notices11.store);
    const [isInProgress, setIsInProgress] = (0, import_element180.useState)(false);
    const { editMediaEntity } = (0, import_data146.useSelect)((select2) => {
      const settings2 = select2(store).getSettings();
      return {
        editMediaEntity: settings2?.[mediaEditKey]
      };
    }, []);
    const cancel = (0, import_element180.useCallback)(() => {
      setIsInProgress(false);
      onFinishEditing();
    }, [onFinishEditing]);
    const apply = (0, import_element180.useCallback)(async () => {
      if (!editMediaEntity) {
        onFinishEditing();
        createErrorNotice(
          (0, import_i18n167.__)("Sorry, you are not allowed to edit images on this site."),
          {
            id: "image-editing-error",
            type: "snackbar"
          }
        );
        return;
      }
      setIsInProgress(true);
      const modifiers = [];
      if (rotation > 0) {
        modifiers.push({
          type: "rotate",
          args: {
            angle: rotation
          }
        });
      }
      if (crop.width < 99.9 || crop.height < 99.9) {
        modifiers.push({
          type: "crop",
          args: {
            left: crop.x,
            top: crop.y,
            width: crop.width,
            height: crop.height
          }
        });
      }
      if (modifiers.length === 0) {
        setIsInProgress(false);
        onFinishEditing();
        return;
      }
      const modifierType = modifiers.length === 1 ? modifiers[0].type : "cropAndRotate";
      try {
        const savedImage = await editMediaEntity(
          id,
          {
            src: url,
            modifiers
          },
          { throwOnError: true }
        );
        if (savedImage) {
          onSaveImage({
            id: savedImage.id,
            url: savedImage.source_url
          });
          createSuccessNotice(messages[modifierType], {
            type: "snackbar",
            actions: [
              {
                label: (0, import_i18n167.__)("Undo"),
                onClick: () => {
                  onSaveImage({
                    id,
                    url
                  });
                }
              }
            ]
          });
        }
      } catch (error) {
        createErrorNotice(
          (0, import_i18n167.sprintf)(
            /* translators: %s: Error message. */
            (0, import_i18n167.__)("Could not edit image. %s"),
            (0, import_dom37.__unstableStripHTML)(error.message)
          ),
          {
            id: "image-editing-error",
            type: "snackbar"
          }
        );
      } finally {
        setIsInProgress(false);
        onFinishEditing();
      }
    }, [
      crop,
      rotation,
      id,
      url,
      onSaveImage,
      createErrorNotice,
      createSuccessNotice,
      onFinishEditing,
      editMediaEntity
    ]);
    return (0, import_element180.useMemo)(
      () => ({
        isInProgress,
        apply,
        cancel
      }),
      [isInProgress, apply, cancel]
    );
  }

  // packages/block-editor/build-module/components/image-editor/use-transform-image.js
  var import_element181 = __toESM(require_element());
  var import_hooks11 = __toESM(require_hooks());
  function useTransformImage({
    url,
    naturalWidth,
    naturalHeight
  }) {
    const [editedUrl, setEditedUrl] = (0, import_element181.useState)();
    const [crop, setCrop] = (0, import_element181.useState)();
    const [position2, setPosition] = (0, import_element181.useState)({ x: 0, y: 0 });
    const [zoom, setZoom] = (0, import_element181.useState)(100);
    const [rotation, setRotation] = (0, import_element181.useState)(0);
    const defaultAspect = naturalWidth / naturalHeight;
    const [aspect, setAspect] = (0, import_element181.useState)(defaultAspect);
    const rotateClockwise = (0, import_element181.useCallback)(() => {
      const angle = (rotation + 90) % 360;
      let naturalAspectRatio = defaultAspect;
      if (rotation % 180 === 90) {
        naturalAspectRatio = 1 / defaultAspect;
      }
      if (angle === 0) {
        setEditedUrl();
        setRotation(angle);
        setAspect(defaultAspect);
        setPosition((prevPosition) => ({
          x: -(prevPosition.y * naturalAspectRatio),
          y: prevPosition.x * naturalAspectRatio
        }));
        return;
      }
      function editImage(event) {
        const canvas = document.createElement("canvas");
        let translateX = 0;
        let translateY = 0;
        if (angle % 180) {
          canvas.width = event.target.height;
          canvas.height = event.target.width;
        } else {
          canvas.width = event.target.width;
          canvas.height = event.target.height;
        }
        if (angle === 90 || angle === 180) {
          translateX = canvas.width;
        }
        if (angle === 270 || angle === 180) {
          translateY = canvas.height;
        }
        const context = canvas.getContext("2d");
        context.translate(translateX, translateY);
        context.rotate(angle * Math.PI / 180);
        context.drawImage(event.target, 0, 0);
        canvas.toBlob((blob) => {
          setEditedUrl(URL.createObjectURL(blob));
          setRotation(angle);
          setAspect(canvas.width / canvas.height);
          setPosition((prevPosition) => ({
            x: -(prevPosition.y * naturalAspectRatio),
            y: prevPosition.x * naturalAspectRatio
          }));
        });
      }
      const el = new window.Image();
      el.src = url;
      el.onload = editImage;
      const imgCrossOrigin = (0, import_hooks11.applyFilters)(
        "media.crossOrigin",
        void 0,
        url
      );
      if (typeof imgCrossOrigin === "string") {
        el.crossOrigin = imgCrossOrigin;
      }
    }, [rotation, defaultAspect, url]);
    return (0, import_element181.useMemo)(
      () => ({
        editedUrl,
        setEditedUrl,
        crop,
        setCrop,
        position: position2,
        setPosition,
        zoom,
        setZoom,
        rotation,
        setRotation,
        rotateClockwise,
        aspect,
        setAspect,
        defaultAspect
      }),
      [
        editedUrl,
        crop,
        position2,
        zoom,
        rotation,
        rotateClockwise,
        aspect,
        defaultAspect
      ]
    );
  }

  // packages/block-editor/build-module/components/image-editor/context.js
  var ImageEditingContext = (0, import_element182.createContext)({});
  ImageEditingContext.displayName = "ImageEditingContext";
  var useImageEditingContext = () => (0, import_element182.useContext)(ImageEditingContext);
  function ImageEditingProvider({
    id,
    url,
    naturalWidth,
    naturalHeight,
    onFinishEditing,
    onSaveImage,
    children
  }) {
    const transformImage = useTransformImage({
      url,
      naturalWidth,
      naturalHeight
    });
    const saveImage = useSaveImage({
      id,
      url,
      onSaveImage,
      onFinishEditing,
      ...transformImage
    });
    const providerValue = (0, import_element182.useMemo)(
      () => ({
        ...transformImage,
        ...saveImage
      }),
      [transformImage, saveImage]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime318.jsx)(ImageEditingContext.Provider, { value: providerValue, children });
  }

  // packages/block-editor/build-module/components/image-editor/aspect-ratio-dropdown.js
  function AspectRatioGroup({
    aspectRatios,
    isDisabled,
    label,
    onClick,
    value
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime319.jsx)(import_components172.MenuGroup, { label, children: aspectRatios.map(({ name, slug, ratio }) => /* @__PURE__ */ (0, import_jsx_runtime319.jsx)(
      import_components172.MenuItem,
      {
        disabled: isDisabled,
        onClick: () => {
          onClick(ratio);
        },
        role: "menuitemradio",
        isSelected: ratio === value,
        icon: ratio === value ? check_default : void 0,
        children: name
      },
      slug
    )) });
  }
  function ratioToNumber(str) {
    const [a2, b2, ...rest] = str.split("/").map(Number);
    if (a2 <= 0 || b2 <= 0 || Number.isNaN(a2) || Number.isNaN(b2) || rest.length) {
      return NaN;
    }
    return b2 ? a2 / b2 : a2;
  }
  function presetRatioAsNumber({ ratio, ...rest }) {
    return {
      ratio: ratioToNumber(ratio),
      ...rest
    };
  }
  function AspectRatioDropdown({ toggleProps }) {
    const { isInProgress, aspect, setAspect, defaultAspect } = useImageEditingContext();
    const [defaultRatios, themeRatios, showDefaultRatios] = useSettings(
      "dimensions.aspectRatios.default",
      "dimensions.aspectRatios.theme",
      "dimensions.defaultAspectRatios"
    );
    return /* @__PURE__ */ (0, import_jsx_runtime319.jsx)(
      import_components172.DropdownMenu,
      {
        icon: aspect_ratio_default,
        label: (0, import_i18n168.__)("Aspect Ratio"),
        popoverProps: POPOVER_PROPS7,
        toggleProps,
        children: ({ onClose }) => /* @__PURE__ */ (0, import_jsx_runtime319.jsxs)(import_jsx_runtime319.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime319.jsx)(
            AspectRatioGroup,
            {
              isDisabled: isInProgress,
              onClick: (newAspect) => {
                setAspect(newAspect);
                onClose();
              },
              value: aspect,
              aspectRatios: [
                // All ratios should be mirrored in AspectRatioTool in @wordpress/block-editor.
                {
                  slug: "original",
                  name: (0, import_i18n168.__)("Original"),
                  ratio: defaultAspect
                },
                ...showDefaultRatios ? defaultRatios.map(presetRatioAsNumber).filter(({ ratio }) => ratio === 1) : []
              ]
            }
          ),
          themeRatios?.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime319.jsx)(
            AspectRatioGroup,
            {
              label: (0, import_i18n168.__)("Theme"),
              isDisabled: isInProgress,
              onClick: (newAspect) => {
                setAspect(newAspect);
                onClose();
              },
              value: aspect,
              aspectRatios: themeRatios
            }
          ),
          showDefaultRatios && /* @__PURE__ */ (0, import_jsx_runtime319.jsx)(
            AspectRatioGroup,
            {
              label: (0, import_i18n168.__)("Landscape"),
              isDisabled: isInProgress,
              onClick: (newAspect) => {
                setAspect(newAspect);
                onClose();
              },
              value: aspect,
              aspectRatios: defaultRatios.map(presetRatioAsNumber).filter(({ ratio }) => ratio > 1)
            }
          ),
          showDefaultRatios && /* @__PURE__ */ (0, import_jsx_runtime319.jsx)(
            AspectRatioGroup,
            {
              label: (0, import_i18n168.__)("Portrait"),
              isDisabled: isInProgress,
              onClick: (newAspect) => {
                setAspect(newAspect);
                onClose();
              },
              value: aspect,
              aspectRatios: defaultRatios.map(presetRatioAsNumber).filter(({ ratio }) => ratio < 1)
            }
          )
        ] })
      }
    );
  }

  // packages/block-editor/build-module/components/image-editor/cropper.js
  var import_jsx_runtime320 = __toESM(require_jsx_runtime());

  // packages/block-editor/node_modules/tslib/tslib.es6.js
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  function __extends(d2, b2) {
    extendStatics(d2, b2);
    function __189() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__189.prototype = b2.prototype, new __189());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t3) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t3[p2] = s2[p2];
      }
      return t3;
    };
    return __assign.apply(this, arguments);
  };

  // packages/block-editor/node_modules/react-easy-crop/index.module.js
  var React3 = __toESM(require_react());
  var import_normalize_wheel = __toESM(require_normalize_wheel());
  function getCropSize(mediaWidth, mediaHeight, containerWidth, containerHeight, aspect, rotation) {
    if (rotation === void 0) {
      rotation = 0;
    }
    var _a = rotateSize(mediaWidth, mediaHeight, rotation), width = _a.width, height = _a.height;
    var fittingWidth = Math.min(width, containerWidth);
    var fittingHeight = Math.min(height, containerHeight);
    if (fittingWidth > fittingHeight * aspect) {
      return {
        width: fittingHeight * aspect,
        height: fittingHeight
      };
    }
    return {
      width: fittingWidth,
      height: fittingWidth / aspect
    };
  }
  function getMediaZoom(mediaSize) {
    return mediaSize.width > mediaSize.height ? mediaSize.width / mediaSize.naturalWidth : mediaSize.height / mediaSize.naturalHeight;
  }
  function restrictPosition(position2, mediaSize, cropSize, zoom, rotation) {
    if (rotation === void 0) {
      rotation = 0;
    }
    var _a = rotateSize(mediaSize.width, mediaSize.height, rotation), width = _a.width, height = _a.height;
    return {
      x: restrictPositionCoord(position2.x, width, cropSize.width, zoom),
      y: restrictPositionCoord(position2.y, height, cropSize.height, zoom)
    };
  }
  function restrictPositionCoord(position2, mediaSize, cropSize, zoom) {
    var maxPosition = mediaSize * zoom / 2 - cropSize / 2;
    return clamp(position2, -maxPosition, maxPosition);
  }
  function getDistanceBetweenPoints(pointA, pointB) {
    return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));
  }
  function getRotationBetweenPoints(pointA, pointB) {
    return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;
  }
  function computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition2) {
    if (rotation === void 0) {
      rotation = 0;
    }
    if (restrictPosition2 === void 0) {
      restrictPosition2 = true;
    }
    var limitAreaFn = restrictPosition2 ? limitArea : noOp;
    var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);
    var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);
    var croppedAreaPercentages = {
      x: limitAreaFn(100, ((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width * 100),
      y: limitAreaFn(100, ((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaBBoxSize.height * 100),
      width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),
      height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)
    };
    var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));
    var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));
    var isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect;
    var sizePixels = isImgWiderThanHigh ? {
      width: Math.round(heightInPixels * aspect),
      height: heightInPixels
    } : {
      width: widthInPixels,
      height: Math.round(widthInPixels / aspect)
    };
    var croppedAreaPixels = __assign(__assign({}, sizePixels), {
      x: Math.round(limitAreaFn(mediaNaturalBBoxSize.width - sizePixels.width, croppedAreaPercentages.x * mediaNaturalBBoxSize.width / 100)),
      y: Math.round(limitAreaFn(mediaNaturalBBoxSize.height - sizePixels.height, croppedAreaPercentages.y * mediaNaturalBBoxSize.height / 100))
    });
    return {
      croppedAreaPercentages,
      croppedAreaPixels
    };
  }
  function limitArea(max, value) {
    return Math.min(max, Math.max(0, value));
  }
  function noOp(_max, value) {
    return value;
  }
  function getInitialCropFromCroppedAreaPercentages(croppedAreaPercentages, mediaSize, rotation, cropSize, minZoom, maxZoom) {
    var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);
    var zoom = clamp(cropSize.width / mediaBBoxSize.width * (100 / croppedAreaPercentages.width), minZoom, maxZoom);
    var crop = {
      x: zoom * mediaBBoxSize.width / 2 - cropSize.width / 2 - mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),
      y: zoom * mediaBBoxSize.height / 2 - cropSize.height / 2 - mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100)
    };
    return {
      crop,
      zoom
    };
  }
  function getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {
    var mediaZoom = getMediaZoom(mediaSize);
    return cropSize.height > cropSize.width ? cropSize.height / (croppedAreaPixels.height * mediaZoom) : cropSize.width / (croppedAreaPixels.width * mediaZoom);
  }
  function getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, rotation, cropSize, minZoom, maxZoom) {
    if (rotation === void 0) {
      rotation = 0;
    }
    var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);
    var zoom = clamp(getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize), minZoom, maxZoom);
    var cropZoom = cropSize.height > cropSize.width ? cropSize.height / croppedAreaPixels.height : cropSize.width / croppedAreaPixels.width;
    var crop = {
      x: ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,
      y: ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom
    };
    return {
      crop,
      zoom
    };
  }
  function getCenter(a2, b2) {
    return {
      x: (b2.x + a2.x) / 2,
      y: (b2.y + a2.y) / 2
    };
  }
  function getRadianAngle(degreeValue) {
    return degreeValue * Math.PI / 180;
  }
  function rotateSize(width, height, rotation) {
    var rotRad = getRadianAngle(rotation);
    return {
      width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),
      height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)
    };
  }
  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  function classNames() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return args.filter(function(value) {
      if (typeof value === "string" && value.length > 0) {
        return true;
      }
      return false;
    }).join(" ").trim();
  }
  var css_248z = ".reactEasyCrop_Container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  user-select: none;\n  touch-action: none;\n  cursor: move;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.reactEasyCrop_Image,\n.reactEasyCrop_Video {\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\n}\n\n.reactEasyCrop_Contain {\n  max-width: 100%;\n  max-height: 100%;\n  margin: auto;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n.reactEasyCrop_Cover_Horizontal {\n  width: 100%;\n  height: auto;\n}\n.reactEasyCrop_Cover_Vertical {\n  width: auto;\n  height: 100%;\n}\n\n.reactEasyCrop_CropArea {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  box-sizing: border-box;\n  box-shadow: 0 0 0 9999em;\n  color: rgba(0, 0, 0, 0.5);\n  overflow: hidden;\n}\n\n.reactEasyCrop_CropAreaRound {\n  border-radius: 50%;\n}\n\n.reactEasyCrop_CropAreaGrid::before {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 0;\n  bottom: 0;\n  left: 33.33%;\n  right: 33.33%;\n  border-top: 0;\n  border-bottom: 0;\n}\n\n.reactEasyCrop_CropAreaGrid::after {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 33.33%;\n  bottom: 33.33%;\n  left: 0;\n  right: 0;\n  border-left: 0;\n  border-right: 0;\n}\n";
  var MIN_ZOOM2 = 1;
  var MAX_ZOOM2 = 3;
  var Cropper = (
    /** @class */
    (function(_super) {
      __extends(Cropper2, _super);
      function Cropper2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.imageRef = React3.createRef();
        _this.videoRef = React3.createRef();
        _this.containerPosition = {
          x: 0,
          y: 0
        };
        _this.containerRef = null;
        _this.styleRef = null;
        _this.containerRect = null;
        _this.mediaSize = {
          width: 0,
          height: 0,
          naturalWidth: 0,
          naturalHeight: 0
        };
        _this.dragStartPosition = {
          x: 0,
          y: 0
        };
        _this.dragStartCrop = {
          x: 0,
          y: 0
        };
        _this.gestureZoomStart = 0;
        _this.gestureRotationStart = 0;
        _this.isTouching = false;
        _this.lastPinchDistance = 0;
        _this.lastPinchRotation = 0;
        _this.rafDragTimeout = null;
        _this.rafPinchTimeout = null;
        _this.wheelTimer = null;
        _this.currentDoc = typeof document !== "undefined" ? document : null;
        _this.currentWindow = typeof window !== "undefined" ? window : null;
        _this.resizeObserver = null;
        _this.state = {
          cropSize: null,
          hasWheelJustStarted: false,
          mediaObjectFit: void 0
        };
        _this.initResizeObserver = function() {
          if (typeof window.ResizeObserver === "undefined" || !_this.containerRef) {
            return;
          }
          var isFirstResize = true;
          _this.resizeObserver = new window.ResizeObserver(function(entries) {
            if (isFirstResize) {
              isFirstResize = false;
              return;
            }
            _this.computeSizes();
          });
          _this.resizeObserver.observe(_this.containerRef);
        };
        _this.preventZoomSafari = function(e2) {
          return e2.preventDefault();
        };
        _this.cleanEvents = function() {
          if (!_this.currentDoc) return;
          _this.currentDoc.removeEventListener("mousemove", _this.onMouseMove);
          _this.currentDoc.removeEventListener("mouseup", _this.onDragStopped);
          _this.currentDoc.removeEventListener("touchmove", _this.onTouchMove);
          _this.currentDoc.removeEventListener("touchend", _this.onDragStopped);
          _this.currentDoc.removeEventListener("gesturemove", _this.onGestureMove);
          _this.currentDoc.removeEventListener("gestureend", _this.onGestureEnd);
          _this.currentDoc.removeEventListener("scroll", _this.onScroll);
        };
        _this.clearScrollEvent = function() {
          if (_this.containerRef) _this.containerRef.removeEventListener("wheel", _this.onWheel);
          if (_this.wheelTimer) {
            clearTimeout(_this.wheelTimer);
          }
        };
        _this.onMediaLoad = function() {
          var cropSize = _this.computeSizes();
          if (cropSize) {
            _this.emitCropData();
            _this.setInitialCrop(cropSize);
          }
          if (_this.props.onMediaLoaded) {
            _this.props.onMediaLoaded(_this.mediaSize);
          }
        };
        _this.setInitialCrop = function(cropSize) {
          if (_this.props.initialCroppedAreaPercentages) {
            var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom), crop = _a.crop, zoom = _a.zoom;
            _this.props.onCropChange(crop);
            _this.props.onZoomChange && _this.props.onZoomChange(zoom);
          } else if (_this.props.initialCroppedAreaPixels) {
            var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom), crop = _b.crop, zoom = _b.zoom;
            _this.props.onCropChange(crop);
            _this.props.onZoomChange && _this.props.onZoomChange(zoom);
          }
        };
        _this.computeSizes = function() {
          var _a, _b, _c, _d, _e, _f;
          var mediaRef = _this.imageRef.current || _this.videoRef.current;
          if (mediaRef && _this.containerRef) {
            _this.containerRect = _this.containerRef.getBoundingClientRect();
            _this.saveContainerPosition();
            var containerAspect = _this.containerRect.width / _this.containerRect.height;
            var naturalWidth = ((_a = _this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;
            var naturalHeight = ((_c = _this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;
            var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;
            var mediaAspect = naturalWidth / naturalHeight;
            var renderedMediaSize = void 0;
            if (isMediaScaledDown) {
              switch (_this.state.mediaObjectFit) {
                default:
                case "contain":
                  renderedMediaSize = containerAspect > mediaAspect ? {
                    width: _this.containerRect.height * mediaAspect,
                    height: _this.containerRect.height
                  } : {
                    width: _this.containerRect.width,
                    height: _this.containerRect.width / mediaAspect
                  };
                  break;
                case "horizontal-cover":
                  renderedMediaSize = {
                    width: _this.containerRect.width,
                    height: _this.containerRect.width / mediaAspect
                  };
                  break;
                case "vertical-cover":
                  renderedMediaSize = {
                    width: _this.containerRect.height * mediaAspect,
                    height: _this.containerRect.height
                  };
                  break;
              }
            } else {
              renderedMediaSize = {
                width: mediaRef.offsetWidth,
                height: mediaRef.offsetHeight
              };
            }
            _this.mediaSize = __assign(__assign({}, renderedMediaSize), {
              naturalWidth,
              naturalHeight
            });
            if (_this.props.setMediaSize) {
              _this.props.setMediaSize(_this.mediaSize);
            }
            var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);
            if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {
              _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);
            }
            _this.setState({
              cropSize
            }, _this.recomputeCropPosition);
            if (_this.props.setCropSize) {
              _this.props.setCropSize(cropSize);
            }
            return cropSize;
          }
        };
        _this.saveContainerPosition = function() {
          if (_this.containerRef) {
            var bounds = _this.containerRef.getBoundingClientRect();
            _this.containerPosition = {
              x: bounds.left,
              y: bounds.top
            };
          }
        };
        _this.onMouseDown = function(e2) {
          if (!_this.currentDoc) return;
          e2.preventDefault();
          _this.currentDoc.addEventListener("mousemove", _this.onMouseMove);
          _this.currentDoc.addEventListener("mouseup", _this.onDragStopped);
          _this.saveContainerPosition();
          _this.onDragStart(Cropper2.getMousePoint(e2));
        };
        _this.onMouseMove = function(e2) {
          return _this.onDrag(Cropper2.getMousePoint(e2));
        };
        _this.onScroll = function(e2) {
          if (!_this.currentDoc) return;
          e2.preventDefault();
          _this.saveContainerPosition();
        };
        _this.onTouchStart = function(e2) {
          if (!_this.currentDoc) return;
          _this.isTouching = true;
          if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e2)) {
            return;
          }
          _this.currentDoc.addEventListener("touchmove", _this.onTouchMove, {
            passive: false
          });
          _this.currentDoc.addEventListener("touchend", _this.onDragStopped);
          _this.saveContainerPosition();
          if (e2.touches.length === 2) {
            _this.onPinchStart(e2);
          } else if (e2.touches.length === 1) {
            _this.onDragStart(Cropper2.getTouchPoint(e2.touches[0]));
          }
        };
        _this.onTouchMove = function(e2) {
          e2.preventDefault();
          if (e2.touches.length === 2) {
            _this.onPinchMove(e2);
          } else if (e2.touches.length === 1) {
            _this.onDrag(Cropper2.getTouchPoint(e2.touches[0]));
          }
        };
        _this.onGestureStart = function(e2) {
          if (!_this.currentDoc) return;
          e2.preventDefault();
          _this.currentDoc.addEventListener("gesturechange", _this.onGestureMove);
          _this.currentDoc.addEventListener("gestureend", _this.onGestureEnd);
          _this.gestureZoomStart = _this.props.zoom;
          _this.gestureRotationStart = _this.props.rotation;
        };
        _this.onGestureMove = function(e2) {
          e2.preventDefault();
          if (_this.isTouching) {
            return;
          }
          var point = Cropper2.getMousePoint(e2);
          var newZoom = _this.gestureZoomStart - 1 + e2.scale;
          _this.setNewZoom(newZoom, point, {
            shouldUpdatePosition: true
          });
          if (_this.props.onRotationChange) {
            var newRotation = _this.gestureRotationStart + e2.rotation;
            _this.props.onRotationChange(newRotation);
          }
        };
        _this.onGestureEnd = function(e2) {
          _this.cleanEvents();
        };
        _this.onDragStart = function(_a) {
          var _b, _c;
          var x2 = _a.x, y2 = _a.y;
          _this.dragStartPosition = {
            x: x2,
            y: y2
          };
          _this.dragStartCrop = __assign({}, _this.props.crop);
          (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);
        };
        _this.onDrag = function(_a) {
          var x2 = _a.x, y2 = _a.y;
          if (!_this.currentWindow) return;
          if (_this.rafDragTimeout) _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);
          _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(function() {
            if (!_this.state.cropSize) return;
            if (x2 === void 0 || y2 === void 0) return;
            var offsetX = x2 - _this.dragStartPosition.x;
            var offsetY = y2 - _this.dragStartPosition.y;
            var requestedPosition = {
              x: _this.dragStartCrop.x + offsetX,
              y: _this.dragStartCrop.y + offsetY
            };
            var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;
            _this.props.onCropChange(newPosition);
          });
        };
        _this.onDragStopped = function() {
          var _a, _b;
          _this.isTouching = false;
          _this.cleanEvents();
          _this.emitCropData();
          (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        _this.onWheel = function(e2) {
          if (!_this.currentWindow) return;
          if (_this.props.onWheelRequest && !_this.props.onWheelRequest(e2)) {
            return;
          }
          e2.preventDefault();
          var point = Cropper2.getMousePoint(e2);
          var pixelY = (0, import_normalize_wheel.default)(e2).pixelY;
          var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;
          _this.setNewZoom(newZoom, point, {
            shouldUpdatePosition: true
          });
          if (!_this.state.hasWheelJustStarted) {
            _this.setState({
              hasWheelJustStarted: true
            }, function() {
              var _a, _b;
              return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);
            });
          }
          if (_this.wheelTimer) {
            clearTimeout(_this.wheelTimer);
          }
          _this.wheelTimer = _this.currentWindow.setTimeout(function() {
            return _this.setState({
              hasWheelJustStarted: false
            }, function() {
              var _a, _b;
              return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
            });
          }, 250);
        };
        _this.getPointOnContainer = function(_a, containerTopLeft) {
          var x2 = _a.x, y2 = _a.y;
          if (!_this.containerRect) {
            throw new Error("The Cropper is not mounted");
          }
          return {
            x: _this.containerRect.width / 2 - (x2 - containerTopLeft.x),
            y: _this.containerRect.height / 2 - (y2 - containerTopLeft.y)
          };
        };
        _this.getPointOnMedia = function(_a) {
          var x2 = _a.x, y2 = _a.y;
          var _b = _this.props, crop = _b.crop, zoom = _b.zoom;
          return {
            x: (x2 + crop.x) / zoom,
            y: (y2 + crop.y) / zoom
          };
        };
        _this.setNewZoom = function(zoom, point, _a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.shouldUpdatePosition, shouldUpdatePosition = _c === void 0 ? true : _c;
          if (!_this.state.cropSize || !_this.props.onZoomChange) return;
          var newZoom = clamp(zoom, _this.props.minZoom, _this.props.maxZoom);
          if (shouldUpdatePosition) {
            var zoomPoint = _this.getPointOnContainer(point, _this.containerPosition);
            var zoomTarget = _this.getPointOnMedia(zoomPoint);
            var requestedPosition = {
              x: zoomTarget.x * newZoom - zoomPoint.x,
              y: zoomTarget.y * newZoom - zoomPoint.y
            };
            var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;
            _this.props.onCropChange(newPosition);
          }
          _this.props.onZoomChange(newZoom);
        };
        _this.getCropData = function() {
          if (!_this.state.cropSize) {
            return null;
          }
          var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
          return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);
        };
        _this.emitCropData = function() {
          var cropData = _this.getCropData();
          if (!cropData) return;
          var croppedAreaPercentages = cropData.croppedAreaPercentages, croppedAreaPixels = cropData.croppedAreaPixels;
          if (_this.props.onCropComplete) {
            _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);
          }
          if (_this.props.onCropAreaChange) {
            _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);
          }
        };
        _this.emitCropAreaChange = function() {
          var cropData = _this.getCropData();
          if (!cropData) return;
          var croppedAreaPercentages = cropData.croppedAreaPercentages, croppedAreaPixels = cropData.croppedAreaPixels;
          if (_this.props.onCropAreaChange) {
            _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);
          }
        };
        _this.recomputeCropPosition = function() {
          if (!_this.state.cropSize) return;
          var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
          _this.props.onCropChange(newPosition);
          _this.emitCropData();
        };
        return _this;
      }
      Cropper2.prototype.componentDidMount = function() {
        if (!this.currentDoc || !this.currentWindow) return;
        if (this.containerRef) {
          if (this.containerRef.ownerDocument) {
            this.currentDoc = this.containerRef.ownerDocument;
          }
          if (this.currentDoc.defaultView) {
            this.currentWindow = this.currentDoc.defaultView;
          }
          this.initResizeObserver();
          if (typeof window.ResizeObserver === "undefined") {
            this.currentWindow.addEventListener("resize", this.computeSizes);
          }
          this.props.zoomWithScroll && this.containerRef.addEventListener("wheel", this.onWheel, {
            passive: false
          });
          this.containerRef.addEventListener("gesturestart", this.onGestureStart);
        }
        this.currentDoc.addEventListener("scroll", this.onScroll);
        if (!this.props.disableAutomaticStylesInjection) {
          this.styleRef = this.currentDoc.createElement("style");
          this.styleRef.setAttribute("type", "text/css");
          if (this.props.nonce) {
            this.styleRef.setAttribute("nonce", this.props.nonce);
          }
          this.styleRef.innerHTML = css_248z;
          this.currentDoc.head.appendChild(this.styleRef);
        }
        if (this.imageRef.current && this.imageRef.current.complete) {
          this.onMediaLoad();
        }
        if (this.props.setImageRef) {
          this.props.setImageRef(this.imageRef);
        }
        if (this.props.setVideoRef) {
          this.props.setVideoRef(this.videoRef);
        }
      };
      Cropper2.prototype.componentWillUnmount = function() {
        var _a, _b;
        if (!this.currentDoc || !this.currentWindow) return;
        if (typeof window.ResizeObserver === "undefined") {
          this.currentWindow.removeEventListener("resize", this.computeSizes);
        }
        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        if (this.containerRef) {
          this.containerRef.removeEventListener("gesturestart", this.preventZoomSafari);
        }
        if (this.styleRef) {
          (_b = this.styleRef.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.styleRef);
        }
        this.cleanEvents();
        this.props.zoomWithScroll && this.clearScrollEvent();
      };
      Cropper2.prototype.componentDidUpdate = function(prevProps) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (prevProps.rotation !== this.props.rotation) {
          this.computeSizes();
          this.recomputeCropPosition();
        } else if (prevProps.aspect !== this.props.aspect) {
          this.computeSizes();
        } else if (prevProps.objectFit !== this.props.objectFit) {
          this.computeSizes();
        } else if (prevProps.zoom !== this.props.zoom) {
          this.recomputeCropPosition();
        } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {
          this.computeSizes();
        } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {
          this.emitCropAreaChange();
        }
        if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {
          this.props.zoomWithScroll ? this.containerRef.addEventListener("wheel", this.onWheel, {
            passive: false
          }) : this.clearScrollEvent();
        }
        if (prevProps.video !== this.props.video) {
          (_j = this.videoRef.current) === null || _j === void 0 ? void 0 : _j.load();
        }
        var objectFit = this.getObjectFit();
        if (objectFit !== this.state.mediaObjectFit) {
          this.setState({
            mediaObjectFit: objectFit
          }, this.computeSizes);
        }
      };
      Cropper2.prototype.getAspect = function() {
        var _a = this.props, cropSize = _a.cropSize, aspect = _a.aspect;
        if (cropSize) {
          return cropSize.width / cropSize.height;
        }
        return aspect;
      };
      Cropper2.prototype.getObjectFit = function() {
        var _a, _b, _c, _d;
        if (this.props.objectFit === "cover") {
          var mediaRef = this.imageRef.current || this.videoRef.current;
          if (mediaRef && this.containerRef) {
            this.containerRect = this.containerRef.getBoundingClientRect();
            var containerAspect = this.containerRect.width / this.containerRect.height;
            var naturalWidth = ((_a = this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;
            var naturalHeight = ((_c = this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;
            var mediaAspect = naturalWidth / naturalHeight;
            return mediaAspect < containerAspect ? "horizontal-cover" : "vertical-cover";
          }
          return "horizontal-cover";
        }
        return this.props.objectFit;
      };
      Cropper2.prototype.onPinchStart = function(e2) {
        var pointA = Cropper2.getTouchPoint(e2.touches[0]);
        var pointB = Cropper2.getTouchPoint(e2.touches[1]);
        this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);
        this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);
        this.onDragStart(getCenter(pointA, pointB));
      };
      Cropper2.prototype.onPinchMove = function(e2) {
        var _this = this;
        if (!this.currentDoc || !this.currentWindow) return;
        var pointA = Cropper2.getTouchPoint(e2.touches[0]);
        var pointB = Cropper2.getTouchPoint(e2.touches[1]);
        var center = getCenter(pointA, pointB);
        this.onDrag(center);
        if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);
        this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(function() {
          var distance = getDistanceBetweenPoints(pointA, pointB);
          var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);
          _this.setNewZoom(newZoom, center, {
            shouldUpdatePosition: false
          });
          _this.lastPinchDistance = distance;
          var rotation = getRotationBetweenPoints(pointA, pointB);
          var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);
          _this.props.onRotationChange && _this.props.onRotationChange(newRotation);
          _this.lastPinchRotation = rotation;
        });
      };
      Cropper2.prototype.render = function() {
        var _this = this;
        var _a = this.props, image = _a.image, video = _a.video, mediaProps = _a.mediaProps, transform = _a.transform, _b = _a.crop, x2 = _b.x, y2 = _b.y, rotation = _a.rotation, zoom = _a.zoom, cropShape = _a.cropShape, showGrid = _a.showGrid, _c = _a.style, containerStyle = _c.containerStyle, cropAreaStyle = _c.cropAreaStyle, mediaStyle = _c.mediaStyle, _d = _a.classes, containerClassName = _d.containerClassName, cropAreaClassName = _d.cropAreaClassName, mediaClassName = _d.mediaClassName;
        var objectFit = this.state.mediaObjectFit;
        return React3.createElement("div", {
          onMouseDown: this.onMouseDown,
          onTouchStart: this.onTouchStart,
          ref: function ref(el) {
            return _this.containerRef = el;
          },
          "data-testid": "container",
          style: containerStyle,
          className: classNames("reactEasyCrop_Container", containerClassName)
        }, image ? React3.createElement("img", __assign({
          alt: "",
          className: classNames("reactEasyCrop_Image", objectFit === "contain" && "reactEasyCrop_Contain", objectFit === "horizontal-cover" && "reactEasyCrop_Cover_Horizontal", objectFit === "vertical-cover" && "reactEasyCrop_Cover_Vertical", mediaClassName)
        }, mediaProps, {
          src: image,
          ref: this.imageRef,
          style: __assign(__assign({}, mediaStyle), {
            transform: transform || "translate(".concat(x2, "px, ").concat(y2, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
          }),
          onLoad: this.onMediaLoad
        })) : video && React3.createElement("video", __assign({
          autoPlay: true,
          loop: true,
          muted: true,
          className: classNames("reactEasyCrop_Video", objectFit === "contain" && "reactEasyCrop_Contain", objectFit === "horizontal-cover" && "reactEasyCrop_Cover_Horizontal", objectFit === "vertical-cover" && "reactEasyCrop_Cover_Vertical", mediaClassName)
        }, mediaProps, {
          ref: this.videoRef,
          onLoadedMetadata: this.onMediaLoad,
          style: __assign(__assign({}, mediaStyle), {
            transform: transform || "translate(".concat(x2, "px, ").concat(y2, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
          }),
          controls: false
        }), (Array.isArray(video) ? video : [{
          src: video
        }]).map(function(item) {
          return React3.createElement("source", __assign({
            key: item.src
          }, item));
        })), this.state.cropSize && React3.createElement("div", {
          style: __assign(__assign({}, cropAreaStyle), {
            width: this.state.cropSize.width,
            height: this.state.cropSize.height
          }),
          "data-testid": "cropper",
          className: classNames("reactEasyCrop_CropArea", cropShape === "round" && "reactEasyCrop_CropAreaRound", showGrid && "reactEasyCrop_CropAreaGrid", cropAreaClassName)
        }));
      };
      Cropper2.defaultProps = {
        zoom: 1,
        rotation: 0,
        aspect: 4 / 3,
        maxZoom: MAX_ZOOM2,
        minZoom: MIN_ZOOM2,
        cropShape: "rect",
        objectFit: "contain",
        showGrid: true,
        style: {},
        classes: {},
        mediaProps: {},
        zoomSpeed: 1,
        restrictPosition: true,
        zoomWithScroll: true
      };
      Cropper2.getMousePoint = function(e2) {
        return {
          x: Number(e2.clientX),
          y: Number(e2.clientY)
        };
      };
      Cropper2.getTouchPoint = function(touch) {
        return {
          x: Number(touch.clientX),
          y: Number(touch.clientY)
        };
      };
      return Cropper2;
    })(React3.Component)
  );

  // packages/block-editor/build-module/components/image-editor/cropper.js
  var import_components173 = __toESM(require_components());
  var import_compose82 = __toESM(require_compose());
  function ImageCropper({
    url,
    width,
    height,
    naturalHeight,
    naturalWidth,
    borderProps
  }) {
    const {
      isInProgress,
      editedUrl,
      position: position2,
      zoom,
      aspect,
      setPosition,
      setCrop,
      setZoom,
      rotation
    } = useImageEditingContext();
    const [contentResizeListener, { width: clientWidth }] = (0, import_compose82.useResizeObserver)();
    let editedHeight = height || clientWidth * naturalHeight / naturalWidth;
    if (rotation % 180 === 90) {
      editedHeight = clientWidth * naturalWidth / naturalHeight;
    }
    const area = /* @__PURE__ */ (0, import_jsx_runtime320.jsxs)(
      "div",
      {
        className: clsx_default(
          "wp-block-image__crop-area",
          borderProps?.className,
          {
            "is-applying": isInProgress
          }
        ),
        style: {
          ...borderProps?.style,
          width: width || clientWidth,
          height: editedHeight
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime320.jsx)(
            Cropper,
            {
              image: editedUrl || url,
              disabled: isInProgress,
              minZoom: MIN_ZOOM / 100,
              maxZoom: MAX_ZOOM / 100,
              crop: position2,
              zoom: zoom / 100,
              aspect,
              onCropChange: (pos) => {
                setPosition(pos);
              },
              onCropComplete: (newCropPercent) => {
                setCrop(newCropPercent);
              },
              onZoomChange: (newZoom) => {
                setZoom(newZoom * 100);
              }
            }
          ),
          isInProgress && /* @__PURE__ */ (0, import_jsx_runtime320.jsx)(import_components173.Spinner, {})
        ]
      }
    );
    return /* @__PURE__ */ (0, import_jsx_runtime320.jsxs)(import_jsx_runtime320.Fragment, { children: [
      contentResizeListener,
      area
    ] });
  }

  // packages/block-editor/build-module/components/image-editor/zoom-dropdown.js
  var import_jsx_runtime321 = __toESM(require_jsx_runtime());
  var import_components174 = __toESM(require_components());
  var import_i18n169 = __toESM(require_i18n());
  function ZoomDropdown() {
    const { isInProgress, zoom, setZoom } = useImageEditingContext();
    return /* @__PURE__ */ (0, import_jsx_runtime321.jsx)(
      import_components174.Dropdown,
      {
        contentClassName: "wp-block-image__zoom",
        popoverProps: POPOVER_PROPS7,
        renderToggle: ({ isOpen, onToggle }) => /* @__PURE__ */ (0, import_jsx_runtime321.jsx)(
          import_components174.ToolbarButton,
          {
            icon: search_default,
            label: (0, import_i18n169.__)("Zoom"),
            onClick: onToggle,
            "aria-expanded": isOpen,
            disabled: isInProgress
          }
        ),
        renderContent: () => /* @__PURE__ */ (0, import_jsx_runtime321.jsx)(import_components174.__experimentalDropdownContentWrapper, { paddingSize: "medium", children: /* @__PURE__ */ (0, import_jsx_runtime321.jsx)(
          import_components174.RangeControl,
          {
            __next40pxDefaultSize: true,
            __nextHasNoMarginBottom: true,
            label: (0, import_i18n169.__)("Zoom"),
            min: MIN_ZOOM,
            max: MAX_ZOOM,
            value: Math.round(zoom),
            onChange: setZoom
          }
        ) })
      }
    );
  }

  // packages/block-editor/build-module/components/image-editor/rotation-button.js
  var import_jsx_runtime322 = __toESM(require_jsx_runtime());
  var import_components175 = __toESM(require_components());
  var import_i18n170 = __toESM(require_i18n());
  function RotationButton() {
    const { isInProgress, rotateClockwise } = useImageEditingContext();
    return /* @__PURE__ */ (0, import_jsx_runtime322.jsx)(
      import_components175.ToolbarButton,
      {
        icon: rotate_right_default,
        label: (0, import_i18n170.__)("Rotate"),
        onClick: rotateClockwise,
        disabled: isInProgress
      }
    );
  }

  // packages/block-editor/build-module/components/image-editor/form-controls.js
  var import_jsx_runtime323 = __toESM(require_jsx_runtime());
  var import_components176 = __toESM(require_components());
  var import_i18n171 = __toESM(require_i18n());
  function FormControls() {
    const { isInProgress, apply, cancel } = useImageEditingContext();
    return /* @__PURE__ */ (0, import_jsx_runtime323.jsxs)(import_jsx_runtime323.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime323.jsx)(import_components176.ToolbarButton, { onClick: apply, disabled: isInProgress, children: (0, import_i18n171.__)("Apply") }),
      /* @__PURE__ */ (0, import_jsx_runtime323.jsx)(import_components176.ToolbarButton, { onClick: cancel, children: (0, import_i18n171.__)("Cancel") })
    ] });
  }

  // packages/block-editor/build-module/components/image-editor/index.js
  function ImageEditor({
    id,
    url,
    width,
    height,
    naturalHeight,
    naturalWidth,
    onSaveImage,
    onFinishEditing,
    borderProps
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime324.jsxs)(
      ImageEditingProvider,
      {
        id,
        url,
        naturalWidth,
        naturalHeight,
        onSaveImage,
        onFinishEditing,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime324.jsx)(
            ImageCropper,
            {
              borderProps,
              url,
              width,
              height,
              naturalHeight,
              naturalWidth
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime324.jsxs)(block_controls_default, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime324.jsxs)(import_components177.ToolbarGroup, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime324.jsx)(ZoomDropdown, {}),
              /* @__PURE__ */ (0, import_jsx_runtime324.jsx)(import_components177.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0, import_jsx_runtime324.jsx)(AspectRatioDropdown, { toggleProps }) }),
              /* @__PURE__ */ (0, import_jsx_runtime324.jsx)(RotationButton, {})
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime324.jsx)(import_components177.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime324.jsx)(FormControls, {}) })
          ] })
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/image-size-control/index.js
  var import_jsx_runtime325 = __toESM(require_jsx_runtime());
  var import_components178 = __toESM(require_components());
  var import_i18n172 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/image-size-control/use-dimension-handler.js
  var import_element183 = __toESM(require_element());
  function useDimensionHandler(customHeight, customWidth, defaultHeight, defaultWidth, onChange) {
    const [currentWidth, setCurrentWidth] = (0, import_element183.useState)(
      customWidth ?? defaultWidth ?? ""
    );
    const [currentHeight, setCurrentHeight] = (0, import_element183.useState)(
      customHeight ?? defaultHeight ?? ""
    );
    (0, import_element183.useEffect)(() => {
      if (customWidth === void 0 && defaultWidth !== void 0) {
        setCurrentWidth(defaultWidth);
      }
      if (customHeight === void 0 && defaultHeight !== void 0) {
        setCurrentHeight(defaultHeight);
      }
    }, [defaultWidth, defaultHeight]);
    (0, import_element183.useEffect)(() => {
      if (customWidth !== void 0 && Number.parseInt(customWidth) !== Number.parseInt(currentWidth)) {
        setCurrentWidth(customWidth);
      }
      if (customHeight !== void 0 && Number.parseInt(customHeight) !== Number.parseInt(currentHeight)) {
        setCurrentHeight(customHeight);
      }
    }, [customWidth, customHeight]);
    const updateDimension = (dimension, value) => {
      const parsedValue = value === "" ? void 0 : parseInt(value, 10);
      if (dimension === "width") {
        setCurrentWidth(parsedValue);
      } else {
        setCurrentHeight(parsedValue);
      }
      onChange({
        [dimension]: parsedValue
      });
    };
    const updateDimensions = (nextHeight, nextWidth) => {
      setCurrentHeight(nextHeight ?? defaultHeight);
      setCurrentWidth(nextWidth ?? defaultWidth);
      onChange({ height: nextHeight, width: nextWidth });
    };
    return {
      currentHeight,
      currentWidth,
      updateDimension,
      updateDimensions
    };
  }

  // packages/block-editor/build-module/components/image-size-control/index.js
  var IMAGE_SIZE_PRESETS = [25, 50, 75, 100];
  var noop17 = () => {
  };
  function getScaledWidthAndHeight(scale, imageWidth, imageHeight) {
    const scaledWidth = Math.round(imageWidth * (scale / 100));
    const scaledHeight = Math.round(imageHeight * (scale / 100));
    return {
      scaledWidth,
      scaledHeight
    };
  }
  function ImageSizeControl({
    imageSizeHelp,
    imageWidth,
    imageHeight,
    imageSizeOptions = [],
    isResizable = true,
    slug,
    width,
    height,
    onChange,
    onChangeImage = noop17
  }) {
    const { currentHeight, currentWidth, updateDimension, updateDimensions } = useDimensionHandler(height, width, imageHeight, imageWidth, onChange);
    const handleUpdateDimensions = (scale) => {
      if (void 0 === scale) {
        updateDimensions();
        return;
      }
      const { scaledWidth, scaledHeight } = getScaledWidthAndHeight(
        scale,
        imageWidth,
        imageHeight
      );
      updateDimensions(scaledHeight, scaledWidth);
    };
    const selectedValue = IMAGE_SIZE_PRESETS.find((scale) => {
      const { scaledWidth, scaledHeight } = getScaledWidthAndHeight(
        scale,
        imageWidth,
        imageHeight
      );
      return currentWidth === scaledWidth && currentHeight === scaledHeight;
    });
    return /* @__PURE__ */ (0, import_jsx_runtime325.jsxs)(import_components178.__experimentalVStack, { className: "block-editor-image-size-control", spacing: "4", children: [
      imageSizeOptions && imageSizeOptions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime325.jsx)(
        import_components178.SelectControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n172.__)("Resolution"),
          value: slug,
          options: imageSizeOptions,
          onChange: onChangeImage,
          help: imageSizeHelp,
          size: "__unstable-large"
        }
      ),
      isResizable && /* @__PURE__ */ (0, import_jsx_runtime325.jsxs)(import_jsx_runtime325.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime325.jsxs)(import_components178.__experimentalHStack, { align: "baseline", spacing: "4", children: [
          /* @__PURE__ */ (0, import_jsx_runtime325.jsx)(
            import_components178.__experimentalNumberControl,
            {
              label: (0, import_i18n172.__)("Width"),
              value: currentWidth,
              min: 1,
              onChange: (value) => updateDimension("width", value),
              size: "__unstable-large"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime325.jsx)(
            import_components178.__experimentalNumberControl,
            {
              label: (0, import_i18n172.__)("Height"),
              value: currentHeight,
              min: 1,
              onChange: (value) => updateDimension("height", value),
              size: "__unstable-large"
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime325.jsx)(
          import_components178.__experimentalToggleGroupControl,
          {
            label: (0, import_i18n172.__)("Image size presets"),
            hideLabelFromVision: true,
            onChange: handleUpdateDimensions,
            value: selectedValue,
            isBlock: true,
            __next40pxDefaultSize: true,
            __nextHasNoMarginBottom: true,
            children: IMAGE_SIZE_PRESETS.map((scale) => {
              return /* @__PURE__ */ (0, import_jsx_runtime325.jsx)(
                import_components178.__experimentalToggleGroupControlOption,
                {
                  value: scale,
                  label: (0, import_i18n172.sprintf)(
                    /* translators: %d: Percentage value. */
                    (0, import_i18n172.__)("%d%%"),
                    scale
                  )
                },
                scale
              );
            })
          }
        )
      ] })
    ] });
  }

  // packages/block-editor/build-module/components/justify-content-control/index.js
  var import_jsx_runtime327 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/justify-content-control/ui.js
  var import_jsx_runtime326 = __toESM(require_jsx_runtime());
  var import_components179 = __toESM(require_components());
  var import_i18n173 = __toESM(require_i18n());
  var icons = {
    left: justify_left_default,
    center: justify_center_default,
    right: justify_right_default,
    "space-between": justify_space_between_default,
    stretch: justify_stretch_default
  };
  function JustifyContentUI({
    allowedControls = ["left", "center", "right", "space-between"],
    isCollapsed: isCollapsed3 = true,
    onChange,
    value,
    popoverProps: popoverProps3,
    isToolbar
  }) {
    const handleClick = (next2) => {
      if (next2 === value) {
        onChange(void 0);
      } else {
        onChange(next2);
      }
    };
    const icon = value ? icons[value] : icons.left;
    const allControls = [
      {
        name: "left",
        icon: justify_left_default,
        title: (0, import_i18n173.__)("Justify items left"),
        isActive: "left" === value,
        onClick: () => handleClick("left")
      },
      {
        name: "center",
        icon: justify_center_default,
        title: (0, import_i18n173.__)("Justify items center"),
        isActive: "center" === value,
        onClick: () => handleClick("center")
      },
      {
        name: "right",
        icon: justify_right_default,
        title: (0, import_i18n173.__)("Justify items right"),
        isActive: "right" === value,
        onClick: () => handleClick("right")
      },
      {
        name: "space-between",
        icon: justify_space_between_default,
        title: (0, import_i18n173.__)("Space between items"),
        isActive: "space-between" === value,
        onClick: () => handleClick("space-between")
      },
      {
        name: "stretch",
        icon: justify_stretch_default,
        title: (0, import_i18n173.__)("Stretch items"),
        isActive: "stretch" === value,
        onClick: () => handleClick("stretch")
      }
    ];
    const UIComponent = isToolbar ? import_components179.ToolbarGroup : import_components179.ToolbarDropdownMenu;
    const extraProps = isToolbar ? { isCollapsed: isCollapsed3 } : {};
    return /* @__PURE__ */ (0, import_jsx_runtime326.jsx)(
      UIComponent,
      {
        icon,
        popoverProps: popoverProps3,
        label: (0, import_i18n173.__)("Change items justification"),
        controls: allControls.filter(
          (elem) => allowedControls.includes(elem.name)
        ),
        ...extraProps
      }
    );
  }
  var ui_default4 = JustifyContentUI;

  // packages/block-editor/build-module/components/justify-content-control/index.js
  var JustifyContentControl = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime327.jsx)(ui_default4, { ...props, isToolbar: false });
  };
  var JustifyToolbar = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime327.jsx)(ui_default4, { ...props, isToolbar: true });
  };

  // packages/block-editor/build-module/components/media-placeholder/index.js
  var import_jsx_runtime333 = __toESM(require_jsx_runtime());
  var import_components185 = __toESM(require_components());
  var import_i18n178 = __toESM(require_i18n());
  var import_element186 = __toESM(require_element());
  var import_data148 = __toESM(require_data());
  var import_deprecated25 = __toESM(require_deprecated());

  // packages/block-editor/build-module/components/url-popover/index.js
  var import_jsx_runtime332 = __toESM(require_jsx_runtime());
  var import_i18n177 = __toESM(require_i18n());
  var import_element185 = __toESM(require_element());
  var import_components184 = __toESM(require_components());
  var import_deprecated24 = __toESM(require_deprecated());

  // packages/block-editor/build-module/components/url-popover/link-viewer.js
  var import_jsx_runtime329 = __toESM(require_jsx_runtime());
  var import_i18n174 = __toESM(require_i18n());
  var import_components181 = __toESM(require_components());

  // packages/block-editor/build-module/components/url-popover/link-viewer-url.js
  var import_jsx_runtime328 = __toESM(require_jsx_runtime());
  var import_components180 = __toESM(require_components());
  var import_url9 = __toESM(require_url());
  function LinkViewerURL({ url, urlLabel, className }) {
    const linkClassName = clsx_default(
      className,
      "block-editor-url-popover__link-viewer-url"
    );
    if (!url) {
      return /* @__PURE__ */ (0, import_jsx_runtime328.jsx)("span", { className: linkClassName });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime328.jsx)(import_components180.ExternalLink, { className: linkClassName, href: url, children: urlLabel || (0, import_url9.filterURLForDisplay)((0, import_url9.safeDecodeURI)(url)) });
  }

  // packages/block-editor/build-module/components/url-popover/link-viewer.js
  function LinkViewer({
    className,
    linkClassName,
    onEditLinkClick,
    url,
    urlLabel,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime329.jsxs)(
      "div",
      {
        className: clsx_default(
          "block-editor-url-popover__link-viewer",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime329.jsx)(
            LinkViewerURL,
            {
              url,
              urlLabel,
              className: linkClassName
            }
          ),
          onEditLinkClick && /* @__PURE__ */ (0, import_jsx_runtime329.jsx)(
            import_components181.Button,
            {
              icon: pencil_default,
              label: (0, import_i18n174.__)("Edit"),
              onClick: onEditLinkClick,
              size: "compact"
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/url-popover/link-editor.js
  var import_jsx_runtime331 = __toESM(require_jsx_runtime());
  var import_i18n176 = __toESM(require_i18n());
  var import_components183 = __toESM(require_components());

  // packages/block-editor/build-module/components/url-input/index.js
  var import_jsx_runtime330 = __toESM(require_jsx_runtime());
  var import_react4 = __toESM(require_react());
  var import_i18n175 = __toESM(require_i18n());
  var import_element184 = __toESM(require_element());
  var import_keycodes18 = __toESM(require_keycodes());
  var import_components182 = __toESM(require_components());
  var import_compose83 = __toESM(require_compose());
  var import_data147 = __toESM(require_data());
  var import_url10 = __toESM(require_url());
  function isFunction(maybeFunc) {
    return typeof maybeFunc === "function";
  }
  var URLInput = class extends import_element184.Component {
    constructor(props) {
      super(props);
      this.onChange = this.onChange.bind(this);
      this.onFocus = this.onFocus.bind(this);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.selectLink = this.selectLink.bind(this);
      this.handleOnClick = this.handleOnClick.bind(this);
      this.bindSuggestionNode = this.bindSuggestionNode.bind(this);
      this.autocompleteRef = props.autocompleteRef || (0, import_element184.createRef)();
      this.inputRef = props.inputRef || (0, import_element184.createRef)();
      this.updateSuggestions = (0, import_compose83.debounce)(
        this.updateSuggestions.bind(this),
        200
      );
      this.suggestionNodes = [];
      this.suggestionsRequest = null;
      this.state = {
        suggestions: [],
        showSuggestions: false,
        suggestionsValue: null,
        selectedSuggestion: null,
        suggestionsListboxId: "",
        suggestionOptionIdPrefix: ""
      };
    }
    componentDidUpdate(prevProps) {
      const { showSuggestions, selectedSuggestion } = this.state;
      const { value, __experimentalShowInitialSuggestions = false } = this.props;
      if (showSuggestions && selectedSuggestion !== null && this.suggestionNodes[selectedSuggestion]) {
        this.suggestionNodes[selectedSuggestion].scrollIntoView({
          behavior: "instant",
          block: "nearest",
          inline: "nearest"
        });
      }
      if (prevProps.value !== value && !this.props.disableSuggestions) {
        if (value?.length) {
          this.updateSuggestions(value);
        } else if (__experimentalShowInitialSuggestions) {
          this.updateSuggestions();
        }
      }
    }
    componentDidMount() {
      if (this.shouldShowInitialSuggestions()) {
        this.updateSuggestions();
      }
    }
    componentWillUnmount() {
      this.suggestionsRequest?.cancel?.();
      this.suggestionsRequest = null;
    }
    bindSuggestionNode(index) {
      return (ref) => {
        this.suggestionNodes[index] = ref;
      };
    }
    shouldShowInitialSuggestions() {
      const { __experimentalShowInitialSuggestions = false, value } = this.props;
      return __experimentalShowInitialSuggestions && !(value && value.length);
    }
    updateSuggestions(value = "") {
      const {
        __experimentalFetchLinkSuggestions: fetchLinkSuggestions,
        __experimentalHandleURLSuggestions: handleURLSuggestions
      } = this.props;
      if (!fetchLinkSuggestions) {
        return;
      }
      const isInitialSuggestions = !value?.length;
      value = value.trim();
      if (!isInitialSuggestions && (value.length < 2 || !handleURLSuggestions && (0, import_url10.isURL)(value))) {
        this.suggestionsRequest?.cancel?.();
        this.suggestionsRequest = null;
        this.setState({
          suggestions: [],
          showSuggestions: false,
          suggestionsValue: value,
          selectedSuggestion: null,
          loading: false
        });
        return;
      }
      this.setState({
        selectedSuggestion: null,
        loading: true
      });
      const request = fetchLinkSuggestions(value, {
        isInitialSuggestions
      });
      request.then((suggestions) => {
        if (this.suggestionsRequest !== request) {
          return;
        }
        this.setState({
          suggestions,
          suggestionsValue: value,
          loading: false,
          showSuggestions: !!suggestions.length
        });
        if (!!suggestions.length) {
          this.props.debouncedSpeak(
            (0, import_i18n175.sprintf)(
              /* translators: %d: number of results. */
              (0, import_i18n175._n)(
                "%d result found, use up and down arrow keys to navigate.",
                "%d results found, use up and down arrow keys to navigate.",
                suggestions.length
              ),
              suggestions.length
            ),
            "assertive"
          );
        } else {
          this.props.debouncedSpeak(
            (0, import_i18n175.__)("No results."),
            "assertive"
          );
        }
      }).catch(() => {
        if (this.suggestionsRequest !== request) {
          return;
        }
        this.setState({
          loading: false
        });
      }).finally(() => {
        if (this.suggestionsRequest === request) {
          this.suggestionsRequest = null;
        }
      });
      this.suggestionsRequest = request;
    }
    onChange(newValue) {
      this.props.onChange(newValue);
    }
    onFocus() {
      const { suggestions } = this.state;
      const { disableSuggestions, value } = this.props;
      if (value && !disableSuggestions && !(suggestions && suggestions.length) && this.suggestionsRequest === null) {
        this.updateSuggestions(value);
      }
    }
    onKeyDown(event) {
      this.props.onKeyDown?.(event);
      const { showSuggestions, selectedSuggestion, suggestions, loading } = this.state;
      if (!showSuggestions || !suggestions.length || loading) {
        switch (event.keyCode) {
          // When UP is pressed, if the caret is at the start of the text, move it to the 0
          // position.
          case import_keycodes18.UP: {
            if (0 !== event.target.selectionStart) {
              event.preventDefault();
              event.target.setSelectionRange(0, 0);
            }
            break;
          }
          // When DOWN is pressed, if the caret is not at the end of the text, move it to the
          // last position.
          case import_keycodes18.DOWN: {
            if (this.props.value.length !== event.target.selectionStart) {
              event.preventDefault();
              event.target.setSelectionRange(
                this.props.value.length,
                this.props.value.length
              );
            }
            break;
          }
          // Submitting while loading should trigger onSubmit.
          case import_keycodes18.ENTER: {
            if (this.props.onSubmit) {
              event.preventDefault();
              this.props.onSubmit(null, event);
            }
            break;
          }
        }
        return;
      }
      const suggestion = this.state.suggestions[this.state.selectedSuggestion];
      switch (event.keyCode) {
        case import_keycodes18.UP: {
          event.preventDefault();
          const previousIndex = !selectedSuggestion ? suggestions.length - 1 : selectedSuggestion - 1;
          this.setState({
            selectedSuggestion: previousIndex
          });
          break;
        }
        case import_keycodes18.DOWN: {
          event.preventDefault();
          const nextIndex = selectedSuggestion === null || selectedSuggestion === suggestions.length - 1 ? 0 : selectedSuggestion + 1;
          this.setState({
            selectedSuggestion: nextIndex
          });
          break;
        }
        case import_keycodes18.TAB: {
          if (this.state.selectedSuggestion !== null) {
            this.selectLink(suggestion);
            this.props.speak((0, import_i18n175.__)("Link selected."));
          }
          break;
        }
        case import_keycodes18.ENTER: {
          event.preventDefault();
          if (this.state.selectedSuggestion !== null) {
            this.selectLink(suggestion);
            if (this.props.onSubmit) {
              this.props.onSubmit(suggestion, event);
            }
          } else if (this.props.onSubmit) {
            this.props.onSubmit(null, event);
          }
          break;
        }
      }
    }
    selectLink(suggestion) {
      this.props.onChange(suggestion.url, suggestion);
      this.setState({
        selectedSuggestion: null,
        showSuggestions: false
      });
    }
    handleOnClick(suggestion) {
      this.selectLink(suggestion);
      this.inputRef.current.focus();
    }
    static getDerivedStateFromProps({
      value,
      instanceId,
      disableSuggestions,
      __experimentalShowInitialSuggestions = false
    }, { showSuggestions }) {
      let shouldShowSuggestions = showSuggestions;
      const hasValue = value && value.length;
      if (!__experimentalShowInitialSuggestions && !hasValue) {
        shouldShowSuggestions = false;
      }
      if (disableSuggestions === true) {
        shouldShowSuggestions = false;
      }
      return {
        showSuggestions: shouldShowSuggestions,
        suggestionsListboxId: `block-editor-url-input-suggestions-${instanceId}`,
        suggestionOptionIdPrefix: `block-editor-url-input-suggestion-${instanceId}`
      };
    }
    render() {
      return /* @__PURE__ */ (0, import_jsx_runtime330.jsxs)(import_jsx_runtime330.Fragment, { children: [
        this.renderControl(),
        this.renderSuggestions()
      ] });
    }
    renderControl() {
      const {
        label = null,
        className,
        isFullWidth,
        instanceId,
        placeholder = (0, import_i18n175.__)("Paste URL or type to search"),
        __experimentalRenderControl: renderControl,
        value = "",
        hideLabelFromVision = false,
        help = null,
        disabled = false
      } = this.props;
      const {
        loading,
        showSuggestions,
        selectedSuggestion,
        suggestionsListboxId,
        suggestionOptionIdPrefix
      } = this.state;
      const inputId = `url-input-control-${instanceId}`;
      const controlProps = {
        id: inputId,
        // Passes attribute to label for the for attribute
        label,
        className: clsx_default("block-editor-url-input", className, {
          "is-full-width": isFullWidth
        }),
        hideLabelFromVision
      };
      const inputProps = {
        id: inputId,
        value,
        required: true,
        type: "text",
        onChange: disabled ? () => {
        } : this.onChange,
        // Disable onChange when disabled
        onFocus: disabled ? () => {
        } : this.onFocus,
        // Disable onFocus when disabled
        placeholder,
        onKeyDown: disabled ? () => {
        } : this.onKeyDown,
        // Disable onKeyDown when disabled
        role: "combobox",
        "aria-label": label ? void 0 : (0, import_i18n175.__)("URL"),
        // Ensure input always has an accessible label
        "aria-expanded": showSuggestions,
        "aria-autocomplete": "list",
        "aria-owns": suggestionsListboxId,
        "aria-activedescendant": selectedSuggestion !== null ? `${suggestionOptionIdPrefix}-${selectedSuggestion}` : void 0,
        ref: this.inputRef,
        disabled,
        suffix: this.props.suffix,
        help
      };
      if (renderControl) {
        return renderControl(controlProps, inputProps, loading);
      }
      return /* @__PURE__ */ (0, import_jsx_runtime330.jsxs)(import_components182.BaseControl, { __nextHasNoMarginBottom: true, ...controlProps, children: [
        /* @__PURE__ */ (0, import_jsx_runtime330.jsx)(import_components182.__experimentalInputControl, { ...inputProps, __next40pxDefaultSize: true }),
        loading && /* @__PURE__ */ (0, import_jsx_runtime330.jsx)(import_components182.Spinner, {})
      ] });
    }
    renderSuggestions() {
      const {
        className,
        __experimentalRenderSuggestions: renderSuggestions
      } = this.props;
      const {
        showSuggestions,
        suggestions,
        suggestionsValue,
        selectedSuggestion,
        suggestionsListboxId,
        suggestionOptionIdPrefix,
        loading
      } = this.state;
      if (!showSuggestions || suggestions.length === 0) {
        return null;
      }
      const suggestionsListProps = {
        id: suggestionsListboxId,
        ref: this.autocompleteRef,
        role: "listbox"
      };
      const buildSuggestionItemProps = (suggestion, index) => {
        return {
          role: "option",
          tabIndex: "-1",
          id: `${suggestionOptionIdPrefix}-${index}`,
          ref: this.bindSuggestionNode(index),
          "aria-selected": index === selectedSuggestion ? true : void 0
        };
      };
      if (isFunction(renderSuggestions)) {
        return renderSuggestions({
          suggestions,
          selectedSuggestion,
          suggestionsListProps,
          buildSuggestionItemProps,
          isLoading: loading,
          handleSuggestionClick: this.handleOnClick,
          isInitialSuggestions: !suggestionsValue?.length,
          currentInputValue: suggestionsValue
        });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime330.jsx)(import_components182.Popover, { placement: "bottom", focusOnMount: false, children: /* @__PURE__ */ (0, import_jsx_runtime330.jsx)(
        "div",
        {
          ...suggestionsListProps,
          className: clsx_default("block-editor-url-input__suggestions", {
            [`${className}__suggestions`]: className
          }),
          children: suggestions.map((suggestion, index) => /* @__PURE__ */ (0, import_react4.createElement)(
            import_components182.Button,
            {
              __next40pxDefaultSize: true,
              ...buildSuggestionItemProps(suggestion, index),
              key: suggestion.id,
              className: clsx_default(
                "block-editor-url-input__suggestion",
                {
                  "is-selected": index === selectedSuggestion
                }
              ),
              onClick: () => this.handleOnClick(suggestion)
            },
            suggestion.title
          ))
        }
      ) });
    }
  };
  var url_input_default = (0, import_compose83.compose)(
    import_compose83.withSafeTimeout,
    import_components182.withSpokenMessages,
    import_compose83.withInstanceId,
    (0, import_data147.withSelect)((select2, props) => {
      if (isFunction(props.__experimentalFetchLinkSuggestions)) {
        return;
      }
      const { getSettings: getSettings4 } = select2(store);
      return {
        __experimentalFetchLinkSuggestions: getSettings4().__experimentalFetchLinkSuggestions
      };
    })
  )(URLInput);

  // packages/block-editor/build-module/components/url-popover/link-editor.js
  function LinkEditor({
    autocompleteRef,
    className,
    onChangeInputValue,
    value,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime331.jsxs)(
      "form",
      {
        className: clsx_default(
          "block-editor-url-popover__link-editor",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime331.jsx)(
            url_input_default,
            {
              value,
              onChange: onChangeInputValue,
              autocompleteRef
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime331.jsx)(
            import_components183.Button,
            {
              icon: keyboard_return_default,
              label: (0, import_i18n176.__)("Apply"),
              type: "submit",
              size: "compact"
            }
          )
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/url-popover/index.js
  var { __experimentalPopoverLegacyPositionToPlacement } = unlock(
    import_components184.privateApis
  );
  var DEFAULT_PLACEMENT = "bottom";
  var URLPopover = (0, import_element185.forwardRef)(
    ({
      additionalControls,
      children,
      renderSettings,
      // The DEFAULT_PLACEMENT value is assigned inside the function's body
      placement,
      focusOnMount = "firstElement",
      // Deprecated
      position: position2,
      // Rest
      ...popoverProps3
    }, ref) => {
      if (position2 !== void 0) {
        (0, import_deprecated24.default)("`position` prop in wp.blockEditor.URLPopover", {
          since: "6.2",
          alternative: "`placement` prop"
        });
      }
      let computedPlacement;
      if (placement !== void 0) {
        computedPlacement = placement;
      } else if (position2 !== void 0) {
        computedPlacement = __experimentalPopoverLegacyPositionToPlacement(position2);
      }
      computedPlacement = computedPlacement || DEFAULT_PLACEMENT;
      const [isSettingsExpanded, setIsSettingsExpanded] = (0, import_element185.useState)(false);
      const showSettings = !!renderSettings && isSettingsExpanded;
      const toggleSettingsVisibility = () => {
        setIsSettingsExpanded(!isSettingsExpanded);
      };
      return /* @__PURE__ */ (0, import_jsx_runtime332.jsxs)(
        import_components184.Popover,
        {
          ref,
          role: "dialog",
          "aria-modal": "true",
          "aria-label": (0, import_i18n177.__)("Edit URL"),
          className: "block-editor-url-popover",
          focusOnMount,
          placement: computedPlacement,
          shift: true,
          variant: "toolbar",
          ...popoverProps3,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime332.jsx)("div", { className: "block-editor-url-popover__input-container", children: /* @__PURE__ */ (0, import_jsx_runtime332.jsxs)("div", { className: "block-editor-url-popover__row", children: [
              children,
              !!renderSettings && /* @__PURE__ */ (0, import_jsx_runtime332.jsx)(
                import_components184.Button,
                {
                  className: "block-editor-url-popover__settings-toggle",
                  icon: chevron_down_default,
                  label: (0, import_i18n177.__)("Link settings"),
                  onClick: toggleSettingsVisibility,
                  "aria-expanded": isSettingsExpanded,
                  size: "compact"
                }
              )
            ] }) }),
            showSettings && /* @__PURE__ */ (0, import_jsx_runtime332.jsx)("div", { className: "block-editor-url-popover__settings", children: renderSettings() }),
            additionalControls && !showSettings && /* @__PURE__ */ (0, import_jsx_runtime332.jsx)("div", { className: "block-editor-url-popover__additional-controls", children: additionalControls })
          ]
        }
      );
    }
  );
  URLPopover.LinkEditor = LinkEditor;
  URLPopover.LinkViewer = LinkViewer;
  var url_popover_default = URLPopover;

  // packages/block-editor/build-module/components/media-placeholder/index.js
  var noop18 = () => {
  };
  var InsertFromURLPopover = ({
    src,
    onChange,
    onSubmit,
    onClose,
    popoverAnchor
  }) => /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(url_popover_default, { anchor: popoverAnchor, onClose, children: /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
    "form",
    {
      className: "block-editor-media-placeholder__url-input-form",
      onSubmit,
      children: /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        import_components185.__experimentalInputControl,
        {
          __next40pxDefaultSize: true,
          label: (0, import_i18n178.__)("URL"),
          type: "text",
          hideLabelFromVision: true,
          placeholder: (0, import_i18n178.__)("Paste or type URL"),
          onChange,
          value: src,
          suffix: /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(import_components185.__experimentalInputControlSuffixWrapper, { variant: "control", children: /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
            import_components185.Button,
            {
              size: "small",
              icon: keyboard_return_default,
              label: (0, import_i18n178.__)("Apply"),
              type: "submit"
            }
          ) })
        }
      )
    }
  ) });
  var URLSelectionUI = ({ src, onChangeSrc, onSelectURL }) => {
    const [popoverAnchor, setPopoverAnchor] = (0, import_element186.useState)(null);
    const [isURLInputVisible, setIsURLInputVisible] = (0, import_element186.useState)(false);
    const openURLInput = () => {
      setIsURLInputVisible(true);
    };
    const closeURLInput = () => {
      setIsURLInputVisible(false);
      popoverAnchor?.focus();
    };
    const onSubmitSrc = (event) => {
      event.preventDefault();
      if (src && onSelectURL) {
        onSelectURL(src);
        closeURLInput();
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime333.jsxs)("div", { className: "block-editor-media-placeholder__url-input-container", children: [
      /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        import_components185.Button,
        {
          __next40pxDefaultSize: true,
          className: "block-editor-media-placeholder__button",
          onClick: openURLInput,
          isPressed: isURLInputVisible,
          variant: "secondary",
          "aria-haspopup": "dialog",
          ref: setPopoverAnchor,
          children: (0, import_i18n178.__)("Insert from URL")
        }
      ),
      isURLInputVisible && /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        InsertFromURLPopover,
        {
          src,
          onChange: onChangeSrc,
          onSubmit: onSubmitSrc,
          onClose: closeURLInput,
          popoverAnchor
        }
      )
    ] });
  };
  function MediaPlaceholder({
    value = {},
    allowedTypes,
    className,
    icon,
    labels = {},
    mediaPreview,
    notices,
    isAppender,
    accept,
    addToGallery,
    multiple = false,
    handleUpload = true,
    disableDropZone,
    disableMediaButtons,
    onError,
    onSelect,
    onCancel,
    onSelectURL,
    onToggleFeaturedImage,
    onDoubleClick,
    onFilesPreUpload = noop18,
    onHTMLDrop: deprecatedOnHTMLDrop,
    children,
    mediaLibraryButton,
    placeholder,
    style
  }) {
    if (deprecatedOnHTMLDrop) {
      (0, import_deprecated25.default)("wp.blockEditor.MediaPlaceholder onHTMLDrop prop", {
        since: "6.2",
        version: "6.4"
      });
    }
    const mediaUpload2 = (0, import_data148.useSelect)((select2) => {
      const { getSettings: getSettings4 } = select2(store);
      return getSettings4().mediaUpload;
    }, []);
    const [src, setSrc] = (0, import_element186.useState)("");
    (0, import_element186.useEffect)(() => {
      setSrc(value?.src ?? "");
    }, [value?.src]);
    const onlyAllowsImages = () => {
      if (!allowedTypes || allowedTypes.length === 0) {
        return false;
      }
      return allowedTypes.every(
        (allowedType) => allowedType === "image" || allowedType.startsWith("image/")
      );
    };
    const onFilesUpload = (files) => {
      if (!handleUpload || typeof handleUpload === "function" && !handleUpload(files)) {
        return onSelect(files);
      }
      onFilesPreUpload(files);
      let setMedia;
      if (multiple) {
        if (addToGallery) {
          let lastMediaPassed = [];
          setMedia = (newMedia) => {
            const filteredMedia = (value ?? []).filter((item) => {
              if (item.id) {
                return !lastMediaPassed.some(
                  // Be sure to convert to number for comparison.
                  ({ id }) => Number(id) === Number(item.id)
                );
              }
              return !lastMediaPassed.some(
                ({ urlSlug }) => item.url.includes(urlSlug)
              );
            });
            onSelect(filteredMedia.concat(newMedia));
            lastMediaPassed = newMedia.map((media) => {
              const cutOffIndex = media.url.lastIndexOf(".");
              const urlSlug = media.url.slice(0, cutOffIndex);
              return { id: media.id, urlSlug };
            });
          };
        } else {
          setMedia = onSelect;
        }
      } else {
        setMedia = ([media]) => onSelect(media);
      }
      mediaUpload2({
        allowedTypes,
        filesList: files,
        onFileChange: setMedia,
        onError,
        multiple
      });
    };
    async function handleBlocksDrop(event) {
      const { blocks: blocks2 } = parseDropEvent(event);
      if (!blocks2?.length) {
        return;
      }
      const uploadedMediaList = await Promise.all(
        blocks2.map((block) => {
          const blockType = block.name.split("/")[1];
          if (block.attributes.id) {
            block.attributes.type = blockType;
            return block.attributes;
          }
          return new Promise((resolve, reject) => {
            window.fetch(block.attributes.url).then((response) => response.blob()).then(
              (blob) => mediaUpload2({
                filesList: [blob],
                additionalData: {
                  title: block.attributes.title,
                  alt_text: block.attributes.alt,
                  caption: block.attributes.caption,
                  type: blockType
                },
                onFileChange: ([media]) => {
                  if (media.id) {
                    resolve(media);
                  }
                },
                allowedTypes,
                onError: reject
              })
            ).catch(() => resolve(block.attributes.url));
          });
        })
      ).catch((err) => onError(err));
      if (!uploadedMediaList?.length) {
        return;
      }
      onSelect(multiple ? uploadedMediaList : uploadedMediaList[0]);
    }
    const onUpload = (event) => {
      onFilesUpload(event.target.files);
    };
    const defaultRenderPlaceholder = (content) => {
      let { instructions, title } = labels;
      if (!mediaUpload2 && !onSelectURL) {
        instructions = (0, import_i18n178.__)(
          "To edit this block, you need permission to upload media."
        );
      }
      if (instructions === void 0 || title === void 0) {
        const typesAllowed = allowedTypes ?? [];
        const [firstAllowedType] = typesAllowed;
        const isOneType = 1 === typesAllowed.length;
        const isAudio = isOneType && "audio" === firstAllowedType;
        const isImage = isOneType && "image" === firstAllowedType;
        const isVideo = isOneType && "video" === firstAllowedType;
        if (instructions === void 0 && mediaUpload2) {
          instructions = (0, import_i18n178.__)(
            "Drag and drop an image or video, upload, or choose from your library."
          );
          if (isAudio) {
            instructions = (0, import_i18n178.__)(
              "Drag and drop an audio file, upload, or choose from your library."
            );
          } else if (isImage) {
            instructions = (0, import_i18n178.__)(
              "Drag and drop an image, upload, or choose from your library."
            );
          } else if (isVideo) {
            instructions = (0, import_i18n178.__)(
              "Drag and drop a video, upload, or choose from your library."
            );
          }
        }
        if (title === void 0) {
          title = (0, import_i18n178.__)("Media");
          if (isAudio) {
            title = (0, import_i18n178.__)("Audio");
          } else if (isImage) {
            title = (0, import_i18n178.__)("Image");
          } else if (isVideo) {
            title = (0, import_i18n178.__)("Video");
          }
        }
      }
      const placeholderClassName = clsx_default(
        "block-editor-media-placeholder",
        className,
        {
          "is-appender": isAppender
        }
      );
      return /* @__PURE__ */ (0, import_jsx_runtime333.jsxs)(
        import_components185.Placeholder,
        {
          icon,
          label: title,
          instructions,
          className: placeholderClassName,
          notices,
          onDoubleClick,
          preview: mediaPreview,
          style,
          children: [
            content,
            children
          ]
        }
      );
    };
    const renderPlaceholder = placeholder ?? defaultRenderPlaceholder;
    const renderDropZone = () => {
      if (disableDropZone) {
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        import_components185.DropZone,
        {
          onFilesDrop: onFilesUpload,
          onDrop: handleBlocksDrop,
          isEligible: (dataTransfer) => {
            const prefix3 = "wp-block:core/";
            const types = [];
            for (const type of dataTransfer.types) {
              if (type.startsWith(prefix3)) {
                types.push(type.slice(prefix3.length));
              }
            }
            return types.every(
              (type) => allowedTypes.includes(type)
            ) && (multiple ? true : types.length === 1);
          }
        }
      );
    };
    const renderCancelLink = () => {
      return onCancel && /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        import_components185.Button,
        {
          __next40pxDefaultSize: true,
          className: "block-editor-media-placeholder__cancel-button",
          title: (0, import_i18n178.__)("Cancel"),
          variant: "link",
          onClick: onCancel,
          children: (0, import_i18n178.__)("Cancel")
        }
      );
    };
    const renderUrlSelectionUI = () => {
      return onSelectURL && /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        URLSelectionUI,
        {
          src,
          onChangeSrc: setSrc,
          onSelectURL
        }
      );
    };
    const renderFeaturedImageToggle = () => {
      return onToggleFeaturedImage && /* @__PURE__ */ (0, import_jsx_runtime333.jsx)("div", { className: "block-editor-media-placeholder__url-input-container", children: /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        import_components185.Button,
        {
          __next40pxDefaultSize: true,
          className: "block-editor-media-placeholder__button",
          onClick: onToggleFeaturedImage,
          variant: "secondary",
          children: (0, import_i18n178.__)("Use featured image")
        }
      ) });
    };
    const renderMediaUploadChecked = () => {
      const defaultButton = ({ open }) => {
        return /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
          import_components185.Button,
          {
            __next40pxDefaultSize: true,
            variant: "secondary",
            onClick: () => {
              open();
            },
            children: (0, import_i18n178.__)("Media Library")
          }
        );
      };
      const libraryButton = mediaLibraryButton ?? defaultButton;
      const uploadMediaLibraryButton = /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
        media_upload_default,
        {
          addToGallery,
          gallery: multiple && onlyAllowsImages(),
          multiple,
          onSelect,
          allowedTypes,
          mode: "browse",
          value: Array.isArray(value) ? value.map(({ id }) => id) : value.id,
          render: libraryButton
        }
      );
      if (mediaUpload2 && isAppender) {
        return /* @__PURE__ */ (0, import_jsx_runtime333.jsxs)(import_jsx_runtime333.Fragment, { children: [
          renderDropZone(),
          /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
            import_components185.FormFileUpload,
            {
              onChange: onUpload,
              accept,
              multiple: !!multiple,
              render: ({ openFileDialog }) => {
                const content = /* @__PURE__ */ (0, import_jsx_runtime333.jsxs)(import_jsx_runtime333.Fragment, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
                    import_components185.Button,
                    {
                      __next40pxDefaultSize: true,
                      variant: "primary",
                      className: clsx_default(
                        "block-editor-media-placeholder__button",
                        "block-editor-media-placeholder__upload-button"
                      ),
                      onClick: openFileDialog,
                      children: (0, import_i18n178._x)("Upload", "verb")
                    }
                  ),
                  uploadMediaLibraryButton,
                  renderUrlSelectionUI(),
                  renderFeaturedImageToggle(),
                  renderCancelLink()
                ] });
                return renderPlaceholder(content);
              }
            }
          )
        ] });
      }
      if (mediaUpload2) {
        const content = /* @__PURE__ */ (0, import_jsx_runtime333.jsxs)(import_jsx_runtime333.Fragment, { children: [
          renderDropZone(),
          /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
            import_components185.FormFileUpload,
            {
              render: ({ openFileDialog }) => /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
                import_components185.Button,
                {
                  __next40pxDefaultSize: true,
                  onClick: openFileDialog,
                  variant: "primary",
                  className: clsx_default(
                    "block-editor-media-placeholder__button",
                    "block-editor-media-placeholder__upload-button"
                  ),
                  children: (0, import_i18n178._x)("Upload", "verb")
                }
              ),
              onChange: onUpload,
              accept,
              multiple: !!multiple
            }
          ),
          uploadMediaLibraryButton,
          renderUrlSelectionUI(),
          renderFeaturedImageToggle(),
          renderCancelLink()
        ] });
        return renderPlaceholder(content);
      }
      return renderPlaceholder(uploadMediaLibraryButton);
    };
    if (disableMediaButtons) {
      return /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(check_default2, { children: renderDropZone() });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime333.jsx)(
      check_default2,
      {
        fallback: renderPlaceholder(renderUrlSelectionUI()),
        children: renderMediaUploadChecked()
      }
    );
  }
  var media_placeholder_default = (0, import_components185.withFilters)("editor.MediaPlaceholder")(MediaPlaceholder);

  // packages/block-editor/build-module/components/panel-color-settings/index.js
  var import_jsx_runtime334 = __toESM(require_jsx_runtime());
  var PanelColorSettings = ({ colorSettings, ...props }) => {
    const settings2 = colorSettings.map((setting) => {
      if (!setting) {
        return setting;
      }
      const { value, onChange, ...otherSettings } = setting;
      return {
        ...otherSettings,
        colorValue: value,
        onColorChange: onChange
      };
    });
    return /* @__PURE__ */ (0, import_jsx_runtime334.jsx)(
      panel_color_gradient_settings_default,
      {
        settings: settings2,
        gradients: [],
        disableCustomGradients: true,
        ...props
      }
    );
  };
  var panel_color_settings_default = PanelColorSettings;

  // packages/block-editor/build-module/components/plain-text/index.js
  var import_jsx_runtime345 = __toESM(require_jsx_runtime());
  var import_react_autosize_textarea2 = __toESM(require_lib());
  var import_element199 = __toESM(require_element());

  // packages/block-editor/build-module/components/editable-text/index.js
  var import_jsx_runtime344 = __toESM(require_jsx_runtime());
  var import_element198 = __toESM(require_element());

  // packages/block-editor/build-module/components/rich-text/index.js
  var import_jsx_runtime343 = __toESM(require_jsx_runtime());
  var import_es65 = __toESM(require_es6());
  var import_element197 = __toESM(require_element());
  var import_data152 = __toESM(require_data());
  var import_compose85 = __toESM(require_compose());
  var import_rich_text15 = __toESM(require_rich_text());
  var import_components189 = __toESM(require_components());
  var import_blocks87 = __toESM(require_blocks());
  var import_deprecated29 = __toESM(require_deprecated());
  var import_i18n181 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/rich-text/format-toolbar-container.js
  var import_jsx_runtime336 = __toESM(require_jsx_runtime());
  var import_i18n180 = __toESM(require_i18n());
  var import_components187 = __toESM(require_components());

  // packages/block-editor/build-module/components/rich-text/format-toolbar/index.js
  var import_jsx_runtime335 = __toESM(require_jsx_runtime());
  var import_i18n179 = __toESM(require_i18n());
  var import_components186 = __toESM(require_components());
  var POPOVER_PROPS8 = {
    placement: "bottom-start"
  };
  var FormatToolbar = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime335.jsxs)(import_jsx_runtime335.Fragment, { children: [
      ["bold", "italic", "link", "unknown"].map((format) => /* @__PURE__ */ (0, import_jsx_runtime335.jsx)(
        import_components186.Slot,
        {
          name: `RichText.ToolbarControls.${format}`
        },
        format
      )),
      /* @__PURE__ */ (0, import_jsx_runtime335.jsx)(import_components186.Slot, { name: "RichText.ToolbarControls", children: (fills) => {
        if (!fills.length) {
          return null;
        }
        const allProps = fills.map(([{ props }]) => props);
        const hasActive = allProps.some(
          ({ isActive }) => isActive
        );
        return /* @__PURE__ */ (0, import_jsx_runtime335.jsx)(import_components186.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0, import_jsx_runtime335.jsx)(
          import_components186.DropdownMenu,
          {
            icon: chevron_down_default,
            label: (0, import_i18n179.__)("More"),
            toggleProps: {
              ...toggleProps,
              className: clsx_default(
                toggleProps.className,
                { "is-pressed": hasActive }
              ),
              description: (0, import_i18n179.__)(
                "Displays more block tools"
              )
            },
            controls: orderBy(
              fills.map(([{ props }]) => props),
              "title"
            ),
            popoverProps: POPOVER_PROPS8
          }
        ) });
      } })
    ] });
  };
  var format_toolbar_default = FormatToolbar;

  // packages/block-editor/build-module/components/rich-text/format-toolbar-container.js
  function InlineToolbar({ popoverAnchor }) {
    return /* @__PURE__ */ (0, import_jsx_runtime336.jsx)(
      import_components187.Popover,
      {
        placement: "top",
        focusOnMount: false,
        anchor: popoverAnchor,
        className: "block-editor-rich-text__inline-format-toolbar",
        __unstableSlotName: "block-toolbar",
        children: /* @__PURE__ */ (0, import_jsx_runtime336.jsx)(
          NavigableToolbar,
          {
            className: "block-editor-rich-text__inline-format-toolbar-group",
            "aria-label": (0, import_i18n180.__)("Format tools"),
            children: /* @__PURE__ */ (0, import_jsx_runtime336.jsx)(import_components187.ToolbarGroup, { children: /* @__PURE__ */ (0, import_jsx_runtime336.jsx)(format_toolbar_default, {}) })
          }
        )
      }
    );
  }
  var FormatToolbarContainer = ({ inline, editableContentElement }) => {
    if (inline) {
      return /* @__PURE__ */ (0, import_jsx_runtime336.jsx)(InlineToolbar, { popoverAnchor: editableContentElement });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime336.jsx)(block_controls_default, { group: "inline", children: /* @__PURE__ */ (0, import_jsx_runtime336.jsx)(format_toolbar_default, {}) });
  };
  var format_toolbar_container_default = FormatToolbarContainer;

  // packages/block-editor/build-module/components/rich-text/use-mark-persistent.js
  var import_element187 = __toESM(require_element());
  var import_data149 = __toESM(require_data());
  function useMarkPersistent({ html, value }) {
    const previousTextRef = (0, import_element187.useRef)();
    const hasActiveFormats = !!value.activeFormats?.length;
    const { __unstableMarkLastChangeAsPersistent: __unstableMarkLastChangeAsPersistent2 } = (0, import_data149.useDispatch)(store);
    (0, import_element187.useLayoutEffect)(() => {
      if (!previousTextRef.current) {
        previousTextRef.current = value.text;
        return;
      }
      if (previousTextRef.current !== value.text) {
        const timeout = window.setTimeout(() => {
          __unstableMarkLastChangeAsPersistent2();
        }, 1e3);
        previousTextRef.current = value.text;
        return () => {
          window.clearTimeout(timeout);
        };
      }
      __unstableMarkLastChangeAsPersistent2();
    }, [html, hasActiveFormats]);
  }

  // packages/block-editor/build-module/components/rich-text/use-format-types.js
  var import_element188 = __toESM(require_element());
  var import_data150 = __toESM(require_data());
  var import_rich_text5 = __toESM(require_rich_text());
  function formatTypesSelector(select2) {
    return select2(import_rich_text5.store).getFormatTypes();
  }
  var interactiveContentTags = /* @__PURE__ */ new Set([
    "a",
    "audio",
    "button",
    "details",
    "embed",
    "iframe",
    "input",
    "label",
    "select",
    "textarea",
    "video"
  ]);
  function prefixSelectKeys(selected, prefix3) {
    if (typeof selected !== "object") {
      return { [prefix3]: selected };
    }
    return Object.fromEntries(
      Object.entries(selected).map(([key, value]) => [
        `${prefix3}.${key}`,
        value
      ])
    );
  }
  function getPrefixedSelectKeys(selected, prefix3) {
    if (selected[prefix3]) {
      return selected[prefix3];
    }
    return Object.keys(selected).filter((key) => key.startsWith(prefix3 + ".")).reduce((accumulator, key) => {
      accumulator[key.slice(prefix3.length + 1)] = selected[key];
      return accumulator;
    }, {});
  }
  function useFormatTypes({
    clientId,
    identifier: identifier2,
    allowedFormats,
    withoutInteractiveFormatting,
    disableNoneEssentialFormatting = false
  }) {
    const allFormatTypes = (0, import_data150.useSelect)(formatTypesSelector, []);
    const formatTypes = (0, import_element188.useMemo)(() => {
      return allFormatTypes.filter(
        ({
          name,
          interactive,
          tagName,
          [essentialFormatKey]: isEssential
        }) => {
          if (allowedFormats && !allowedFormats.includes(name)) {
            return false;
          }
          if (disableNoneEssentialFormatting && !isEssential) {
            return false;
          }
          if (withoutInteractiveFormatting && (interactive || interactiveContentTags.has(tagName))) {
            return false;
          }
          return true;
        }
      );
    }, [
      allFormatTypes,
      allowedFormats,
      disableNoneEssentialFormatting,
      withoutInteractiveFormatting
    ]);
    const keyedSelected = (0, import_data150.useSelect)(
      (select2) => formatTypes.reduce((accumulator, type) => {
        if (!type.__experimentalGetPropsForEditableTreePreparation) {
          return accumulator;
        }
        return {
          ...accumulator,
          ...prefixSelectKeys(
            type.__experimentalGetPropsForEditableTreePreparation(
              select2,
              {
                richTextIdentifier: identifier2,
                blockClientId: clientId
              }
            ),
            type.name
          )
        };
      }, {}),
      [formatTypes, clientId, identifier2]
    );
    const dispatch = (0, import_data150.useDispatch)();
    const prepareHandlers = [];
    const valueHandlers = [];
    const changeHandlers = [];
    const dependencies = [];
    for (const key in keyedSelected) {
      dependencies.push(keyedSelected[key]);
    }
    formatTypes.forEach((type) => {
      if (type.__experimentalCreatePrepareEditableTree) {
        const handler = type.__experimentalCreatePrepareEditableTree(
          getPrefixedSelectKeys(keyedSelected, type.name),
          {
            richTextIdentifier: identifier2,
            blockClientId: clientId
          }
        );
        if (type.__experimentalCreateOnChangeEditableValue) {
          valueHandlers.push(handler);
        } else {
          prepareHandlers.push(handler);
        }
      }
      if (type.__experimentalCreateOnChangeEditableValue) {
        let dispatchers = {};
        if (type.__experimentalGetPropsForEditableTreeChangeHandler) {
          dispatchers = type.__experimentalGetPropsForEditableTreeChangeHandler(
            dispatch,
            {
              richTextIdentifier: identifier2,
              blockClientId: clientId
            }
          );
        }
        const selected = getPrefixedSelectKeys(keyedSelected, type.name);
        changeHandlers.push(
          type.__experimentalCreateOnChangeEditableValue(
            {
              ...typeof selected === "object" ? selected : {},
              ...dispatchers
            },
            {
              richTextIdentifier: identifier2,
              blockClientId: clientId
            }
          )
        );
      }
    });
    return {
      formatTypes,
      prepareHandlers,
      valueHandlers,
      changeHandlers,
      dependencies
    };
  }

  // packages/block-editor/build-module/components/rich-text/event-listeners/index.js
  var import_element190 = __toESM(require_element());
  var import_compose84 = __toESM(require_compose());

  // packages/block-editor/build-module/components/rich-text/event-listeners/before-input-rules.js
  var import_rich_text6 = __toESM(require_rich_text());
  var import_hooks12 = __toESM(require_hooks());
  var wrapSelectionSettings = ["`", '"', "'", "\u201C\u201D", "\u2018\u2019"];
  var before_input_rules_default = (props) => (element) => {
    function onInput(event) {
      const { inputType, data } = event;
      const { value, onChange, registry } = props.current;
      if (inputType !== "insertText") {
        return;
      }
      if ((0, import_rich_text6.isCollapsed)(value)) {
        return;
      }
      const pair = (0, import_hooks12.applyFilters)(
        "blockEditor.wrapSelectionSettings",
        wrapSelectionSettings
      ).find(
        ([startChar2, endChar2]) => startChar2 === data || endChar2 === data
      );
      if (!pair) {
        return;
      }
      const [startChar, endChar = startChar] = pair;
      const start2 = value.start;
      const end = value.end + startChar.length;
      let newValue = (0, import_rich_text6.insert)(value, startChar, start2, start2);
      newValue = (0, import_rich_text6.insert)(newValue, endChar, end, end);
      const {
        __unstableMarkLastChangeAsPersistent: __unstableMarkLastChangeAsPersistent2,
        __unstableMarkAutomaticChange: __unstableMarkAutomaticChange2
      } = registry.dispatch(store);
      __unstableMarkLastChangeAsPersistent2();
      onChange(newValue);
      __unstableMarkAutomaticChange2();
      const init = {};
      for (const key in event) {
        init[key] = event[key];
      }
      init.data = endChar;
      const { ownerDocument } = element;
      const { defaultView } = ownerDocument;
      const newEvent = new defaultView.InputEvent("input", init);
      window.queueMicrotask(() => {
        event.target.dispatchEvent(newEvent);
      });
      event.preventDefault();
    }
    element.addEventListener("beforeinput", onInput);
    return () => {
      element.removeEventListener("beforeinput", onInput);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/input-rules.js
  var import_rich_text8 = __toESM(require_rich_text());
  var import_blocks82 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/rich-text/prevent-event-discovery.js
  var import_rich_text7 = __toESM(require_rich_text());
  function preventEventDiscovery(value) {
    const searchText = "tales of gutenberg";
    const addText = " \u{1F421}\u{1F422}\u{1F980}\u{1F424}\u{1F98B}\u{1F418}\u{1F427}\u{1F439}\u{1F981}\u{1F984}\u{1F98D}\u{1F43C}\u{1F43F}\u{1F383}\u{1F434}\u{1F41D}\u{1F406}\u{1F995}\u{1F994}\u{1F331}\u{1F347}\u03C0\u{1F34C}\u{1F409}\u{1F4A7}\u{1F968}\u{1F30C}\u{1F342}\u{1F360}\u{1F966}\u{1F95A}\u{1F95D}\u{1F39F}\u{1F965}\u{1F952}\u{1F6F5}\u{1F956}\u{1F352}\u{1F36F}\u{1F3BE}\u{1F3B2}\u{1F43A}\u{1F41A}\u{1F42E}\u231B\uFE0F";
    const { start: start2, text } = value;
    if (start2 < searchText.length) {
      return value;
    }
    const charactersBefore = text.slice(start2 - searchText.length, start2);
    if (charactersBefore.toLowerCase() !== searchText) {
      return value;
    }
    return (0, import_rich_text7.insert)(value, addText);
  }

  // packages/block-editor/build-module/components/rich-text/event-listeners/input-rules.js
  function findSelection(blocks2) {
    let i2 = blocks2.length;
    while (i2--) {
      const attributeKey = retrieveSelectedAttribute(
        blocks2[i2].attributes
      );
      if (attributeKey) {
        blocks2[i2].attributes[attributeKey] = blocks2[i2].attributes[attributeKey].toString().replace(START_OF_SELECTED_AREA, "");
        return [blocks2[i2].clientId, attributeKey, 0, 0];
      }
      const nestedSelection = findSelection(blocks2[i2].innerBlocks);
      if (nestedSelection) {
        return nestedSelection;
      }
    }
    return [];
  }
  var input_rules_default = (props) => (element) => {
    function inputRule() {
      const { getValue, onReplace, selectionChange: selectionChange2, registry } = props.current;
      if (!onReplace) {
        return;
      }
      const value = getValue();
      const { start: start2, text } = value;
      const characterBefore = text.slice(start2 - 1, start2);
      if (characterBefore !== " ") {
        return;
      }
      const trimmedTextBefore = text.slice(0, start2).trim();
      const prefixTransforms = (0, import_blocks82.getBlockTransforms)("from").filter(
        ({ type }) => type === "prefix"
      );
      const transformation = (0, import_blocks82.findTransform)(
        prefixTransforms,
        ({ prefix: prefix3 }) => {
          return trimmedTextBefore === prefix3;
        }
      );
      if (!transformation) {
        return;
      }
      const content = (0, import_rich_text8.toHTMLString)({
        value: (0, import_rich_text8.insert)(value, START_OF_SELECTED_AREA, 0, start2)
      });
      const block = transformation.transform(content);
      selectionChange2(...findSelection([block]));
      onReplace([block]);
      registry.dispatch(store).__unstableMarkAutomaticChange();
      return true;
    }
    function onInput(event) {
      const { inputType, type } = event;
      const {
        getValue,
        onChange,
        __unstableAllowPrefixTransformations,
        formatTypes,
        registry
      } = props.current;
      if (inputType !== "insertText" && type !== "compositionend") {
        return;
      }
      if (__unstableAllowPrefixTransformations && inputRule()) {
        return;
      }
      const value = getValue();
      const transformed = formatTypes.reduce(
        (accumulator, { __unstableInputRule }) => {
          if (__unstableInputRule) {
            accumulator = __unstableInputRule(accumulator);
          }
          return accumulator;
        },
        preventEventDiscovery(value)
      );
      const {
        __unstableMarkLastChangeAsPersistent: __unstableMarkLastChangeAsPersistent2,
        __unstableMarkAutomaticChange: __unstableMarkAutomaticChange2
      } = registry.dispatch(store);
      if (transformed !== value) {
        __unstableMarkLastChangeAsPersistent2();
        onChange({
          ...transformed,
          activeFormats: value.activeFormats
        });
        __unstableMarkAutomaticChange2();
      }
    }
    element.addEventListener("input", onInput);
    element.addEventListener("compositionend", onInput);
    return () => {
      element.removeEventListener("input", onInput);
      element.removeEventListener("compositionend", onInput);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/insert-replacement-text.js
  var insert_replacement_text_default = (props) => (element) => {
    function onInput(event) {
      if (event.inputType !== "insertReplacementText") {
        return;
      }
      const { registry } = props.current;
      registry.dispatch(store).__unstableMarkLastChangeAsPersistent();
    }
    element.addEventListener("beforeinput", onInput);
    return () => {
      element.removeEventListener("beforeinput", onInput);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/remove-browser-shortcuts.js
  var import_keycodes19 = __toESM(require_keycodes());
  var remove_browser_shortcuts_default = () => (node2) => {
    function onKeydown(event) {
      if (import_keycodes19.isKeyboardEvent.primary(event, "z") || import_keycodes19.isKeyboardEvent.primary(event, "y") || import_keycodes19.isKeyboardEvent.primaryShift(event, "z")) {
        event.preventDefault();
      }
    }
    node2.addEventListener("keydown", onKeydown);
    return () => {
      node2.removeEventListener("keydown", onKeydown);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/shortcuts.js
  var shortcuts_default = (props) => (element) => {
    const { keyboardShortcuts } = props.current;
    function onKeyDown(event) {
      for (const keyboardShortcut of keyboardShortcuts.current) {
        keyboardShortcut(event);
      }
    }
    element.addEventListener("keydown", onKeyDown);
    return () => {
      element.removeEventListener("keydown", onKeyDown);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/input-events.js
  var input_events_default = (props) => (element) => {
    const { inputEvents } = props.current;
    function onInput(event) {
      for (const keyboardShortcut of inputEvents.current) {
        keyboardShortcut(event);
      }
    }
    element.addEventListener("input", onInput);
    return () => {
      element.removeEventListener("input", onInput);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/undo-automatic-change.js
  var import_keycodes20 = __toESM(require_keycodes());
  var undo_automatic_change_default = (props) => (element) => {
    function onKeyDown(event) {
      const { keyCode } = event;
      if (event.defaultPrevented) {
        return;
      }
      if (keyCode !== import_keycodes20.BACKSPACE && keyCode !== import_keycodes20.ESCAPE) {
        return;
      }
      const { registry } = props.current;
      const { didAutomaticChange: didAutomaticChange2, getSettings: getSettings4 } = registry.select(store);
      const { __experimentalUndo } = getSettings4();
      if (!__experimentalUndo) {
        return;
      }
      if (!didAutomaticChange2()) {
        return;
      }
      event.preventDefault();
      __experimentalUndo();
    }
    element.addEventListener("keydown", onKeyDown);
    return () => {
      element.removeEventListener("keydown", onKeyDown);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/paste-handler.js
  var import_blocks84 = __toESM(require_blocks());
  var import_rich_text9 = __toESM(require_rich_text());
  var import_url11 = __toESM(require_url());

  // packages/block-editor/build-module/components/rich-text/utils.js
  var import_jsx_runtime337 = __toESM(require_jsx_runtime());
  var import_element189 = __toESM(require_element());
  var import_blocks83 = __toESM(require_blocks());
  function addActiveFormats(value, activeFormats) {
    if (activeFormats?.length) {
      let index = value.formats.length;
      while (index--) {
        value.formats[index] = [
          ...activeFormats,
          ...value.formats[index] || []
        ];
      }
    }
  }
  function getMultilineTag(multiline) {
    if (multiline !== true && multiline !== "p" && multiline !== "li") {
      return;
    }
    return multiline === true ? "p" : multiline;
  }
  function getAllowedFormats({ allowedFormats, disableFormats }) {
    if (disableFormats) {
      return getAllowedFormats.EMPTY_ARRAY;
    }
    return allowedFormats;
  }
  getAllowedFormats.EMPTY_ARRAY = [];

  // packages/block-editor/build-module/components/rich-text/event-listeners/paste-handler.js
  var paste_handler_default = (props) => (element) => {
    function _onPaste(event) {
      const {
        disableFormats,
        onChange,
        value,
        formatTypes,
        tagName,
        onReplace,
        __unstableEmbedURLOnPaste,
        preserveWhiteSpace,
        pastePlainText
      } = props.current;
      if (!element.contains(event.target)) {
        return;
      }
      if (event.defaultPrevented) {
        return;
      }
      const { plainText, html } = getPasteEventData(event);
      event.preventDefault();
      window.console.log("Received HTML:\n\n", html);
      window.console.log("Received plain text:\n\n", plainText);
      if (disableFormats) {
        onChange((0, import_rich_text9.insert)(value, plainText));
        return;
      }
      const isInternal = event.clipboardData.getData("rich-text") === "true";
      function pasteInline(content2) {
        const transformed = formatTypes.reduce(
          (accumulator, { __unstablePasteRule }) => {
            if (__unstablePasteRule && accumulator === value) {
              accumulator = __unstablePasteRule(value, {
                html,
                plainText
              });
            }
            return accumulator;
          },
          value
        );
        if (transformed !== value) {
          onChange(transformed);
        } else {
          const valueToInsert = (0, import_rich_text9.create)({ html: content2 });
          addActiveFormats(valueToInsert, value.activeFormats);
          onChange((0, import_rich_text9.insert)(value, valueToInsert));
        }
      }
      if (isInternal) {
        pasteInline(html);
        return;
      }
      if (pastePlainText) {
        onChange((0, import_rich_text9.insert)(value, (0, import_rich_text9.create)({ text: plainText })));
        return;
      }
      let mode2 = "INLINE";
      const trimmedPlainText = plainText.trim();
      if (__unstableEmbedURLOnPaste && (0, import_rich_text9.isEmpty)(value) && (0, import_url11.isURL)(trimmedPlainText) && // For the link pasting feature, allow only http(s) protocols.
      /^https?:/.test(trimmedPlainText)) {
        mode2 = "BLOCKS";
      }
      const content = (0, import_blocks84.pasteHandler)({
        HTML: html,
        plainText,
        mode: mode2,
        tagName,
        preserveWhiteSpace
      });
      if (typeof content === "string") {
        pasteInline(content);
      } else if (content.length > 0) {
        if (onReplace && (0, import_rich_text9.isEmpty)(value)) {
          onReplace(content, content.length - 1, -1);
        }
      }
    }
    const { defaultView } = element.ownerDocument;
    defaultView.addEventListener("paste", _onPaste);
    return () => {
      defaultView.removeEventListener("paste", _onPaste);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/delete.js
  var import_keycodes21 = __toESM(require_keycodes());
  var import_rich_text10 = __toESM(require_rich_text());
  var delete_default = (props) => (element) => {
    function onKeyDown(event) {
      const { keyCode } = event;
      if (event.defaultPrevented) {
        return;
      }
      const { value, onMerge, onRemove } = props.current;
      if (keyCode === import_keycodes21.DELETE || keyCode === import_keycodes21.BACKSPACE) {
        const { start: start2, end, text } = value;
        const isReverse = keyCode === import_keycodes21.BACKSPACE;
        const hasActiveFormats = value.activeFormats && !!value.activeFormats.length;
        if (!(0, import_rich_text10.isCollapsed)(value) || hasActiveFormats || isReverse && start2 !== 0 || !isReverse && end !== text.length) {
          return;
        }
        if (onMerge) {
          onMerge(!isReverse);
        } else if (onRemove && (0, import_rich_text10.isEmpty)(value) && isReverse) {
          onRemove(!isReverse);
        }
        event.preventDefault();
      }
    }
    element.addEventListener("keydown", onKeyDown);
    return () => {
      element.removeEventListener("keydown", onKeyDown);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/enter.js
  var import_keycodes22 = __toESM(require_keycodes());
  var import_rich_text11 = __toESM(require_rich_text());
  var enter_default = (props) => (element) => {
    function onKeyDownDeprecated(event) {
      if (event.keyCode !== import_keycodes22.ENTER) {
        return;
      }
      const { onReplace, onSplit } = props.current;
      if (onReplace && onSplit) {
        event.__deprecatedOnSplit = true;
      }
    }
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.target !== element) {
        return;
      }
      if (event.keyCode !== import_keycodes22.ENTER) {
        return;
      }
      const {
        value,
        onChange,
        disableLineBreaks,
        onSplitAtEnd,
        onSplitAtDoubleLineEnd,
        registry
      } = props.current;
      event.preventDefault();
      const { text, start: start2, end } = value;
      if (event.shiftKey) {
        if (!disableLineBreaks) {
          onChange((0, import_rich_text11.insert)(value, "\n"));
        }
      } else if (onSplitAtEnd && start2 === end && end === text.length) {
        onSplitAtEnd();
      } else if (
        // For some blocks it's desirable to split at the end of the
        // block when there are two line breaks at the end of the
        // block, so triple Enter exits the block.
        onSplitAtDoubleLineEnd && start2 === end && end === text.length && text.slice(-2) === "\n\n"
      ) {
        registry.batch(() => {
          const _value = { ...value };
          _value.start = _value.end - 2;
          onChange((0, import_rich_text11.remove)(_value));
          onSplitAtDoubleLineEnd();
        });
      } else if (!disableLineBreaks) {
        onChange((0, import_rich_text11.insert)(value, "\n"));
      }
    }
    const { defaultView } = element.ownerDocument;
    defaultView.addEventListener("keydown", onKeyDown);
    element.addEventListener("keydown", onKeyDownDeprecated);
    return () => {
      defaultView.removeEventListener("keydown", onKeyDown);
      element.removeEventListener("keydown", onKeyDownDeprecated);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/firefox-compat.js
  var firefox_compat_default = (props) => (element) => {
    function onFocus() {
      const { registry } = props.current;
      if (!registry.select(store).isMultiSelecting()) {
        return;
      }
      const parentEditable = element.parentElement.closest(
        '[contenteditable="true"]'
      );
      if (parentEditable) {
        parentEditable.focus();
      }
    }
    element.addEventListener("focus", onFocus);
    return () => {
      element.removeEventListener("focus", onFocus);
    };
  };

  // packages/block-editor/build-module/components/rich-text/event-listeners/index.js
  var allEventListeners = [
    before_input_rules_default,
    input_rules_default,
    insert_replacement_text_default,
    remove_browser_shortcuts_default,
    shortcuts_default,
    input_events_default,
    undo_automatic_change_default,
    paste_handler_default,
    delete_default,
    enter_default,
    firefox_compat_default
  ];
  function useEventListeners(props) {
    const propsRef = (0, import_element190.useRef)(props);
    (0, import_element190.useInsertionEffect)(() => {
      propsRef.current = props;
    });
    const refEffects = (0, import_element190.useMemo)(
      () => allEventListeners.map((refEffect) => refEffect(propsRef)),
      [propsRef]
    );
    return (0, import_compose84.useRefEffect)(
      (element) => {
        if (!props.isSelected) {
          return;
        }
        const cleanups = refEffects.map((effect) => effect(element));
        return () => {
          cleanups.forEach((cleanup) => cleanup());
        };
      },
      [refEffects, props.isSelected]
    );
  }

  // packages/block-editor/build-module/components/rich-text/format-edit.js
  var import_jsx_runtime338 = __toESM(require_jsx_runtime());
  var import_react5 = __toESM(require_react());
  var import_rich_text12 = __toESM(require_rich_text());
  var import_element191 = __toESM(require_element());
  var DEFAULT_BLOCK_CONTEXT2 = {};
  var usesContextKey = Symbol("usesContext");
  function Edit3({ onChange, onFocus, value, forwardedRef, settings: settings2 }) {
    const {
      name,
      edit: EditFunction,
      [usesContextKey]: usesContext
    } = settings2;
    const blockContext = (0, import_element191.useContext)(block_context_default);
    const context = (0, import_element191.useMemo)(() => {
      return usesContext ? Object.fromEntries(
        Object.entries(blockContext).filter(
          ([key]) => usesContext.includes(key)
        )
      ) : DEFAULT_BLOCK_CONTEXT2;
    }, [usesContext, blockContext]);
    if (!EditFunction) {
      return null;
    }
    const activeFormat = (0, import_rich_text12.getActiveFormat)(value, name);
    const isActive = activeFormat !== void 0;
    const activeObject = (0, import_rich_text12.getActiveObject)(value);
    const isObjectActive = activeObject !== void 0 && activeObject.type === name;
    return /* @__PURE__ */ (0, import_jsx_runtime338.jsx)(
      EditFunction,
      {
        isActive,
        activeAttributes: isActive ? activeFormat.attributes || {} : {},
        isObjectActive,
        activeObjectAttributes: isObjectActive ? activeObject.attributes || {} : {},
        value,
        onChange,
        onFocus,
        contentRef: forwardedRef,
        context
      },
      name
    );
  }
  function FormatEdit({ formatTypes, ...props }) {
    return formatTypes.map((settings2) => /* @__PURE__ */ (0, import_react5.createElement)(Edit3, { settings: settings2, ...props, key: settings2.name }));
  }

  // packages/block-editor/build-module/components/rich-text/content.js
  var import_jsx_runtime339 = __toESM(require_jsx_runtime());
  var import_element192 = __toESM(require_element());
  var import_blocks85 = __toESM(require_blocks());
  var import_deprecated26 = __toESM(require_deprecated());
  function valueToHTMLString(value, multiline) {
    if (rich_text_default.isEmpty(value)) {
      const multilineTag = getMultilineTag(multiline);
      return multilineTag ? `<${multilineTag}></${multilineTag}>` : "";
    }
    if (Array.isArray(value)) {
      (0, import_deprecated26.default)("wp.blockEditor.RichText value prop as children type", {
        since: "6.1",
        version: "6.3",
        alternative: "value prop as string",
        link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
      });
      return import_blocks85.children.toHTML(value);
    }
    if (typeof value === "string") {
      return value;
    }
    return value.toHTMLString();
  }
  function Content({
    value,
    tagName: Tag,
    multiline,
    format,
    ...props
  }) {
    value = /* @__PURE__ */ (0, import_jsx_runtime339.jsx)(import_element192.RawHTML, { children: valueToHTMLString(value, multiline) });
    return Tag ? /* @__PURE__ */ (0, import_jsx_runtime339.jsx)(Tag, { ...props, children: value }) : value;
  }

  // packages/block-editor/build-module/components/rich-text/with-deprecations.js
  var import_jsx_runtime341 = __toESM(require_jsx_runtime());
  var import_element194 = __toESM(require_element());
  var import_blocks86 = __toESM(require_blocks());
  var import_rich_text14 = __toESM(require_rich_text());
  var import_deprecated28 = __toESM(require_deprecated());

  // packages/block-editor/build-module/components/rich-text/multiline.js
  var import_jsx_runtime340 = __toESM(require_jsx_runtime());
  var import_element193 = __toESM(require_element());
  var import_deprecated27 = __toESM(require_deprecated());
  var import_data151 = __toESM(require_data());
  var import_keycodes23 = __toESM(require_keycodes());
  var import_rich_text13 = __toESM(require_rich_text());
  function RichTextMultiline({
    children,
    identifier: identifier2,
    tagName: TagName = "div",
    value = "",
    onChange,
    multiline,
    ...props
  }, forwardedRef) {
    (0, import_deprecated27.default)("wp.blockEditor.RichText multiline prop", {
      since: "6.1",
      version: "6.3",
      alternative: "nested blocks (InnerBlocks)",
      link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/nested-blocks-inner-blocks/"
    });
    const { clientId } = useBlockEditContext();
    const { getSelectionStart: getSelectionStart2, getSelectionEnd: getSelectionEnd2 } = (0, import_data151.useSelect)(store);
    const { selectionChange: selectionChange2 } = (0, import_data151.useDispatch)(store);
    const multilineTagName = getMultilineTag(multiline);
    value = value || `<${multilineTagName}></${multilineTagName}>`;
    const padded = `</${multilineTagName}>${value}<${multilineTagName}>`;
    const values = padded.split(
      `</${multilineTagName}><${multilineTagName}>`
    );
    values.shift();
    values.pop();
    function _onChange(newValues) {
      onChange(
        `<${multilineTagName}>${newValues.join(
          `</${multilineTagName}><${multilineTagName}>`
        )}</${multilineTagName}>`
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime340.jsx)(TagName, { ref: forwardedRef, children: values.map((_value, index) => {
      return /* @__PURE__ */ (0, import_jsx_runtime340.jsx)(
        RichTextWrapper,
        {
          identifier: `${identifier2}-${index}`,
          tagName: multilineTagName,
          value: _value,
          onChange: (newValue) => {
            const newValues = values.slice();
            newValues[index] = newValue;
            _onChange(newValues);
          },
          isSelected: void 0,
          onKeyDown: (event) => {
            if (event.keyCode !== import_keycodes23.ENTER) {
              return;
            }
            event.preventDefault();
            const { offset: start2 } = getSelectionStart2();
            const { offset: end } = getSelectionEnd2();
            if (typeof start2 !== "number" || typeof end !== "number") {
              return;
            }
            const richTextValue = (0, import_rich_text13.create)({ html: _value });
            richTextValue.start = start2;
            richTextValue.end = end;
            const array = (0, import_rich_text13.split)(richTextValue).map(
              (v2) => (0, import_rich_text13.toHTMLString)({ value: v2 })
            );
            const newValues = values.slice();
            newValues.splice(index, 1, ...array);
            _onChange(newValues);
            selectionChange2(
              clientId,
              `${identifier2}-${index + 1}`,
              0,
              0
            );
          },
          onMerge: (forward) => {
            const newValues = values.slice();
            let offset = 0;
            if (forward) {
              if (!newValues[index + 1]) {
                return;
              }
              newValues.splice(
                index,
                2,
                newValues[index] + newValues[index + 1]
              );
              offset = newValues[index].length - 1;
            } else {
              if (!newValues[index - 1]) {
                return;
              }
              newValues.splice(
                index - 1,
                2,
                newValues[index - 1] + newValues[index]
              );
              offset = newValues[index - 1].length - 1;
            }
            _onChange(newValues);
            selectionChange2(
              clientId,
              `${identifier2}-${index - (forward ? 0 : 1)}`,
              offset,
              offset
            );
          },
          ...props
        },
        index
      );
    }) });
  }
  var multiline_default = (0, import_element193.forwardRef)(RichTextMultiline);

  // packages/block-editor/build-module/components/rich-text/with-deprecations.js
  function withDeprecations(Component7) {
    return (0, import_element194.forwardRef)((props, ref) => {
      let value = props.value;
      let onChange = props.onChange;
      if (Array.isArray(value)) {
        (0, import_deprecated28.default)("wp.blockEditor.RichText value prop as children type", {
          since: "6.1",
          version: "6.3",
          alternative: "value prop as string",
          link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
        });
        value = import_blocks86.children.toHTML(props.value);
        onChange = (newValue) => props.onChange(
          import_blocks86.children.fromDOM(
            (0, import_rich_text14.__unstableCreateElement)(document, newValue).childNodes
          )
        );
      }
      const NewComponent = props.multiline ? multiline_default : Component7;
      return /* @__PURE__ */ (0, import_jsx_runtime341.jsx)(
        NewComponent,
        {
          ...props,
          value,
          onChange,
          ref
        }
      );
    });
  }

  // packages/block-editor/build-module/components/rich-text/shortcut.js
  var import_keycodes24 = __toESM(require_keycodes());
  var import_element195 = __toESM(require_element());
  function RichTextShortcut({ character: character2, type, onUse }) {
    const keyboardShortcuts = (0, import_element195.useContext)(keyboardShortcutContext);
    const onUseRef = (0, import_element195.useRef)();
    onUseRef.current = onUse;
    (0, import_element195.useEffect)(() => {
      function callback(event) {
        if (import_keycodes24.isKeyboardEvent[type](event, character2)) {
          onUseRef.current();
          event.preventDefault();
        }
      }
      keyboardShortcuts.current.add(callback);
      return () => {
        keyboardShortcuts.current.delete(callback);
      };
    }, [character2, type]);
    return null;
  }

  // packages/block-editor/build-module/components/rich-text/toolbar-button.js
  var import_jsx_runtime342 = __toESM(require_jsx_runtime());
  var import_components188 = __toESM(require_components());
  var import_keycodes25 = __toESM(require_keycodes());
  function RichTextToolbarButton({
    name,
    shortcutType,
    shortcutCharacter,
    ...props
  }) {
    let shortcut;
    let fillName = "RichText.ToolbarControls";
    if (name) {
      fillName += `.${name}`;
    }
    if (shortcutType && shortcutCharacter) {
      shortcut = import_keycodes25.displayShortcut[shortcutType](shortcutCharacter);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime342.jsx)(import_components188.Fill, { name: fillName, children: /* @__PURE__ */ (0, import_jsx_runtime342.jsx)(import_components188.ToolbarButton, { ...props, shortcut }) });
  }

  // packages/block-editor/build-module/components/rich-text/input-event.js
  var import_element196 = __toESM(require_element());
  function __unstableRichTextInputEvent({ inputType, onInput }) {
    const callbacks = (0, import_element196.useContext)(inputEventContext);
    const onInputRef = (0, import_element196.useRef)();
    onInputRef.current = onInput;
    (0, import_element196.useEffect)(() => {
      function callback(event) {
        if (event.inputType === inputType) {
          onInputRef.current();
          event.preventDefault();
        }
      }
      callbacks.current.add(callback);
      return () => {
        callbacks.current.delete(callback);
      };
    }, [inputType]);
    return null;
  }

  // packages/block-editor/build-module/components/rich-text/index.js
  var keyboardShortcutContext = (0, import_element197.createContext)();
  keyboardShortcutContext.displayName = "keyboardShortcutContext";
  var inputEventContext = (0, import_element197.createContext)();
  inputEventContext.displayName = "inputEventContext";
  var instanceIdKey = Symbol("instanceId");
  function removeNativeProps(props) {
    const {
      __unstableMobileNoFocusOnMount,
      deleteEnter,
      placeholderTextColor,
      textAlign,
      selectionColor,
      tagsToEliminate,
      disableEditingMenu,
      fontSize,
      fontFamily,
      fontWeight,
      fontStyle,
      minWidth,
      maxWidth,
      disableSuggestions,
      disableAutocorrection,
      ...restProps
    } = props;
    return restProps;
  }
  function RichTextWrapper({
    children,
    tagName = "div",
    value: adjustedValue = "",
    onChange: adjustedOnChange,
    isSelected: originalIsSelected,
    multiline,
    inlineToolbar,
    wrapperClassName,
    autocompleters,
    onReplace,
    placeholder,
    allowedFormats,
    withoutInteractiveFormatting,
    onRemove,
    onMerge,
    onSplit,
    __unstableOnSplitAtEnd: onSplitAtEnd,
    __unstableOnSplitAtDoubleLineEnd: onSplitAtDoubleLineEnd,
    identifier: identifier2,
    preserveWhiteSpace,
    __unstablePastePlainText: pastePlainText,
    __unstableEmbedURLOnPaste,
    __unstableDisableFormats: disableFormats,
    disableLineBreaks,
    __unstableAllowPrefixTransformations,
    readOnly,
    ...props
  }, forwardedRef) {
    props = removeNativeProps(props);
    if (onSplit) {
      (0, import_deprecated29.default)("wp.blockEditor.RichText onSplit prop", {
        since: "6.4",
        alternative: 'block.json support key: "splitting"'
      });
    }
    const instanceId = (0, import_compose85.useInstanceId)(RichTextWrapper);
    const anchorRef = (0, import_element197.useRef)();
    const context = useBlockEditContext();
    const { clientId, isSelected: isBlockSelected2, name: blockName } = context;
    const blockBindings = context[blockBindingsKey];
    const blockContext = (0, import_element197.useContext)(block_context_default);
    const registry = (0, import_data152.useRegistry)();
    const selector3 = (select2) => {
      if (!isBlockSelected2) {
        return { isSelected: false };
      }
      const { getSelectionStart: getSelectionStart22, getSelectionEnd: getSelectionEnd22, getBlockEditingMode: getBlockEditingMode2 } = select2(store);
      const selectionStart2 = getSelectionStart22();
      const selectionEnd2 = getSelectionEnd22();
      let isSelected2;
      if (originalIsSelected === void 0) {
        isSelected2 = selectionStart2.clientId === clientId && selectionEnd2.clientId === clientId && (identifier2 ? selectionStart2.attributeKey === identifier2 : selectionStart2[instanceIdKey] === instanceId);
      } else if (originalIsSelected) {
        isSelected2 = selectionStart2.clientId === clientId;
      }
      return {
        selectionStart: isSelected2 ? selectionStart2.offset : void 0,
        selectionEnd: isSelected2 ? selectionEnd2.offset : void 0,
        isSelected: isSelected2,
        isContentOnly: getBlockEditingMode2(clientId) === "contentOnly"
      };
    };
    const { selectionStart, selectionEnd, isSelected, isContentOnly } = (0, import_data152.useSelect)(selector3, [
      clientId,
      identifier2,
      instanceId,
      originalIsSelected,
      isBlockSelected2
    ]);
    const { disableBoundBlock, bindingsPlaceholder, bindingsLabel } = (0, import_data152.useSelect)(
      (select2) => {
        const { __experimentalBlockBindingsSupportedAttributes } = select2(store).getSettings();
        if (!blockBindings?.[identifier2] || !(blockName in __experimentalBlockBindingsSupportedAttributes)) {
          return {};
        }
        const relatedBinding = blockBindings[identifier2];
        const blockBindingsSource = (0, import_blocks87.getBlockBindingsSource)(
          relatedBinding.source
        );
        const blockBindingsContext = {};
        if (blockBindingsSource?.usesContext?.length) {
          for (const key of blockBindingsSource.usesContext) {
            blockBindingsContext[key] = blockContext[key];
          }
        }
        const _disableBoundBlock = !blockBindingsSource?.canUserEditValue?.({
          select: select2,
          context: blockBindingsContext,
          args: relatedBinding.args
        });
        if (adjustedValue.length > 0) {
          return {
            disableBoundBlock: _disableBoundBlock,
            // Null values will make them fall back to the default behavior.
            bindingsPlaceholder: null,
            bindingsLabel: null
          };
        }
        const { getBlockAttributes: getBlockAttributes3 } = select2(store);
        const blockAttributes = getBlockAttributes3(clientId);
        let clientSideFieldLabel = null;
        if (blockBindingsSource?.editorUI) {
          const editorUIResult = blockBindingsSource.editorUI({
            select: select2,
            context: blockBindingsContext
          });
          clientSideFieldLabel = editorUIResult.data?.find(
            (item) => (0, import_es65.default)(item.args, relatedBinding?.args)
          )?.label;
        }
        const bindingKey = clientSideFieldLabel ?? blockBindingsSource?.label;
        const _bindingsPlaceholder = _disableBoundBlock ? bindingKey : (0, import_i18n181.sprintf)(
          /* translators: %s: connected field label or source label */
          (0, import_i18n181.__)("Add %s"),
          bindingKey
        );
        const _bindingsLabel = _disableBoundBlock ? relatedBinding?.args?.key || blockBindingsSource?.label : (0, import_i18n181.sprintf)(
          /* translators: %s: source label or key */
          (0, import_i18n181.__)("Empty %s; start writing to edit its value"),
          relatedBinding?.args?.key || blockBindingsSource?.label
        );
        return {
          disableBoundBlock: _disableBoundBlock,
          bindingsPlaceholder: blockAttributes?.placeholder || _bindingsPlaceholder,
          bindingsLabel: _bindingsLabel
        };
      },
      [
        blockBindings,
        identifier2,
        blockName,
        adjustedValue,
        clientId,
        blockContext
      ]
    );
    const isInsidePatternOverrides = !!blockContext?.["pattern/overrides"];
    const hasOverrideEnabled = blockBindings?.__default?.source === "core/pattern-overrides";
    const shouldDisableForPattern = isInsidePatternOverrides && !hasOverrideEnabled;
    const shouldDisableEditing = readOnly || disableBoundBlock || shouldDisableForPattern;
    const { getSelectionStart: getSelectionStart2, getSelectionEnd: getSelectionEnd2, getBlockRootClientId: getBlockRootClientId2 } = (0, import_data152.useSelect)(store);
    const { selectionChange: selectionChange2 } = (0, import_data152.useDispatch)(store);
    const adjustedAllowedFormats = getAllowedFormats({
      allowedFormats,
      disableFormats
    });
    const hasFormats = !adjustedAllowedFormats || adjustedAllowedFormats.length > 0;
    const onSelectionChange = (0, import_element197.useCallback)(
      (start2, end) => {
        const selection2 = {};
        const unset = start2 === void 0 && end === void 0;
        const baseSelection = {
          clientId,
          [identifier2 ? "attributeKey" : instanceIdKey]: identifier2 ? identifier2 : instanceId
        };
        if (typeof start2 === "number" || unset) {
          if (end === void 0 && getBlockRootClientId2(clientId) !== getBlockRootClientId2(getSelectionEnd2().clientId)) {
            return;
          }
          selection2.start = {
            ...baseSelection,
            offset: start2
          };
        }
        if (typeof end === "number" || unset) {
          if (start2 === void 0 && getBlockRootClientId2(clientId) !== getBlockRootClientId2(getSelectionStart2().clientId)) {
            return;
          }
          selection2.end = {
            ...baseSelection,
            offset: end
          };
        }
        selectionChange2(selection2);
      },
      [
        clientId,
        getBlockRootClientId2,
        getSelectionEnd2,
        getSelectionStart2,
        identifier2,
        instanceId,
        selectionChange2
      ]
    );
    const {
      formatTypes,
      prepareHandlers,
      valueHandlers,
      changeHandlers,
      dependencies
    } = useFormatTypes({
      clientId,
      identifier: identifier2,
      allowedFormats: adjustedAllowedFormats,
      withoutInteractiveFormatting,
      disableNoneEssentialFormatting: isContentOnly
    });
    function addEditorOnlyFormats(value2) {
      return valueHandlers.reduce(
        (accumulator, fn) => fn(accumulator, value2.text),
        value2.formats
      );
    }
    function removeEditorOnlyFormats(value2) {
      formatTypes.forEach((formatType) => {
        if (formatType.__experimentalCreatePrepareEditableTree) {
          value2 = (0, import_rich_text15.removeFormat)(
            value2,
            formatType.name,
            0,
            value2.text.length
          );
        }
      });
      return value2.formats;
    }
    function addInvisibleFormats(value2) {
      return prepareHandlers.reduce(
        (accumulator, fn) => fn(accumulator, value2.text),
        value2.formats
      );
    }
    const {
      value,
      getValue,
      onChange,
      ref: richTextRef
    } = (0, import_rich_text15.__unstableUseRichText)({
      value: adjustedValue,
      onChange(html, { __unstableFormats, __unstableText }) {
        adjustedOnChange(html);
        Object.values(changeHandlers).forEach((changeHandler) => {
          changeHandler(__unstableFormats, __unstableText);
        });
      },
      selectionStart,
      selectionEnd,
      onSelectionChange,
      placeholder: bindingsPlaceholder || placeholder,
      __unstableIsSelected: isSelected,
      __unstableDisableFormats: disableFormats,
      preserveWhiteSpace,
      __unstableDependencies: [...dependencies, tagName],
      __unstableAfterParse: addEditorOnlyFormats,
      __unstableBeforeSerialize: removeEditorOnlyFormats,
      __unstableAddInvisibleFormats: addInvisibleFormats
    });
    const autocompleteProps = useBlockEditorAutocompleteProps({
      onReplace,
      completers: autocompleters,
      record: value,
      onChange
    });
    useMarkPersistent({ html: adjustedValue, value });
    const keyboardShortcuts = (0, import_element197.useRef)(/* @__PURE__ */ new Set());
    const inputEvents = (0, import_element197.useRef)(/* @__PURE__ */ new Set());
    function onFocus() {
      anchorRef.current?.focus();
    }
    const TagName = tagName;
    return /* @__PURE__ */ (0, import_jsx_runtime343.jsxs)(import_jsx_runtime343.Fragment, { children: [
      isSelected && /* @__PURE__ */ (0, import_jsx_runtime343.jsx)(keyboardShortcutContext.Provider, { value: keyboardShortcuts, children: /* @__PURE__ */ (0, import_jsx_runtime343.jsx)(inputEventContext.Provider, { value: inputEvents, children: /* @__PURE__ */ (0, import_jsx_runtime343.jsxs)(import_components189.Popover.__unstableSlotNameProvider, { value: "__unstable-block-tools-after", children: [
        children && children({ value, onChange, onFocus }),
        /* @__PURE__ */ (0, import_jsx_runtime343.jsx)(
          FormatEdit,
          {
            value,
            onChange,
            onFocus,
            formatTypes,
            forwardedRef: anchorRef
          }
        )
      ] }) }) }),
      isSelected && hasFormats && /* @__PURE__ */ (0, import_jsx_runtime343.jsx)(
        format_toolbar_container_default,
        {
          inline: inlineToolbar,
          editableContentElement: anchorRef.current
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime343.jsx)(
        TagName,
        {
          role: "textbox",
          "aria-multiline": !disableLineBreaks,
          "aria-readonly": shouldDisableEditing,
          ...props,
          draggable: void 0,
          "aria-label": bindingsLabel || props["aria-label"] || placeholder,
          ...autocompleteProps,
          ref: (0, import_compose85.useMergeRefs)([
            // Rich text ref must be first because its focus listener
            // must be set up before any other ref calls .focus() on
            // mount.
            richTextRef,
            forwardedRef,
            autocompleteProps.ref,
            props.ref,
            useEventListeners({
              registry,
              getValue,
              onChange,
              __unstableAllowPrefixTransformations,
              formatTypes,
              onReplace,
              selectionChange: selectionChange2,
              isSelected,
              disableFormats,
              value,
              tagName,
              onSplit,
              __unstableEmbedURLOnPaste,
              pastePlainText,
              onMerge,
              onRemove,
              removeEditorOnlyFormats,
              disableLineBreaks,
              onSplitAtEnd,
              onSplitAtDoubleLineEnd,
              keyboardShortcuts,
              inputEvents
            }),
            anchorRef
          ]),
          contentEditable: !shouldDisableEditing,
          suppressContentEditableWarning: true,
          className: clsx_default(
            "block-editor-rich-text__editable",
            props.className,
            "rich-text"
          ),
          tabIndex: props.tabIndex === 0 && !shouldDisableEditing ? null : props.tabIndex,
          "data-wp-block-attribute-key": identifier2
        }
      )
    ] });
  }
  var PrivateRichText = withDeprecations(
    (0, import_element197.forwardRef)(RichTextWrapper)
  );
  PrivateRichText.Content = Content;
  PrivateRichText.isEmpty = (value) => {
    return !value || value.length === 0;
  };
  var PublicForwardedRichTextContainer = (0, import_element197.forwardRef)((props, ref) => {
    const context = useBlockEditContext();
    const isPreviewMode = context[isPreviewModeKey];
    if (isPreviewMode) {
      const {
        children,
        tagName: Tag = "div",
        value,
        onChange,
        isSelected,
        multiline,
        inlineToolbar,
        wrapperClassName,
        autocompleters,
        onReplace,
        placeholder,
        allowedFormats,
        withoutInteractiveFormatting,
        onRemove,
        onMerge,
        onSplit,
        __unstableOnSplitAtEnd,
        __unstableOnSplitAtDoubleLineEnd,
        identifier: identifier2,
        preserveWhiteSpace,
        __unstablePastePlainText,
        __unstableEmbedURLOnPaste,
        __unstableDisableFormats,
        disableLineBreaks,
        __unstableAllowPrefixTransformations,
        readOnly,
        ...contentProps
      } = removeNativeProps(props);
      return /* @__PURE__ */ (0, import_jsx_runtime343.jsx)(
        Tag,
        {
          ...contentProps,
          dangerouslySetInnerHTML: {
            __html: valueToHTMLString(value, multiline)
          }
        }
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime343.jsx)(PrivateRichText, { ref, ...props, readOnly: false });
  });
  PublicForwardedRichTextContainer.Content = Content;
  PublicForwardedRichTextContainer.isEmpty = (value) => {
    return !value || value.length === 0;
  };
  var rich_text_default = PublicForwardedRichTextContainer;

  // packages/block-editor/build-module/components/editable-text/index.js
  var EditableText = (0, import_element198.forwardRef)((props, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime344.jsx)(rich_text_default, { ref, ...props, __unstableDisableFormats: true });
  });
  EditableText.Content = ({ value = "", tagName: Tag = "div", ...props }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime344.jsx)(Tag, { ...props, children: value });
  };
  var editable_text_default = EditableText;

  // packages/block-editor/build-module/components/plain-text/index.js
  var PlainText = (0, import_element199.forwardRef)(({ __experimentalVersion, ...props }, ref) => {
    if (__experimentalVersion === 2) {
      return /* @__PURE__ */ (0, import_jsx_runtime345.jsx)(editable_text_default, { ref, ...props });
    }
    const { className, onChange, ...remainingProps } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime345.jsx)(
      import_react_autosize_textarea2.default,
      {
        ref,
        className: clsx_default("block-editor-plain-text", className),
        onChange: (event) => onChange(event.target.value),
        ...remainingProps
      }
    );
  });
  var plain_text_default = PlainText;

  // packages/block-editor/build-module/components/responsive-block-control/index.js
  var import_jsx_runtime347 = __toESM(require_jsx_runtime());
  var import_i18n183 = __toESM(require_i18n());
  var import_element200 = __toESM(require_element());
  var import_components191 = __toESM(require_components());

  // packages/block-editor/build-module/components/responsive-block-control/label.js
  var import_jsx_runtime346 = __toESM(require_jsx_runtime());
  var import_compose86 = __toESM(require_compose());
  var import_components190 = __toESM(require_components());
  var import_i18n182 = __toESM(require_i18n());
  function ResponsiveBlockControlLabel({
    property,
    viewport,
    desc
  }) {
    const instanceId = (0, import_compose86.useInstanceId)(ResponsiveBlockControlLabel);
    const accessibleLabel = desc || (0, import_i18n182.sprintf)(
      /* translators: 1: property name. 2: viewport name. */
      (0, import_i18n182._x)(
        "Controls the %1$s property for %2$s viewports.",
        "Text labelling a interface as controlling a given layout property (eg: margin) for a given screen size."
      ),
      property,
      viewport.label
    );
    return /* @__PURE__ */ (0, import_jsx_runtime346.jsxs)(import_jsx_runtime346.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime346.jsx)("span", { "aria-describedby": `rbc-desc-${instanceId}`, children: viewport.label }),
      /* @__PURE__ */ (0, import_jsx_runtime346.jsx)(import_components190.VisuallyHidden, { as: "span", id: `rbc-desc-${instanceId}`, children: accessibleLabel })
    ] });
  }

  // packages/block-editor/build-module/components/responsive-block-control/index.js
  function ResponsiveBlockControl(props) {
    const {
      title,
      property,
      toggleLabel,
      onIsResponsiveChange,
      renderDefaultControl,
      renderResponsiveControls,
      isResponsive = false,
      defaultLabel = {
        id: "all",
        label: (0, import_i18n183._x)("All", "screen sizes")
      },
      viewports = [
        {
          id: "small",
          label: (0, import_i18n183.__)("Small screens")
        },
        {
          id: "medium",
          label: (0, import_i18n183.__)("Medium screens")
        },
        {
          id: "large",
          label: (0, import_i18n183.__)("Large screens")
        }
      ]
    } = props;
    if (!title || !property || !renderDefaultControl) {
      return null;
    }
    const toggleControlLabel = toggleLabel || (0, import_i18n183.sprintf)(
      /* translators: %s: Property value for the control (eg: margin, padding, etc.). */
      (0, import_i18n183.__)("Use the same %s on all screen sizes."),
      property
    );
    const toggleHelpText = (0, import_i18n183.__)(
      "Choose whether to use the same value for all screen sizes or a unique value for each screen size."
    );
    const defaultControl = renderDefaultControl(
      /* @__PURE__ */ (0, import_jsx_runtime347.jsx)(
        ResponsiveBlockControlLabel,
        {
          property,
          viewport: defaultLabel
        }
      ),
      defaultLabel
    );
    const defaultResponsiveControls = () => {
      return viewports.map((viewport) => /* @__PURE__ */ (0, import_jsx_runtime347.jsx)(import_element200.Fragment, { children: renderDefaultControl(
        /* @__PURE__ */ (0, import_jsx_runtime347.jsx)(
          ResponsiveBlockControlLabel,
          {
            property,
            viewport
          }
        ),
        viewport
      ) }, viewport.id));
    };
    return /* @__PURE__ */ (0, import_jsx_runtime347.jsxs)("fieldset", { className: "block-editor-responsive-block-control", children: [
      /* @__PURE__ */ (0, import_jsx_runtime347.jsx)("legend", { className: "block-editor-responsive-block-control__title", children: title }),
      /* @__PURE__ */ (0, import_jsx_runtime347.jsxs)("div", { className: "block-editor-responsive-block-control__inner", children: [
        /* @__PURE__ */ (0, import_jsx_runtime347.jsx)(
          import_components191.ToggleControl,
          {
            __nextHasNoMarginBottom: true,
            className: "block-editor-responsive-block-control__toggle",
            label: toggleControlLabel,
            checked: !isResponsive,
            onChange: onIsResponsiveChange,
            help: toggleHelpText
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime347.jsxs)(
          "div",
          {
            className: clsx_default(
              "block-editor-responsive-block-control__group",
              {
                "is-responsive": isResponsive
              }
            ),
            children: [
              !isResponsive && defaultControl,
              isResponsive && (renderResponsiveControls ? renderResponsiveControls(viewports) : defaultResponsiveControls())
            ]
          }
        )
      ] })
    ] });
  }
  var responsive_block_control_default = ResponsiveBlockControl;

  // packages/block-editor/build-module/components/unit-control/index.js
  var import_jsx_runtime348 = __toESM(require_jsx_runtime());
  var import_components192 = __toESM(require_components());
  function UnitControl10({ units: unitsProp, ...props }) {
    const [availableUnits] = useSettings("spacing.units");
    const units2 = (0, import_components192.__experimentalUseCustomUnits)({
      availableUnits: availableUnits || ["%", "px", "em", "rem", "vw"],
      units: unitsProp
    });
    return /* @__PURE__ */ (0, import_jsx_runtime348.jsx)(import_components192.__experimentalUnitControl, { units: units2, ...props });
  }

  // packages/block-editor/build-module/components/url-input/button.js
  var import_jsx_runtime349 = __toESM(require_jsx_runtime());
  var import_i18n184 = __toESM(require_i18n());
  var import_element201 = __toESM(require_element());
  var import_components193 = __toESM(require_components());
  function URLInputButton({ url, onChange }) {
    const [expanded2, toggleExpanded] = (0, import_element201.useReducer)(
      (isExpanded) => !isExpanded,
      false
    );
    const submitLink = (event) => {
      event.preventDefault();
      toggleExpanded();
    };
    return /* @__PURE__ */ (0, import_jsx_runtime349.jsxs)("div", { className: "block-editor-url-input__button", children: [
      /* @__PURE__ */ (0, import_jsx_runtime349.jsx)(
        import_components193.Button,
        {
          size: "compact",
          icon: link_default,
          label: url ? (0, import_i18n184.__)("Edit link") : (0, import_i18n184.__)("Insert link"),
          onClick: toggleExpanded,
          className: "components-toolbar__control",
          isPressed: !!url
        }
      ),
      expanded2 && /* @__PURE__ */ (0, import_jsx_runtime349.jsx)(
        "form",
        {
          className: "block-editor-url-input__button-modal",
          onSubmit: submitLink,
          children: /* @__PURE__ */ (0, import_jsx_runtime349.jsxs)("div", { className: "block-editor-url-input__button-modal-line", children: [
            /* @__PURE__ */ (0, import_jsx_runtime349.jsx)(
              import_components193.Button,
              {
                __next40pxDefaultSize: true,
                className: "block-editor-url-input__back",
                icon: arrow_left_default,
                label: (0, import_i18n184.__)("Close"),
                onClick: toggleExpanded
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime349.jsx)(
              url_input_default,
              {
                value: url || "",
                onChange,
                suffix: /* @__PURE__ */ (0, import_jsx_runtime349.jsx)(import_components193.__experimentalInputControlSuffixWrapper, { variant: "control", children: /* @__PURE__ */ (0, import_jsx_runtime349.jsx)(
                  import_components193.Button,
                  {
                    size: "small",
                    icon: keyboard_return_default,
                    label: (0, import_i18n184.__)("Submit"),
                    type: "submit"
                  }
                ) })
              }
            )
          ] })
        }
      )
    ] });
  }
  var button_default = URLInputButton;

  // packages/block-editor/build-module/components/url-popover/image-url-input-ui.js
  var import_jsx_runtime350 = __toESM(require_jsx_runtime());
  var import_i18n185 = __toESM(require_i18n());
  var import_element202 = __toESM(require_element());
  var import_dom38 = __toESM(require_dom());
  var import_components194 = __toESM(require_components());
  var import_url12 = __toESM(require_url());
  var LINK_DESTINATION_NONE = "none";
  var LINK_DESTINATION_CUSTOM = "custom";
  var LINK_DESTINATION_MEDIA = "media";
  var LINK_DESTINATION_ATTACHMENT = "attachment";
  var NEW_TAB_REL = ["noreferrer", "noopener"];
  var ImageURLInputUI = ({
    linkDestination,
    onChangeUrl,
    url,
    mediaType = "image",
    mediaUrl,
    mediaLink,
    linkTarget,
    linkClass,
    rel,
    showLightboxSetting,
    lightboxEnabled,
    onSetLightbox,
    resetLightbox
  }) => {
    const [isOpen, setIsOpen] = (0, import_element202.useState)(false);
    const [popoverAnchor, setPopoverAnchor] = (0, import_element202.useState)(null);
    const openLinkUI = () => {
      setIsOpen(true);
    };
    const [isEditingLink, setIsEditingLink] = (0, import_element202.useState)(false);
    const [urlInput, setUrlInput] = (0, import_element202.useState)(null);
    const autocompleteRef = (0, import_element202.useRef)(null);
    const wrapperRef = (0, import_element202.useRef)();
    (0, import_element202.useEffect)(() => {
      if (!wrapperRef.current) {
        return;
      }
      const nextFocusTarget = import_dom38.focus.focusable.find(wrapperRef.current)[0] || wrapperRef.current;
      nextFocusTarget.focus();
    }, [isEditingLink, url, lightboxEnabled]);
    const startEditLink = () => {
      if (linkDestination === LINK_DESTINATION_MEDIA || linkDestination === LINK_DESTINATION_ATTACHMENT) {
        setUrlInput("");
      }
      setIsEditingLink(true);
    };
    const stopEditLink = () => {
      setIsEditingLink(false);
    };
    const closeLinkUI = () => {
      setUrlInput(null);
      stopEditLink();
      setIsOpen(false);
    };
    const getUpdatedLinkTargetSettings = (value) => {
      const newLinkTarget = value ? "_blank" : void 0;
      let updatedRel;
      if (newLinkTarget) {
        const rels = (rel ?? "").split(" ");
        NEW_TAB_REL.forEach((relVal) => {
          if (!rels.includes(relVal)) {
            rels.push(relVal);
          }
        });
        updatedRel = rels.join(" ");
      } else {
        const rels = (rel ?? "").split(" ").filter(
          (relVal) => NEW_TAB_REL.includes(relVal) === false
        );
        updatedRel = rels.length ? rels.join(" ") : void 0;
      }
      return {
        linkTarget: newLinkTarget,
        rel: updatedRel
      };
    };
    const onFocusOutside = () => {
      return (event) => {
        const autocompleteElement = autocompleteRef.current;
        if (autocompleteElement && autocompleteElement.contains(event.target)) {
          return;
        }
        setIsOpen(false);
        setUrlInput(null);
        stopEditLink();
      };
    };
    const onSubmitLinkChange = () => {
      return (event) => {
        if (urlInput) {
          const selectedDestination = getLinkDestinations().find(
            (destination) => destination.url === urlInput
          )?.linkDestination || LINK_DESTINATION_CUSTOM;
          onChangeUrl({
            href: (0, import_url12.prependHTTP)(urlInput),
            linkDestination: selectedDestination,
            lightbox: { enabled: false }
          });
        }
        stopEditLink();
        setUrlInput(null);
        event.preventDefault();
      };
    };
    const onLinkRemove = () => {
      onChangeUrl({
        linkDestination: LINK_DESTINATION_NONE,
        href: ""
      });
    };
    const getLinkDestinations = () => {
      const linkDestinations = [
        {
          linkDestination: LINK_DESTINATION_MEDIA,
          title: (0, import_i18n185.__)("Link to image file"),
          url: mediaType === "image" ? mediaUrl : void 0,
          icon: image_default
        }
      ];
      if (mediaType === "image" && mediaLink) {
        linkDestinations.push({
          linkDestination: LINK_DESTINATION_ATTACHMENT,
          title: (0, import_i18n185.__)("Link to attachment page"),
          url: mediaType === "image" ? mediaLink : void 0,
          icon: page_default
        });
      }
      return linkDestinations;
    };
    const onSetHref = (value) => {
      const linkDestinations = getLinkDestinations();
      let linkDestinationInput;
      if (!value) {
        linkDestinationInput = LINK_DESTINATION_NONE;
      } else {
        linkDestinationInput = (linkDestinations.find((destination) => {
          return destination.url === value;
        }) || { linkDestination: LINK_DESTINATION_CUSTOM }).linkDestination;
      }
      onChangeUrl({
        linkDestination: linkDestinationInput,
        href: value
      });
    };
    const onSetNewTab = (value) => {
      const updatedLinkTarget = getUpdatedLinkTargetSettings(value);
      onChangeUrl(updatedLinkTarget);
    };
    const onSetLinkRel = (value) => {
      onChangeUrl({ rel: value });
    };
    const onSetLinkClass = (value) => {
      onChangeUrl({ linkClass: value });
    };
    const advancedOptions = /* @__PURE__ */ (0, import_jsx_runtime350.jsxs)(import_components194.__experimentalVStack, { spacing: "3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
        import_components194.ToggleControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n185.__)("Open in new tab"),
          onChange: onSetNewTab,
          checked: linkTarget === "_blank"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
        import_components194.TextControl,
        {
          __next40pxDefaultSize: true,
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n185.__)("Link relation"),
          value: rel ?? "",
          onChange: onSetLinkRel,
          help: (0, import_element202.createInterpolateElement)(
            (0, import_i18n185.__)(
              "The <a>Link Relation</a> attribute defines the relationship between a linked resource and the current document."
            ),
            {
              a: /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(import_components194.ExternalLink, { href: "https://developer.mozilla.org/docs/Web/HTML/Attributes/rel" })
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
        import_components194.TextControl,
        {
          __next40pxDefaultSize: true,
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n185.__)("Link CSS class"),
          value: linkClass || "",
          onChange: onSetLinkClass
        }
      )
    ] });
    const linkEditorValue = urlInput !== null ? urlInput : url;
    const hideLightboxPanel = !lightboxEnabled || lightboxEnabled && !showLightboxSetting;
    const showLinkEditor = !linkEditorValue && hideLightboxPanel;
    const urlLabel = (getLinkDestinations().find(
      (destination) => destination.linkDestination === linkDestination
    ) || {}).title;
    const PopoverChildren = () => {
      if (lightboxEnabled && showLightboxSetting && !url && !isEditingLink) {
        return /* @__PURE__ */ (0, import_jsx_runtime350.jsxs)("div", { className: "block-editor-url-popover__expand-on-click", children: [
          /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(icon_default, { icon: fullscreen_default }),
          /* @__PURE__ */ (0, import_jsx_runtime350.jsxs)("div", { className: "text", children: [
            /* @__PURE__ */ (0, import_jsx_runtime350.jsx)("p", { children: (0, import_i18n185.__)("Enlarge on click") }),
            /* @__PURE__ */ (0, import_jsx_runtime350.jsx)("p", { className: "description", children: (0, import_i18n185.__)("Scales the image with a lightbox effect") })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
            import_components194.Button,
            {
              icon: link_off_default,
              label: (0, import_i18n185.__)("Disable enlarge on click"),
              onClick: () => {
                onSetLightbox?.(false);
              },
              size: "compact"
            }
          )
        ] });
      } else if (!url || isEditingLink) {
        return /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
          url_popover_default.LinkEditor,
          {
            className: "block-editor-format-toolbar__link-container-content",
            value: linkEditorValue,
            onChangeInputValue: setUrlInput,
            onSubmit: onSubmitLinkChange(),
            autocompleteRef
          }
        );
      } else if (url && !isEditingLink) {
        return /* @__PURE__ */ (0, import_jsx_runtime350.jsxs)(import_jsx_runtime350.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
            url_popover_default.LinkViewer,
            {
              className: "block-editor-format-toolbar__link-container-content",
              url,
              onEditLinkClick: startEditLink,
              urlLabel
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
            import_components194.Button,
            {
              icon: link_off_default,
              label: (0, import_i18n185.__)("Remove link"),
              onClick: () => {
                onLinkRemove();
                resetLightbox?.();
              },
              size: "compact"
            }
          )
        ] });
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime350.jsxs)(import_jsx_runtime350.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
        import_components194.ToolbarButton,
        {
          icon: link_default,
          className: "components-toolbar__control",
          label: (0, import_i18n185.__)("Link"),
          "aria-expanded": isOpen,
          onClick: openLinkUI,
          ref: setPopoverAnchor,
          isActive: !!url || lightboxEnabled && showLightboxSetting
        }
      ),
      isOpen && /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
        url_popover_default,
        {
          ref: wrapperRef,
          anchor: popoverAnchor,
          onFocusOutside: onFocusOutside(),
          onClose: closeLinkUI,
          renderSettings: hideLightboxPanel ? () => advancedOptions : null,
          additionalControls: showLinkEditor && /* @__PURE__ */ (0, import_jsx_runtime350.jsxs)(import_components194.NavigableMenu, { children: [
            getLinkDestinations().map((link) => /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
              import_components194.MenuItem,
              {
                icon: link.icon,
                iconPosition: "left",
                onClick: () => {
                  setUrlInput(null);
                  onSetHref(link.url);
                  stopEditLink();
                },
                children: link.title
              },
              link.linkDestination
            )),
            showLightboxSetting && /* @__PURE__ */ (0, import_jsx_runtime350.jsx)(
              import_components194.MenuItem,
              {
                className: "block-editor-url-popover__expand-on-click",
                icon: fullscreen_default,
                info: (0, import_i18n185.__)(
                  "Scale the image with a lightbox effect."
                ),
                iconPosition: "left",
                onClick: () => {
                  setUrlInput(null);
                  onChangeUrl({
                    linkDestination: LINK_DESTINATION_NONE,
                    href: ""
                  });
                  onSetLightbox?.(true);
                  stopEditLink();
                },
                children: (0, import_i18n185.__)("Enlarge on click")
              },
              "expand-on-click"
            )
          ] }),
          offset: 13,
          children: PopoverChildren()
        }
      )
    ] });
  };

  // packages/block-editor/build-module/components/preview-options/index.js
  var import_deprecated30 = __toESM(require_deprecated());
  function PreviewOptions() {
    (0, import_deprecated30.default)("wp.blockEditor.PreviewOptions", {
      version: "6.5"
    });
    return null;
  }

  // packages/block-editor/build-module/components/use-resize-canvas/index.js
  var import_element203 = __toESM(require_element());
  function useResizeCanvas(deviceType) {
    const [actualWidth, updateActualWidth] = (0, import_element203.useState)(window.innerWidth);
    (0, import_element203.useEffect)(() => {
      if (deviceType === "Desktop") {
        return;
      }
      const resizeListener = () => updateActualWidth(window.innerWidth);
      window.addEventListener("resize", resizeListener);
      return () => {
        window.removeEventListener("resize", resizeListener);
      };
    }, [deviceType]);
    const getCanvasWidth = (device) => {
      let deviceWidth;
      switch (device) {
        case "Tablet":
          deviceWidth = 780;
          break;
        case "Mobile":
          deviceWidth = 360;
          break;
        default:
          return null;
      }
      return deviceWidth < actualWidth ? deviceWidth : actualWidth;
    };
    const contentInlineStyles = (device) => {
      const height = device === "Mobile" ? "768px" : "1024px";
      const marginVertical = "40px";
      const marginHorizontal = "auto";
      switch (device) {
        case "Tablet":
        case "Mobile":
          return {
            width: getCanvasWidth(device),
            // Keeping margin styles separate to avoid warnings
            // when those props get overridden in the iframe component
            marginTop: marginVertical,
            marginBottom: marginVertical,
            marginLeft: marginHorizontal,
            marginRight: marginHorizontal,
            height,
            overflowY: "auto"
          };
        default:
          return {
            marginLeft: marginHorizontal,
            marginRight: marginHorizontal
          };
      }
    };
    return contentInlineStyles(deviceType);
  }

  // packages/block-editor/build-module/components/block-inspector/index.js
  var import_jsx_runtime361 = __toESM(require_jsx_runtime());
  var import_i18n194 = __toESM(require_i18n());
  var import_blocks88 = __toESM(require_blocks());
  var import_components205 = __toESM(require_components());
  var import_data161 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-inspector/edit-contents-button.js
  var import_jsx_runtime351 = __toESM(require_jsx_runtime());
  var import_components195 = __toESM(require_components());
  var import_data153 = __toESM(require_data());
  var import_i18n186 = __toESM(require_i18n());
  function EditContentsButton({ clientId }) {
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data153.useDispatch)(store);
    const { attributes } = (0, import_data153.useSelect)(
      (select2) => {
        return {
          attributes: select2(store).getBlockAttributes(clientId)
        };
      },
      [clientId]
    );
    if (!attributes?.metadata?.patternName) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime351.jsx)(
      import_components195.Button,
      {
        className: "block-editor-block-inspector-edit-contents-button",
        __next40pxDefaultSize: true,
        variant: "secondary",
        onClick: () => {
          const { patternName, ...metadataWithoutPatternName } = attributes?.metadata ?? {};
          updateBlockAttributes2(clientId, {
            ...attributes,
            metadata: metadataWithoutPatternName
          });
        },
        children: (0, import_i18n186.__)("Edit contents")
      }
    );
  }

  // packages/block-editor/build-module/components/skip-to-selected-block/index.js
  var import_jsx_runtime352 = __toESM(require_jsx_runtime());
  var import_data154 = __toESM(require_data());
  var import_i18n187 = __toESM(require_i18n());
  var import_components196 = __toESM(require_components());
  var import_element204 = __toESM(require_element());
  function SkipToSelectedBlock() {
    const selectedBlockClientId = (0, import_data154.useSelect)(
      (select2) => select2(store).getBlockSelectionStart(),
      []
    );
    const ref = (0, import_element204.useRef)();
    useBlockElementRef(selectedBlockClientId, ref);
    const onClick = () => {
      ref.current?.focus();
    };
    return selectedBlockClientId ? /* @__PURE__ */ (0, import_jsx_runtime352.jsx)(
      import_components196.Button,
      {
        __next40pxDefaultSize: true,
        variant: "secondary",
        className: "block-editor-skip-to-selected-block",
        onClick,
        children: (0, import_i18n187.__)("Skip to the selected block")
      }
    ) : null;
  }

  // packages/block-editor/build-module/components/multi-selection-inspector/index.js
  var import_jsx_runtime353 = __toESM(require_jsx_runtime());
  var import_i18n188 = __toESM(require_i18n());
  var import_data155 = __toESM(require_data());
  var import_components197 = __toESM(require_components());
  function MultiSelectionInspector() {
    const selectedBlockCount = (0, import_data155.useSelect)(
      (select2) => select2(store).getSelectedBlockCount(),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime353.jsxs)(
      import_components197.__experimentalHStack,
      {
        justify: "flex-start",
        spacing: 2,
        className: "block-editor-multi-selection-inspector__card",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime353.jsx)(block_icon_default, { icon: copy_default, showColors: true }),
          /* @__PURE__ */ (0, import_jsx_runtime353.jsx)("div", { className: "block-editor-multi-selection-inspector__card-title", children: (0, import_i18n188.sprintf)(
            /* translators: %d: number of blocks */
            (0, import_i18n188._n)("%d Block", "%d Blocks", selectedBlockCount),
            selectedBlockCount
          ) })
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/inspector-controls-tabs/index.js
  var import_jsx_runtime360 = __toESM(require_jsx_runtime());
  var import_components203 = __toESM(require_components());
  var import_element205 = __toESM(require_element());
  var import_preferences5 = __toESM(require_preferences());
  var import_data158 = __toESM(require_data());

  // packages/block-editor/build-module/components/inspector-controls-tabs/utils.js
  var import_i18n189 = __toESM(require_i18n());
  var TAB_SETTINGS = {
    name: "settings",
    title: (0, import_i18n189.__)("Settings"),
    value: "settings",
    icon: cog_default
  };
  var TAB_STYLES = {
    name: "styles",
    title: (0, import_i18n189.__)("Styles"),
    value: "styles",
    icon: styles_default
  };
  var TAB_CONTENT = {
    name: "content",
    title: (0, import_i18n189.__)("Content"),
    value: "content",
    icon: page_default
  };
  var TAB_LIST_VIEW = {
    name: "list",
    title: (0, import_i18n189.__)("List View"),
    value: "list-view",
    icon: list_view_default
  };

  // packages/block-editor/build-module/components/inspector-controls-tabs/settings-tab.js
  var import_jsx_runtime356 = __toESM(require_jsx_runtime());

  // packages/block-editor/build-module/components/inspector-controls-tabs/advanced-controls-panel.js
  var import_jsx_runtime354 = __toESM(require_jsx_runtime());
  var import_components198 = __toESM(require_components());
  var import_i18n190 = __toESM(require_i18n());
  var AdvancedControls = () => {
    const fills = (0, import_components198.__experimentalUseSlotFills)(InspectorAdvancedControls.slotName);
    const privateFills = (0, import_components198.__experimentalUseSlotFills)(
      PrivateInspectorControlsAllowedBlocks.name
    );
    const hasFills = Boolean(fills && fills.length);
    const hasPrivateFills = Boolean(privateFills && privateFills.length);
    if (!hasFills && !hasPrivateFills) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime354.jsxs)(
      import_components198.PanelBody,
      {
        className: "block-editor-block-inspector__advanced",
        title: (0, import_i18n190.__)("Advanced"),
        initialOpen: false,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime354.jsx)(inspector_controls_default.Slot, { group: "advanced" }),
          /* @__PURE__ */ (0, import_jsx_runtime354.jsx)(PrivateInspectorControlsAllowedBlocks.Slot, {})
        ]
      }
    );
  };
  var advanced_controls_panel_default = AdvancedControls;

  // packages/block-editor/build-module/components/inspector-controls-tabs/position-controls-panel.js
  var import_jsx_runtime355 = __toESM(require_jsx_runtime());
  var import_components199 = __toESM(require_components());
  var import_data156 = __toESM(require_data());
  var import_i18n191 = __toESM(require_i18n());
  var PositionControlsPanel = () => {
    const { selectedClientIds, selectedBlocks, hasPositionAttribute } = (0, import_data156.useSelect)((select2) => {
      const { getBlocksByClientId: getBlocksByClientId2, getSelectedBlockClientIds: getSelectedBlockClientIds2 } = select2(store);
      const selectedBlockClientIds = getSelectedBlockClientIds2();
      const _selectedBlocks = getBlocksByClientId2(
        selectedBlockClientIds
      );
      return {
        selectedClientIds: selectedBlockClientIds,
        selectedBlocks: _selectedBlocks,
        hasPositionAttribute: _selectedBlocks?.some(
          ({ attributes }) => !!attributes?.style?.position?.type
        )
      };
    }, []);
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data156.useDispatch)(store);
    const dropdownMenuProps = useToolsPanelDropdownMenuProps();
    function resetPosition() {
      if (!selectedClientIds?.length || !selectedBlocks?.length) {
        return;
      }
      const attributesByClientId = Object.fromEntries(
        selectedBlocks?.map(({ clientId, attributes }) => [
          clientId,
          {
            style: cleanEmptyObject({
              ...attributes?.style,
              position: {
                ...attributes?.style?.position,
                type: void 0,
                top: void 0,
                right: void 0,
                bottom: void 0,
                left: void 0
              }
            })
          }
        ])
      );
      updateBlockAttributes2(selectedClientIds, attributesByClientId, true);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime355.jsx)(
      import_components199.__experimentalToolsPanel,
      {
        className: "block-editor-block-inspector__position",
        label: (0, import_i18n191.__)("Position"),
        resetAll: resetPosition,
        dropdownMenuProps,
        children: /* @__PURE__ */ (0, import_jsx_runtime355.jsx)(
          import_components199.__experimentalToolsPanelItem,
          {
            isShownByDefault: hasPositionAttribute,
            label: (0, import_i18n191.__)("Position"),
            hasValue: () => hasPositionAttribute,
            onDeselect: resetPosition,
            children: /* @__PURE__ */ (0, import_jsx_runtime355.jsx)(inspector_controls_default.Slot, { group: "position" })
          }
        )
      }
    );
  };
  var PositionControls = () => {
    const fills = (0, import_components199.__experimentalUseSlotFills)(groups_default.position.name);
    const hasFills = Boolean(fills && fills.length);
    if (!hasFills) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime355.jsx)(PositionControlsPanel, {});
  };
  var position_controls_panel_default = PositionControls;

  // packages/block-editor/build-module/components/inspector-controls-tabs/settings-tab.js
  var SettingsTab = ({ showAdvancedControls = false }) => /* @__PURE__ */ (0, import_jsx_runtime356.jsxs)(import_jsx_runtime356.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime356.jsx)(inspector_controls_default.Slot, {}),
    /* @__PURE__ */ (0, import_jsx_runtime356.jsx)(position_controls_panel_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime356.jsx)(inspector_controls_default.Slot, { group: "bindings" }),
    showAdvancedControls && /* @__PURE__ */ (0, import_jsx_runtime356.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime356.jsx)(advanced_controls_panel_default, {}) })
  ] });
  var settings_tab_default = SettingsTab;

  // packages/block-editor/build-module/components/inspector-controls-tabs/styles-tab.js
  var import_jsx_runtime357 = __toESM(require_jsx_runtime());
  var import_components200 = __toESM(require_components());
  var import_i18n192 = __toESM(require_i18n());
  var StylesTab = ({
    blockName,
    clientId,
    hasBlockStyles,
    isSectionBlock: isSectionBlock2
  }) => {
    const borderPanelLabel = useBorderPanelLabel({ blockName });
    return /* @__PURE__ */ (0, import_jsx_runtime357.jsxs)(import_jsx_runtime357.Fragment, { children: [
      hasBlockStyles && /* @__PURE__ */ (0, import_jsx_runtime357.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(import_components200.PanelBody, { title: (0, import_i18n192.__)("Styles"), children: /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(block_styles_default, { clientId }) }) }),
      !isSectionBlock2 && /* @__PURE__ */ (0, import_jsx_runtime357.jsxs)(import_jsx_runtime357.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(
          inspector_controls_default.Slot,
          {
            group: "color",
            label: (0, import_i18n192.__)("Color"),
            className: "color-block-support-panel__inner-wrapper"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(
          inspector_controls_default.Slot,
          {
            group: "background",
            label: (0, import_i18n192.__)("Background image")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(inspector_controls_default.Slot, { group: "filter" }),
        /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(
          inspector_controls_default.Slot,
          {
            group: "typography",
            label: (0, import_i18n192.__)("Typography")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(
          inspector_controls_default.Slot,
          {
            group: "dimensions",
            label: (0, import_i18n192.__)("Dimensions")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(
          inspector_controls_default.Slot,
          {
            group: "border",
            label: borderPanelLabel
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime357.jsx)(inspector_controls_default.Slot, { group: "styles" })
      ] })
    ] });
  };
  var styles_tab_default = StylesTab;

  // packages/block-editor/build-module/components/inspector-controls-tabs/content-tab.js
  var import_jsx_runtime359 = __toESM(require_jsx_runtime());
  var import_components202 = __toESM(require_components());
  var import_i18n193 = __toESM(require_i18n());

  // packages/block-editor/build-module/components/block-quick-navigation/index.js
  var import_jsx_runtime358 = __toESM(require_jsx_runtime());
  var import_data157 = __toESM(require_data());
  var import_components201 = __toESM(require_components());
  function BlockQuickNavigation({ clientIds, onSelect }) {
    if (!clientIds.length) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime358.jsx)(import_components201.__experimentalVStack, { spacing: 1, children: clientIds.map((clientId) => /* @__PURE__ */ (0, import_jsx_runtime358.jsx)(
      BlockQuickNavigationItem,
      {
        onSelect,
        clientId
      },
      clientId
    )) });
  }
  function BlockQuickNavigationItem({ clientId, onSelect }) {
    const blockInformation = useBlockDisplayInformation(clientId);
    const blockTitle = useBlockDisplayTitle({
      clientId,
      context: "list-view"
    });
    const { isSelected } = (0, import_data157.useSelect)(
      (select2) => {
        const { isBlockSelected: isBlockSelected2, hasSelectedInnerBlock: hasSelectedInnerBlock2 } = select2(store);
        return {
          isSelected: isBlockSelected2(clientId) || hasSelectedInnerBlock2(
            clientId,
            /* deep: */
            true
          )
        };
      },
      [clientId]
    );
    const { selectBlock: selectBlock2 } = (0, import_data157.useDispatch)(store);
    return /* @__PURE__ */ (0, import_jsx_runtime358.jsx)(
      import_components201.Button,
      {
        __next40pxDefaultSize: true,
        isPressed: isSelected,
        onClick: async () => {
          await selectBlock2(clientId);
          if (onSelect) {
            onSelect(clientId);
          }
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime358.jsxs)(import_components201.Flex, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime358.jsx)(import_components201.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime358.jsx)(block_icon_default, { icon: blockInformation?.icon }) }),
          /* @__PURE__ */ (0, import_jsx_runtime358.jsx)(import_components201.FlexBlock, { style: { textAlign: "left" }, children: /* @__PURE__ */ (0, import_jsx_runtime358.jsx)(import_components201.__experimentalTruncate, { children: blockTitle }) })
        ] })
      }
    );
  }

  // packages/block-editor/build-module/components/inspector-controls-tabs/content-tab.js
  var ContentTab = ({ contentClientIds }) => {
    if (!contentClientIds || contentClientIds.length === 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime359.jsx)(import_components202.PanelBody, { title: (0, import_i18n193.__)("Content"), children: /* @__PURE__ */ (0, import_jsx_runtime359.jsx)(BlockQuickNavigation, { clientIds: contentClientIds }) });
  };
  var content_tab_default = ContentTab;

  // packages/block-editor/build-module/components/inspector-controls-tabs/use-is-list-view-tab-disabled.js
  var allowlist = ["core/navigation"];
  var useIsListViewTabDisabled = (blockName) => {
    return !allowlist.includes(blockName);
  };
  var use_is_list_view_tab_disabled_default = useIsListViewTabDisabled;

  // packages/block-editor/build-module/components/inspector-controls-tabs/index.js
  var { Tabs: Tabs5 } = unlock(import_components203.privateApis);
  function InspectorControlsTabs({
    blockName,
    clientId,
    hasBlockStyles,
    tabs,
    isSectionBlock: isSectionBlock2,
    contentClientIds
  }) {
    const showIconLabels = (0, import_data158.useSelect)((select2) => {
      return select2(import_preferences5.store).get("core", "showIconLabels");
    }, []);
    const initialTabName = !use_is_list_view_tab_disabled_default(blockName) ? TAB_LIST_VIEW.name : void 0;
    const [selectedTabId, setSelectedTabId] = (0, import_element205.useState)(
      initialTabName ?? tabs[0]?.name
    );
    (0, import_element205.useEffect)(() => {
      if (initialTabName) {
        return;
      }
      if (tabs?.length && selectedTabId) {
        const activeTab = tabs.find(
          (tab) => tab.name === selectedTabId
        );
        if (!activeTab) {
          setSelectedTabId(tabs[0].name);
        }
      }
    }, [tabs, selectedTabId, initialTabName]);
    return /* @__PURE__ */ (0, import_jsx_runtime360.jsx)("div", { className: "block-editor-block-inspector__tabs", children: /* @__PURE__ */ (0, import_jsx_runtime360.jsxs)(
      Tabs5,
      {
        defaultTabId: initialTabName,
        selectedTabId,
        onSelect: setSelectedTabId,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(Tabs5.TabList, { children: tabs.map(
            (tab) => showIconLabels ? /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(Tabs5.Tab, { tabId: tab.name, children: tab.title }, tab.name) : /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(import_components203.Tooltip, { text: tab.title, children: /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(
              Tabs5.Tab,
              {
                tabId: tab.name,
                "aria-label": tab.title,
                children: /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(import_components203.Icon, { icon: tab.icon })
              }
            ) }, tab.name)
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(Tabs5.TabPanel, { tabId: TAB_SETTINGS.name, focusable: false, children: /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(settings_tab_default, { showAdvancedControls: !!blockName }) }),
          /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(Tabs5.TabPanel, { tabId: TAB_STYLES.name, focusable: false, children: /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(
            styles_tab_default,
            {
              blockName,
              clientId,
              hasBlockStyles,
              isSectionBlock: isSectionBlock2
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(Tabs5.TabPanel, { tabId: TAB_CONTENT.name, focusable: false, children: /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(content_tab_default, { contentClientIds }) }),
          /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(Tabs5.TabPanel, { tabId: TAB_LIST_VIEW.name, focusable: false, children: /* @__PURE__ */ (0, import_jsx_runtime360.jsx)(inspector_controls_default.Slot, { group: "list" }) })
        ]
      },
      clientId
    ) });
  }

  // packages/block-editor/build-module/components/inspector-controls-tabs/use-inspector-controls-tabs.js
  var import_components204 = __toESM(require_components());
  var import_data159 = __toESM(require_data());
  var EMPTY_ARRAY14 = [];
  function getShowTabs(blockName, tabSettings = {}) {
    if (tabSettings[blockName] !== void 0) {
      return tabSettings[blockName];
    }
    if (tabSettings.default !== void 0) {
      return tabSettings.default;
    }
    return true;
  }
  function useInspectorControlsTabs(blockName, contentClientIds, isSectionBlock2, hasBlockStyles) {
    const tabs = [];
    const {
      bindings: bindingsGroup,
      border: borderGroup,
      color: colorGroup,
      default: defaultGroup,
      dimensions: dimensionsGroup,
      list: listGroup,
      position: positionGroup,
      styles: stylesGroup,
      typography: typographyGroup,
      effects: effectsGroup
    } = groups_default;
    const listViewDisabled = use_is_list_view_tab_disabled_default(blockName);
    const listFills = (0, import_components204.__experimentalUseSlotFills)(listGroup.name);
    const hasListFills = !listViewDisabled && !!listFills && listFills.length;
    const styleFills = [
      ...(0, import_components204.__experimentalUseSlotFills)(borderGroup.name) || [],
      ...(0, import_components204.__experimentalUseSlotFills)(colorGroup.name) || [],
      ...(0, import_components204.__experimentalUseSlotFills)(dimensionsGroup.name) || [],
      ...(0, import_components204.__experimentalUseSlotFills)(stylesGroup.name) || [],
      ...(0, import_components204.__experimentalUseSlotFills)(typographyGroup.name) || [],
      ...(0, import_components204.__experimentalUseSlotFills)(effectsGroup.name) || []
    ];
    const hasStyleFills = styleFills.length;
    const advancedFills = [
      ...(0, import_components204.__experimentalUseSlotFills)(InspectorAdvancedControls.slotName) || [],
      ...(0, import_components204.__experimentalUseSlotFills)(bindingsGroup.name) || []
    ];
    const settingsFills = [
      ...(0, import_components204.__experimentalUseSlotFills)(defaultGroup.name) || [],
      ...(0, import_components204.__experimentalUseSlotFills)(positionGroup.name) || [],
      ...hasListFills && hasStyleFills > 1 ? advancedFills : []
    ];
    const hasContentTab = !!(contentClientIds && contentClientIds.length > 0);
    if (hasListFills && !isSectionBlock2) {
      tabs.push(TAB_LIST_VIEW);
    }
    if (hasContentTab) {
      tabs.push(TAB_CONTENT);
    }
    if (settingsFills.length && !isSectionBlock2) {
      tabs.push(TAB_SETTINGS);
    }
    if (isSectionBlock2 ? hasBlockStyles : hasStyleFills) {
      tabs.push(TAB_STYLES);
    }
    const tabSettings = (0, import_data159.useSelect)((select2) => {
      return select2(store).getSettings().blockInspectorTabs;
    }, []);
    const showTabs = getShowTabs(blockName, tabSettings);
    return showTabs ? tabs : EMPTY_ARRAY14;
  }

  // packages/block-editor/build-module/components/block-inspector/useBlockInspectorAnimationSettings.js
  var import_data160 = __toESM(require_data());
  function useBlockInspectorAnimationSettings(blockType) {
    return (0, import_data160.useSelect)(
      (select2) => {
        if (blockType) {
          const globalBlockInspectorAnimationSettings = select2(store).getSettings().blockInspectorAnimation;
          const animationParent = globalBlockInspectorAnimationSettings?.animationParent;
          const { getSelectedBlockClientId: getSelectedBlockClientId2, getBlockParentsByBlockName: getBlockParentsByBlockName2 } = select2(store);
          const _selectedBlockClientId = getSelectedBlockClientId2();
          const animationParentBlockClientId = getBlockParentsByBlockName2(
            _selectedBlockClientId,
            animationParent,
            true
          )[0];
          if (!animationParentBlockClientId && blockType.name !== animationParent) {
            return null;
          }
          return globalBlockInspectorAnimationSettings?.[blockType.name];
        }
        return null;
      },
      [blockType]
    );
  }

  // packages/block-editor/build-module/components/block-inspector/index.js
  function BlockStylesPanel({ clientId }) {
    return /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(import_components205.PanelBody, { title: (0, import_i18n194.__)("Styles"), children: /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(block_styles_default, { clientId }) });
  }
  function StyleInspectorSlots({
    blockName,
    showAdvancedControls = true,
    showPositionControls = true,
    showListControls = false,
    showBindingsControls = true
  }) {
    const borderPanelLabel = useBorderPanelLabel({ blockName });
    return /* @__PURE__ */ (0, import_jsx_runtime361.jsxs)(import_jsx_runtime361.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(inspector_controls_default.Slot, {}),
      showListControls && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(inspector_controls_default.Slot, { group: "list" }),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
        inspector_controls_default.Slot,
        {
          group: "color",
          label: (0, import_i18n194.__)("Color"),
          className: "color-block-support-panel__inner-wrapper"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
        inspector_controls_default.Slot,
        {
          group: "background",
          label: (0, import_i18n194.__)("Background image")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
        inspector_controls_default.Slot,
        {
          group: "typography",
          label: (0, import_i18n194.__)("Typography")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
        inspector_controls_default.Slot,
        {
          group: "dimensions",
          label: (0, import_i18n194.__)("Dimensions")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(inspector_controls_default.Slot, { group: "border", label: borderPanelLabel }),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(inspector_controls_default.Slot, { group: "styles" }),
      showPositionControls && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(position_controls_panel_default, {}),
      showBindingsControls && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(inspector_controls_default.Slot, { group: "bindings" }),
      showAdvancedControls && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(advanced_controls_panel_default, {}) })
    ] });
  }
  function BlockInspector() {
    const {
      selectedBlockCount,
      selectedBlockName,
      selectedBlockClientId,
      blockType,
      isSectionBlock: isSectionBlock2,
      isSectionBlockInSelection,
      hasBlockStyles
    } = (0, import_data161.useSelect)((select2) => {
      const {
        getSelectedBlockClientId: getSelectedBlockClientId2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        getSelectedBlockCount: getSelectedBlockCount2,
        getBlockName: getBlockName2,
        getParentSectionBlock: getParentSectionBlock2,
        isSectionBlock: _isSectionBlock
      } = unlock(select2(store));
      const { getBlockStyles: getBlockStyles2 } = select2(import_blocks88.store);
      const _selectedBlockClientId = getSelectedBlockClientId2();
      const renderedBlockClientId = getParentSectionBlock2(_selectedBlockClientId) || _selectedBlockClientId;
      const _selectedBlockName = renderedBlockClientId && getBlockName2(renderedBlockClientId);
      const _blockType = _selectedBlockName && (0, import_blocks88.getBlockType)(_selectedBlockName);
      const selectedBlockClientIds = getSelectedBlockClientIds2();
      const _isSectionBlockInSelection = selectedBlockClientIds.some(
        (id) => _isSectionBlock(id)
      );
      const blockStyles = _selectedBlockName && getBlockStyles2(_selectedBlockName);
      const _hasBlockStyles = blockStyles && blockStyles.length > 0;
      return {
        selectedBlockCount: getSelectedBlockCount2(),
        selectedBlockClientId: renderedBlockClientId,
        selectedBlockName: _selectedBlockName,
        blockType: _blockType,
        isSectionBlockInSelection: _isSectionBlockInSelection,
        isSectionBlock: _isSectionBlock(renderedBlockClientId),
        hasBlockStyles: _hasBlockStyles
      };
    }, []);
    const contentClientIds = (0, import_data161.useSelect)(
      (select2) => {
        if (!isSectionBlock2 || !selectedBlockClientId) {
          return [];
        }
        const {
          getClientIdsOfDescendants: getClientIdsOfDescendants2,
          getBlockName: getBlockName2,
          getBlockEditingMode: getBlockEditingMode2
        } = unlock(select2(store));
        const descendants = getClientIdsOfDescendants2(
          selectedBlockClientId
        );
        const navigationDescendants = /* @__PURE__ */ new Set();
        descendants.forEach((clientId) => {
          if (getBlockName2(clientId) === "core/navigation") {
            const navChildren = getClientIdsOfDescendants2(clientId);
            navChildren.forEach(
              (childId) => navigationDescendants.add(childId)
            );
          }
        });
        return descendants.filter((current) => {
          if (navigationDescendants.has(current)) {
            return false;
          }
          return getBlockName2(current) !== "core/list-item" && getBlockEditingMode2(current) === "contentOnly";
        });
      },
      [isSectionBlock2, selectedBlockClientId]
    );
    const availableTabs = useInspectorControlsTabs(
      blockType?.name,
      contentClientIds,
      isSectionBlock2,
      hasBlockStyles
    );
    const hasMultipleTabs = availableTabs?.length > 1;
    const blockInspectorAnimationSettings = useBlockInspectorAnimationSettings(blockType);
    const hasSelectedBlocks = selectedBlockCount > 1;
    if (hasSelectedBlocks && !isSectionBlockInSelection) {
      return /* @__PURE__ */ (0, import_jsx_runtime361.jsxs)("div", { className: "block-editor-block-inspector", children: [
        /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(MultiSelectionInspector, {}),
        hasMultipleTabs ? /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(InspectorControlsTabs, { tabs: availableTabs }) : /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
          StyleInspectorSlots,
          {
            blockName: selectedBlockName,
            showAdvancedControls: false,
            showPositionControls: false,
            showBindingsControls: false
          }
        )
      ] });
    }
    if (hasSelectedBlocks && isSectionBlockInSelection) {
      return /* @__PURE__ */ (0, import_jsx_runtime361.jsx)("div", { className: "block-editor-block-inspector", children: /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(MultiSelectionInspector, {}) });
    }
    const isSelectedBlockUnregistered = selectedBlockName === (0, import_blocks88.getUnregisteredTypeHandlerName)();
    const shouldShowWarning = !blockType || !selectedBlockClientId || isSelectedBlockUnregistered;
    if (shouldShowWarning) {
      return /* @__PURE__ */ (0, import_jsx_runtime361.jsx)("span", { className: "block-editor-block-inspector__no-blocks", children: (0, import_i18n194.__)("No block selected.") });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
      BlockInspectorSingleBlockWrapper,
      {
        animate: blockInspectorAnimationSettings,
        wrapper: (children) => /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
          AnimatedContainer,
          {
            blockInspectorAnimationSettings,
            selectedBlockClientId,
            children
          }
        ),
        children: /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
          BlockInspectorSingleBlock,
          {
            clientId: selectedBlockClientId,
            blockName: blockType.name,
            isSectionBlock: isSectionBlock2,
            availableTabs,
            contentClientIds,
            hasBlockStyles
          }
        )
      }
    );
  }
  var BlockInspectorSingleBlockWrapper = ({ animate, wrapper, children }) => {
    return animate ? wrapper(children) : children;
  };
  var AnimatedContainer = ({
    blockInspectorAnimationSettings,
    selectedBlockClientId,
    children
  }) => {
    const animationOrigin = blockInspectorAnimationSettings && blockInspectorAnimationSettings.enterDirection === "leftToRight" ? -50 : 50;
    return /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
      import_components205.__unstableMotion.div,
      {
        animate: {
          x: 0,
          opacity: 1,
          transition: {
            ease: "easeInOut",
            duration: 0.14
          }
        },
        initial: {
          x: animationOrigin,
          opacity: 0
        },
        children
      },
      selectedBlockClientId
    );
  };
  var BlockInspectorSingleBlock = ({
    clientId,
    blockName,
    isSectionBlock: isSectionBlock2,
    availableTabs,
    contentClientIds,
    hasBlockStyles
  }) => {
    const hasMultipleTabs = availableTabs?.length > 1;
    const blockInformation = useBlockDisplayInformation(clientId);
    const isBlockSynced = blockInformation.isSynced;
    const shouldShowTabs = !isBlockSynced && hasMultipleTabs;
    return /* @__PURE__ */ (0, import_jsx_runtime361.jsxs)("div", { className: "block-editor-block-inspector", children: [
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
        block_card_default,
        {
          ...blockInformation,
          className: isBlockSynced && "is-synced",
          allowParentNavigation: true,
          children: window?.__experimentalContentOnlyPatternInsertion && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(EditContentsButton, { clientId })
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(block_variation_transforms_default, { blockClientId: clientId }),
      shouldShowTabs && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
        InspectorControlsTabs,
        {
          hasBlockStyles,
          clientId,
          blockName,
          tabs: availableTabs,
          isSectionBlock: isSectionBlock2,
          contentClientIds
        }
      ),
      !shouldShowTabs && /* @__PURE__ */ (0, import_jsx_runtime361.jsxs)(import_jsx_runtime361.Fragment, { children: [
        hasBlockStyles && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(BlockStylesPanel, { clientId }),
        /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(content_tab_default, { contentClientIds }),
        !isSectionBlock2 && /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(
          StyleInspectorSlots,
          {
            blockName,
            showListControls: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime361.jsx)(SkipToSelectedBlock, {}, "back")
    ] });
  };
  var block_inspector_default = BlockInspector;

  // packages/block-editor/build-module/components/copy-handler/index.js
  var import_jsx_runtime362 = __toESM(require_jsx_runtime());
  var import_deprecated31 = __toESM(require_deprecated());
  var __unstableUseClipboardHandler = () => {
    (0, import_deprecated31.default)("__unstableUseClipboardHandler", {
      alternative: "BlockCanvas or WritingFlow",
      since: "6.4",
      version: "6.7"
    });
    return useClipboardHandler();
  };
  function CopyHandler(props) {
    (0, import_deprecated31.default)("CopyHandler", {
      alternative: "BlockCanvas or WritingFlow",
      since: "6.4",
      version: "6.7"
    });
    return /* @__PURE__ */ (0, import_jsx_runtime362.jsx)("div", { ...props, ref: useClipboardHandler() });
  }

  // packages/block-editor/build-module/components/inserter/library.js
  var import_jsx_runtime363 = __toESM(require_jsx_runtime());
  var import_data162 = __toESM(require_data());
  var import_element206 = __toESM(require_element());
  var noop19 = () => {
  };
  function InserterLibrary({
    rootClientId,
    clientId,
    isAppender,
    showInserterHelpPanel,
    showMostUsedBlocks = false,
    __experimentalInsertionIndex,
    __experimentalInitialTab,
    __experimentalInitialCategory,
    __experimentalFilterValue,
    onPatternCategorySelection,
    onSelect = noop19,
    shouldFocusBlock = false,
    onClose
  }, ref) {
    const { destinationRootClientId } = (0, import_data162.useSelect)(
      (select2) => {
        const { getBlockRootClientId: getBlockRootClientId2 } = select2(store);
        const _rootClientId = rootClientId || getBlockRootClientId2(clientId) || void 0;
        return {
          destinationRootClientId: _rootClientId
        };
      },
      [clientId, rootClientId]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime363.jsx)(
      PrivateInserterMenu,
      {
        onSelect,
        rootClientId: destinationRootClientId,
        clientId,
        isAppender,
        showInserterHelpPanel,
        showMostUsedBlocks,
        __experimentalInsertionIndex,
        __experimentalFilterValue,
        onPatternCategorySelection,
        __experimentalInitialTab,
        __experimentalInitialCategory,
        shouldFocusBlock,
        ref,
        onClose
      }
    );
  }
  var PrivateInserterLibrary = (0, import_element206.forwardRef)(InserterLibrary);
  function PublicInserterLibrary(props, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime363.jsx)(
      PrivateInserterLibrary,
      {
        ...props,
        onPatternCategorySelection: void 0,
        ref
      }
    );
  }
  var library_default = (0, import_element206.forwardRef)(PublicInserterLibrary);

  // packages/block-editor/build-module/components/selection-scroll-into-view/index.js
  var import_deprecated32 = __toESM(require_deprecated());
  function MultiSelectScrollIntoView() {
    (0, import_deprecated32.default)("wp.blockEditor.MultiSelectScrollIntoView", {
      hint: "This behaviour is now built-in.",
      since: "5.8"
    });
    return null;
  }

  // packages/block-editor/build-module/components/typewriter/index.js
  var import_jsx_runtime364 = __toESM(require_jsx_runtime());
  var import_compose87 = __toESM(require_compose());
  var import_dom39 = __toESM(require_dom());
  var import_data163 = __toESM(require_data());
  var import_keycodes26 = __toESM(require_keycodes());
  var isIE = window.navigator.userAgent.indexOf("Trident") !== -1;
  var arrowKeyCodes = /* @__PURE__ */ new Set([import_keycodes26.UP, import_keycodes26.DOWN, import_keycodes26.LEFT, import_keycodes26.RIGHT]);
  var initialTriggerPercentage = 0.75;
  function useTypewriter() {
    const hasSelectedBlock2 = (0, import_data163.useSelect)(
      (select2) => select2(store).hasSelectedBlock(),
      []
    );
    return (0, import_compose87.useRefEffect)(
      (node2) => {
        if (!hasSelectedBlock2) {
          return;
        }
        const { ownerDocument } = node2;
        const { defaultView } = ownerDocument;
        let scrollResizeRafId;
        let onKeyDownRafId;
        let caretRect;
        function onScrollResize() {
          if (scrollResizeRafId) {
            return;
          }
          scrollResizeRafId = defaultView.requestAnimationFrame(() => {
            computeCaretRectangle();
            scrollResizeRafId = null;
          });
        }
        function onKeyDown(event) {
          if (onKeyDownRafId) {
            defaultView.cancelAnimationFrame(onKeyDownRafId);
          }
          onKeyDownRafId = defaultView.requestAnimationFrame(() => {
            maintainCaretPosition(event);
            onKeyDownRafId = null;
          });
        }
        function maintainCaretPosition({ keyCode }) {
          if (!isSelectionEligibleForScroll()) {
            return;
          }
          const currentCaretRect = (0, import_dom39.computeCaretRect)(defaultView);
          if (!currentCaretRect) {
            return;
          }
          if (!caretRect) {
            caretRect = currentCaretRect;
            return;
          }
          if (arrowKeyCodes.has(keyCode)) {
            caretRect = currentCaretRect;
            return;
          }
          const diff = currentCaretRect.top - caretRect.top;
          if (diff === 0) {
            return;
          }
          const scrollContainer = (0, import_dom39.getScrollContainer)(node2);
          if (!scrollContainer) {
            return;
          }
          const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
          const scrollY = windowScroll ? defaultView.scrollY : scrollContainer.scrollTop;
          const scrollContainerY = windowScroll ? 0 : scrollContainer.getBoundingClientRect().top;
          const relativeScrollPosition = windowScroll ? caretRect.top / defaultView.innerHeight : (caretRect.top - scrollContainerY) / (defaultView.innerHeight - scrollContainerY);
          if (scrollY === 0 && relativeScrollPosition < initialTriggerPercentage && isLastEditableNode()) {
            caretRect = currentCaretRect;
            return;
          }
          const scrollContainerHeight = windowScroll ? defaultView.innerHeight : scrollContainer.clientHeight;
          if (
            // The caret is under the lower fold.
            caretRect.top + caretRect.height > scrollContainerY + scrollContainerHeight || // The caret is above the upper fold.
            caretRect.top < scrollContainerY
          ) {
            caretRect = currentCaretRect;
            return;
          }
          if (windowScroll) {
            defaultView.scrollBy(0, diff);
          } else {
            scrollContainer.scrollTop += diff;
          }
        }
        function addSelectionChangeListener() {
          ownerDocument.addEventListener(
            "selectionchange",
            computeCaretRectOnSelectionChange
          );
        }
        function computeCaretRectOnSelectionChange() {
          ownerDocument.removeEventListener(
            "selectionchange",
            computeCaretRectOnSelectionChange
          );
          computeCaretRectangle();
        }
        function computeCaretRectangle() {
          if (isSelectionEligibleForScroll()) {
            caretRect = (0, import_dom39.computeCaretRect)(defaultView);
          }
        }
        function isSelectionEligibleForScroll() {
          return node2.contains(ownerDocument.activeElement) && ownerDocument.activeElement.isContentEditable;
        }
        function isLastEditableNode() {
          const editableNodes = node2.querySelectorAll(
            '[contenteditable="true"]'
          );
          const lastEditableNode = editableNodes[editableNodes.length - 1];
          return lastEditableNode === ownerDocument.activeElement;
        }
        defaultView.addEventListener("scroll", onScrollResize, true);
        defaultView.addEventListener("resize", onScrollResize, true);
        node2.addEventListener("keydown", onKeyDown);
        node2.addEventListener("keyup", maintainCaretPosition);
        node2.addEventListener("mousedown", addSelectionChangeListener);
        node2.addEventListener("touchstart", addSelectionChangeListener);
        return () => {
          defaultView.removeEventListener(
            "scroll",
            onScrollResize,
            true
          );
          defaultView.removeEventListener(
            "resize",
            onScrollResize,
            true
          );
          node2.removeEventListener("keydown", onKeyDown);
          node2.removeEventListener("keyup", maintainCaretPosition);
          node2.removeEventListener(
            "mousedown",
            addSelectionChangeListener
          );
          node2.removeEventListener(
            "touchstart",
            addSelectionChangeListener
          );
          ownerDocument.removeEventListener(
            "selectionchange",
            computeCaretRectOnSelectionChange
          );
          defaultView.cancelAnimationFrame(scrollResizeRafId);
          defaultView.cancelAnimationFrame(onKeyDownRafId);
        };
      },
      [hasSelectedBlock2]
    );
  }
  function Typewriter({ children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime364.jsx)("div", { ref: useTypewriter(), className: "block-editor__typewriter", children });
  }
  var TypewriterOrIEBypass = isIE ? (props) => props.children : Typewriter;
  var typewriter_default = TypewriterOrIEBypass;

  // packages/block-editor/build-module/components/recursion-provider/index.js
  var import_jsx_runtime365 = __toESM(require_jsx_runtime());
  var import_element207 = __toESM(require_element());
  var import_deprecated33 = __toESM(require_deprecated());
  var RenderedRefsContext = (0, import_element207.createContext)({});
  RenderedRefsContext.displayName = "RenderedRefsContext";
  function addToBlockType(renderedBlocks, blockName, uniqueId2) {
    const result = {
      ...renderedBlocks,
      [blockName]: renderedBlocks[blockName] ? new Set(renderedBlocks[blockName]) : /* @__PURE__ */ new Set()
    };
    result[blockName].add(uniqueId2);
    return result;
  }
  function RecursionProvider({ children, uniqueId: uniqueId2, blockName = "" }) {
    const previouslyRenderedBlocks = (0, import_element207.useContext)(RenderedRefsContext);
    const { name } = useBlockEditContext();
    blockName = blockName || name;
    const newRenderedBlocks = (0, import_element207.useMemo)(
      () => addToBlockType(previouslyRenderedBlocks, blockName, uniqueId2),
      [previouslyRenderedBlocks, blockName, uniqueId2]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime365.jsx)(RenderedRefsContext.Provider, { value: newRenderedBlocks, children });
  }
  function useHasRecursion(uniqueId2, blockName = "") {
    const previouslyRenderedBlocks = (0, import_element207.useContext)(RenderedRefsContext);
    const { name } = useBlockEditContext();
    blockName = blockName || name;
    return Boolean(previouslyRenderedBlocks[blockName]?.has(uniqueId2));
  }
  var DeprecatedExperimentalRecursionProvider = (props) => {
    (0, import_deprecated33.default)("wp.blockEditor.__experimentalRecursionProvider", {
      since: "6.5",
      alternative: "wp.blockEditor.RecursionProvider"
    });
    return /* @__PURE__ */ (0, import_jsx_runtime365.jsx)(RecursionProvider, { ...props });
  };
  var DeprecatedExperimentalUseHasRecursion = (...args) => {
    (0, import_deprecated33.default)("wp.blockEditor.__experimentalUseHasRecursion", {
      since: "6.5",
      alternative: "wp.blockEditor.useHasRecursion"
    });
    return useHasRecursion(...args);
  };

  // packages/block-editor/build-module/components/publish-date-time-picker/index.js
  var import_jsx_runtime367 = __toESM(require_jsx_runtime());
  var import_components207 = __toESM(require_components());
  var import_i18n196 = __toESM(require_i18n());
  var import_element208 = __toESM(require_element());
  var import_date2 = __toESM(require_date());

  // packages/block-editor/build-module/components/inspector-popover-header/index.js
  var import_jsx_runtime366 = __toESM(require_jsx_runtime());
  var import_components206 = __toESM(require_components());
  var import_i18n195 = __toESM(require_i18n());
  function InspectorPopoverHeader({
    title,
    help,
    actions = [],
    onClose
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime366.jsxs)(import_components206.__experimentalVStack, { className: "block-editor-inspector-popover-header", spacing: 4, children: [
      /* @__PURE__ */ (0, import_jsx_runtime366.jsxs)(import_components206.__experimentalHStack, { alignment: "center", children: [
        /* @__PURE__ */ (0, import_jsx_runtime366.jsx)(
          import_components206.__experimentalHeading,
          {
            className: "block-editor-inspector-popover-header__heading",
            level: 2,
            size: 13,
            children: title
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime366.jsx)(import_components206.__experimentalSpacer, {}),
        actions.map(({ label, icon, onClick }) => /* @__PURE__ */ (0, import_jsx_runtime366.jsx)(
          import_components206.Button,
          {
            size: "small",
            className: "block-editor-inspector-popover-header__action",
            label,
            icon,
            variant: !icon && "tertiary",
            onClick,
            children: !icon && label
          },
          label
        )),
        onClose && /* @__PURE__ */ (0, import_jsx_runtime366.jsx)(
          import_components206.Button,
          {
            size: "small",
            className: "block-editor-inspector-popover-header__action",
            label: (0, import_i18n195.__)("Close"),
            icon: close_small_default,
            onClick: onClose
          }
        )
      ] }),
      help && /* @__PURE__ */ (0, import_jsx_runtime366.jsx)(import_components206.__experimentalText, { children: help })
    ] });
  }

  // packages/block-editor/build-module/components/publish-date-time-picker/index.js
  function PublishDateTimePicker({
    onClose,
    onChange,
    showPopoverHeaderActions,
    isCompact,
    currentDate,
    title,
    ...additionalProps
  }, ref) {
    const datePickerProps = {
      startOfWeek: (0, import_date2.getSettings)().l10n.startOfWeek,
      onChange,
      currentDate: isCompact ? void 0 : currentDate,
      currentTime: isCompact ? currentDate : void 0,
      ...additionalProps
    };
    const DatePickerComponent = isCompact ? import_components207.TimePicker : import_components207.DateTimePicker;
    return /* @__PURE__ */ (0, import_jsx_runtime367.jsxs)("div", { ref, className: "block-editor-publish-date-time-picker", children: [
      /* @__PURE__ */ (0, import_jsx_runtime367.jsx)(
        InspectorPopoverHeader,
        {
          title: title || (0, import_i18n196.__)("Publish"),
          actions: showPopoverHeaderActions ? [
            {
              label: (0, import_i18n196.__)("Now"),
              onClick: () => onChange?.(null)
            }
          ] : void 0,
          onClose
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime367.jsx)(DatePickerComponent, { ...datePickerProps })
    ] });
  }
  var PrivatePublishDateTimePicker = (0, import_element208.forwardRef)(PublishDateTimePicker);
  function PublicPublishDateTimePicker(props, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime367.jsx)(
      PrivatePublishDateTimePicker,
      {
        ...props,
        showPopoverHeaderActions: true,
        isCompact: false,
        ref
      }
    );
  }
  var publish_date_time_picker_default = (0, import_element208.forwardRef)(PublicPublishDateTimePicker);

  // packages/block-editor/build-module/components/block-editing-mode/index.js
  var import_data164 = __toESM(require_data());
  var import_element209 = __toESM(require_element());
  function useBlockEditingMode(mode2) {
    const context = useBlockEditContext();
    const { clientId = "" } = context;
    const { setBlockEditingMode: setBlockEditingMode2, unsetBlockEditingMode: unsetBlockEditingMode2 } = (0, import_data164.useDispatch)(store);
    const globalBlockEditingMode = (0, import_data164.useSelect)(
      (select2) => (
        // Avoid adding the subscription if not needed!
        clientId ? null : select2(store).getBlockEditingMode()
      ),
      [clientId]
    );
    (0, import_element209.useEffect)(() => {
      if (mode2) {
        setBlockEditingMode2(clientId, mode2);
      }
      return () => {
        if (mode2) {
          unsetBlockEditingMode2(clientId);
        }
      };
    }, [clientId, mode2, setBlockEditingMode2, unsetBlockEditingMode2]);
    return clientId ? context[blockEditingModeKey] : globalBlockEditingMode;
  }

  // packages/block-editor/build-module/hooks/utils.js
  var cleanEmptyObject = (object) => {
    if (object === null || typeof object !== "object" || Array.isArray(object)) {
      return object;
    }
    const cleanedNestedObjects = Object.entries(object).map(([key, value]) => [key, cleanEmptyObject(value)]).filter(([, value]) => value !== void 0);
    return !cleanedNestedObjects.length ? void 0 : Object.fromEntries(cleanedNestedObjects);
  };
  function transformStyles2(activeSupports, migrationPaths, result, source, index, results) {
    if (Object.values(activeSupports ?? {}).every(
      (isActive) => !isActive
    )) {
      return result;
    }
    if (results.length === 1 && result.innerBlocks.length === source.length) {
      return result;
    }
    let referenceBlockAttributes = source[0]?.attributes;
    if (results.length > 1 && source.length > 1) {
      if (source[index]) {
        referenceBlockAttributes = source[index]?.attributes;
      } else {
        return result;
      }
    }
    let returnBlock = result;
    Object.entries(activeSupports).forEach(([support, isActive]) => {
      if (isActive) {
        migrationPaths[support].forEach((path) => {
          const styleValue = getValueFromObjectPath(
            referenceBlockAttributes,
            path
          );
          if (styleValue) {
            returnBlock = {
              ...returnBlock,
              attributes: setImmutably(
                returnBlock.attributes,
                path,
                styleValue
              )
            };
          }
        });
      }
    });
    return returnBlock;
  }
  function shouldSkipSerialization(blockNameOrType, featureSet, feature) {
    const support = (0, import_blocks89.getBlockSupport)(blockNameOrType, featureSet);
    const skipSerialization = support?.__experimentalSkipSerialization;
    if (Array.isArray(skipSerialization)) {
      return skipSerialization.includes(feature);
    }
    return skipSerialization;
  }
  var pendingStyleOverrides = /* @__PURE__ */ new WeakMap();
  function useStyleOverride({ id, css }) {
    return usePrivateStyleOverride({ id, css });
  }
  function usePrivateStyleOverride({
    id,
    css,
    assets,
    __unstableType,
    variation,
    clientId
  } = {}) {
    const { setStyleOverride: setStyleOverride2, deleteStyleOverride: deleteStyleOverride2 } = unlock(
      (0, import_data165.useDispatch)(store)
    );
    const registry = (0, import_data165.useRegistry)();
    const fallbackId = (0, import_element210.useId)();
    (0, import_element210.useEffect)(() => {
      if (!css && !assets) {
        return;
      }
      const _id = id || fallbackId;
      const override = {
        id,
        css,
        assets,
        __unstableType,
        variation,
        clientId
      };
      if (!pendingStyleOverrides.get(registry)) {
        pendingStyleOverrides.set(registry, []);
      }
      pendingStyleOverrides.get(registry).push([_id, override]);
      window.queueMicrotask(() => {
        if (pendingStyleOverrides.get(registry)?.length) {
          registry.batch(() => {
            pendingStyleOverrides.get(registry).forEach((args) => {
              setStyleOverride2(...args);
            });
            pendingStyleOverrides.set(registry, []);
          });
        }
      });
      return () => {
        const isPending = pendingStyleOverrides.get(registry)?.find(([currentId]) => currentId === _id);
        if (isPending) {
          pendingStyleOverrides.set(
            registry,
            pendingStyleOverrides.get(registry).filter(([currentId]) => currentId !== _id)
          );
        } else {
          deleteStyleOverride2(_id);
        }
      };
    }, [
      id,
      css,
      clientId,
      assets,
      __unstableType,
      fallbackId,
      setStyleOverride2,
      deleteStyleOverride2,
      registry
    ]);
  }
  function useBlockSettings(name, parentLayout) {
    const [
      backgroundImage,
      backgroundSize,
      customFontFamilies,
      defaultFontFamilies,
      themeFontFamilies,
      defaultFontSizesEnabled,
      customFontSizes,
      defaultFontSizes,
      themeFontSizes,
      customFontSize,
      fontStyle,
      fontWeight,
      lineHeight,
      textAlign,
      textColumns,
      textDecoration,
      writingMode,
      textTransform,
      letterSpacing,
      padding,
      margin,
      blockGap,
      defaultSpacingSizesEnabled,
      customSpacingSize,
      userSpacingSizes,
      defaultSpacingSizes,
      themeSpacingSizes,
      units2,
      aspectRatio,
      minHeight,
      layout,
      borderColor,
      borderRadius,
      borderStyle,
      borderWidth,
      borderRadiusSizes,
      customColorsEnabled,
      customColors,
      customDuotone,
      themeColors,
      defaultColors,
      defaultPalette,
      defaultDuotone,
      userDuotonePalette,
      themeDuotonePalette,
      defaultDuotonePalette,
      userGradientPalette,
      themeGradientPalette,
      defaultGradientPalette,
      defaultGradients,
      areCustomGradientsEnabled,
      isBackgroundEnabled,
      isLinkEnabled,
      isTextEnabled,
      isHeadingEnabled,
      isButtonEnabled,
      shadow
    ] = useSettings(
      "background.backgroundImage",
      "background.backgroundSize",
      "typography.fontFamilies.custom",
      "typography.fontFamilies.default",
      "typography.fontFamilies.theme",
      "typography.defaultFontSizes",
      "typography.fontSizes.custom",
      "typography.fontSizes.default",
      "typography.fontSizes.theme",
      "typography.customFontSize",
      "typography.fontStyle",
      "typography.fontWeight",
      "typography.lineHeight",
      "typography.textAlign",
      "typography.textColumns",
      "typography.textDecoration",
      "typography.writingMode",
      "typography.textTransform",
      "typography.letterSpacing",
      "spacing.padding",
      "spacing.margin",
      "spacing.blockGap",
      "spacing.defaultSpacingSizes",
      "spacing.customSpacingSize",
      "spacing.spacingSizes.custom",
      "spacing.spacingSizes.default",
      "spacing.spacingSizes.theme",
      "spacing.units",
      "dimensions.aspectRatio",
      "dimensions.minHeight",
      "layout",
      "border.color",
      "border.radius",
      "border.style",
      "border.width",
      "border.radiusSizes",
      "color.custom",
      "color.palette.custom",
      "color.customDuotone",
      "color.palette.theme",
      "color.palette.default",
      "color.defaultPalette",
      "color.defaultDuotone",
      "color.duotone.custom",
      "color.duotone.theme",
      "color.duotone.default",
      "color.gradients.custom",
      "color.gradients.theme",
      "color.gradients.default",
      "color.defaultGradients",
      "color.customGradient",
      "color.background",
      "color.link",
      "color.text",
      "color.heading",
      "color.button",
      "shadow"
    );
    const rawSettings = (0, import_element210.useMemo)(() => {
      return {
        background: {
          backgroundImage,
          backgroundSize
        },
        color: {
          palette: {
            custom: customColors,
            theme: themeColors,
            default: defaultColors
          },
          gradients: {
            custom: userGradientPalette,
            theme: themeGradientPalette,
            default: defaultGradientPalette
          },
          duotone: {
            custom: userDuotonePalette,
            theme: themeDuotonePalette,
            default: defaultDuotonePalette
          },
          defaultGradients,
          defaultPalette,
          defaultDuotone,
          custom: customColorsEnabled,
          customGradient: areCustomGradientsEnabled,
          customDuotone,
          background: isBackgroundEnabled,
          link: isLinkEnabled,
          heading: isHeadingEnabled,
          button: isButtonEnabled,
          text: isTextEnabled
        },
        typography: {
          fontFamilies: {
            custom: customFontFamilies,
            default: defaultFontFamilies,
            theme: themeFontFamilies
          },
          fontSizes: {
            custom: customFontSizes,
            default: defaultFontSizes,
            theme: themeFontSizes
          },
          customFontSize,
          defaultFontSizes: defaultFontSizesEnabled,
          fontStyle,
          fontWeight,
          lineHeight,
          textAlign,
          textColumns,
          textDecoration,
          textTransform,
          letterSpacing,
          writingMode
        },
        spacing: {
          spacingSizes: {
            custom: userSpacingSizes,
            default: defaultSpacingSizes,
            theme: themeSpacingSizes
          },
          customSpacingSize,
          defaultSpacingSizes: defaultSpacingSizesEnabled,
          padding,
          margin,
          blockGap,
          units: units2
        },
        border: {
          color: borderColor,
          radius: borderRadius,
          style: borderStyle,
          width: borderWidth,
          radiusSizes: borderRadiusSizes
        },
        dimensions: {
          aspectRatio,
          minHeight
        },
        layout,
        parentLayout,
        shadow
      };
    }, [
      backgroundImage,
      backgroundSize,
      customFontFamilies,
      defaultFontFamilies,
      themeFontFamilies,
      defaultFontSizesEnabled,
      customFontSizes,
      defaultFontSizes,
      themeFontSizes,
      customFontSize,
      fontStyle,
      fontWeight,
      lineHeight,
      textAlign,
      textColumns,
      textDecoration,
      textTransform,
      letterSpacing,
      writingMode,
      padding,
      margin,
      blockGap,
      defaultSpacingSizesEnabled,
      customSpacingSize,
      userSpacingSizes,
      defaultSpacingSizes,
      themeSpacingSizes,
      units2,
      aspectRatio,
      minHeight,
      layout,
      parentLayout,
      borderColor,
      borderRadius,
      borderStyle,
      borderWidth,
      borderRadiusSizes,
      customColorsEnabled,
      customColors,
      customDuotone,
      themeColors,
      defaultColors,
      defaultPalette,
      defaultDuotone,
      userDuotonePalette,
      themeDuotonePalette,
      defaultDuotonePalette,
      userGradientPalette,
      themeGradientPalette,
      defaultGradientPalette,
      defaultGradients,
      areCustomGradientsEnabled,
      isBackgroundEnabled,
      isLinkEnabled,
      isTextEnabled,
      isHeadingEnabled,
      isButtonEnabled,
      shadow
    ]);
    return useSettingsForBlockElement(rawSettings, name);
  }
  function createBlockEditFilter(features) {
    features = features.map((settings2) => {
      return { ...settings2, Edit: (0, import_element210.memo)(settings2.edit) };
    });
    const withBlockEditHooks = (0, import_compose88.createHigherOrderComponent)(
      (OriginalBlockEdit) => (props) => {
        const context = useBlockEditContext();
        return [
          ...features.map((feature, i2) => {
            const {
              Edit: Edit4,
              hasSupport,
              attributeKeys = [],
              shareWithChildBlocks
            } = feature;
            const shouldDisplayControls = context[mayDisplayControlsKey] || context[mayDisplayParentControlsKey] && shareWithChildBlocks;
            if (!shouldDisplayControls || !hasSupport(props.name)) {
              return null;
            }
            const neededProps = {};
            for (const key of attributeKeys) {
              if (props.attributes[key]) {
                neededProps[key] = props.attributes[key];
              }
            }
            return /* @__PURE__ */ (0, import_jsx_runtime368.jsx)(
              Edit4,
              {
                name: props.name,
                isSelected: props.isSelected,
                clientId: props.clientId,
                setAttributes: props.setAttributes,
                __unstableParentLayout: props.__unstableParentLayout,
                ...neededProps
              },
              i2
            );
          }),
          /* @__PURE__ */ (0, import_jsx_runtime368.jsx)(OriginalBlockEdit, { ...props }, "edit")
        ];
      },
      "withBlockEditHooks"
    );
    (0, import_hooks13.addFilter)("editor.BlockEdit", "core/editor/hooks", withBlockEditHooks);
  }
  function BlockProps({
    index,
    useBlockProps: hook,
    setAllWrapperProps,
    ...props
  }) {
    const wrapperProps = hook(props);
    const setWrapperProps = (next2) => setAllWrapperProps((prev2) => {
      const nextAll = [...prev2];
      nextAll[index] = next2;
      return nextAll;
    });
    (0, import_element210.useEffect)(() => {
      setWrapperProps(wrapperProps);
      return () => {
        setWrapperProps(void 0);
      };
    });
    return null;
  }
  var BlockPropsPure = (0, import_element210.memo)(BlockProps);
  function createBlockListBlockFilter(features) {
    const withBlockListBlockHooks = (0, import_compose88.createHigherOrderComponent)(
      (BlockListBlock2) => (props) => {
        const [allWrapperProps, setAllWrapperProps] = (0, import_element210.useState)(
          Array(features.length).fill(void 0)
        );
        return [
          ...features.map((feature, i2) => {
            const {
              hasSupport,
              attributeKeys = [],
              useBlockProps: useBlockProps15,
              isMatch
            } = feature;
            const neededProps = {};
            for (const key of attributeKeys) {
              if (props.attributes[key]) {
                neededProps[key] = props.attributes[key];
              }
            }
            if (
              // Skip rendering if none of the needed attributes are
              // set.
              !Object.keys(neededProps).length || !hasSupport(props.name) || isMatch && !isMatch(neededProps)
            ) {
              return null;
            }
            return /* @__PURE__ */ (0, import_jsx_runtime368.jsx)(
              BlockPropsPure,
              {
                index: i2,
                useBlockProps: useBlockProps15,
                setAllWrapperProps,
                name: props.name,
                clientId: props.clientId,
                ...neededProps
              },
              i2
            );
          }),
          /* @__PURE__ */ (0, import_jsx_runtime368.jsx)(
            BlockListBlock2,
            {
              ...props,
              wrapperProps: allWrapperProps.filter(Boolean).reduce((acc, wrapperProps) => {
                return {
                  ...acc,
                  ...wrapperProps,
                  className: clsx_default(
                    acc.className,
                    wrapperProps.className
                  ),
                  style: {
                    ...acc.style,
                    ...wrapperProps.style
                  }
                };
              }, props.wrapperProps || {})
            },
            "edit"
          )
        ];
      },
      "withBlockListBlockHooks"
    );
    (0, import_hooks13.addFilter)(
      "editor.BlockListBlock",
      "core/editor/hooks",
      withBlockListBlockHooks
    );
  }
  function createBlockSaveFilter(features) {
    function extraPropsFromHooks(props, name, attributes) {
      return features.reduce((accu, feature) => {
        const { hasSupport, attributeKeys = [], addSaveProps: addSaveProps10 } = feature;
        const neededAttributes = {};
        for (const key of attributeKeys) {
          if (attributes[key]) {
            neededAttributes[key] = attributes[key];
          }
        }
        if (
          // Skip rendering if none of the needed attributes are
          // set.
          !Object.keys(neededAttributes).length || !hasSupport(name)
        ) {
          return accu;
        }
        return addSaveProps10(accu, name, neededAttributes);
      }, props);
    }
    (0, import_hooks13.addFilter)(
      "blocks.getSaveContent.extraProps",
      "core/editor/hooks",
      extraPropsFromHooks,
      0
    );
    (0, import_hooks13.addFilter)(
      "blocks.getSaveContent.extraProps",
      "core/editor/hooks",
      (props) => {
        if (props.hasOwnProperty("className") && !props.className) {
          delete props.className;
        }
        return props;
      }
    );
  }

  // packages/block-editor/build-module/hooks/compat.js
  var import_blocks90 = __toESM(require_blocks());
  var import_hooks15 = __toESM(require_hooks());
  function migrateLightBlockWrapper(settings2) {
    const { apiVersion = 1 } = settings2;
    if (apiVersion < 2 && (0, import_blocks90.hasBlockSupport)(settings2, "lightBlockWrapper", false)) {
      settings2.apiVersion = 2;
    }
    return settings2;
  }
  (0, import_hooks15.addFilter)(
    "blocks.registerBlockType",
    "core/compat/migrateLightBlockWrapper",
    migrateLightBlockWrapper
  );

  // packages/block-editor/build-module/hooks/align.js
  var import_jsx_runtime369 = __toESM(require_jsx_runtime());
  var import_hooks16 = __toESM(require_hooks());
  var import_blocks91 = __toESM(require_blocks());
  var ALL_ALIGNMENTS = ["left", "center", "right", "wide", "full"];
  var WIDE_ALIGNMENTS = ["wide", "full"];
  function getValidAlignments(blockAlign, hasWideBlockSupport = true, hasWideEnabled = true) {
    let validAlignments;
    if (Array.isArray(blockAlign)) {
      validAlignments = ALL_ALIGNMENTS.filter(
        (value) => blockAlign.includes(value)
      );
    } else if (blockAlign === true) {
      validAlignments = [...ALL_ALIGNMENTS];
    } else {
      validAlignments = [];
    }
    if (!hasWideEnabled || blockAlign === true && !hasWideBlockSupport) {
      return validAlignments.filter(
        (alignment) => !WIDE_ALIGNMENTS.includes(alignment)
      );
    }
    return validAlignments;
  }
  function addAttribute(settings2) {
    if ("type" in (settings2.attributes?.align ?? {})) {
      return settings2;
    }
    if ((0, import_blocks91.hasBlockSupport)(settings2, "align")) {
      settings2.attributes = {
        ...settings2.attributes,
        align: {
          type: "string",
          // Allow for '' since it is used by the `updateAlignment` function
          // in toolbar controls for special cases with defined default values.
          enum: [...ALL_ALIGNMENTS, ""]
        }
      };
    }
    return settings2;
  }
  function BlockEditAlignmentToolbarControlsPure({
    name: blockName,
    align,
    setAttributes
  }) {
    const blockAllowedAlignments = getValidAlignments(
      (0, import_blocks91.getBlockSupport)(blockName, "align"),
      (0, import_blocks91.hasBlockSupport)(blockName, "alignWide", true)
    );
    const validAlignments = useAvailableAlignments(
      blockAllowedAlignments
    ).map(({ name }) => name);
    const blockEditingMode = useBlockEditingMode();
    if (!validAlignments.length || blockEditingMode !== "default") {
      return null;
    }
    const updateAlignment = (nextAlign) => {
      if (!nextAlign) {
        const blockType = (0, import_blocks91.getBlockType)(blockName);
        const blockDefaultAlign = blockType?.attributes?.align?.default;
        if (blockDefaultAlign) {
          nextAlign = "";
        }
      }
      setAttributes({ align: nextAlign });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime369.jsx)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: /* @__PURE__ */ (0, import_jsx_runtime369.jsx)(
      BlockAlignmentControl,
      {
        value: align,
        onChange: updateAlignment,
        controls: validAlignments
      }
    ) });
  }
  var align_default = {
    shareWithChildBlocks: true,
    edit: BlockEditAlignmentToolbarControlsPure,
    useBlockProps: useBlockProps6,
    addSaveProps: addAssignedAlign,
    attributeKeys: ["align"],
    hasSupport(name) {
      return (0, import_blocks91.hasBlockSupport)(name, "align", false);
    }
  };
  function useBlockProps6({ name, align }) {
    const blockAllowedAlignments = getValidAlignments(
      (0, import_blocks91.getBlockSupport)(name, "align"),
      (0, import_blocks91.hasBlockSupport)(name, "alignWide", true)
    );
    const validAlignments = useAvailableAlignments(blockAllowedAlignments);
    if (validAlignments.some((alignment) => alignment.name === align)) {
      return { "data-align": align };
    }
    return {};
  }
  function addAssignedAlign(props, blockType, attributes) {
    const { align } = attributes;
    const blockAlign = (0, import_blocks91.getBlockSupport)(blockType, "align");
    const hasWideBlockSupport = (0, import_blocks91.hasBlockSupport)(blockType, "alignWide", true);
    const isAlignValid = getValidAlignments(
      blockAlign,
      hasWideBlockSupport
    ).includes(align);
    if (isAlignValid) {
      props.className = clsx_default(`align${align}`, props.className);
    }
    return props;
  }
  (0, import_hooks16.addFilter)(
    "blocks.registerBlockType",
    "core/editor/align/addAttribute",
    addAttribute
  );

  // packages/block-editor/build-module/hooks/lock.js
  var import_hooks17 = __toESM(require_hooks());
  function addAttribute2(settings2) {
    if ("type" in (settings2.attributes?.lock ?? {})) {
      return settings2;
    }
    settings2.attributes = {
      ...settings2.attributes,
      lock: {
        type: "object"
      }
    };
    return settings2;
  }
  (0, import_hooks17.addFilter)("blocks.registerBlockType", "core/lock/addAttribute", addAttribute2);

  // packages/block-editor/build-module/hooks/allowed-blocks.js
  var import_jsx_runtime375 = __toESM(require_jsx_runtime());
  var import_hooks18 = __toESM(require_hooks());
  var import_blocks94 = __toESM(require_blocks());
  var import_data169 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-allowed-blocks/allowed-blocks-control.js
  var import_jsx_runtime374 = __toESM(require_jsx_runtime());
  var import_components214 = __toESM(require_components());
  var import_i18n199 = __toESM(require_i18n());
  var import_element214 = __toESM(require_element());
  var import_data168 = __toESM(require_data());
  var import_blocks93 = __toESM(require_blocks());

  // packages/block-editor/build-module/components/block-allowed-blocks/modal.js
  var import_jsx_runtime373 = __toESM(require_jsx_runtime());
  var import_components213 = __toESM(require_components());
  var import_element213 = __toESM(require_element());
  var import_i18n198 = __toESM(require_i18n());
  var import_data167 = __toESM(require_data());

  // packages/block-editor/build-module/components/block-manager/index.js
  var import_jsx_runtime372 = __toESM(require_jsx_runtime());
  var import_blocks92 = __toESM(require_blocks());
  var import_data166 = __toESM(require_data());
  var import_components212 = __toESM(require_components());
  var import_i18n197 = __toESM(require_i18n());
  var import_element212 = __toESM(require_element());
  var import_compose90 = __toESM(require_compose());
  var import_a11y19 = __toESM(require_a11y());

  // packages/block-editor/build-module/components/block-manager/category.js
  var import_jsx_runtime371 = __toESM(require_jsx_runtime());
  var import_element211 = __toESM(require_element());
  var import_compose89 = __toESM(require_compose());
  var import_components211 = __toESM(require_components());

  // packages/block-editor/build-module/components/block-manager/checklist.js
  var import_jsx_runtime370 = __toESM(require_jsx_runtime());
  var import_components210 = __toESM(require_components());
  function BlockTypesChecklist({ blockTypes, value, onItemChange }) {
    return /* @__PURE__ */ (0, import_jsx_runtime370.jsx)("ul", { className: "block-editor-block-manager__checklist", children: blockTypes.map((blockType) => /* @__PURE__ */ (0, import_jsx_runtime370.jsxs)(
      "li",
      {
        className: "block-editor-block-manager__checklist-item",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime370.jsx)(
            import_components210.CheckboxControl,
            {
              __nextHasNoMarginBottom: true,
              label: blockType.title,
              checked: value.includes(blockType.name),
              onChange: (...args) => onItemChange(blockType, ...args)
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime370.jsx)(block_icon_default, { icon: blockType.icon })
        ]
      },
      blockType.name
    )) });
  }
  var checklist_default = BlockTypesChecklist;

  // packages/block-editor/build-module/components/block-manager/category.js
  function BlockManagerCategory({
    title,
    blockTypes,
    selectedBlockTypes,
    onChange
  }) {
    const instanceId = (0, import_compose89.useInstanceId)(BlockManagerCategory);
    const toggleVisible = (0, import_element211.useCallback)(
      (blockType, nextIsChecked) => {
        if (nextIsChecked) {
          onChange([...selectedBlockTypes, blockType]);
        } else {
          onChange(
            selectedBlockTypes.filter(
              ({ name }) => name !== blockType.name
            )
          );
        }
      },
      [selectedBlockTypes, onChange]
    );
    const toggleAllVisible = (0, import_element211.useCallback)(
      (nextIsChecked) => {
        if (nextIsChecked) {
          onChange([
            ...selectedBlockTypes,
            ...blockTypes.filter(
              (blockType) => !selectedBlockTypes.find(
                ({ name }) => name === blockType.name
              )
            )
          ]);
        } else {
          onChange(
            selectedBlockTypes.filter(
              (selectedBlockType) => !blockTypes.find(
                ({ name }) => name === selectedBlockType.name
              )
            )
          );
        }
      },
      [blockTypes, selectedBlockTypes, onChange]
    );
    if (!blockTypes.length) {
      return null;
    }
    const checkedBlockNames = blockTypes.map(({ name }) => name).filter(
      (type) => (selectedBlockTypes ?? []).some(
        (selectedBlockType) => selectedBlockType.name === type
      )
    );
    const titleId = "block-editor-block-manager__category-title-" + instanceId;
    const isAllChecked = checkedBlockNames.length === blockTypes.length;
    const isIndeterminate = !isAllChecked && checkedBlockNames.length > 0;
    return /* @__PURE__ */ (0, import_jsx_runtime371.jsxs)(
      "div",
      {
        role: "group",
        "aria-labelledby": titleId,
        className: "block-editor-block-manager__category",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime371.jsx)(
            import_components211.CheckboxControl,
            {
              __nextHasNoMarginBottom: true,
              checked: isAllChecked,
              onChange: toggleAllVisible,
              className: "block-editor-block-manager__category-title",
              indeterminate: isIndeterminate,
              label: /* @__PURE__ */ (0, import_jsx_runtime371.jsx)("span", { id: titleId, children: title })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime371.jsx)(
            checklist_default,
            {
              blockTypes,
              value: checkedBlockNames,
              onItemChange: toggleVisible
            }
          )
        ]
      }
    );
  }
  var category_default2 = BlockManagerCategory;

  // packages/block-editor/build-module/components/block-manager/index.js
  function BlockManager({
    blockTypes,
    selectedBlockTypes,
    onChange,
    showSelectAll = true
  }) {
    const debouncedSpeak = (0, import_compose90.useDebounce)(import_a11y19.speak, 500);
    const [search, setSearch] = (0, import_element212.useState)("");
    const { categories, isMatchingSearchTerm } = (0, import_data166.useSelect)((select2) => {
      return {
        categories: select2(import_blocks92.store).getCategories(),
        isMatchingSearchTerm: select2(import_blocks92.store).isMatchingSearchTerm
      };
    }, []);
    const filteredBlockTypes = blockTypes.filter((blockType) => {
      return !search || isMatchingSearchTerm(blockType, search);
    });
    const isIndeterminate = selectedBlockTypes.length > 0 && selectedBlockTypes.length !== blockTypes.length;
    const isAllChecked = blockTypes.length > 0 && selectedBlockTypes.length === blockTypes.length;
    (0, import_element212.useEffect)(() => {
      if (!search) {
        return;
      }
      const count = filteredBlockTypes.length;
      const resultsFoundMessage = (0, import_i18n197.sprintf)(
        /* translators: %d: number of results. */
        (0, import_i18n197._n)("%d result found.", "%d results found.", count),
        count
      );
      debouncedSpeak(resultsFoundMessage);
    }, [filteredBlockTypes?.length, search, debouncedSpeak]);
    return /* @__PURE__ */ (0, import_jsx_runtime372.jsxs)(import_components212.__experimentalVStack, { className: "block-editor-block-manager__content", spacing: 4, children: [
      /* @__PURE__ */ (0, import_jsx_runtime372.jsx)(
        import_components212.SearchControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0, import_i18n197.__)("Search for a block"),
          placeholder: (0, import_i18n197.__)("Search for a block"),
          value: search,
          onChange: (nextSearch) => setSearch(nextSearch),
          className: "block-editor-block-manager__search"
        }
      ),
      showSelectAll && /* @__PURE__ */ (0, import_jsx_runtime372.jsx)(
        import_components212.CheckboxControl,
        {
          className: "block-editor-block-manager__select-all",
          label: (0, import_i18n197.__)("Select all"),
          checked: isAllChecked,
          onChange: () => {
            if (isAllChecked) {
              onChange([]);
            } else {
              onChange(blockTypes);
            }
          },
          indeterminate: isIndeterminate,
          __nextHasNoMarginBottom: true
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime372.jsxs)(
        "div",
        {
          tabIndex: "0",
          role: "region",
          "aria-label": (0, import_i18n197.__)("Available block types"),
          className: "block-editor-block-manager__results",
          children: [
            filteredBlockTypes.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime372.jsx)("p", { className: "block-editor-block-manager__no-results", children: (0, import_i18n197.__)("No blocks found.") }),
            categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime372.jsx)(
              category_default2,
              {
                title: category.title,
                blockTypes: filteredBlockTypes.filter(
                  (blockType) => blockType.category === category.slug
                ),
                selectedBlockTypes,
                onChange
              },
              category.slug
            )),
            /* @__PURE__ */ (0, import_jsx_runtime372.jsx)(
              category_default2,
              {
                title: (0, import_i18n197.__)("Uncategorized"),
                blockTypes: filteredBlockTypes.filter(
                  ({ category }) => !category
                ),
                selectedBlockTypes,
                onChange
              }
            )
          ]
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/block-allowed-blocks/modal.js
  function BlockAllowedBlocksModal({
    clientId,
    blockTypes,
    selectedBlockTypes,
    onClose
  }) {
    const [currentSelectedBlockTypes, setCurrentSelectedBlockTypes] = (0, import_element213.useState)(selectedBlockTypes);
    const { updateBlockAttributes: updateBlockAttributes2 } = (0, import_data167.useDispatch)(store);
    const handleSubmit = () => {
      const isFullySelected = currentSelectedBlockTypes.length === blockTypes.length;
      const newBlockNames = currentSelectedBlockTypes.map(
        ({ name }) => name
      );
      updateBlockAttributes2(clientId, {
        allowedBlocks: isFullySelected ? void 0 : newBlockNames
      });
      onClose();
    };
    return /* @__PURE__ */ (0, import_jsx_runtime373.jsx)(
      import_components213.Modal,
      {
        title: (0, import_i18n198.__)("Manage allowed blocks"),
        onRequestClose: onClose,
        overlayClassName: "block-editor-block-allowed-blocks-modal",
        focusOnMount: "firstContentElement",
        size: "medium",
        children: /* @__PURE__ */ (0, import_jsx_runtime373.jsxs)(
          import_components213.__experimentalVStack,
          {
            as: "form",
            onSubmit: (e2) => {
              e2.preventDefault();
              handleSubmit();
            },
            spacing: "4",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime373.jsx)(import_components213.__experimentalText, { children: (0, import_i18n198.__)(
                "Select which blocks can be added inside this container."
              ) }),
              /* @__PURE__ */ (0, import_jsx_runtime373.jsx)(
                BlockManager,
                {
                  blockTypes,
                  selectedBlockTypes: currentSelectedBlockTypes,
                  onChange: (newSelectedBlockTypes) => {
                    setCurrentSelectedBlockTypes(newSelectedBlockTypes);
                  }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime373.jsxs)(
                import_components213.Flex,
                {
                  className: "block-editor-block-allowed-blocks-modal__actions",
                  justify: "flex-end",
                  expanded: false,
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime373.jsx)(import_components213.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime373.jsx)(
                      import_components213.Button,
                      {
                        variant: "tertiary",
                        onClick: onClose,
                        __next40pxDefaultSize: true,
                        children: (0, import_i18n198.__)("Cancel")
                      }
                    ) }),
                    /* @__PURE__ */ (0, import_jsx_runtime373.jsx)(import_components213.FlexItem, { children: /* @__PURE__ */ (0, import_jsx_runtime373.jsx)(
                      import_components213.Button,
                      {
                        variant: "primary",
                        type: "submit",
                        __next40pxDefaultSize: true,
                        children: (0, import_i18n198.__)("Apply")
                      }
                    ) })
                  ]
                }
              )
            ]
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/block-allowed-blocks/allowed-blocks-control.js
  function BlockAllowedBlocksControl({ clientId }) {
    const [isBlockControlOpened, setIsBlockControlOpened] = (0, import_element214.useState)(false);
    const { blockTypes, selectedBlockNames } = (0, import_data168.useSelect)(
      (select2) => {
        const { getBlockAttributes: getBlockAttributes3 } = select2(store);
        return {
          blockTypes: select2(import_blocks93.store).getBlockTypes(),
          selectedBlockNames: getBlockAttributes3(clientId)?.allowedBlocks
        };
      },
      [clientId]
    );
    const filteredBlockTypes = blockTypes.filter(
      (blockType) => (0, import_blocks93.hasBlockSupport)(blockType, "inserter", true) && (!blockType.parent || blockType.parent.includes("core/post-content"))
    );
    if (!filteredBlockTypes) {
      return null;
    }
    const selectedBlockTypes = selectedBlockNames === void 0 ? filteredBlockTypes : filteredBlockTypes.filter(
      (blockType) => selectedBlockNames.includes(blockType.name)
    );
    return /* @__PURE__ */ (0, import_jsx_runtime374.jsxs)("div", { className: "block-editor-block-allowed-blocks-control", children: [
      /* @__PURE__ */ (0, import_jsx_runtime374.jsxs)(
        import_components214.BaseControl,
        {
          help: (0, import_i18n199.__)(
            "Specify which blocks are allowed inside this container."
          ),
          __nextHasNoMarginBottom: true,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime374.jsx)(import_components214.BaseControl.VisualLabel, { children: (0, import_i18n199.__)("Allowed Blocks") }),
            /* @__PURE__ */ (0, import_jsx_runtime374.jsx)(
              import_components214.Button,
              {
                __next40pxDefaultSize: true,
                variant: "secondary",
                onClick: () => {
                  setIsBlockControlOpened(true);
                },
                className: "block-editor-block-allowed-blocks-control__button",
                children: (0, import_i18n199.__)("Manage allowed blocks")
              }
            )
          ]
        }
      ),
      isBlockControlOpened && /* @__PURE__ */ (0, import_jsx_runtime374.jsx)(
        BlockAllowedBlocksModal,
        {
          clientId,
          blockTypes: filteredBlockTypes,
          selectedBlockTypes,
          onClose: () => setIsBlockControlOpened(false)
        }
      )
    ] });
  }

  // packages/block-editor/build-module/hooks/allowed-blocks.js
  function BlockEditAllowedBlocksControlPure({ clientId }) {
    const isContentOnly = (0, import_data169.useSelect)(
      (select2) => {
        return select2(store).getBlockEditingMode(clientId) === "contentOnly";
      },
      [clientId]
    );
    if (isContentOnly) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime375.jsx)(PrivateInspectorControlsAllowedBlocks.Fill, { children: /* @__PURE__ */ (0, import_jsx_runtime375.jsx)(BlockAllowedBlocksControl, { clientId }) });
  }
  var allowed_blocks_default = {
    edit: BlockEditAllowedBlocksControlPure,
    attributeKeys: ["allowedBlocks"],
    hasSupport(name) {
      return (0, import_blocks94.hasBlockSupport)(name, "allowedBlocks");
    }
  };
  function addAttribute3(settings2) {
    if (settings2?.attributes?.allowedBlocks?.type) {
      return settings2;
    }
    if ((0, import_blocks94.hasBlockSupport)(settings2, "allowedBlocks")) {
      settings2.attributes = {
        ...settings2.attributes,
        allowedBlocks: {
          type: "array"
        }
      };
    }
    return settings2;
  }
  (0, import_hooks18.addFilter)(
    "blocks.registerBlockType",
    "core/allowedBlocks/attribute",
    addAttribute3
  );

  // packages/block-editor/build-module/hooks/anchor.js
  var import_jsx_runtime376 = __toESM(require_jsx_runtime());
  var import_hooks19 = __toESM(require_hooks());
  var import_components215 = __toESM(require_components());
  var import_i18n200 = __toESM(require_i18n());
  var import_blocks95 = __toESM(require_blocks());
  var import_element215 = __toESM(require_element());
  var ANCHOR_REGEX = /[\s#]/g;
  var ANCHOR_SCHEMA = {
    type: "string",
    source: "attribute",
    attribute: "id",
    selector: "*"
  };
  function addAttribute4(settings2) {
    if ("type" in (settings2.attributes?.anchor ?? {})) {
      return settings2;
    }
    if ((0, import_blocks95.hasBlockSupport)(settings2, "anchor")) {
      settings2.attributes = {
        ...settings2.attributes,
        anchor: ANCHOR_SCHEMA
      };
    }
    return settings2;
  }
  function BlockEditAnchorControlPure({ anchor, setAttributes }) {
    const blockEditingMode = useBlockEditingMode();
    if (blockEditingMode !== "default") {
      return null;
    }
    const isWeb = import_element215.Platform.OS === "web";
    return /* @__PURE__ */ (0, import_jsx_runtime376.jsx)(inspector_controls_default, { group: "advanced", children: /* @__PURE__ */ (0, import_jsx_runtime376.jsx)(
      import_components215.TextControl,
      {
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: true,
        className: "html-anchor-control",
        label: (0, import_i18n200.__)("HTML anchor"),
        help: /* @__PURE__ */ (0, import_jsx_runtime376.jsxs)(import_jsx_runtime376.Fragment, { children: [
          (0, import_i18n200.__)(
            "Enter a word or two \u2014 without spaces \u2014 to make a unique web address just for this block, called an \u201Canchor\u201D. Then, you\u2019ll be able to link directly to this section of your page."
          ),
          isWeb && /* @__PURE__ */ (0, import_jsx_runtime376.jsxs)(import_jsx_runtime376.Fragment, { children: [
            " ",
            /* @__PURE__ */ (0, import_jsx_runtime376.jsx)(
              import_components215.ExternalLink,
              {
                href: (0, import_i18n200.__)(
                  "https://wordpress.org/documentation/article/page-jumps/"
                ),
                children: (0, import_i18n200.__)("Learn more about anchors")
              }
            )
          ] })
        ] }),
        value: anchor || "",
        placeholder: !isWeb ? (0, import_i18n200.__)("Add an anchor") : null,
        onChange: (nextValue) => {
          nextValue = nextValue.replace(ANCHOR_REGEX, "-");
          setAttributes({
            anchor: nextValue
          });
        },
        autoCapitalize: "none",
        autoComplete: "off"
      }
    ) });
  }
  var anchor_default = {
    addSaveProps: addSaveProps2,
    edit: BlockEditAnchorControlPure,
    attributeKeys: ["anchor"],
    hasSupport(name) {
      return (0, import_blocks95.hasBlockSupport)(name, "anchor");
    }
  };
  function addSaveProps2(extraProps, blockType, attributes) {
    if ((0, import_blocks95.hasBlockSupport)(blockType, "anchor")) {
      extraProps.id = attributes.anchor === "" ? null : attributes.anchor;
    }
    return extraProps;
  }
  (0, import_hooks19.addFilter)("blocks.registerBlockType", "core/anchor/attribute", addAttribute4);

  // packages/block-editor/build-module/hooks/aria-label.js
  var import_hooks20 = __toESM(require_hooks());
  var import_blocks96 = __toESM(require_blocks());
  function addAttribute5(settings2) {
    if (settings2?.attributes?.ariaLabel?.type) {
      return settings2;
    }
    if ((0, import_blocks96.hasBlockSupport)(settings2, "ariaLabel")) {
      settings2.attributes = {
        ...settings2.attributes,
        ariaLabel: {
          type: "string"
        }
      };
    }
    return settings2;
  }
  function addSaveProps3(extraProps, blockType, attributes) {
    if ((0, import_blocks96.hasBlockSupport)(blockType, "ariaLabel")) {
      extraProps["aria-label"] = attributes.ariaLabel === "" ? null : attributes.ariaLabel;
    }
    return extraProps;
  }
  var aria_label_default = {
    addSaveProps: addSaveProps3,
    attributeKeys: ["ariaLabel"],
    hasSupport(name) {
      return (0, import_blocks96.hasBlockSupport)(name, "ariaLabel");
    }
  };
  (0, import_hooks20.addFilter)(
    "blocks.registerBlockType",
    "core/ariaLabel/attribute",
    addAttribute5
  );

  // packages/block-editor/build-module/hooks/custom-class-name.js
  var import_jsx_runtime377 = __toESM(require_jsx_runtime());
  var import_hooks21 = __toESM(require_hooks());
  var import_components217 = __toESM(require_components());
  var import_i18n201 = __toESM(require_i18n());
  var import_blocks97 = __toESM(require_blocks());
  function addAttribute6(settings2) {
    if ((0, import_blocks97.hasBlockSupport)(settings2, "customClassName", true)) {
      settings2.attributes = {
        ...settings2.attributes,
        className: {
          type: "string"
        }
      };
    }
    return settings2;
  }
  function CustomClassNameControlsPure({ className, setAttributes }) {
    const blockEditingMode = useBlockEditingMode();
    if (blockEditingMode !== "default") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime377.jsx)(inspector_controls_default, { group: "advanced", children: /* @__PURE__ */ (0, import_jsx_runtime377.jsx)(
      import_components217.TextControl,
      {
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: true,
        autoComplete: "off",
        label: (0, import_i18n201.__)("Additional CSS class(es)"),
        value: className || "",
        onChange: (nextValue) => {
          setAttributes({
            className: nextValue !== "" ? nextValue : void 0
          });
        },
        help: (0, import_i18n201.__)("Separate multiple classes with spaces.")
      }
    ) });
  }
  var custom_class_name_default = {
    edit: CustomClassNameControlsPure,
    addSaveProps: addSaveProps4,
    attributeKeys: ["className"],
    hasSupport(name) {
      return (0, import_blocks97.hasBlockSupport)(name, "customClassName", true);
    }
  };
  function addSaveProps4(extraProps, blockType, attributes) {
    if ((0, import_blocks97.hasBlockSupport)(blockType, "customClassName", true) && attributes.className) {
      extraProps.className = clsx_default(
        extraProps.className,
        attributes.className
      );
    }
    return extraProps;
  }
  function addTransforms(result, source, index, results) {
    if (!(0, import_blocks97.hasBlockSupport)(result.name, "customClassName", true)) {
      return result;
    }
    if (results.length === 1 && result.innerBlocks.length === source.length) {
      return result;
    }
    if (results.length === 1 && source.length > 1 || results.length > 1 && source.length === 1) {
      return result;
    }
    if (source[index]) {
      const originClassName = source[index]?.attributes.className;
      if (originClassName && result.attributes.className === void 0) {
        return {
          ...result,
          attributes: {
            ...result.attributes,
            className: originClassName
          }
        };
      }
    }
    return result;
  }
  (0, import_hooks21.addFilter)(
    "blocks.registerBlockType",
    "core/editor/custom-class-name/attribute",
    addAttribute6
  );
  (0, import_hooks21.addFilter)(
    "blocks.switchToBlockType.transformedBlock",
    "core/color/addTransforms",
    addTransforms
  );

  // packages/block-editor/build-module/hooks/generated-class-name.js
  var import_hooks22 = __toESM(require_hooks());
  var import_blocks98 = __toESM(require_blocks());
  function addGeneratedClassName(extraProps, blockType) {
    if ((0, import_blocks98.hasBlockSupport)(blockType, "className", true)) {
      if (typeof extraProps.className === "string") {
        extraProps.className = [
          .../* @__PURE__ */ new Set([
            (0, import_blocks98.getBlockDefaultClassName)(blockType.name),
            ...extraProps.className.split(" ")
          ])
        ].join(" ").trim();
      } else {
        extraProps.className = (0, import_blocks98.getBlockDefaultClassName)(blockType.name);
      }
    }
    return extraProps;
  }
  (0, import_hooks22.addFilter)(
    "blocks.getSaveContent.extraProps",
    "core/generated-class-name/save-props",
    addGeneratedClassName
  );

  // packages/block-editor/build-module/hooks/style.js
  var import_jsx_runtime387 = __toESM(require_jsx_runtime());
  var import_element222 = __toESM(require_element());
  var import_hooks27 = __toESM(require_hooks());
  var import_blocks107 = __toESM(require_blocks());
  var import_compose91 = __toESM(require_compose());
  var import_style_engine4 = __toESM(require_style_engine());

  // packages/block-editor/build-module/hooks/color.js
  var import_jsx_runtime379 = __toESM(require_jsx_runtime());
  var import_hooks23 = __toESM(require_hooks());
  var import_blocks99 = __toESM(require_blocks());
  var import_element217 = __toESM(require_element());
  var import_data170 = __toESM(require_data());

  // packages/block-editor/build-module/hooks/contrast-checker.js
  var import_jsx_runtime378 = __toESM(require_jsx_runtime());
  var import_element216 = __toESM(require_element());
  function getComputedValue(node2, property) {
    return node2.ownerDocument.defaultView.getComputedStyle(node2).getPropertyValue(property);
  }
  function getBlockElementColors(blockEl) {
    if (!blockEl) {
      return {};
    }
    const firstLinkElement = blockEl.querySelector("a");
    const linkColor = !!firstLinkElement?.innerText ? getComputedValue(firstLinkElement, "color") : void 0;
    const textColor = getComputedValue(blockEl, "color");
    let backgroundColorNode = blockEl;
    let backgroundColor = getComputedValue(
      backgroundColorNode,
      "background-color"
    );
    while (backgroundColor === "rgba(0, 0, 0, 0)" && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
      backgroundColorNode = backgroundColorNode.parentNode;
      backgroundColor = getComputedValue(
        backgroundColorNode,
        "background-color"
      );
    }
    return {
      textColor,
      backgroundColor,
      linkColor
    };
  }
  function reducer3(prevColors, newColors) {
    const hasChanged = Object.keys(newColors).some(
      (key) => prevColors[key] !== newColors[key]
    );
    return hasChanged ? newColors : prevColors;
  }
  function BlockColorContrastChecker({ clientId }) {
    const blockEl = useBlockElement(clientId);
    const [colors2, setColors] = (0, import_element216.useReducer)(reducer3, {});
    (0, import_element216.useLayoutEffect)(() => {
      if (!blockEl) {
        return;
      }
      function updateColors() {
        setColors(getBlockElementColors(blockEl));
      }
      window.requestAnimationFrame(
        () => window.requestAnimationFrame(updateColors)
      );
    });
    return /* @__PURE__ */ (0, import_jsx_runtime378.jsx)(
      contrast_checker_default,
      {
        backgroundColor: colors2.backgroundColor,
        textColor: colors2.textColor,
        linkColor: colors2.linkColor,
        enableAlphaChecker: true
      }
    );
  }

  // packages/block-editor/build-module/hooks/color.js
  var COLOR_SUPPORT_KEY2 = "color";
  var hasColorSupport = (blockNameOrType) => {
    const colorSupport = (0, import_blocks99.getBlockSupport)(blockNameOrType, COLOR_SUPPORT_KEY2);
    return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
  };
  var hasLinkColorSupport = (blockType) => {
    if (import_element217.Platform.OS !== "web") {
      return false;
    }
    const colorSupport = (0, import_blocks99.getBlockSupport)(blockType, COLOR_SUPPORT_KEY2);
    return colorSupport !== null && typeof colorSupport === "object" && !!colorSupport.link;
  };
  var hasGradientSupport2 = (blockNameOrType) => {
    const colorSupport = (0, import_blocks99.getBlockSupport)(blockNameOrType, COLOR_SUPPORT_KEY2);
    return colorSupport !== null && typeof colorSupport === "object" && !!colorSupport.gradients;
  };
  var hasBackgroundColorSupport2 = (blockType) => {
    const colorSupport = (0, import_blocks99.getBlockSupport)(blockType, COLOR_SUPPORT_KEY2);
    return colorSupport && colorSupport.background !== false;
  };
  var hasTextColorSupport2 = (blockType) => {
    const colorSupport = (0, import_blocks99.getBlockSupport)(blockType, COLOR_SUPPORT_KEY2);
    return colorSupport && colorSupport.text !== false;
  };
  function addAttributes2(settings2) {
    if (!hasColorSupport(settings2)) {
      return settings2;
    }
    if (!settings2.attributes.backgroundColor) {
      Object.assign(settings2.attributes, {
        backgroundColor: {
          type: "string"
        }
      });
    }
    if (!settings2.attributes.textColor) {
      Object.assign(settings2.attributes, {
        textColor: {
          type: "string"
        }
      });
    }
    if (hasGradientSupport2(settings2) && !settings2.attributes.gradient) {
      Object.assign(settings2.attributes, {
        gradient: {
          type: "string"
        }
      });
    }
    return settings2;
  }
  function addSaveProps5(props, blockNameOrType, attributes) {
    if (!hasColorSupport(blockNameOrType) || shouldSkipSerialization(blockNameOrType, COLOR_SUPPORT_KEY2)) {
      return props;
    }
    const hasGradient = hasGradientSupport2(blockNameOrType);
    const { backgroundColor, textColor, gradient, style } = attributes;
    const shouldSerialize = (feature) => !shouldSkipSerialization(
      blockNameOrType,
      COLOR_SUPPORT_KEY2,
      feature
    );
    const textClass = shouldSerialize("text") ? getColorClassName("color", textColor) : void 0;
    const gradientClass = shouldSerialize("gradients") ? __experimentalGetGradientClass(gradient) : void 0;
    const backgroundClass = shouldSerialize("background") ? getColorClassName("background-color", backgroundColor) : void 0;
    const serializeHasBackground = shouldSerialize("background") || shouldSerialize("gradients");
    const hasBackground = backgroundColor || style?.color?.background || hasGradient && (gradient || style?.color?.gradient);
    const newClassName = clsx_default(props.className, textClass, gradientClass, {
      // Don't apply the background class if there's a custom gradient.
      [backgroundClass]: (!hasGradient || !style?.color?.gradient) && !!backgroundClass,
      "has-text-color": shouldSerialize("text") && (textColor || style?.color?.text),
      "has-background": serializeHasBackground && hasBackground,
      "has-link-color": shouldSerialize("link") && style?.elements?.link?.color
    });
    props.className = newClassName ? newClassName : void 0;
    return props;
  }
  function styleToAttributes2(style) {
    const textColorValue = style?.color?.text;
    const textColorSlug = textColorValue?.startsWith("var:preset|color|") ? textColorValue.substring("var:preset|color|".length) : void 0;
    const backgroundColorValue = style?.color?.background;
    const backgroundColorSlug = backgroundColorValue?.startsWith(
      "var:preset|color|"
    ) ? backgroundColorValue.substring("var:preset|color|".length) : void 0;
    const gradientValue = style?.color?.gradient;
    const gradientSlug = gradientValue?.startsWith("var:preset|gradient|") ? gradientValue.substring("var:preset|gradient|".length) : void 0;
    const updatedStyle = { ...style };
    updatedStyle.color = {
      ...updatedStyle.color,
      text: textColorSlug ? void 0 : textColorValue,
      background: backgroundColorSlug ? void 0 : backgroundColorValue,
      gradient: gradientSlug ? void 0 : gradientValue
    };
    return {
      style: cleanEmptyObject(updatedStyle),
      textColor: textColorSlug,
      backgroundColor: backgroundColorSlug,
      gradient: gradientSlug
    };
  }
  function attributesToStyle2(attributes) {
    return {
      ...attributes.style,
      color: {
        ...attributes.style?.color,
        text: attributes.textColor ? "var:preset|color|" + attributes.textColor : attributes.style?.color?.text,
        background: attributes.backgroundColor ? "var:preset|color|" + attributes.backgroundColor : attributes.style?.color?.background,
        gradient: attributes.gradient ? "var:preset|gradient|" + attributes.gradient : attributes.style?.color?.gradient
      }
    };
  }
  function ColorInspectorControl({ children, resetAllFilter }) {
    const attributesResetAllFilter = (0, import_element217.useCallback)(
      (attributes) => {
        const existingStyle = attributesToStyle2(attributes);
        const updatedStyle = resetAllFilter(existingStyle);
        return {
          ...attributes,
          ...styleToAttributes2(updatedStyle)
        };
      },
      [resetAllFilter]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime379.jsx)(
      inspector_controls_default,
      {
        group: "color",
        resetAllFilter: attributesResetAllFilter,
        children
      }
    );
  }
  function ColorEdit({ clientId, name, setAttributes, settings: settings2 }) {
    const isEnabled = useHasColorPanel(settings2);
    function selector3(select2) {
      const { style: style2, textColor: textColor2, backgroundColor: backgroundColor2, gradient: gradient2 } = select2(store).getBlockAttributes(clientId) || {};
      return { style: style2, textColor: textColor2, backgroundColor: backgroundColor2, gradient: gradient2 };
    }
    const { style, textColor, backgroundColor, gradient } = (0, import_data170.useSelect)(
      selector3,
      [clientId]
    );
    const value = (0, import_element217.useMemo)(() => {
      return attributesToStyle2({
        style,
        textColor,
        backgroundColor,
        gradient
      });
    }, [style, textColor, backgroundColor, gradient]);
    const onChange = (newStyle) => {
      setAttributes(styleToAttributes2(newStyle));
    };
    if (!isEnabled) {
      return null;
    }
    const defaultControls = (0, import_blocks99.getBlockSupport)(name, [
      COLOR_SUPPORT_KEY2,
      "__experimentalDefaultControls"
    ]);
    const enableContrastChecking = import_element217.Platform.OS === "web" && !value?.color?.gradient && (settings2?.color?.text || settings2?.color?.link) && // Contrast checking is enabled by default.
    // Deactivating it requires `enableContrastChecker` to have
    // an explicit value of `false`.
    false !== (0, import_blocks99.getBlockSupport)(name, [
      COLOR_SUPPORT_KEY2,
      "enableContrastChecker"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime379.jsx)(
      ColorPanel,
      {
        as: ColorInspectorControl,
        panelId: clientId,
        settings: settings2,
        value,
        onChange,
        defaultControls,
        enableContrastChecker: false !== (0, import_blocks99.getBlockSupport)(name, [
          COLOR_SUPPORT_KEY2,
          "enableContrastChecker"
        ]),
        children: enableContrastChecking && /* @__PURE__ */ (0, import_jsx_runtime379.jsx)(BlockColorContrastChecker, { clientId })
      }
    );
  }
  function useBlockProps7({
    name,
    backgroundColor,
    textColor,
    gradient,
    style
  }) {
    const [userPalette, themePalette, defaultPalette] = useSettings(
      "color.palette.custom",
      "color.palette.theme",
      "color.palette.default"
    );
    const colors2 = (0, import_element217.useMemo)(
      () => [
        ...userPalette || [],
        ...themePalette || [],
        ...defaultPalette || []
      ],
      [userPalette, themePalette, defaultPalette]
    );
    if (!hasColorSupport(name) || shouldSkipSerialization(name, COLOR_SUPPORT_KEY2)) {
      return {};
    }
    const extraStyles = {};
    if (textColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY2, "text")) {
      extraStyles.color = getColorObjectByAttributeValues(
        colors2,
        textColor
      )?.color;
    }
    if (backgroundColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY2, "background")) {
      extraStyles.backgroundColor = getColorObjectByAttributeValues(
        colors2,
        backgroundColor
      )?.color;
    }
    const saveProps = addSaveProps5({ style: extraStyles }, name, {
      textColor,
      backgroundColor,
      gradient,
      style
    });
    const hasBackgroundValue = backgroundColor || style?.color?.background || gradient || style?.color?.gradient;
    return {
      ...saveProps,
      className: clsx_default(
        saveProps.className,
        // Add background image classes in the editor, if not already handled by background color values.
        !hasBackgroundValue && getBackgroundImageClasses(style)
      )
    };
  }
  var color_default = {
    useBlockProps: useBlockProps7,
    addSaveProps: addSaveProps5,
    attributeKeys: ["backgroundColor", "textColor", "gradient", "style"],
    hasSupport: hasColorSupport
  };
  var MIGRATION_PATHS = {
    linkColor: [["style", "elements", "link", "color", "text"]],
    textColor: [["textColor"], ["style", "color", "text"]],
    backgroundColor: [
      ["backgroundColor"],
      ["style", "color", "background"]
    ],
    gradient: [["gradient"], ["style", "color", "gradient"]]
  };
  function addTransforms2(result, source, index, results) {
    const destinationBlockType = result.name;
    const activeSupports = {
      linkColor: hasLinkColorSupport(destinationBlockType),
      textColor: hasTextColorSupport2(destinationBlockType),
      backgroundColor: hasBackgroundColorSupport2(destinationBlockType),
      gradient: hasGradientSupport2(destinationBlockType)
    };
    return transformStyles2(
      activeSupports,
      MIGRATION_PATHS,
      result,
      source,
      index,
      results
    );
  }
  (0, import_hooks23.addFilter)(
    "blocks.registerBlockType",
    "core/color/addAttribute",
    addAttributes2
  );
  (0, import_hooks23.addFilter)(
    "blocks.switchToBlockType.transformedBlock",
    "core/color/addTransforms",
    addTransforms2
  );

  // packages/block-editor/build-module/hooks/typography.js
  var import_jsx_runtime384 = __toESM(require_jsx_runtime());
  var import_blocks105 = __toESM(require_blocks());
  var import_element219 = __toESM(require_element());
  var import_data172 = __toESM(require_data());

  // packages/block-editor/build-module/hooks/line-height.js
  var import_jsx_runtime380 = __toESM(require_jsx_runtime());
  var import_blocks100 = __toESM(require_blocks());
  var LINE_HEIGHT_SUPPORT_KEY2 = "typography.lineHeight";

  // packages/block-editor/build-module/hooks/font-family.js
  var import_hooks24 = __toESM(require_hooks());
  var import_blocks101 = __toESM(require_blocks());
  var import_token_list2 = __toESM(require_token_list());
  var import_components219 = __toESM(require_components());
  var FONT_FAMILY_SUPPORT_KEY2 = "typography.__experimentalFontFamily";
  var { kebabCase: kebabCase5 } = unlock(import_components219.privateApis);
  function addAttributes3(settings2) {
    if (!(0, import_blocks101.hasBlockSupport)(settings2, FONT_FAMILY_SUPPORT_KEY2)) {
      return settings2;
    }
    if (!settings2.attributes.fontFamily) {
      Object.assign(settings2.attributes, {
        fontFamily: {
          type: "string"
        }
      });
    }
    return settings2;
  }
  function addSaveProps6(props, blockType, attributes) {
    if (!(0, import_blocks101.hasBlockSupport)(blockType, FONT_FAMILY_SUPPORT_KEY2)) {
      return props;
    }
    if (shouldSkipSerialization(
      blockType,
      TYPOGRAPHY_SUPPORT_KEY,
      "fontFamily"
    )) {
      return props;
    }
    if (!attributes?.fontFamily) {
      return props;
    }
    const classes = new import_token_list2.default(props.className);
    classes.add(`has-${kebabCase5(attributes?.fontFamily)}-font-family`);
    const newClassName = classes.value;
    props.className = newClassName ? newClassName : void 0;
    return props;
  }
  function useBlockProps8({ name, fontFamily }) {
    return addSaveProps6({}, name, { fontFamily });
  }
  var font_family_default = {
    useBlockProps: useBlockProps8,
    addSaveProps: addSaveProps6,
    attributeKeys: ["fontFamily"],
    hasSupport(name) {
      return (0, import_blocks101.hasBlockSupport)(name, FONT_FAMILY_SUPPORT_KEY2);
    }
  };
  (0, import_hooks24.addFilter)(
    "blocks.registerBlockType",
    "core/fontFamily/addAttribute",
    addAttributes3
  );

  // packages/block-editor/build-module/hooks/font-size.js
  var import_jsx_runtime381 = __toESM(require_jsx_runtime());
  var import_hooks25 = __toESM(require_hooks());
  var import_blocks102 = __toESM(require_blocks());
  var import_token_list3 = __toESM(require_token_list());
  var FONT_SIZE_SUPPORT_KEY2 = "typography.fontSize";
  function addAttributes4(settings2) {
    if (!(0, import_blocks102.hasBlockSupport)(settings2, FONT_SIZE_SUPPORT_KEY2)) {
      return settings2;
    }
    if (!settings2.attributes.fontSize) {
      Object.assign(settings2.attributes, {
        fontSize: {
          type: "string"
        }
      });
    }
    return settings2;
  }
  function addSaveProps7(props, blockNameOrType, attributes) {
    if (!(0, import_blocks102.hasBlockSupport)(blockNameOrType, FONT_SIZE_SUPPORT_KEY2)) {
      return props;
    }
    if (shouldSkipSerialization(
      blockNameOrType,
      TYPOGRAPHY_SUPPORT_KEY,
      "fontSize"
    )) {
      return props;
    }
    const classes = new import_token_list3.default(props.className);
    classes.add(getFontSizeClass(attributes.fontSize));
    const newClassName = classes.value;
    props.className = newClassName ? newClassName : void 0;
    return props;
  }
  function useBlockProps9({ name, fontSize, style }) {
    const [fontSizes, fluidTypographySettings, layoutSettings] = useSettings(
      "typography.fontSizes",
      "typography.fluid",
      "layout"
    );
    if (!(0, import_blocks102.hasBlockSupport)(name, FONT_SIZE_SUPPORT_KEY2) || shouldSkipSerialization(name, TYPOGRAPHY_SUPPORT_KEY, "fontSize") || !fontSize && !style?.typography?.fontSize) {
      return;
    }
    let props;
    if (style?.typography?.fontSize) {
      props = {
        style: {
          fontSize: getTypographyFontSizeValue(
            { size: style.typography.fontSize },
            {
              typography: {
                fluid: fluidTypographySettings
              },
              layout: layoutSettings
            }
          )
        }
      };
    }
    if (fontSize) {
      props = {
        style: {
          fontSize: getFontSize(
            fontSizes,
            fontSize,
            style?.typography?.fontSize
          ).size
        }
      };
    }
    if (!props) {
      return;
    }
    return addSaveProps7(props, name, { fontSize });
  }
  var font_size_default = {
    useBlockProps: useBlockProps9,
    addSaveProps: addSaveProps7,
    attributeKeys: ["fontSize", "style"],
    hasSupport(name) {
      return (0, import_blocks102.hasBlockSupport)(name, FONT_SIZE_SUPPORT_KEY2);
    }
  };
  var MIGRATION_PATHS2 = {
    fontSize: [["fontSize"], ["style", "typography", "fontSize"]]
  };
  function addTransforms3(result, source, index, results) {
    const destinationBlockType = result.name;
    const activeSupports = {
      fontSize: (0, import_blocks102.hasBlockSupport)(
        destinationBlockType,
        FONT_SIZE_SUPPORT_KEY2
      )
    };
    return transformStyles2(
      activeSupports,
      MIGRATION_PATHS2,
      result,
      source,
      index,
      results
    );
  }
  (0, import_hooks25.addFilter)(
    "blocks.registerBlockType",
    "core/font/addAttribute",
    addAttributes4
  );
  (0, import_hooks25.addFilter)(
    "blocks.switchToBlockType.transformedBlock",
    "core/font-size/addTransforms",
    addTransforms3
  );

  // packages/block-editor/build-module/hooks/text-align.js
  var import_jsx_runtime382 = __toESM(require_jsx_runtime());
  var import_i18n202 = __toESM(require_i18n());
  var import_blocks103 = __toESM(require_blocks());
  var TEXT_ALIGN_SUPPORT_KEY2 = "typography.textAlign";
  var TEXT_ALIGNMENT_OPTIONS2 = [
    {
      icon: align_left_default,
      title: (0, import_i18n202.__)("Align text left"),
      align: "left"
    },
    {
      icon: align_center_default,
      title: (0, import_i18n202.__)("Align text center"),
      align: "center"
    },
    {
      icon: align_right_default,
      title: (0, import_i18n202.__)("Align text right"),
      align: "right"
    }
  ];
  var VALID_TEXT_ALIGNMENTS = ["left", "center", "right"];
  var NO_TEXT_ALIGNMENTS = [];
  function getValidTextAlignments(blockTextAlign) {
    if (Array.isArray(blockTextAlign)) {
      return VALID_TEXT_ALIGNMENTS.filter(
        (textAlign) => blockTextAlign.includes(textAlign)
      );
    }
    return blockTextAlign === true ? VALID_TEXT_ALIGNMENTS : NO_TEXT_ALIGNMENTS;
  }
  function BlockEditTextAlignmentToolbarControlsPure({
    style,
    name: blockName,
    setAttributes
  }) {
    const settings2 = useBlockSettings(blockName);
    const hasTextAlignControl = settings2?.typography?.textAlign;
    const blockEditingMode = useBlockEditingMode();
    if (!hasTextAlignControl || blockEditingMode !== "default") {
      return null;
    }
    const validTextAlignments = getValidTextAlignments(
      (0, import_blocks103.getBlockSupport)(blockName, TEXT_ALIGN_SUPPORT_KEY2)
    );
    if (!validTextAlignments.length) {
      return null;
    }
    const textAlignmentControls = TEXT_ALIGNMENT_OPTIONS2.filter(
      (control) => validTextAlignments.includes(control.align)
    );
    const onChange = (newTextAlignValue) => {
      const newStyle = {
        ...style,
        typography: {
          ...style?.typography,
          textAlign: newTextAlignValue
        }
      };
      setAttributes({ style: cleanEmptyObject(newStyle) });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime382.jsx)(block_controls_default, { group: "block", children: /* @__PURE__ */ (0, import_jsx_runtime382.jsx)(
      AlignmentControl,
      {
        value: style?.typography?.textAlign,
        onChange,
        alignmentControls: textAlignmentControls
      }
    ) });
  }
  var text_align_default = {
    edit: BlockEditTextAlignmentToolbarControlsPure,
    useBlockProps: useBlockProps10,
    addSaveProps: addAssignedTextAlign,
    attributeKeys: ["style"],
    hasSupport(name) {
      return (0, import_blocks103.hasBlockSupport)(name, TEXT_ALIGN_SUPPORT_KEY2, false);
    }
  };
  function useBlockProps10({ name, style }) {
    if (!style?.typography?.textAlign) {
      return null;
    }
    const validTextAlignments = getValidTextAlignments(
      (0, import_blocks103.getBlockSupport)(name, TEXT_ALIGN_SUPPORT_KEY2)
    );
    if (!validTextAlignments.length) {
      return null;
    }
    if (shouldSkipSerialization(name, TYPOGRAPHY_SUPPORT_KEY, "textAlign")) {
      return null;
    }
    const textAlign = style.typography.textAlign;
    const className = clsx_default({
      [`has-text-align-${textAlign}`]: textAlign
    });
    return { className };
  }
  function addAssignedTextAlign(props, blockType, attributes) {
    if (!attributes?.style?.typography?.textAlign) {
      return props;
    }
    const { textAlign } = attributes.style.typography;
    const blockTextAlign = (0, import_blocks103.getBlockSupport)(blockType, TEXT_ALIGN_SUPPORT_KEY2);
    const isTextAlignValid = getValidTextAlignments(blockTextAlign).includes(textAlign);
    if (isTextAlignValid && !shouldSkipSerialization(
      blockType,
      TYPOGRAPHY_SUPPORT_KEY,
      "textAlign"
    )) {
      props.className = clsx_default(
        `has-text-align-${textAlign}`,
        props.className
      );
    }
    return props;
  }

  // packages/block-editor/build-module/hooks/fit-text.js
  var import_jsx_runtime383 = __toESM(require_jsx_runtime());
  var import_hooks26 = __toESM(require_hooks());
  var import_blocks104 = __toESM(require_blocks());
  var import_element218 = __toESM(require_element());
  var import_data171 = __toESM(require_data());
  var import_i18n203 = __toESM(require_i18n());
  var import_components221 = __toESM(require_components());

  // packages/block-editor/build-module/utils/fit-text-utils.js
  function generateCSSRule(elementSelector, fontSize) {
    return `${elementSelector} { font-size: ${fontSize}px !important; }`;
  }
  function findOptimalFontSize(textElement, elementSelector, applyStylesFn, maxSize = 600) {
    const alreadyHasScrollableHeight = textElement.scrollHeight > textElement.clientHeight;
    let minSize = 5;
    let bestSize = minSize;
    while (minSize <= maxSize) {
      const midSize = Math.floor((minSize + maxSize) / 2);
      applyStylesFn(generateCSSRule(elementSelector, midSize));
      const fitsWidth = textElement.scrollWidth <= textElement.clientWidth;
      const fitsHeight = alreadyHasScrollableHeight || textElement.scrollHeight <= textElement.clientHeight;
      if (fitsWidth && fitsHeight) {
        bestSize = midSize;
        minSize = midSize + 1;
      } else {
        maxSize = midSize - 1;
      }
    }
    return bestSize;
  }
  function optimizeFitText(textElement, elementSelector, applyStylesFn, maxSize) {
    if (!textElement) {
      return;
    }
    applyStylesFn("");
    const optimalSize = findOptimalFontSize(
      textElement,
      elementSelector,
      applyStylesFn,
      maxSize
    );
    const cssRule = generateCSSRule(elementSelector, optimalSize);
    applyStylesFn(cssRule);
  }

  // packages/block-editor/build-module/hooks/fit-text.js
  var FIT_TEXT_SUPPORT_KEY = "typography.fitText";
  function addAttributes5(settings2) {
    if (!(0, import_blocks104.hasBlockSupport)(settings2, FIT_TEXT_SUPPORT_KEY)) {
      return settings2;
    }
    if (settings2.attributes?.fitText) {
      return settings2;
    }
    return {
      ...settings2,
      attributes: {
        ...settings2.attributes,
        fitText: {
          type: "boolean"
        }
      }
    };
  }
  function useFitText({ fitText, name, clientId }) {
    const hasFitTextSupport2 = (0, import_blocks104.hasBlockSupport)(name, FIT_TEXT_SUPPORT_KEY);
    const blockElement = useBlockElement(clientId);
    const { blockAttributes, isSelected } = (0, import_data171.useSelect)(
      (select2) => {
        if (!clientId) {
          return { blockAttributes: void 0, isSelected: false };
        }
        return {
          blockAttributes: select2(store).getBlockAttributes(clientId),
          isSelected: select2(store).isBlockSelected(clientId)
        };
      },
      [clientId]
    );
    const isSelectedRef = (0, import_element218.useRef)();
    (0, import_element218.useEffect)(() => {
      isSelectedRef.current = isSelected;
    }, [isSelected]);
    const applyFitText = (0, import_element218.useCallback)(() => {
      if (!blockElement || !hasFitTextSupport2 || !fitText) {
        return;
      }
      const styleId = `fit-text-${clientId}`;
      let styleElement = blockElement.ownerDocument.getElementById(styleId);
      if (!styleElement) {
        styleElement = blockElement.ownerDocument.createElement("style");
        styleElement.id = styleId;
        blockElement.ownerDocument.head.appendChild(styleElement);
      }
      const blockSelector = `#block-${clientId}`;
      const applyStylesFn = (css) => {
        styleElement.textContent = css;
      };
      const maxSize = isSelectedRef.current ? 200 : void 0;
      optimizeFitText(blockElement, blockSelector, applyStylesFn, maxSize);
    }, [blockElement, clientId, hasFitTextSupport2, fitText, isSelectedRef]);
    (0, import_element218.useEffect)(() => {
      if (!fitText || !blockElement || !clientId || !hasFitTextSupport2) {
        return;
      }
      applyFitText();
      const currentElement = blockElement;
      let resizeObserver;
      if (window.ResizeObserver && currentElement.parentElement) {
        resizeObserver = new window.ResizeObserver(applyFitText);
        resizeObserver.observe(currentElement.parentElement);
      }
      return () => {
        if (resizeObserver) {
          resizeObserver.disconnect();
        }
        const styleId = `fit-text-${clientId}`;
        const styleElement = currentElement.ownerDocument.getElementById(styleId);
        if (styleElement) {
          styleElement.remove();
        }
      };
    }, [fitText, clientId, applyFitText, blockElement, hasFitTextSupport2]);
    (0, import_element218.useEffect)(() => {
      if (fitText && blockElement && hasFitTextSupport2) {
        const frameId = window.requestAnimationFrame(() => {
          if (blockElement) {
            applyFitText();
          }
        });
        return () => window.cancelAnimationFrame(frameId);
      }
    }, [
      blockAttributes,
      isSelected,
      fitText,
      applyFitText,
      blockElement,
      hasFitTextSupport2
    ]);
  }
  function FitTextControl({
    clientId,
    fitText = false,
    setAttributes,
    name
  }) {
    if (!(0, import_blocks104.hasBlockSupport)(name, FIT_TEXT_SUPPORT_KEY)) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime383.jsx)(inspector_controls_default, { group: "typography", children: /* @__PURE__ */ (0, import_jsx_runtime383.jsx)(
      import_components221.__experimentalToolsPanelItem,
      {
        hasValue: () => fitText,
        label: (0, import_i18n203.__)("Fit text"),
        onDeselect: () => setAttributes({ fitText: void 0 }),
        resetAllFilter: () => ({ fitText: void 0 }),
        panelId: clientId,
        children: /* @__PURE__ */ (0, import_jsx_runtime383.jsx)(
          import_components221.ToggleControl,
          {
            __nextHasNoMarginBottom: true,
            label: (0, import_i18n203.__)("Fit text"),
            checked: fitText,
            onChange: () => setAttributes({ fitText: !fitText || void 0 }),
            help: fitText ? (0, import_i18n203.__)("Text will resize to fit its container.") : (0, import_i18n203.__)("Resize text to fit its container.")
          }
        )
      }
    ) });
  }
  function addSaveProps8(props, blockType, attributes) {
    if (!(0, import_blocks104.hasBlockSupport)(blockType, FIT_TEXT_SUPPORT_KEY)) {
      return props;
    }
    const { fitText } = attributes;
    if (!fitText) {
      return props;
    }
    const className = props.className ? `${props.className} has-fit-text` : "has-fit-text";
    return {
      ...props,
      className
    };
  }
  function useBlockProps11({ name, fitText, clientId }) {
    useFitText({ fitText, name, clientId });
    if (!fitText || !(0, import_blocks104.hasBlockSupport)(name, FIT_TEXT_SUPPORT_KEY)) {
      return {};
    }
    return {
      className: "has-fit-text"
    };
  }
  (0, import_hooks26.addFilter)(
    "blocks.registerBlockType",
    "core/fit-text/addAttribute",
    addAttributes5
  );
  var hasFitTextSupport = (blockNameOrType) => {
    return (0, import_blocks104.hasBlockSupport)(blockNameOrType, FIT_TEXT_SUPPORT_KEY);
  };
  var fit_text_default = {
    useBlockProps: useBlockProps11,
    addSaveProps: addSaveProps8,
    attributeKeys: ["fitText"],
    hasSupport: hasFitTextSupport,
    edit: FitTextControl
  };

  // packages/block-editor/build-module/hooks/typography.js
  function omit(object, keys) {
    return Object.fromEntries(
      Object.entries(object).filter(([key]) => !keys.includes(key))
    );
  }
  var LETTER_SPACING_SUPPORT_KEY2 = "typography.__experimentalLetterSpacing";
  var TEXT_TRANSFORM_SUPPORT_KEY2 = "typography.__experimentalTextTransform";
  var TEXT_DECORATION_SUPPORT_KEY2 = "typography.__experimentalTextDecoration";
  var TEXT_COLUMNS_SUPPORT_KEY2 = "typography.textColumns";
  var FONT_STYLE_SUPPORT_KEY2 = "typography.__experimentalFontStyle";
  var FONT_WEIGHT_SUPPORT_KEY2 = "typography.__experimentalFontWeight";
  var WRITING_MODE_SUPPORT_KEY2 = "typography.__experimentalWritingMode";
  var TYPOGRAPHY_SUPPORT_KEY = "typography";
  var TYPOGRAPHY_SUPPORT_KEYS2 = [
    LINE_HEIGHT_SUPPORT_KEY2,
    FONT_SIZE_SUPPORT_KEY2,
    FONT_STYLE_SUPPORT_KEY2,
    FONT_WEIGHT_SUPPORT_KEY2,
    FONT_FAMILY_SUPPORT_KEY2,
    TEXT_ALIGN_SUPPORT_KEY2,
    TEXT_COLUMNS_SUPPORT_KEY2,
    TEXT_DECORATION_SUPPORT_KEY2,
    WRITING_MODE_SUPPORT_KEY2,
    TEXT_TRANSFORM_SUPPORT_KEY2,
    LETTER_SPACING_SUPPORT_KEY2,
    FIT_TEXT_SUPPORT_KEY
  ];
  function styleToAttributes3(style) {
    const updatedStyle = { ...omit(style, ["fontFamily"]) };
    const fontSizeValue = style?.typography?.fontSize;
    const fontFamilyValue = style?.typography?.fontFamily;
    const fontSizeSlug = typeof fontSizeValue === "string" && fontSizeValue?.startsWith("var:preset|font-size|") ? fontSizeValue.substring("var:preset|font-size|".length) : void 0;
    const fontFamilySlug = fontFamilyValue?.startsWith(
      "var:preset|font-family|"
    ) ? fontFamilyValue.substring("var:preset|font-family|".length) : void 0;
    updatedStyle.typography = {
      ...omit(updatedStyle.typography, ["fontFamily"]),
      fontSize: fontSizeSlug ? void 0 : fontSizeValue
    };
    return {
      style: cleanEmptyObject(updatedStyle),
      fontFamily: fontFamilySlug,
      fontSize: fontSizeSlug
    };
  }
  function attributesToStyle3(attributes) {
    return {
      ...attributes.style,
      typography: {
        ...attributes.style?.typography,
        fontFamily: attributes.fontFamily ? "var:preset|font-family|" + attributes.fontFamily : void 0,
        fontSize: attributes.fontSize ? "var:preset|font-size|" + attributes.fontSize : attributes.style?.typography?.fontSize
      }
    };
  }
  function TypographyInspectorControl({ children, resetAllFilter }) {
    const attributesResetAllFilter = (0, import_element219.useCallback)(
      (attributes) => {
        const existingStyle = attributesToStyle3(attributes);
        const updatedStyle = resetAllFilter(existingStyle);
        return {
          ...attributes,
          ...styleToAttributes3(updatedStyle)
        };
      },
      [resetAllFilter]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime384.jsx)(
      inspector_controls_default,
      {
        group: "typography",
        resetAllFilter: attributesResetAllFilter,
        children
      }
    );
  }
  function TypographyPanel2({ clientId, name, setAttributes, settings: settings2 }) {
    function selector3(select2) {
      const { style: style2, fontFamily: fontFamily2, fontSize: fontSize2 } = select2(store).getBlockAttributes(clientId) || {};
      return { style: style2, fontFamily: fontFamily2, fontSize: fontSize2 };
    }
    const { style, fontFamily, fontSize } = (0, import_data172.useSelect)(selector3, [clientId]);
    const isEnabled = useHasTypographyPanel(settings2);
    const value = (0, import_element219.useMemo)(
      () => attributesToStyle3({ style, fontFamily, fontSize }),
      [style, fontSize, fontFamily]
    );
    const onChange = (newStyle) => {
      setAttributes(styleToAttributes3(newStyle));
    };
    if (!isEnabled) {
      return null;
    }
    const defaultControls = (0, import_blocks105.getBlockSupport)(name, [
      TYPOGRAPHY_SUPPORT_KEY,
      "__experimentalDefaultControls"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime384.jsx)(
      TypographyPanel,
      {
        as: TypographyInspectorControl,
        panelId: clientId,
        settings: settings2,
        value,
        onChange,
        defaultControls
      }
    );
  }

  // packages/block-editor/build-module/hooks/dimensions.js
  var import_jsx_runtime386 = __toESM(require_jsx_runtime());
  var import_element221 = __toESM(require_element());
  var import_data173 = __toESM(require_data());
  var import_blocks106 = __toESM(require_blocks());
  var import_deprecated34 = __toESM(require_deprecated());

  // packages/block-editor/build-module/hooks/spacing-visualizer.js
  var import_jsx_runtime385 = __toESM(require_jsx_runtime());
  var import_element220 = __toESM(require_element());
  var import_is_shallow_equal4 = __toESM(require_is_shallow_equal());
  function SpacingVisualizer({ clientId, value, computeStyle, forceShow }) {
    const blockElement = useBlockElement(clientId);
    const [style, updateStyle] = (0, import_element220.useReducer)(
      () => computeStyle(blockElement)
    );
    (0, import_element220.useEffect)(() => {
      if (!blockElement) {
        return;
      }
      const observer = new window.MutationObserver(updateStyle);
      observer.observe(blockElement, {
        attributes: true,
        attributeFilter: ["style", "class"]
      });
      return () => {
        observer.disconnect();
      };
    }, [blockElement]);
    const previousValueRef = (0, import_element220.useRef)(value);
    const [isActive, setIsActive] = (0, import_element220.useState)(false);
    (0, import_element220.useEffect)(() => {
      if ((0, import_is_shallow_equal4.default)(value, previousValueRef.current) || forceShow) {
        return;
      }
      setIsActive(true);
      previousValueRef.current = value;
      const timeout = setTimeout(() => {
        setIsActive(false);
      }, 400);
      return () => {
        setIsActive(false);
        clearTimeout(timeout);
      };
    }, [value, forceShow]);
    if (!isActive && !forceShow) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime385.jsx)(
      cover_default,
      {
        clientId,
        __unstablePopoverSlot: "block-toolbar",
        children: /* @__PURE__ */ (0, import_jsx_runtime385.jsx)("div", { className: "block-editor__spacing-visualizer", style })
      }
    );
  }
  function getComputedCSS(element, property) {
    return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
  }
  function MarginVisualizer({ clientId, value, forceShow }) {
    return /* @__PURE__ */ (0, import_jsx_runtime385.jsx)(
      SpacingVisualizer,
      {
        clientId,
        value: value?.spacing?.margin,
        computeStyle: (blockElement) => {
          const top = getComputedCSS(blockElement, "margin-top");
          const right = getComputedCSS(blockElement, "margin-right");
          const bottom = getComputedCSS(blockElement, "margin-bottom");
          const left = getComputedCSS(blockElement, "margin-left");
          return {
            borderTopWidth: top,
            borderRightWidth: right,
            borderBottomWidth: bottom,
            borderLeftWidth: left,
            top: top ? `-${top}` : 0,
            right: right ? `-${right}` : 0,
            bottom: bottom ? `-${bottom}` : 0,
            left: left ? `-${left}` : 0
          };
        },
        forceShow
      }
    );
  }
  function PaddingVisualizer({ clientId, value, forceShow }) {
    return /* @__PURE__ */ (0, import_jsx_runtime385.jsx)(
      SpacingVisualizer,
      {
        clientId,
        value: value?.spacing?.padding,
        computeStyle: (blockElement) => ({
          borderTopWidth: getComputedCSS(blockElement, "padding-top"),
          borderRightWidth: getComputedCSS(
            blockElement,
            "padding-right"
          ),
          borderBottomWidth: getComputedCSS(
            blockElement,
            "padding-bottom"
          ),
          borderLeftWidth: getComputedCSS(blockElement, "padding-left")
        }),
        forceShow
      }
    );
  }

  // packages/block-editor/build-module/hooks/dimensions.js
  var DIMENSIONS_SUPPORT_KEY = "dimensions";
  var SPACING_SUPPORT_KEY2 = "spacing";
  function useVisualizer() {
    const [property, setProperty] = (0, import_element221.useState)(false);
    const { hideBlockInterface: hideBlockInterface2, showBlockInterface: showBlockInterface2 } = unlock(
      (0, import_data173.useDispatch)(store)
    );
    (0, import_element221.useEffect)(() => {
      if (!property) {
        showBlockInterface2();
      } else {
        hideBlockInterface2();
      }
    }, [property, showBlockInterface2, hideBlockInterface2]);
    return [property, setProperty];
  }
  function DimensionsInspectorControl({ children, resetAllFilter }) {
    const attributesResetAllFilter = (0, import_element221.useCallback)(
      (attributes) => {
        const existingStyle = attributes.style;
        const updatedStyle = resetAllFilter(existingStyle);
        return {
          ...attributes,
          style: updatedStyle
        };
      },
      [resetAllFilter]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime386.jsx)(
      inspector_controls_default,
      {
        group: "dimensions",
        resetAllFilter: attributesResetAllFilter,
        children
      }
    );
  }
  function DimensionsPanel2({ clientId, name, setAttributes, settings: settings2 }) {
    const isEnabled = useHasDimensionsPanel(settings2);
    const value = (0, import_data173.useSelect)(
      (select2) => select2(store).getBlockAttributes(clientId)?.style,
      [clientId]
    );
    const [visualizedProperty, setVisualizedProperty] = useVisualizer();
    const onChange = (newStyle) => {
      setAttributes({
        style: cleanEmptyObject(newStyle)
      });
    };
    if (!isEnabled) {
      return null;
    }
    const defaultDimensionsControls = (0, import_blocks106.getBlockSupport)(name, [
      DIMENSIONS_SUPPORT_KEY,
      "__experimentalDefaultControls"
    ]);
    const defaultSpacingControls = (0, import_blocks106.getBlockSupport)(name, [
      SPACING_SUPPORT_KEY2,
      "__experimentalDefaultControls"
    ]);
    const defaultControls = {
      ...defaultDimensionsControls,
      ...defaultSpacingControls
    };
    return /* @__PURE__ */ (0, import_jsx_runtime386.jsxs)(import_jsx_runtime386.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime386.jsx)(
        DimensionsPanel,
        {
          as: DimensionsInspectorControl,
          panelId: clientId,
          settings: settings2,
          value,
          onChange,
          defaultControls,
          onVisualize: setVisualizedProperty
        }
      ),
      !!settings2?.spacing?.padding && /* @__PURE__ */ (0, import_jsx_runtime386.jsx)(
        PaddingVisualizer,
        {
          forceShow: visualizedProperty === "padding",
          clientId,
          value
        }
      ),
      !!settings2?.spacing?.margin && /* @__PURE__ */ (0, import_jsx_runtime386.jsx)(
        MarginVisualizer,
        {
          forceShow: visualizedProperty === "margin",
          clientId,
          value
        }
      )
    ] });
  }
  function hasDimensionsSupport(blockName, feature = "any") {
    if (import_element221.Platform.OS !== "web") {
      return false;
    }
    const support = (0, import_blocks106.getBlockSupport)(blockName, DIMENSIONS_SUPPORT_KEY);
    if (support === true) {
      return true;
    }
    if (feature === "any") {
      return !!(support?.aspectRatio || !!support?.minHeight);
    }
    return !!support?.[feature];
  }
  var dimensions_default = {
    useBlockProps: useBlockProps12,
    attributeKeys: ["minHeight", "style"],
    hasSupport(name) {
      return hasDimensionsSupport(name, "aspectRatio");
    }
  };
  function useBlockProps12({ name, minHeight, style }) {
    if (!hasDimensionsSupport(name, "aspectRatio") || shouldSkipSerialization(name, DIMENSIONS_SUPPORT_KEY, "aspectRatio")) {
      return {};
    }
    const className = clsx_default({
      "has-aspect-ratio": !!style?.dimensions?.aspectRatio
    });
    const inlineStyleOverrides = {};
    if (style?.dimensions?.aspectRatio) {
      inlineStyleOverrides.minHeight = "unset";
    } else if (minHeight || style?.dimensions?.minHeight) {
      inlineStyleOverrides.aspectRatio = "unset";
    }
    return { className, style: inlineStyleOverrides };
  }
  function useCustomSides() {
    (0, import_deprecated34.default)("wp.blockEditor.__experimentalUseCustomSides", {
      since: "6.3",
      version: "6.4"
    });
  }

  // packages/block-editor/build-module/hooks/style.js
  var styleSupportKeys2 = [
    ...TYPOGRAPHY_SUPPORT_KEYS2,
    BORDER_SUPPORT_KEY2,
    COLOR_SUPPORT_KEY2,
    DIMENSIONS_SUPPORT_KEY,
    BACKGROUND_SUPPORT_KEY,
    SPACING_SUPPORT_KEY2,
    SHADOW_SUPPORT_KEY
  ];
  var hasStyleSupport2 = (nameOrType) => styleSupportKeys2.some((key) => (0, import_blocks107.hasBlockSupport)(nameOrType, key));
  function getInlineStyles(styles = {}) {
    const output = {};
    (0, import_style_engine4.getCSSRules)(styles).forEach((rule) => {
      output[rule.key] = rule.value;
    });
    return output;
  }
  function addAttribute7(settings2) {
    if (!hasStyleSupport2(settings2)) {
      return settings2;
    }
    if (!settings2.attributes.style) {
      Object.assign(settings2.attributes, {
        style: {
          type: "object"
        }
      });
    }
    return settings2;
  }
  var skipSerializationPathsEdit = {
    [`${BORDER_SUPPORT_KEY2}.__experimentalSkipSerialization`]: ["border"],
    [`${COLOR_SUPPORT_KEY2}.__experimentalSkipSerialization`]: [
      COLOR_SUPPORT_KEY2
    ],
    [`${TYPOGRAPHY_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
      TYPOGRAPHY_SUPPORT_KEY
    ],
    [`${DIMENSIONS_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
      DIMENSIONS_SUPPORT_KEY
    ],
    [`${SPACING_SUPPORT_KEY2}.__experimentalSkipSerialization`]: [
      SPACING_SUPPORT_KEY2
    ],
    [`${SHADOW_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
      SHADOW_SUPPORT_KEY
    ]
  };
  var skipSerializationPathsSave = {
    ...skipSerializationPathsEdit,
    [`${DIMENSIONS_SUPPORT_KEY}.aspectRatio`]: [
      `${DIMENSIONS_SUPPORT_KEY}.aspectRatio`
    ],
    // Skip serialization of aspect ratio in save mode.
    [`${BACKGROUND_SUPPORT_KEY}`]: [BACKGROUND_SUPPORT_KEY]
    // Skip serialization of background support in save mode.
  };
  var skipSerializationPathsSaveChecks = {
    [`${DIMENSIONS_SUPPORT_KEY}.aspectRatio`]: true,
    [`${BACKGROUND_SUPPORT_KEY}`]: true
  };
  var renamedFeatures = { gradients: "gradient" };
  function omitStyle(style, paths, preserveReference = false) {
    if (!style) {
      return style;
    }
    let newStyle = style;
    if (!preserveReference) {
      newStyle = JSON.parse(JSON.stringify(style));
    }
    if (!Array.isArray(paths)) {
      paths = [paths];
    }
    paths.forEach((path) => {
      if (!Array.isArray(path)) {
        path = path.split(".");
      }
      if (path.length > 1) {
        const [firstSubpath, ...restPath] = path;
        omitStyle(newStyle[firstSubpath], [restPath], true);
      } else if (path.length === 1) {
        delete newStyle[path[0]];
      }
    });
    return newStyle;
  }
  function addSaveProps9(props, blockNameOrType, attributes, skipPaths = skipSerializationPathsSave) {
    if (!hasStyleSupport2(blockNameOrType)) {
      return props;
    }
    let { style } = attributes;
    Object.entries(skipPaths).forEach(([indicator, path]) => {
      const skipSerialization = skipSerializationPathsSaveChecks[indicator] || (0, import_blocks107.getBlockSupport)(blockNameOrType, indicator);
      if (skipSerialization === true) {
        style = omitStyle(style, path);
      }
      if (Array.isArray(skipSerialization)) {
        skipSerialization.forEach((featureName) => {
          const feature = renamedFeatures[featureName] || featureName;
          style = omitStyle(style, [[...path, feature]]);
        });
      }
    });
    props.style = {
      ...getInlineStyles(style),
      ...props.style
    };
    return props;
  }
  function BlockStyleControls({
    clientId,
    name,
    setAttributes,
    __unstableParentLayout
  }) {
    const settings2 = useBlockSettings(name, __unstableParentLayout);
    const blockEditingMode = useBlockEditingMode();
    const passedProps = {
      clientId,
      name,
      setAttributes,
      settings: {
        ...settings2,
        typography: {
          ...settings2.typography,
          // The text alignment UI for individual blocks is rendered in
          // the block toolbar, so disable it here.
          textAlign: false
        }
      }
    };
    if (blockEditingMode !== "default") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime387.jsxs)(import_jsx_runtime387.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime387.jsx)(ColorEdit, { ...passedProps }),
      /* @__PURE__ */ (0, import_jsx_runtime387.jsx)(BackgroundImagePanel3, { ...passedProps }),
      /* @__PURE__ */ (0, import_jsx_runtime387.jsx)(TypographyPanel2, { ...passedProps }),
      /* @__PURE__ */ (0, import_jsx_runtime387.jsx)(BorderPanel2, { ...passedProps }),
      /* @__PURE__ */ (0, import_jsx_runtime387.jsx)(DimensionsPanel2, { ...passedProps })
    ] });
  }
  var style_default = {
    edit: BlockStyleControls,
    hasSupport: hasStyleSupport2,
    addSaveProps: addSaveProps9,
    attributeKeys: ["style"],
    useBlockProps: useBlockProps13
  };
  var elementTypes = [
    { elementType: "button" },
    { elementType: "link", pseudo: [":hover"] },
    {
      elementType: "heading",
      elements: ["h1", "h2", "h3", "h4", "h5", "h6"]
    }
  ];
  var STYLE_BLOCK_PROPS_REFERENCE = {};
  function useBlockProps13({ name, style }) {
    const blockElementsContainerIdentifier = (0, import_compose91.useInstanceId)(
      STYLE_BLOCK_PROPS_REFERENCE,
      "wp-elements"
    );
    const baseElementSelector = `.${blockElementsContainerIdentifier}`;
    const blockElementStyles = style?.elements;
    const styles = (0, import_element222.useMemo)(() => {
      if (!blockElementStyles) {
        return;
      }
      const elementCSSRules = [];
      elementTypes.forEach(({ elementType, pseudo, elements }) => {
        const skipSerialization = shouldSkipSerialization(
          name,
          COLOR_SUPPORT_KEY2,
          elementType
        );
        if (skipSerialization) {
          return;
        }
        const elementStyles = blockElementStyles?.[elementType];
        if (elementStyles) {
          const selector3 = scopeSelector(
            baseElementSelector,
            import_blocks107.__EXPERIMENTAL_ELEMENTS[elementType]
          );
          elementCSSRules.push(
            (0, import_style_engine4.compileCSS)(elementStyles, { selector: selector3 })
          );
          if (pseudo) {
            pseudo.forEach((pseudoSelector) => {
              if (elementStyles[pseudoSelector]) {
                elementCSSRules.push(
                  (0, import_style_engine4.compileCSS)(elementStyles[pseudoSelector], {
                    selector: scopeSelector(
                      baseElementSelector,
                      `${import_blocks107.__EXPERIMENTAL_ELEMENTS[elementType]}${pseudoSelector}`
                    )
                  })
                );
              }
            });
          }
        }
        if (elements) {
          elements.forEach((element) => {
            if (blockElementStyles[element]) {
              elementCSSRules.push(
                (0, import_style_engine4.compileCSS)(blockElementStyles[element], {
                  selector: scopeSelector(
                    baseElementSelector,
                    import_blocks107.__EXPERIMENTAL_ELEMENTS[element]
                  )
                })
              );
            }
          });
        }
      });
      return elementCSSRules.length > 0 ? elementCSSRules.join("") : void 0;
    }, [baseElementSelector, blockElementStyles, name]);
    useStyleOverride({ css: styles });
    return addSaveProps9(
      { className: blockElementsContainerIdentifier },
      name,
      { style },
      skipSerializationPathsEdit
    );
  }
  (0, import_hooks27.addFilter)(
    "blocks.registerBlockType",
    "core/style/addAttribute",
    addAttribute7
  );

  // packages/block-editor/build-module/hooks/settings.js
  var import_hooks28 = __toESM(require_hooks());
  var import_blocks108 = __toESM(require_blocks());
  var hasSettingsSupport = (blockType) => (0, import_blocks108.hasBlockSupport)(blockType, "__experimentalSettings", false);
  function addAttribute8(settings2) {
    if (!hasSettingsSupport(settings2)) {
      return settings2;
    }
    if (!settings2?.attributes?.settings) {
      settings2.attributes = {
        ...settings2.attributes,
        settings: {
          type: "object"
        }
      };
    }
    return settings2;
  }
  (0, import_hooks28.addFilter)(
    "blocks.registerBlockType",
    "core/settings/addAttribute",
    addAttribute8
  );

  // packages/block-editor/build-module/hooks/duotone.js
  var import_jsx_runtime388 = __toESM(require_jsx_runtime());
  var import_blocks109 = __toESM(require_blocks());
  var import_compose92 = __toESM(require_compose());
  var import_hooks29 = __toESM(require_hooks());
  var import_element223 = __toESM(require_element());
  var EMPTY_ARRAY15 = [];
  var isSafari = window?.navigator.userAgent && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome") && !window.navigator.userAgent.includes("Chromium");
  k([names_default]);
  function useMultiOriginPresets({ presetSetting, defaultSetting }) {
    const [enableDefault, userPresets, themePresets, defaultPresets] = useSettings(
      defaultSetting,
      `${presetSetting}.custom`,
      `${presetSetting}.theme`,
      `${presetSetting}.default`
    );
    return (0, import_element223.useMemo)(
      () => [
        ...userPresets || EMPTY_ARRAY15,
        ...themePresets || EMPTY_ARRAY15,
        ...enableDefault && defaultPresets || EMPTY_ARRAY15
      ],
      [enableDefault, userPresets, themePresets, defaultPresets]
    );
  }
  function getColorsFromDuotonePreset(duotone, duotonePalette) {
    if (!duotone) {
      return;
    }
    const preset = duotonePalette?.find(({ slug }) => {
      return duotone === `var:preset|duotone|${slug}`;
    });
    return preset ? preset.colors : void 0;
  }
  function getDuotonePresetFromColors(colors2, duotonePalette) {
    if (!colors2 || !Array.isArray(colors2)) {
      return;
    }
    const preset = duotonePalette?.find((duotonePreset) => {
      return duotonePreset?.colors?.every(
        (val, index) => val === colors2[index]
      );
    });
    return preset ? `var:preset|duotone|${preset.slug}` : void 0;
  }
  function DuotonePanelPure({ style, setAttributes, name }) {
    const duotoneStyle = style?.color?.duotone;
    const settings2 = useBlockSettings(name);
    const blockEditingMode = useBlockEditingMode();
    const duotonePalette = useMultiOriginPresets({
      presetSetting: "color.duotone",
      defaultSetting: "color.defaultDuotone"
    });
    const colorPalette = useMultiOriginPresets({
      presetSetting: "color.palette",
      defaultSetting: "color.defaultPalette"
    });
    const [enableCustomColors, enableCustomDuotone] = useSettings(
      "color.custom",
      "color.customDuotone"
    );
    const disableCustomColors = !enableCustomColors;
    const disableCustomDuotone = !enableCustomDuotone || colorPalette?.length === 0 && disableCustomColors;
    if (duotonePalette?.length === 0 && disableCustomDuotone) {
      return null;
    }
    if (blockEditingMode !== "default") {
      return null;
    }
    const duotonePresetOrColors = duotoneStyle === "unset" || Array.isArray(duotoneStyle) ? duotoneStyle : getColorsFromDuotonePreset(duotoneStyle, duotonePalette);
    return /* @__PURE__ */ (0, import_jsx_runtime388.jsxs)(import_jsx_runtime388.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime388.jsx)(inspector_controls_default, { group: "filter", children: /* @__PURE__ */ (0, import_jsx_runtime388.jsx)(
        FiltersPanel,
        {
          value: { filter: { duotone: duotonePresetOrColors } },
          onChange: (newDuotone) => {
            const newStyle = {
              ...style,
              color: {
                ...newDuotone?.filter
              }
            };
            setAttributes({
              style: cleanEmptyObject(newStyle)
            });
          },
          settings: settings2
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime388.jsx)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: /* @__PURE__ */ (0, import_jsx_runtime388.jsx)(
        duotone_control_default,
        {
          duotonePalette,
          colorPalette,
          disableCustomDuotone,
          disableCustomColors,
          value: duotonePresetOrColors,
          onChange: (newDuotone) => {
            const maybePreset = getDuotonePresetFromColors(
              newDuotone,
              duotonePalette
            );
            const newStyle = {
              ...style,
              color: {
                ...style?.color,
                duotone: maybePreset ?? newDuotone
                // use preset or fallback to custom colors.
              }
            };
            setAttributes({
              style: cleanEmptyObject(newStyle)
            });
          },
          settings: settings2
        }
      ) })
    ] });
  }
  var duotone_default = {
    shareWithChildBlocks: true,
    edit: DuotonePanelPure,
    useBlockProps: useBlockProps14,
    attributeKeys: ["style"],
    hasSupport(name) {
      return (0, import_blocks109.hasBlockSupport)(name, "filter.duotone");
    }
  };
  function addDuotoneAttributes(settings2) {
    if (!(0, import_blocks109.hasBlockSupport)(settings2, "filter.duotone")) {
      return settings2;
    }
    if (!settings2.attributes.style) {
      Object.assign(settings2.attributes, {
        style: {
          type: "object"
        }
      });
    }
    return settings2;
  }
  function useDuotoneStyles({
    clientId,
    id: filterId,
    selector: duotoneSelector,
    attribute: duotoneAttr
  }) {
    const duotonePalette = useMultiOriginPresets({
      presetSetting: "color.duotone",
      defaultSetting: "color.defaultDuotone"
    });
    const isCustom = Array.isArray(duotoneAttr);
    const duotonePreset = isCustom ? void 0 : getColorsFromDuotonePreset(duotoneAttr, duotonePalette);
    const isPreset = typeof duotoneAttr === "string" && duotonePreset;
    const isCSS = typeof duotoneAttr === "string" && !isPreset;
    let colors2 = null;
    if (isPreset) {
      colors2 = duotonePreset;
    } else if (isCSS) {
      colors2 = duotoneAttr;
    } else if (isCustom) {
      colors2 = duotoneAttr;
    }
    const selectors = duotoneSelector.split(",");
    const selectorsScoped = selectors.map((selectorPart) => {
      return `.${filterId}${selectorPart.trim()}`;
    });
    const selector3 = selectorsScoped.join(", ");
    const isValidFilter = Array.isArray(colors2) || colors2 === "unset";
    usePrivateStyleOverride(
      isValidFilter ? {
        css: colors2 !== "unset" ? getDuotoneStylesheet(selector3, filterId) : getDuotoneUnsetStylesheet(selector3),
        __unstableType: "presets"
      } : void 0
    );
    usePrivateStyleOverride(
      isValidFilter ? {
        assets: colors2 !== "unset" ? getDuotoneFilter(filterId, colors2) : "",
        __unstableType: "svgs"
      } : void 0
    );
    const blockElement = useBlockElement(clientId);
    (0, import_element223.useEffect)(() => {
      if (!isValidFilter) {
        return;
      }
      if (blockElement && isSafari) {
        const display = blockElement.style.display;
        blockElement.style.setProperty("display", "inline-block");
        blockElement.offsetHeight;
        blockElement.style.setProperty("display", display);
      }
    }, [isValidFilter, blockElement, colors2]);
  }
  var DUOTONE_BLOCK_PROPS_REFERENCE = {};
  function useBlockProps14({ clientId, name, style }) {
    const id = (0, import_compose92.useInstanceId)(DUOTONE_BLOCK_PROPS_REFERENCE);
    const selector3 = (0, import_element223.useMemo)(() => {
      const blockType = (0, import_blocks109.getBlockType)(name);
      if (blockType) {
        const duotoneSupport = (0, import_blocks109.getBlockSupport)(
          blockType,
          "filter.duotone",
          false
        );
        if (!duotoneSupport) {
          return null;
        }
        const experimentalDuotone = (0, import_blocks109.getBlockSupport)(
          blockType,
          "color.__experimentalDuotone",
          false
        );
        if (experimentalDuotone) {
          const rootSelector = getBlockCSSSelector(blockType);
          return typeof experimentalDuotone === "string" ? scopeSelector(rootSelector, experimentalDuotone) : rootSelector;
        }
        return getBlockCSSSelector(blockType, "filter.duotone", {
          fallback: true
        });
      }
    }, [name]);
    const attribute = style?.color?.duotone;
    const filterClass = `wp-duotone-${id}`;
    const shouldRender = selector3 && attribute;
    useDuotoneStyles({
      clientId,
      id: filterClass,
      selector: selector3,
      attribute
    });
    return {
      className: shouldRender ? filterClass : ""
    };
  }
  (0, import_hooks29.addFilter)(
    "blocks.registerBlockType",
    "core/editor/duotone/add-attributes",
    addDuotoneAttributes
  );

  // packages/block-editor/build-module/hooks/layout.js
  var import_jsx_runtime389 = __toESM(require_jsx_runtime());
  var import_compose93 = __toESM(require_compose());
  var import_hooks30 = __toESM(require_hooks());
  var import_blocks110 = __toESM(require_blocks());
  var import_data174 = __toESM(require_data());
  var import_components223 = __toESM(require_components());
  var import_i18n204 = __toESM(require_i18n());
  var layoutBlockSupportKey = "layout";
  var { kebabCase: kebabCase6 } = unlock(import_components223.privateApis);
  function hasLayoutBlockSupport(blockName) {
    return (0, import_blocks110.hasBlockSupport)(blockName, "layout") || (0, import_blocks110.hasBlockSupport)(blockName, "__experimentalLayout");
  }
  function useLayoutClasses(blockAttributes = {}, blockName = "") {
    const { layout } = blockAttributes;
    const { default: defaultBlockLayout } = (0, import_blocks110.getBlockSupport)(blockName, layoutBlockSupportKey) || {};
    const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout, type: "constrained" } : layout || defaultBlockLayout || {};
    const layoutClassnames = [];
    if (LAYOUT_DEFINITIONS[usedLayout?.type || "default"]?.className) {
      const baseClassName = LAYOUT_DEFINITIONS[usedLayout?.type || "default"]?.className;
      const splitBlockName = blockName.split("/");
      const fullBlockName = splitBlockName[0] === "core" ? splitBlockName.pop() : splitBlockName.join("-");
      const compoundClassName = `wp-block-${fullBlockName}-${baseClassName}`;
      layoutClassnames.push(baseClassName, compoundClassName);
    }
    const hasGlobalPadding = (0, import_data174.useSelect)(
      (select2) => {
        return (usedLayout?.inherit || usedLayout?.contentSize || usedLayout?.type === "constrained") && select2(store).getSettings().__experimentalFeatures?.useRootPaddingAwareAlignments;
      },
      [usedLayout?.contentSize, usedLayout?.inherit, usedLayout?.type]
    );
    if (hasGlobalPadding) {
      layoutClassnames.push("has-global-padding");
    }
    if (usedLayout?.orientation) {
      layoutClassnames.push(`is-${kebabCase6(usedLayout.orientation)}`);
    }
    if (usedLayout?.justifyContent) {
      layoutClassnames.push(
        `is-content-justification-${kebabCase6(
          usedLayout.justifyContent
        )}`
      );
    }
    if (usedLayout?.flexWrap && usedLayout.flexWrap === "nowrap") {
      layoutClassnames.push("is-nowrap");
    }
    return layoutClassnames;
  }
  function useLayoutStyles(blockAttributes = {}, blockName, selector3) {
    const { layout = {}, style = {} } = blockAttributes;
    const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout, type: "constrained" } : layout || {};
    const fullLayoutType = getLayoutType(usedLayout?.type || "default");
    const [blockGapSupport] = useSettings("spacing.blockGap");
    const hasBlockGapSupport = blockGapSupport !== null;
    return fullLayoutType?.getLayoutStyle?.({
      blockName,
      selector: selector3,
      layout,
      style,
      hasBlockGapSupport
    });
  }
  function LayoutPanelPure({
    layout,
    setAttributes,
    name: blockName,
    clientId
  }) {
    const settings2 = useBlockSettings(blockName);
    const { layout: layoutSettings } = settings2;
    const { themeSupportsLayout } = (0, import_data174.useSelect)((select2) => {
      const { getSettings: getSettings4 } = select2(store);
      return {
        themeSupportsLayout: getSettings4().supportsLayout
      };
    }, []);
    const blockEditingMode = useBlockEditingMode();
    if (blockEditingMode !== "default") {
      return null;
    }
    const layoutBlockSupport = (0, import_blocks110.getBlockSupport)(
      blockName,
      layoutBlockSupportKey,
      {}
    );
    const blockSupportAndThemeSettings = {
      ...layoutSettings,
      ...layoutBlockSupport
    };
    const {
      allowSwitching,
      allowEditing = true,
      allowInheriting = true,
      default: defaultBlockLayout
    } = blockSupportAndThemeSettings;
    if (!allowEditing) {
      return null;
    }
    const blockSupportAndLayout = {
      ...layoutBlockSupport,
      ...layout
    };
    const { type, default: { type: defaultType = "default" } = {} } = blockSupportAndLayout;
    const blockLayoutType = type || defaultType;
    const showInheritToggle = !!(allowInheriting && (!blockLayoutType || blockLayoutType === "default" || blockLayoutType === "constrained" || blockSupportAndLayout.inherit));
    const usedLayout = layout || defaultBlockLayout || {};
    const { inherit = false, contentSize = null } = usedLayout;
    if ((blockLayoutType === "default" || blockLayoutType === "constrained") && !themeSupportsLayout) {
      return null;
    }
    const layoutType = getLayoutType(blockLayoutType);
    const constrainedType = getLayoutType("constrained");
    const displayControlsForLegacyLayouts = !usedLayout.type && (contentSize || inherit);
    const hasContentSizeOrLegacySettings = !!inherit || !!contentSize;
    const onChangeType = (newType) => setAttributes({ layout: { type: newType } });
    const onChangeLayout = (newLayout) => setAttributes({ layout: newLayout });
    return /* @__PURE__ */ (0, import_jsx_runtime389.jsxs)(import_jsx_runtime389.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(inspector_controls_default, { children: /* @__PURE__ */ (0, import_jsx_runtime389.jsxs)(import_components223.PanelBody, { title: (0, import_i18n204.__)("Layout"), children: [
        showInheritToggle && /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(import_jsx_runtime389.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
          import_components223.ToggleControl,
          {
            __nextHasNoMarginBottom: true,
            label: (0, import_i18n204.__)("Inner blocks use content width"),
            checked: layoutType?.name === "constrained" || hasContentSizeOrLegacySettings,
            onChange: () => setAttributes({
              layout: {
                type: layoutType?.name === "constrained" || hasContentSizeOrLegacySettings ? "default" : "constrained"
              }
            }),
            help: layoutType?.name === "constrained" || hasContentSizeOrLegacySettings ? (0, import_i18n204.__)(
              "Nested blocks use content width with options for full and wide widths."
            ) : (0, import_i18n204.__)(
              "Nested blocks will fill the width of this container."
            )
          }
        ) }),
        !inherit && allowSwitching && /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
          LayoutTypeSwitcher,
          {
            type: blockLayoutType,
            onChange: onChangeType
          }
        ),
        layoutType && layoutType.name !== "default" && /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
          layoutType.inspectorControls,
          {
            layout: usedLayout,
            onChange: onChangeLayout,
            layoutBlockSupport: blockSupportAndThemeSettings,
            name: blockName,
            clientId
          }
        ),
        constrainedType && displayControlsForLegacyLayouts && /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
          constrainedType.inspectorControls,
          {
            layout: usedLayout,
            onChange: onChangeLayout,
            layoutBlockSupport: blockSupportAndThemeSettings,
            name: blockName,
            clientId
          }
        )
      ] }) }),
      !inherit && layoutType && /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
        layoutType.toolBarControls,
        {
          layout: usedLayout,
          onChange: onChangeLayout,
          layoutBlockSupport,
          name: blockName,
          clientId
        }
      )
    ] });
  }
  var layout_default2 = {
    shareWithChildBlocks: true,
    edit: LayoutPanelPure,
    attributeKeys: ["layout"],
    hasSupport(name) {
      return hasLayoutBlockSupport(name);
    }
  };
  function LayoutTypeSwitcher({ type, onChange }) {
    return /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
      import_components223.__experimentalToggleGroupControl,
      {
        __next40pxDefaultSize: true,
        isBlock: true,
        label: (0, import_i18n204.__)("Layout type"),
        __nextHasNoMarginBottom: true,
        hideLabelFromVision: true,
        isAdaptiveWidth: true,
        value: type,
        onChange,
        children: getLayoutTypes().map(({ name, label }) => {
          return /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
            import_components223.__experimentalToggleGroupControlOption,
            {
              value: name,
              label
            },
            name
          );
        })
      }
    );
  }
  function addAttribute9(settings2) {
    if ("type" in (settings2.attributes?.layout ?? {})) {
      return settings2;
    }
    if (hasLayoutBlockSupport(settings2)) {
      settings2.attributes = {
        ...settings2.attributes,
        layout: {
          type: "object"
        }
      };
    }
    return settings2;
  }
  function BlockWithLayoutStyles({
    block: BlockListBlock2,
    props,
    blockGapSupport,
    layoutClasses
  }) {
    const { name, attributes } = props;
    const id = (0, import_compose93.useInstanceId)(BlockListBlock2);
    const { layout } = attributes;
    const { default: defaultBlockLayout } = (0, import_blocks110.getBlockSupport)(name, layoutBlockSupportKey) || {};
    const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout, type: "constrained" } : layout || defaultBlockLayout || {};
    const selectorPrefix = `wp-container-${kebabCase6(name)}-is-layout-`;
    const selector3 = `.${selectorPrefix}${id}`;
    const hasBlockGapSupport = blockGapSupport !== null;
    const fullLayoutType = getLayoutType(usedLayout?.type || "default");
    const css = fullLayoutType?.getLayoutStyle?.({
      blockName: name,
      selector: selector3,
      layout: usedLayout,
      style: attributes?.style,
      hasBlockGapSupport
    });
    const layoutClassNames = clsx_default(
      {
        [`${selectorPrefix}${id}`]: !!css
        // Only attach a container class if there is generated CSS to be attached.
      },
      layoutClasses
    );
    useStyleOverride({ css });
    return /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
      BlockListBlock2,
      {
        ...props,
        __unstableLayoutClassNames: layoutClassNames
      }
    );
  }
  var withLayoutStyles = (0, import_compose93.createHigherOrderComponent)(
    (BlockListBlock2) => (props) => {
      const { clientId, name, attributes } = props;
      const blockSupportsLayout = hasLayoutBlockSupport(name);
      const layoutClasses = useLayoutClasses(attributes, name);
      const extraProps = (0, import_data174.useSelect)(
        (select2) => {
          if (!blockSupportsLayout) {
            return;
          }
          const { getSettings: getSettings4, getBlockSettings: getBlockSettings2 } = unlock(
            select2(store)
          );
          const { disableLayoutStyles } = getSettings4();
          if (disableLayoutStyles) {
            return;
          }
          const [blockGapSupport] = getBlockSettings2(
            clientId,
            "spacing.blockGap"
          );
          return { blockGapSupport };
        },
        [blockSupportsLayout, clientId]
      );
      if (!extraProps) {
        return /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
          BlockListBlock2,
          {
            ...props,
            __unstableLayoutClassNames: blockSupportsLayout ? layoutClasses : void 0
          }
        );
      }
      return /* @__PURE__ */ (0, import_jsx_runtime389.jsx)(
        BlockWithLayoutStyles,
        {
          block: BlockListBlock2,
          props,
          layoutClasses,
          ...extraProps
        }
      );
    },
    "withLayoutStyles"
  );
  (0, import_hooks30.addFilter)(
    "blocks.registerBlockType",
    "core/layout/addAttribute",
    addAttribute9
  );
  (0, import_hooks30.addFilter)(
    "editor.BlockListBlock",
    "core/editor/layout/with-layout-styles",
    withLayoutStyles
  );

  // packages/block-editor/build-module/hooks/layout-child.js
  var import_jsx_runtime393 = __toESM(require_jsx_runtime());
  var import_compose97 = __toESM(require_compose());
  var import_data178 = __toESM(require_data());
  var import_element227 = __toESM(require_element());

  // packages/block-editor/build-module/components/grid/grid-visualizer.js
  var import_jsx_runtime390 = __toESM(require_jsx_runtime());
  var import_element224 = __toESM(require_element());
  var import_data175 = __toESM(require_data());
  var import_compose94 = __toESM(require_compose());

  // packages/block-editor/build-module/components/grid/utils.js
  function range(start2, length2) {
    return Array.from({ length: length2 }, (_, i2) => start2 + i2);
  }
  var GridRect = class {
    constructor({
      columnStart,
      rowStart,
      columnEnd,
      rowEnd,
      columnSpan,
      rowSpan
    } = {}) {
      this.columnStart = columnStart ?? 1;
      this.rowStart = rowStart ?? 1;
      if (columnSpan !== void 0) {
        this.columnEnd = this.columnStart + columnSpan - 1;
      } else {
        this.columnEnd = columnEnd ?? this.columnStart;
      }
      if (rowSpan !== void 0) {
        this.rowEnd = this.rowStart + rowSpan - 1;
      } else {
        this.rowEnd = rowEnd ?? this.rowStart;
      }
    }
    get columnSpan() {
      return this.columnEnd - this.columnStart + 1;
    }
    get rowSpan() {
      return this.rowEnd - this.rowStart + 1;
    }
    contains(column2, row) {
      return column2 >= this.columnStart && column2 <= this.columnEnd && row >= this.rowStart && row <= this.rowEnd;
    }
    containsRect(rect) {
      return this.contains(rect.columnStart, rect.rowStart) && this.contains(rect.columnEnd, rect.rowEnd);
    }
    intersectsRect(rect) {
      return this.columnStart <= rect.columnEnd && this.columnEnd >= rect.columnStart && this.rowStart <= rect.rowEnd && this.rowEnd >= rect.rowStart;
    }
  };
  function getComputedCSS2(element, property) {
    return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
  }
  function getGridTracks(template2, gap) {
    const tracks = [];
    for (const size of template2.split(" ")) {
      const previousTrack = tracks[tracks.length - 1];
      const start2 = previousTrack ? previousTrack.end + gap : 0;
      const end = start2 + parseFloat(size);
      tracks.push({ start: start2, end });
    }
    return tracks;
  }
  function getClosestTrack(tracks, position2, edge = "start") {
    return tracks.reduce(
      (closest, track, index) => Math.abs(track[edge] - position2) < Math.abs(tracks[closest][edge] - position2) ? index : closest,
      0
    );
  }
  function getGridInfo(gridElement) {
    const gridTemplateColumns = getComputedCSS2(
      gridElement,
      "grid-template-columns"
    );
    const gridTemplateRows = getComputedCSS2(
      gridElement,
      "grid-template-rows"
    );
    const borderTopWidth = getComputedCSS2(gridElement, "border-top-width");
    const borderRightWidth = getComputedCSS2(
      gridElement,
      "border-right-width"
    );
    const borderBottomWidth = getComputedCSS2(
      gridElement,
      "border-bottom-width"
    );
    const borderLeftWidth = getComputedCSS2(gridElement, "border-left-width");
    const paddingTop = getComputedCSS2(gridElement, "padding-top");
    const paddingRight = getComputedCSS2(gridElement, "padding-right");
    const paddingBottom = getComputedCSS2(gridElement, "padding-bottom");
    const paddingLeft = getComputedCSS2(gridElement, "padding-left");
    const numColumns = gridTemplateColumns.split(" ").length;
    const numRows = gridTemplateRows.split(" ").length;
    const numItems = numColumns * numRows;
    return {
      numColumns,
      numRows,
      numItems,
      currentColor: getComputedCSS2(gridElement, "color"),
      style: {
        gridTemplateColumns,
        gridTemplateRows,
        gap: getComputedCSS2(gridElement, "gap"),
        inset: `
				calc(${paddingTop} + ${borderTopWidth})
				calc(${paddingRight} + ${borderRightWidth})
				calc(${paddingBottom} + ${borderBottomWidth})
				calc(${paddingLeft} + ${borderLeftWidth})
			`
      }
    };
  }

  // packages/block-editor/build-module/components/grid/grid-visualizer.js
  function GridVisualizer({ clientId, contentRef, parentLayout }) {
    const isDistractionFree = (0, import_data175.useSelect)(
      (select2) => select2(store).getSettings().isDistractionFree,
      []
    );
    const gridElement = useBlockElement(clientId);
    if (isDistractionFree || !gridElement) {
      return null;
    }
    const isManualGrid = parentLayout?.isManualPlacement && window.__experimentalEnableGridInteractivity;
    return /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
      GridVisualizerGrid,
      {
        gridClientId: clientId,
        gridElement,
        isManualGrid,
        ref: contentRef
      }
    );
  }
  var GridVisualizerGrid = (0, import_element224.forwardRef)(
    ({ gridClientId, gridElement, isManualGrid }, ref) => {
      const [gridInfo, setGridInfo] = (0, import_element224.useState)(
        () => getGridInfo(gridElement)
      );
      const [isDroppingAllowed, setIsDroppingAllowed] = (0, import_element224.useState)(false);
      (0, import_element224.useEffect)(() => {
        const resizeCallback = () => setGridInfo(getGridInfo(gridElement));
        const borderBoxSpy = new window.ResizeObserver(resizeCallback);
        borderBoxSpy.observe(gridElement, { box: "border-box" });
        const contentBoxSpy = new window.ResizeObserver(resizeCallback);
        contentBoxSpy.observe(gridElement);
        return () => {
          borderBoxSpy.disconnect();
          contentBoxSpy.disconnect();
        };
      }, [gridElement]);
      (0, import_element224.useEffect)(() => {
        function onGlobalDrag() {
          setIsDroppingAllowed(true);
        }
        function onGlobalDragEnd() {
          setIsDroppingAllowed(false);
        }
        document.addEventListener("drag", onGlobalDrag);
        document.addEventListener("dragend", onGlobalDragEnd);
        return () => {
          document.removeEventListener("drag", onGlobalDrag);
          document.removeEventListener("dragend", onGlobalDragEnd);
        };
      }, []);
      return /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
        cover_default,
        {
          className: clsx_default("block-editor-grid-visualizer", {
            "is-dropping-allowed": isDroppingAllowed
          }),
          clientId: gridClientId,
          __unstablePopoverSlot: "__unstable-block-tools-after",
          children: /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
            "div",
            {
              ref,
              className: "block-editor-grid-visualizer__grid",
              style: gridInfo.style,
              children: isManualGrid ? /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
                ManualGridVisualizer,
                {
                  gridClientId,
                  gridInfo
                }
              ) : Array.from({ length: gridInfo.numItems }, (_, i2) => /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
                GridVisualizerCell,
                {
                  color: gridInfo.currentColor
                },
                i2
              ))
            }
          )
        }
      );
    }
  );
  function ManualGridVisualizer({ gridClientId, gridInfo }) {
    const [highlightedRect, setHighlightedRect] = (0, import_element224.useState)(null);
    const gridItemStyles = (0, import_data175.useSelect)(
      (select2) => {
        const { getBlockOrder: getBlockOrder2, getBlockStyles: getBlockStyles2 } = unlock(
          select2(store)
        );
        const blockOrder = getBlockOrder2(gridClientId);
        return getBlockStyles2(blockOrder);
      },
      [gridClientId]
    );
    const occupiedRects = (0, import_element224.useMemo)(() => {
      const rects = [];
      for (const style of Object.values(gridItemStyles)) {
        const {
          columnStart,
          rowStart,
          columnSpan = 1,
          rowSpan = 1
        } = style?.layout ?? {};
        if (!columnStart || !rowStart) {
          continue;
        }
        rects.push(
          new GridRect({
            columnStart,
            rowStart,
            columnSpan,
            rowSpan
          })
        );
      }
      return rects;
    }, [gridItemStyles]);
    return range(1, gridInfo.numRows).map(
      (row) => range(1, gridInfo.numColumns).map((column2) => {
        const isCellOccupied = occupiedRects.some(
          (rect) => rect.contains(column2, row)
        );
        const isHighlighted = highlightedRect?.contains(column2, row) ?? false;
        return /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
          GridVisualizerCell,
          {
            color: gridInfo.currentColor,
            className: isHighlighted && "is-highlighted",
            children: isCellOccupied ? /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
              GridVisualizerDropZone,
              {
                column: column2,
                row,
                gridClientId,
                gridInfo,
                setHighlightedRect
              }
            ) : /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
              GridVisualizerAppender,
              {
                column: column2,
                row,
                gridClientId,
                gridInfo,
                setHighlightedRect
              }
            )
          },
          `${row}-${column2}`
        );
      })
    );
  }
  function GridVisualizerCell({ color, children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
      "div",
      {
        className: clsx_default(
          "block-editor-grid-visualizer__cell",
          className
        ),
        style: {
          boxShadow: `inset 0 0 0 1px color-mix(in srgb, ${color} 20%, #0000)`,
          color
        },
        children
      }
    );
  }
  function useGridVisualizerDropZone(column2, row, gridClientId, gridInfo, setHighlightedRect) {
    const {
      getBlockAttributes: getBlockAttributes3,
      getBlockRootClientId: getBlockRootClientId2,
      canInsertBlockType: canInsertBlockType2,
      getBlockName: getBlockName2
    } = (0, import_data175.useSelect)(store);
    const {
      updateBlockAttributes: updateBlockAttributes2,
      moveBlocksToPosition: moveBlocksToPosition2,
      __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2
    } = (0, import_data175.useDispatch)(store);
    const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
      gridClientId,
      gridInfo.numColumns
    );
    return useDropZoneWithValidation({
      validateDrag(srcClientId) {
        const blockName = getBlockName2(srcClientId);
        if (!canInsertBlockType2(blockName, gridClientId)) {
          return false;
        }
        const attributes = getBlockAttributes3(srcClientId);
        const rect = new GridRect({
          columnStart: column2,
          rowStart: row,
          columnSpan: attributes.style?.layout?.columnSpan,
          rowSpan: attributes.style?.layout?.rowSpan
        });
        const isInBounds = new GridRect({
          columnSpan: gridInfo.numColumns,
          rowSpan: gridInfo.numRows
        }).containsRect(rect);
        return isInBounds;
      },
      onDragEnter(srcClientId) {
        const attributes = getBlockAttributes3(srcClientId);
        setHighlightedRect(
          new GridRect({
            columnStart: column2,
            rowStart: row,
            columnSpan: attributes.style?.layout?.columnSpan,
            rowSpan: attributes.style?.layout?.rowSpan
          })
        );
      },
      onDragLeave() {
        setHighlightedRect(
          (prevHighlightedRect) => prevHighlightedRect?.columnStart === column2 && prevHighlightedRect?.rowStart === row ? null : prevHighlightedRect
        );
      },
      onDrop(srcClientId) {
        setHighlightedRect(null);
        const attributes = getBlockAttributes3(srcClientId);
        updateBlockAttributes2(srcClientId, {
          style: {
            ...attributes.style,
            layout: {
              ...attributes.style?.layout,
              columnStart: column2,
              rowStart: row
            }
          }
        });
        __unstableMarkNextChangeAsNotPersistent2();
        moveBlocksToPosition2(
          [srcClientId],
          getBlockRootClientId2(srcClientId),
          gridClientId,
          getNumberOfBlocksBeforeCell(column2, row)
        );
      }
    });
  }
  function GridVisualizerDropZone({
    column: column2,
    row,
    gridClientId,
    gridInfo,
    setHighlightedRect
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
      "div",
      {
        className: "block-editor-grid-visualizer__drop-zone",
        ref: useGridVisualizerDropZone(
          column2,
          row,
          gridClientId,
          gridInfo,
          setHighlightedRect
        )
      }
    );
  }
  function GridVisualizerAppender({
    column: column2,
    row,
    gridClientId,
    gridInfo,
    setHighlightedRect
  }) {
    const {
      updateBlockAttributes: updateBlockAttributes2,
      moveBlocksToPosition: moveBlocksToPosition2,
      __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2
    } = (0, import_data175.useDispatch)(store);
    const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
      gridClientId,
      gridInfo.numColumns
    );
    return /* @__PURE__ */ (0, import_jsx_runtime390.jsx)(
      button_block_appender_default,
      {
        rootClientId: gridClientId,
        className: "block-editor-grid-visualizer__appender",
        ref: useGridVisualizerDropZone(
          column2,
          row,
          gridClientId,
          gridInfo,
          setHighlightedRect
        ),
        style: {
          color: gridInfo.currentColor
        },
        onSelect: (block) => {
          if (!block) {
            return;
          }
          updateBlockAttributes2(block.clientId, {
            style: {
              layout: {
                columnStart: column2,
                rowStart: row
              }
            }
          });
          __unstableMarkNextChangeAsNotPersistent2();
          moveBlocksToPosition2(
            [block.clientId],
            gridClientId,
            gridClientId,
            getNumberOfBlocksBeforeCell(column2, row)
          );
        }
      }
    );
  }
  function useDropZoneWithValidation({
    validateDrag,
    onDragEnter,
    onDragLeave,
    onDrop
  }) {
    const { getDraggedBlockClientIds: getDraggedBlockClientIds2 } = (0, import_data175.useSelect)(store);
    return (0, import_compose94.__experimentalUseDropZone)({
      onDragEnter() {
        const [srcClientId] = getDraggedBlockClientIds2();
        if (srcClientId && validateDrag(srcClientId)) {
          onDragEnter(srcClientId);
        }
      },
      onDragLeave() {
        onDragLeave();
      },
      onDrop() {
        const [srcClientId] = getDraggedBlockClientIds2();
        if (srcClientId && validateDrag(srcClientId)) {
          onDrop(srcClientId);
        }
      }
    });
  }

  // packages/block-editor/build-module/components/grid/grid-item-resizer.js
  var import_jsx_runtime391 = __toESM(require_jsx_runtime());
  var import_components225 = __toESM(require_components());
  var import_element225 = __toESM(require_element());
  function GridItemResizer({
    clientId,
    bounds,
    onChange,
    parentLayout
  }) {
    const blockElement = useBlockElement(clientId);
    const rootBlockElement = blockElement?.parentElement;
    const { isManualPlacement } = parentLayout;
    if (!blockElement || !rootBlockElement) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime391.jsx)(
      GridItemResizerInner,
      {
        clientId,
        bounds,
        blockElement,
        rootBlockElement,
        onChange,
        isManualGrid: isManualPlacement && window.__experimentalEnableGridInteractivity
      }
    );
  }
  function GridItemResizerInner({
    clientId,
    bounds,
    blockElement,
    rootBlockElement,
    onChange,
    isManualGrid
  }) {
    const [resizeDirection, setResizeDirection] = (0, import_element225.useState)(null);
    const [enableSide, setEnableSide] = (0, import_element225.useState)({
      top: false,
      bottom: false,
      left: false,
      right: false
    });
    (0, import_element225.useEffect)(() => {
      const observer = new window.ResizeObserver(() => {
        const blockClientRect = blockElement.getBoundingClientRect();
        const rootBlockClientRect = rootBlockElement.getBoundingClientRect();
        setEnableSide({
          top: blockClientRect.top > rootBlockClientRect.top,
          bottom: blockClientRect.bottom < rootBlockClientRect.bottom,
          left: blockClientRect.left > rootBlockClientRect.left,
          right: blockClientRect.right < rootBlockClientRect.right
        });
      });
      observer.observe(blockElement);
      return () => observer.disconnect();
    }, [blockElement, rootBlockElement]);
    const justification = {
      right: "left",
      left: "right"
    };
    const alignment = {
      top: "flex-end",
      bottom: "flex-start"
    };
    const styles = {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      ...justification[resizeDirection] && {
        justifyContent: justification[resizeDirection]
      },
      ...alignment[resizeDirection] && {
        alignItems: alignment[resizeDirection]
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime391.jsx)(
      cover_default,
      {
        className: "block-editor-grid-item-resizer",
        clientId,
        __unstablePopoverSlot: "__unstable-block-tools-after",
        additionalStyles: styles,
        children: /* @__PURE__ */ (0, import_jsx_runtime391.jsx)(
          import_components225.ResizableBox,
          {
            className: "block-editor-grid-item-resizer__box",
            size: {
              width: "100%",
              height: "100%"
            },
            enable: {
              bottom: enableSide.bottom,
              bottomLeft: false,
              bottomRight: false,
              left: enableSide.left,
              right: enableSide.right,
              top: enableSide.top,
              topLeft: false,
              topRight: false
            },
            bounds,
            boundsByDirection: true,
            onPointerDown: ({ target, pointerId }) => {
              target.setPointerCapture(pointerId);
            },
            onResizeStart: (event, direction) => {
              setResizeDirection(direction);
            },
            onResizeStop: (event, direction, boxElement) => {
              const columnGap = parseFloat(
                getComputedCSS2(rootBlockElement, "column-gap")
              );
              const rowGap = parseFloat(
                getComputedCSS2(rootBlockElement, "row-gap")
              );
              const gridColumnTracks = getGridTracks(
                getComputedCSS2(
                  rootBlockElement,
                  "grid-template-columns"
                ),
                columnGap
              );
              const gridRowTracks = getGridTracks(
                getComputedCSS2(
                  rootBlockElement,
                  "grid-template-rows"
                ),
                rowGap
              );
              const rect = new window.DOMRect(
                blockElement.offsetLeft + boxElement.offsetLeft,
                blockElement.offsetTop + boxElement.offsetTop,
                boxElement.offsetWidth,
                boxElement.offsetHeight
              );
              const columnStart = getClosestTrack(gridColumnTracks, rect.left) + 1;
              const rowStart = getClosestTrack(gridRowTracks, rect.top) + 1;
              const columnEnd = getClosestTrack(gridColumnTracks, rect.right, "end") + 1;
              const rowEnd = getClosestTrack(gridRowTracks, rect.bottom, "end") + 1;
              onChange({
                columnSpan: columnEnd - columnStart + 1,
                rowSpan: rowEnd - rowStart + 1,
                columnStart: isManualGrid ? columnStart : void 0,
                rowStart: isManualGrid ? rowStart : void 0
              });
            }
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/grid/grid-item-movers.js
  var import_jsx_runtime392 = __toESM(require_jsx_runtime());
  var import_i18n205 = __toESM(require_i18n());
  var import_components226 = __toESM(require_components());
  var import_data176 = __toESM(require_data());
  var import_compose95 = __toESM(require_compose());
  function GridItemMovers({
    layout,
    parentLayout,
    onChange,
    gridClientId,
    blockClientId
  }) {
    const { moveBlocksToPosition: moveBlocksToPosition2, __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2 } = (0, import_data176.useDispatch)(store);
    const columnStart = layout?.columnStart ?? 1;
    const rowStart = layout?.rowStart ?? 1;
    const columnSpan = layout?.columnSpan ?? 1;
    const rowSpan = layout?.rowSpan ?? 1;
    const columnEnd = columnStart + columnSpan - 1;
    const rowEnd = rowStart + rowSpan - 1;
    const columnCount = parentLayout?.columnCount;
    const rowCount = parentLayout?.rowCount;
    const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
      gridClientId,
      columnCount
    );
    return /* @__PURE__ */ (0, import_jsx_runtime392.jsx)(block_controls_default, { group: "parent", children: /* @__PURE__ */ (0, import_jsx_runtime392.jsxs)(import_components226.ToolbarGroup, { className: "block-editor-grid-item-mover__move-button-container", children: [
      /* @__PURE__ */ (0, import_jsx_runtime392.jsx)("div", { className: "block-editor-grid-item-mover__move-horizontal-button-container is-left", children: /* @__PURE__ */ (0, import_jsx_runtime392.jsx)(
        GridItemMover,
        {
          icon: (0, import_i18n205.isRTL)() ? chevron_right_default : chevron_left_default,
          label: (0, import_i18n205.__)("Move left"),
          description: (0, import_i18n205.__)("Move left"),
          isDisabled: columnStart <= 1,
          onClick: () => {
            onChange({
              columnStart: columnStart - 1
            });
            __unstableMarkNextChangeAsNotPersistent2();
            moveBlocksToPosition2(
              [blockClientId],
              gridClientId,
              gridClientId,
              getNumberOfBlocksBeforeCell(
                columnStart - 1,
                rowStart
              )
            );
          }
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime392.jsxs)("div", { className: "block-editor-grid-item-mover__move-vertical-button-container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime392.jsx)(
          GridItemMover,
          {
            className: "is-up-button",
            icon: chevron_up_default,
            label: (0, import_i18n205.__)("Move up"),
            description: (0, import_i18n205.__)("Move up"),
            isDisabled: rowStart <= 1,
            onClick: () => {
              onChange({
                rowStart: rowStart - 1
              });
              __unstableMarkNextChangeAsNotPersistent2();
              moveBlocksToPosition2(
                [blockClientId],
                gridClientId,
                gridClientId,
                getNumberOfBlocksBeforeCell(
                  columnStart,
                  rowStart - 1
                )
              );
            }
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime392.jsx)(
          GridItemMover,
          {
            className: "is-down-button",
            icon: chevron_down_default,
            label: (0, import_i18n205.__)("Move down"),
            description: (0, import_i18n205.__)("Move down"),
            isDisabled: rowCount && rowEnd >= rowCount,
            onClick: () => {
              onChange({
                rowStart: rowStart + 1
              });
              __unstableMarkNextChangeAsNotPersistent2();
              moveBlocksToPosition2(
                [blockClientId],
                gridClientId,
                gridClientId,
                getNumberOfBlocksBeforeCell(
                  columnStart,
                  rowStart + 1
                )
              );
            }
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime392.jsx)("div", { className: "block-editor-grid-item-mover__move-horizontal-button-container is-right", children: /* @__PURE__ */ (0, import_jsx_runtime392.jsx)(
        GridItemMover,
        {
          icon: (0, import_i18n205.isRTL)() ? chevron_left_default : chevron_right_default,
          label: (0, import_i18n205.__)("Move right"),
          description: (0, import_i18n205.__)("Move right"),
          isDisabled: columnCount && columnEnd >= columnCount,
          onClick: () => {
            onChange({
              columnStart: columnStart + 1
            });
            __unstableMarkNextChangeAsNotPersistent2();
            moveBlocksToPosition2(
              [blockClientId],
              gridClientId,
              gridClientId,
              getNumberOfBlocksBeforeCell(
                columnStart + 1,
                rowStart
              )
            );
          }
        }
      ) })
    ] }) });
  }
  function GridItemMover({
    className,
    icon,
    label,
    isDisabled,
    onClick,
    description
  }) {
    const instanceId = (0, import_compose95.useInstanceId)(GridItemMover);
    const descriptionId = `block-editor-grid-item-mover-button__description-${instanceId}`;
    return /* @__PURE__ */ (0, import_jsx_runtime392.jsxs)(import_jsx_runtime392.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime392.jsx)(
        import_components226.ToolbarButton,
        {
          className: clsx_default(
            "block-editor-grid-item-mover-button",
            className
          ),
          icon,
          label,
          "aria-describedby": descriptionId,
          onClick: isDisabled ? null : onClick,
          disabled: isDisabled,
          accessibleWhenDisabled: true
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime392.jsx)(import_components226.VisuallyHidden, { id: descriptionId, children: description })
    ] });
  }

  // packages/block-editor/build-module/components/grid/use-grid-layout-sync.js
  var import_data177 = __toESM(require_data());
  var import_element226 = __toESM(require_element());
  var import_compose96 = __toESM(require_compose());
  function useGridLayoutSync({ clientId: gridClientId }) {
    const { gridLayout, blockOrder, selectedBlockLayout } = (0, import_data177.useSelect)(
      (select2) => {
        const { getBlockAttributes: getBlockAttributes22, getBlockOrder: getBlockOrder2 } = select2(store);
        const selectedBlock = select2(store).getSelectedBlock();
        return {
          gridLayout: getBlockAttributes22(gridClientId).layout ?? {},
          blockOrder: getBlockOrder2(gridClientId),
          selectedBlockLayout: selectedBlock?.attributes.style?.layout
        };
      },
      [gridClientId]
    );
    const { getBlockAttributes: getBlockAttributes3, getBlockRootClientId: getBlockRootClientId2 } = (0, import_data177.useSelect)(store);
    const { updateBlockAttributes: updateBlockAttributes2, __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2 } = (0, import_data177.useDispatch)(store);
    const selectedBlockRect = (0, import_element226.useMemo)(
      () => selectedBlockLayout ? new GridRect(selectedBlockLayout) : null,
      [selectedBlockLayout]
    );
    const previouslySelectedBlockRect = (0, import_compose96.usePrevious)(selectedBlockRect);
    const previousIsManualPlacement = (0, import_compose96.usePrevious)(
      gridLayout.isManualPlacement
    );
    const previousBlockOrder = (0, import_compose96.usePrevious)(blockOrder);
    (0, import_element226.useEffect)(() => {
      const updates = {};
      if (gridLayout.isManualPlacement) {
        const occupiedRects = [];
        for (const clientId of blockOrder) {
          const {
            columnStart,
            rowStart,
            columnSpan = 1,
            rowSpan = 1
          } = getBlockAttributes3(clientId).style?.layout ?? {};
          if (!columnStart || !rowStart) {
            continue;
          }
          occupiedRects.push(
            new GridRect({
              columnStart,
              rowStart,
              columnSpan,
              rowSpan
            })
          );
        }
        for (const clientId of blockOrder) {
          const attributes = getBlockAttributes3(clientId);
          const {
            columnStart,
            rowStart,
            columnSpan = 1,
            rowSpan = 1
          } = attributes.style?.layout ?? {};
          if (columnStart && rowStart) {
            continue;
          }
          const [newColumnStart, newRowStart] = placeBlock(
            occupiedRects,
            gridLayout.columnCount,
            columnSpan,
            rowSpan,
            previouslySelectedBlockRect?.columnEnd,
            previouslySelectedBlockRect?.rowEnd
          );
          occupiedRects.push(
            new GridRect({
              columnStart: newColumnStart,
              rowStart: newRowStart,
              columnSpan,
              rowSpan
            })
          );
          updates[clientId] = {
            style: {
              ...attributes.style,
              layout: {
                ...attributes.style?.layout,
                columnStart: newColumnStart,
                rowStart: newRowStart
              }
            }
          };
        }
        const bottomMostRow = Math.max(
          ...occupiedRects.map((r3) => r3.rowEnd)
        );
        if (!gridLayout.rowCount || gridLayout.rowCount < bottomMostRow) {
          updates[gridClientId] = {
            layout: {
              ...gridLayout,
              rowCount: bottomMostRow
            }
          };
        }
        for (const clientId of previousBlockOrder ?? []) {
          if (!blockOrder.includes(clientId)) {
            const rootClientId = getBlockRootClientId2(clientId);
            if (rootClientId === null) {
              continue;
            }
            const rootAttributes = getBlockAttributes3(rootClientId);
            if (rootAttributes?.layout?.type === "grid") {
              continue;
            }
            const attributes = getBlockAttributes3(clientId);
            const {
              columnStart,
              rowStart,
              columnSpan,
              rowSpan,
              ...layout
            } = attributes.style?.layout ?? {};
            if (columnStart || rowStart || columnSpan || rowSpan) {
              const hasEmptyLayoutAttribute = Object.keys(layout).length === 0;
              updates[clientId] = setImmutably(
                attributes,
                ["style", "layout"],
                hasEmptyLayoutAttribute ? void 0 : layout
              );
            }
          }
        }
      } else {
        if (previousIsManualPlacement === true) {
          for (const clientId of blockOrder) {
            const attributes = getBlockAttributes3(clientId);
            const { columnStart, rowStart, ...layout } = attributes.style?.layout ?? {};
            if (columnStart || rowStart) {
              const hasEmptyLayoutAttribute = Object.keys(layout).length === 0;
              updates[clientId] = setImmutably(
                attributes,
                ["style", "layout"],
                hasEmptyLayoutAttribute ? void 0 : layout
              );
            }
          }
        }
        if (gridLayout.rowCount) {
          updates[gridClientId] = {
            layout: {
              ...gridLayout,
              rowCount: void 0
            }
          };
        }
      }
      if (Object.keys(updates).length) {
        __unstableMarkNextChangeAsNotPersistent2();
        updateBlockAttributes2(
          Object.keys(updates),
          updates,
          /* uniqueByBlock: */
          true
        );
      }
    }, [
      // Actual deps to sync:
      gridClientId,
      gridLayout,
      previousBlockOrder,
      blockOrder,
      previouslySelectedBlockRect,
      previousIsManualPlacement,
      // These won't change, but the linter thinks they might:
      __unstableMarkNextChangeAsNotPersistent2,
      getBlockAttributes3,
      getBlockRootClientId2,
      updateBlockAttributes2
    ]);
  }
  function placeBlock(occupiedRects, gridColumnCount, blockColumnSpan, blockRowSpan, startColumn = 1, startRow = 1) {
    for (let row = startRow; ; row++) {
      for (let column2 = row === startRow ? startColumn : 1; column2 <= gridColumnCount; column2++) {
        const candidateRect = new GridRect({
          columnStart: column2,
          rowStart: row,
          columnSpan: blockColumnSpan,
          rowSpan: blockRowSpan
        });
        if (!occupiedRects.some(
          (r3) => r3.intersectsRect(candidateRect)
        )) {
          return [column2, row];
        }
      }
    }
  }

  // packages/block-editor/build-module/hooks/layout-child.js
  var LAYOUT_CHILD_BLOCK_PROPS_REFERENCE = {};
  function useBlockPropsChildLayoutStyles({ style }) {
    const shouldRenderChildLayoutStyles = (0, import_data178.useSelect)((select2) => {
      return !select2(store).getSettings().disableLayoutStyles;
    });
    const layout = style?.layout ?? {};
    const {
      selfStretch,
      flexSize,
      columnStart,
      rowStart,
      columnSpan,
      rowSpan
    } = layout;
    const parentLayout = useLayout() || {};
    const { columnCount, minimumColumnWidth } = parentLayout;
    const id = (0, import_compose97.useInstanceId)(LAYOUT_CHILD_BLOCK_PROPS_REFERENCE);
    const selector3 = `.wp-container-content-${id}`;
    if (true) {
      if (columnStart && typeof columnStart !== "number") {
        throw new Error("columnStart must be a number");
      }
      if (rowStart && typeof rowStart !== "number") {
        throw new Error("rowStart must be a number");
      }
      if (columnSpan && typeof columnSpan !== "number") {
        throw new Error("columnSpan must be a number");
      }
      if (rowSpan && typeof rowSpan !== "number") {
        throw new Error("rowSpan must be a number");
      }
    }
    let css = "";
    if (shouldRenderChildLayoutStyles) {
      if (selfStretch === "fixed" && flexSize) {
        css = `${selector3} {
				flex-basis: ${flexSize};
				box-sizing: border-box;
			}`;
      } else if (selfStretch === "fill") {
        css = `${selector3} {
				flex-grow: 1;
			}`;
      } else if (columnStart && columnSpan) {
        css = `${selector3} {
				grid-column: ${columnStart} / span ${columnSpan};
			}`;
      } else if (columnStart) {
        css = `${selector3} {
				grid-column: ${columnStart};
			}`;
      } else if (columnSpan) {
        css = `${selector3} {
				grid-column: span ${columnSpan};
			}`;
      }
      if (rowStart && rowSpan) {
        css += `${selector3} {
				grid-row: ${rowStart} / span ${rowSpan};
			}`;
      } else if (rowStart) {
        css += `${selector3} {
				grid-row: ${rowStart};
			}`;
      } else if (rowSpan) {
        css += `${selector3} {
				grid-row: span ${rowSpan};
			}`;
      }
      if ((columnSpan || columnStart) && (minimumColumnWidth || !columnCount)) {
        let parentColumnValue = parseFloat(minimumColumnWidth);
        if (isNaN(parentColumnValue)) {
          parentColumnValue = 12;
        }
        let parentColumnUnit = minimumColumnWidth?.replace(
          parentColumnValue,
          ""
        );
        if (!["px", "rem", "em"].includes(parentColumnUnit)) {
          parentColumnUnit = "rem";
        }
        let numColsToBreakAt = 2;
        if (columnSpan && columnStart) {
          numColsToBreakAt = columnSpan + columnStart - 1;
        } else if (columnSpan) {
          numColsToBreakAt = columnSpan;
        } else {
          numColsToBreakAt = columnStart;
        }
        const defaultGapValue = parentColumnUnit === "px" ? 24 : 1.5;
        const containerQueryValue = numColsToBreakAt * parentColumnValue + (numColsToBreakAt - 1) * defaultGapValue;
        const minimumContainerQueryValue = parentColumnValue * 2 + defaultGapValue - 1;
        const gridColumnValue = columnSpan && columnSpan > 1 ? "1/-1" : "auto";
        css += `@container (max-width: ${Math.max(
          containerQueryValue,
          minimumContainerQueryValue
        )}${parentColumnUnit}) {
				${selector3} {
					grid-column: ${gridColumnValue};
					grid-row: auto;
				}
			}`;
      }
    }
    useStyleOverride({ css });
    if (!css) {
      return;
    }
    return { className: `wp-container-content-${id}` };
  }
  function ChildLayoutControlsPure({ clientId, style, setAttributes }) {
    const parentLayout = useLayout() || {};
    const {
      type: parentLayoutType = "default",
      allowSizingOnChildren = false,
      isManualPlacement
    } = parentLayout;
    if (parentLayoutType !== "grid") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime393.jsx)(
      GridTools,
      {
        clientId,
        style,
        setAttributes,
        allowSizingOnChildren,
        isManualPlacement,
        parentLayout
      }
    );
  }
  function GridTools({
    clientId,
    style,
    setAttributes,
    allowSizingOnChildren,
    isManualPlacement,
    parentLayout
  }) {
    const { rootClientId, isVisible } = (0, import_data178.useSelect)(
      (select2) => {
        const {
          getBlockRootClientId: getBlockRootClientId2,
          getBlockEditingMode: getBlockEditingMode2,
          getTemplateLock: getTemplateLock2
        } = select2(store);
        const _rootClientId = getBlockRootClientId2(clientId);
        if (getTemplateLock2(_rootClientId) || getBlockEditingMode2(_rootClientId) !== "default") {
          return {
            rootClientId: _rootClientId,
            isVisible: false
          };
        }
        return {
          rootClientId: _rootClientId,
          isVisible: true
        };
      },
      [clientId]
    );
    const [resizerBounds, setResizerBounds] = (0, import_element227.useState)();
    if (!isVisible) {
      return null;
    }
    function updateLayout(layout) {
      setAttributes({
        style: {
          ...style,
          layout: {
            ...style?.layout,
            ...layout
          }
        }
      });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime393.jsxs)(import_jsx_runtime393.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime393.jsx)(
        GridVisualizer,
        {
          clientId: rootClientId,
          contentRef: setResizerBounds,
          parentLayout
        }
      ),
      allowSizingOnChildren && /* @__PURE__ */ (0, import_jsx_runtime393.jsx)(
        GridItemResizer,
        {
          clientId,
          bounds: resizerBounds,
          onChange: updateLayout,
          parentLayout
        }
      ),
      isManualPlacement && window.__experimentalEnableGridInteractivity && /* @__PURE__ */ (0, import_jsx_runtime393.jsx)(
        GridItemMovers,
        {
          layout: style?.layout,
          parentLayout,
          onChange: updateLayout,
          gridClientId: rootClientId,
          blockClientId: clientId
        }
      )
    ] });
  }
  var layout_child_default = {
    useBlockProps: useBlockPropsChildLayoutStyles,
    edit: ChildLayoutControlsPure,
    attributeKeys: ["style"],
    hasSupport() {
      return true;
    }
  };

  // packages/block-editor/build-module/hooks/content-lock-ui.js
  var import_jsx_runtime394 = __toESM(require_jsx_runtime());
  var import_components227 = __toESM(require_components());
  var import_data179 = __toESM(require_data());
  var import_i18n206 = __toESM(require_i18n());
  var import_element228 = __toESM(require_element());
  function ContentLockControlsPure({ clientId }) {
    const { templateLock, isLockedByParent, isEditingAsBlocks } = (0, import_data179.useSelect)(
      (select2) => {
        const {
          getContentLockingParent: getContentLockingParent2,
          getTemplateLock: getTemplateLock2,
          getTemporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks2
        } = unlock(select2(store));
        return {
          templateLock: getTemplateLock2(clientId),
          isLockedByParent: !!getContentLockingParent2(clientId),
          isEditingAsBlocks: getTemporarilyEditingAsBlocks2() === clientId
        };
      },
      [clientId]
    );
    const { stopEditingAsBlocks: stopEditingAsBlocks2 } = unlock((0, import_data179.useDispatch)(store));
    const isContentLocked = !isLockedByParent && templateLock === "contentOnly";
    const stopEditingAsBlockCallback = (0, import_element228.useCallback)(() => {
      stopEditingAsBlocks2(clientId);
    }, [clientId, stopEditingAsBlocks2]);
    if (!isContentLocked && !isEditingAsBlocks) {
      return null;
    }
    const showStopEditingAsBlocks = isEditingAsBlocks && !isContentLocked;
    return showStopEditingAsBlocks && /* @__PURE__ */ (0, import_jsx_runtime394.jsx)(block_controls_default, { group: "other", children: /* @__PURE__ */ (0, import_jsx_runtime394.jsx)(import_components227.ToolbarButton, { onClick: stopEditingAsBlockCallback, children: (0, import_i18n206.__)("Done") }) });
  }
  var content_lock_ui_default = {
    edit: ContentLockControlsPure,
    hasSupport() {
      return true;
    }
  };

  // packages/block-editor/build-module/hooks/metadata.js
  var import_hooks31 = __toESM(require_hooks());
  var META_ATTRIBUTE_NAME = "metadata";
  function addMetaAttribute(blockTypeSettings) {
    if (blockTypeSettings?.attributes?.[META_ATTRIBUTE_NAME]?.type) {
      return blockTypeSettings;
    }
    blockTypeSettings.attributes = {
      ...blockTypeSettings.attributes,
      [META_ATTRIBUTE_NAME]: {
        type: "object"
      }
    };
    return blockTypeSettings;
  }
  (0, import_hooks31.addFilter)(
    "blocks.registerBlockType",
    "core/metadata/addMetaAttribute",
    addMetaAttribute
  );

  // packages/block-editor/build-module/hooks/block-hooks.js
  var import_jsx_runtime395 = __toESM(require_jsx_runtime());
  var import_i18n207 = __toESM(require_i18n());
  var import_element229 = __toESM(require_element());
  var import_components229 = __toESM(require_components());
  var import_blocks111 = __toESM(require_blocks());
  var import_data180 = __toESM(require_data());
  var EMPTY_OBJECT3 = {};
  function BlockHooksControlPure({
    name,
    clientId,
    metadata: { ignoredHookedBlocks = [] } = {}
  }) {
    const blockTypes = (0, import_data180.useSelect)(
      (select2) => select2(import_blocks111.store).getBlockTypes(),
      []
    );
    const hookedBlocksForCurrentBlock = (0, import_element229.useMemo)(
      () => blockTypes?.filter(
        ({ name: blockName, blockHooks }) => blockHooks && name in blockHooks || ignoredHookedBlocks.includes(blockName)
      ),
      [blockTypes, name, ignoredHookedBlocks]
    );
    const hookedBlockClientIds = (0, import_data180.useSelect)(
      (select2) => {
        const { getBlocks: getBlocks2, getBlockRootClientId: getBlockRootClientId22, getGlobalBlockCount: getGlobalBlockCount2 } = select2(store);
        const rootClientId = getBlockRootClientId22(clientId);
        const _hookedBlockClientIds = hookedBlocksForCurrentBlock.reduce(
          (clientIds, block) => {
            if (getGlobalBlockCount2(block.name) === 0) {
              return clientIds;
            }
            const relativePosition = block?.blockHooks?.[name];
            let candidates;
            switch (relativePosition) {
              case "before":
              case "after":
                candidates = getBlocks2(rootClientId);
                break;
              case "first_child":
              case "last_child":
                candidates = getBlocks2(clientId);
                break;
              case void 0:
                candidates = [
                  ...getBlocks2(rootClientId),
                  ...getBlocks2(clientId)
                ];
                break;
            }
            const hookedBlock = candidates?.find(
              (candidate) => candidate.name === block.name
            );
            if (hookedBlock) {
              return {
                ...clientIds,
                [block.name]: hookedBlock.clientId
              };
            }
            return clientIds;
          },
          {}
        );
        if (Object.values(_hookedBlockClientIds).length > 0) {
          return _hookedBlockClientIds;
        }
        return EMPTY_OBJECT3;
      },
      [hookedBlocksForCurrentBlock, name, clientId]
    );
    const { getBlockIndex: getBlockIndex2, getBlockCount: getBlockCount2, getBlockRootClientId: getBlockRootClientId2 } = (0, import_data180.useSelect)(store);
    const { insertBlock: insertBlock2, removeBlock: removeBlock2 } = (0, import_data180.useDispatch)(store);
    if (!hookedBlocksForCurrentBlock.length) {
      return null;
    }
    const groupedHookedBlocks = hookedBlocksForCurrentBlock.reduce(
      (groups3, block) => {
        const [namespace] = block.name.split("/");
        if (!groups3[namespace]) {
          groups3[namespace] = [];
        }
        groups3[namespace].push(block);
        return groups3;
      },
      {}
    );
    const insertBlockIntoDesignatedLocation = (block, relativePosition) => {
      const blockIndex = getBlockIndex2(clientId);
      const innerBlocksLength = getBlockCount2(clientId);
      const rootClientId = getBlockRootClientId2(clientId);
      switch (relativePosition) {
        case "before":
        case "after":
          insertBlock2(
            block,
            relativePosition === "after" ? blockIndex + 1 : blockIndex,
            rootClientId,
            // Insert as a child of the current block's parent
            false
          );
          break;
        case "first_child":
        case "last_child":
          insertBlock2(
            block,
            // TODO: It'd be great if insertBlock() would accept negative indices for insertion.
            relativePosition === "first_child" ? 0 : innerBlocksLength,
            clientId,
            // Insert as a child of the current block.
            false
          );
          break;
        case void 0:
          insertBlock2(
            block,
            blockIndex + 1,
            rootClientId,
            // Insert as a child of the current block's parent
            false
          );
          break;
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime395.jsx)(inspector_controls_default, { children: /* @__PURE__ */ (0, import_jsx_runtime395.jsxs)(
      import_components229.PanelBody,
      {
        className: "block-editor-hooks__block-hooks",
        title: (0, import_i18n207.__)("Plugins"),
        initialOpen: true,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime395.jsx)("p", { className: "block-editor-hooks__block-hooks-helptext", children: (0, import_i18n207.__)(
            "Manage the inclusion of blocks added automatically by plugins."
          ) }),
          Object.keys(groupedHookedBlocks).map((vendor) => {
            return /* @__PURE__ */ (0, import_jsx_runtime395.jsxs)(import_element229.Fragment, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime395.jsx)("h3", { children: vendor }),
              groupedHookedBlocks[vendor].map((block) => {
                const checked = block.name in hookedBlockClientIds;
                return /* @__PURE__ */ (0, import_jsx_runtime395.jsx)(
                  import_components229.ToggleControl,
                  {
                    __nextHasNoMarginBottom: true,
                    checked,
                    label: block.title,
                    onChange: () => {
                      if (!checked) {
                        const relativePosition = block.blockHooks[name];
                        insertBlockIntoDesignatedLocation(
                          (0, import_blocks111.createBlock)(block.name),
                          relativePosition
                        );
                        return;
                      }
                      removeBlock2(
                        hookedBlockClientIds[block.name],
                        false
                      );
                    }
                  },
                  block.title
                );
              })
            ] }, vendor);
          })
        ]
      }
    ) });
  }
  var block_hooks_default = {
    edit: BlockHooksControlPure,
    attributeKeys: ["metadata"],
    hasSupport() {
      return true;
    }
  };

  // packages/block-editor/build-module/hooks/block-bindings.js
  var import_jsx_runtime396 = __toESM(require_jsx_runtime());
  var import_es66 = __toESM(require_es6());
  var import_i18n208 = __toESM(require_i18n());
  var import_blocks112 = __toESM(require_blocks());
  var import_components231 = __toESM(require_components());
  var import_data181 = __toESM(require_data());
  var import_element230 = __toESM(require_element());
  var import_compose98 = __toESM(require_compose());
  var { Menu } = unlock(import_components231.privateApis);
  var EMPTY_OBJECT4 = {};
  var getAttributeType = (blockName, attribute) => {
    const _attributeType = (0, import_blocks112.getBlockType)(blockName).attributes?.[attribute]?.type;
    return _attributeType === "rich-text" ? "string" : _attributeType;
  };
  var useToolsPanelDropdownMenuProps2 = () => {
    const isMobile = (0, import_compose98.useViewportMatch)("medium", "<");
    return !isMobile ? {
      popoverProps: {
        placement: "left-start",
        // For non-mobile, inner sidebar width (248px) - button width (24px) - border (1px) + padding (16px) + spacing (20px)
        offset: 259
      }
    } : {};
  };
  function BlockBindingsPanelMenuContent({
    attribute,
    binding,
    sources,
    onOpenModal
  }) {
    const { clientId } = useBlockEditContext();
    const { updateBlockBindings } = useBlockBindingsUtils();
    const isMobile = (0, import_compose98.useViewportMatch)("medium", "<");
    const blockContext = (0, import_element230.useContext)(block_context_default);
    const { attributeType, select: select2 } = (0, import_data181.useSelect)(
      (_select) => {
        const { name: blockName } = _select(store).getBlock(clientId);
        return {
          attributeType: getAttributeType(blockName, attribute),
          select: _select
        };
      },
      [clientId, attribute]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu, { placement: isMobile ? "bottom-start" : "left-start", children: Object.entries(sources).map(([sourceKey, source]) => {
      const sourceDataItems = source.data?.filter(
        (item) => item?.type === attributeType
      );
      const noItemsAvailable = !sourceDataItems || sourceDataItems.length === 0;
      if (noItemsAvailable) {
        return null;
      }
      if (source.mode === "dropdown") {
        return /* @__PURE__ */ (0, import_jsx_runtime396.jsxs)(
          Menu,
          {
            placement: isMobile ? "bottom-start" : "left-start",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.SubmenuTriggerItem, { children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.ItemLabel, { children: source.label }) }),
              /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.Popover, { gutter: 8, children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.Group, { children: sourceDataItems.map((item) => {
                const itemBindings = {
                  source: sourceKey,
                  args: item?.args || {
                    key: item.key
                  }
                };
                const values = source.getValues({
                  select: select2,
                  context: blockContext,
                  bindings: {
                    [attribute]: itemBindings
                  }
                });
                return /* @__PURE__ */ (0, import_jsx_runtime396.jsxs)(
                  Menu.CheckboxItem,
                  {
                    onChange: () => {
                      const isCurrentlySelected = (0, import_es66.default)(
                        binding?.args,
                        item.args
                      ) ?? // Deprecate key dependency in 7.0.
                      item.key === binding?.args?.key;
                      if (isCurrentlySelected) {
                        updateBlockBindings({
                          [attribute]: void 0
                        });
                      } else {
                        updateBlockBindings({
                          [attribute]: itemBindings
                        });
                      }
                    },
                    name: attribute + "-binding",
                    value: values[attribute],
                    checked: (0, import_es66.default)(
                      binding?.args,
                      item.args
                    ) ?? // Deprecate key dependency in 7.0.
                    item.key === binding?.args?.key,
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.ItemLabel, { children: item?.label }),
                      /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.ItemHelpText, { children: values[attribute] })
                    ]
                  },
                  sourceKey + JSON.stringify(
                    item.args
                  ) || item.key
                );
              }) }) })
            ]
          },
          sourceKey
        );
      }
      if (source.mode === "modal") {
        return /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
          Menu.Item,
          {
            onClick: () => onOpenModal({ sourceKey }),
            children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.ItemLabel, { children: source.label })
          },
          sourceKey
        );
      }
      return null;
    }) });
  }
  function BlockBindingsAttribute({ attribute, binding, sources, blockName }) {
    const { source: sourceName, args } = binding || {};
    const source = sources?.[sourceName];
    let displayText;
    let isValid = true;
    const isNotBound = binding === void 0;
    if (isNotBound) {
      const attributeType = getAttributeType(blockName, attribute);
      const hasCompatibleSources = Object.values(sources).some(
        (src) => src.data?.some((item) => item?.type === attributeType)
      );
      if (!hasCompatibleSources) {
        displayText = (0, import_i18n208.__)("No sources available");
      } else {
        displayText = (0, import_i18n208.__)("Not connected");
      }
      isValid = true;
    } else if (!source) {
      isValid = false;
      displayText = (0, import_i18n208.__)("Source not registered");
      if (Object.keys(sources).length === 0) {
        displayText = (0, import_i18n208.__)("No sources available");
      }
    } else {
      displayText = source.data?.find((item) => (0, import_es66.default)(item.args, args))?.label || source.label || sourceName;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime396.jsxs)(import_components231.__experimentalVStack, { className: "block-editor-bindings__item", spacing: 0, children: [
      /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(import_components231.__experimentalText, { truncate: true, children: attribute }),
      /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
        import_components231.__experimentalText,
        {
          truncate: true,
          variant: isValid ? "muted" : void 0,
          isDestructive: !isValid,
          children: displayText
        }
      )
    ] });
  }
  function ReadOnlyBlockBindingsPanelItem({
    attribute,
    binding,
    sources,
    blockName
  }) {
    const isMobile = (0, import_compose98.useViewportMatch)("medium", "<");
    return /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(import_components231.__experimentalToolsPanelItem, { hasValue: () => !!binding, label: attribute, children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu, { placement: isMobile ? "bottom-start" : "left-start", children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.TriggerButton, { render: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(import_components231.__experimentalItem, {}), disabled: true, children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
      BlockBindingsAttribute,
      {
        attribute,
        binding,
        sources,
        blockName
      }
    ) }) }) });
  }
  function EditableBlockBindingsPanelItem({
    attribute,
    binding,
    sources,
    setModalState,
    blockName
  }) {
    const { updateBlockBindings } = useBlockBindingsUtils();
    const isMobile = (0, import_compose98.useViewportMatch)("medium", "<");
    const handleOpenModal = ({ sourceKey }) => {
      setModalState({ attribute, sourceKey });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
      import_components231.__experimentalToolsPanelItem,
      {
        hasValue: () => !!binding,
        label: attribute,
        onDeselect: () => {
          updateBlockBindings({
            [attribute]: void 0
          });
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime396.jsxs)(Menu, { placement: isMobile ? "bottom-start" : "left-start", children: [
          /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.TriggerButton, { render: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(import_components231.__experimentalItem, {}), children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
            BlockBindingsAttribute,
            {
              attribute,
              binding,
              sources,
              blockName
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(Menu.Popover, { gutter: isMobile ? 8 : 36, children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
            BlockBindingsPanelMenuContent,
            {
              attribute,
              binding,
              sources,
              onOpenModal: handleOpenModal
            }
          ) })
        ] })
      }
    );
  }
  var BlockBindingsPanel = ({ name: blockName, metadata }) => {
    const blockContext = (0, import_element230.useContext)(block_context_default);
    const { removeAllBlockBindings } = useBlockBindingsUtils();
    const dropdownMenuProps = useToolsPanelDropdownMenuProps2();
    const [modalState, setModalState] = (0, import_element230.useState)(null);
    const handleCloseModal = () => {
      setModalState(null);
    };
    const _sources = {};
    const { sources, canUpdateBlockBindings, bindableAttributes } = (0, import_data181.useSelect)(
      (select2) => {
        const { __experimentalBlockBindingsSupportedAttributes } = select2(store).getSettings();
        const _bindableAttributes = __experimentalBlockBindingsSupportedAttributes?.[blockName];
        if (!_bindableAttributes || _bindableAttributes.length === 0) {
          return EMPTY_OBJECT4;
        }
        const registeredSources = (0, import_blocks112.getBlockBindingsSources)();
        Object.entries(registeredSources).forEach(
          ([
            sourceName,
            { editorUI, getFieldsList, usesContext, label, getValues }
          ]) => {
            const context = {};
            if (usesContext?.length) {
              for (const key of usesContext) {
                context[key] = blockContext[key];
              }
            }
            if (editorUI) {
              const editorUIResult = editorUI({
                select: select2,
                context
              });
              _sources[sourceName] = {
                ...editorUIResult,
                label,
                getValues
              };
            } else if (getFieldsList) {
              const fieldsListResult = getFieldsList({
                select: select2,
                context
              });
              if (fieldsListResult) {
                const data = Object.entries(fieldsListResult).map(
                  ([key, field]) => ({
                    label: field.label || key,
                    type: field.type || "string",
                    args: { key }
                  })
                );
                _sources[sourceName] = {
                  mode: "dropdown",
                  // Default mode for backward compatibility.
                  data,
                  label,
                  getValues
                };
              }
            } else {
              _sources[sourceName] = {
                data: [],
                label,
                getValues
              };
            }
          }
        );
        return {
          sources: Object.values(_sources).length > 0 ? _sources : EMPTY_OBJECT4,
          canUpdateBlockBindings: select2(store).getSettings().canUpdateBlockBindings,
          bindableAttributes: _bindableAttributes
        };
      },
      [blockContext, blockName]
    );
    if (!bindableAttributes || bindableAttributes.length === 0) {
      return null;
    }
    const { bindings } = metadata || {};
    const hasCompatibleData = Object.values(sources).some(
      (source) => source.data && source.data.length > 0
    );
    const readOnly = !canUpdateBlockBindings || !hasCompatibleData;
    const RenderModalContent = sources[modalState?.sourceKey]?.renderModalContent;
    if (bindings === void 0 && !hasCompatibleData) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime396.jsxs)(inspector_controls_default, { group: "bindings", children: [
      /* @__PURE__ */ (0, import_jsx_runtime396.jsxs)(
        import_components231.__experimentalToolsPanel,
        {
          label: (0, import_i18n208.__)("Attributes"),
          resetAll: () => {
            removeAllBlockBindings();
          },
          dropdownMenuProps,
          className: "block-editor-bindings__panel",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(import_components231.__experimentalItemGroup, { isBordered: true, isSeparated: true, children: bindableAttributes.map((attribute) => {
              const binding = bindings?.[attribute];
              const attributeType = getAttributeType(
                blockName,
                attribute
              );
              const hasCompatibleDataForAttribute = Object.values(
                sources
              ).some(
                (source) => source.data?.some(
                  (item) => item?.type === attributeType
                )
              );
              const isAttributeReadOnly = readOnly || !hasCompatibleDataForAttribute;
              return isAttributeReadOnly ? /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
                ReadOnlyBlockBindingsPanelItem,
                {
                  attribute,
                  binding,
                  sources,
                  blockName
                },
                attribute
              ) : /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
                EditableBlockBindingsPanelItem,
                {
                  attribute,
                  binding,
                  sources,
                  setModalState,
                  blockName
                },
                attribute
              );
            }) }),
            /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(import_components231.__experimentalText, { as: "div", variant: "muted", children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)("p", { children: (0, import_i18n208.__)(
              "Attributes connected to custom fields or other dynamic data."
            ) }) })
          ]
        }
      ),
      RenderModalContent && /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(import_components231.Modal, { onRequestClose: handleCloseModal, children: /* @__PURE__ */ (0, import_jsx_runtime396.jsx)(
        RenderModalContent,
        {
          attribute: modalState.attribute,
          closeModal: handleCloseModal
        }
      ) })
    ] });
  };
  var block_bindings_default = {
    edit: BlockBindingsPanel,
    attributeKeys: ["metadata"],
    hasSupport() {
      return true;
    }
  };

  // packages/block-editor/build-module/hooks/block-renaming.js
  var import_hooks32 = __toESM(require_hooks());
  var import_blocks113 = __toESM(require_blocks());
  function addLabelCallback(settings2) {
    if (settings2.__experimentalLabel) {
      return settings2;
    }
    const supportsBlockNaming = (0, import_blocks113.hasBlockSupport)(
      settings2,
      "renaming",
      true
      // default value
    );
    if (supportsBlockNaming) {
      settings2.__experimentalLabel = (attributes, { context }) => {
        const { metadata } = attributes;
        if (context === "list-view" && metadata?.name) {
          return metadata.name;
        }
      };
    }
    return settings2;
  }
  (0, import_hooks32.addFilter)(
    "blocks.registerBlockType",
    "core/metadata/addLabelCallback",
    addLabelCallback
  );

  // packages/block-editor/build-module/hooks/grid-visualizer.js
  var import_jsx_runtime397 = __toESM(require_jsx_runtime());
  var import_compose99 = __toESM(require_compose());
  var import_hooks33 = __toESM(require_hooks());
  var import_data182 = __toESM(require_data());
  function GridLayoutSync(props) {
    useGridLayoutSync(props);
  }
  function GridTools2({ clientId, layout }) {
    const isVisible = (0, import_data182.useSelect)(
      (select2) => {
        const {
          isBlockSelected: isBlockSelected2,
          isDraggingBlocks: isDraggingBlocks2,
          getTemplateLock: getTemplateLock2,
          getBlockEditingMode: getBlockEditingMode2
        } = select2(store);
        if (!isDraggingBlocks2() && !isBlockSelected2(clientId) || getTemplateLock2(clientId) || getBlockEditingMode2(clientId) !== "default") {
          return false;
        }
        return true;
      },
      [clientId]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime397.jsxs)(import_jsx_runtime397.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime397.jsx)(GridLayoutSync, { clientId }),
      isVisible && /* @__PURE__ */ (0, import_jsx_runtime397.jsx)(GridVisualizer, { clientId, parentLayout: layout })
    ] });
  }
  var addGridVisualizerToBlockEdit = (0, import_compose99.createHigherOrderComponent)(
    (BlockEdit2) => (props) => {
      if (props.attributes.layout?.type !== "grid") {
        return /* @__PURE__ */ (0, import_jsx_runtime397.jsx)(BlockEdit2, { ...props }, "edit");
      }
      return /* @__PURE__ */ (0, import_jsx_runtime397.jsxs)(import_jsx_runtime397.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime397.jsx)(
          GridTools2,
          {
            clientId: props.clientId,
            layout: props.attributes.layout
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime397.jsx)(BlockEdit2, { ...props }, "edit")
      ] });
    },
    "addGridVisualizerToBlockEdit"
  );
  (0, import_hooks33.addFilter)(
    "editor.BlockEdit",
    "core/editor/grid-visualizer",
    addGridVisualizerToBlockEdit
  );

  // packages/block-editor/build-module/hooks/use-border-props.js
  function getBorderClassesAndStyles(attributes) {
    const border = attributes.style?.border || {};
    const className = getBorderClasses(attributes);
    return {
      className: className || void 0,
      style: getInlineStyles({ border })
    };
  }
  function useBorderProps(attributes) {
    const { colors: colors2 } = useMultipleOriginColorsAndGradients();
    const borderProps = getBorderClassesAndStyles(attributes);
    const { borderColor } = attributes;
    if (borderColor) {
      const borderColorObject = getMultiOriginColor({
        colors: colors2,
        namedColor: borderColor
      });
      borderProps.style.borderColor = borderColorObject.color;
    }
    return borderProps;
  }

  // packages/block-editor/build-module/hooks/use-shadow-props.js
  function getShadowClassesAndStyles(attributes) {
    const shadow = attributes.style?.shadow || "";
    return {
      style: getInlineStyles({ shadow })
    };
  }

  // packages/block-editor/build-module/hooks/use-color-props.js
  var import_element231 = __toESM(require_element());
  function getColorClassesAndStyles(attributes) {
    const { backgroundColor, textColor, gradient, style } = attributes;
    const backgroundClass = getColorClassName(
      "background-color",
      backgroundColor
    );
    const textClass = getColorClassName("color", textColor);
    const gradientClass = __experimentalGetGradientClass(gradient);
    const hasGradient = gradientClass || style?.color?.gradient;
    const className = clsx_default(textClass, gradientClass, {
      // Don't apply the background class if there's a gradient.
      [backgroundClass]: !hasGradient && !!backgroundClass,
      "has-text-color": textColor || style?.color?.text,
      "has-background": backgroundColor || style?.color?.background || gradient || style?.color?.gradient,
      "has-link-color": style?.elements?.link?.color
    });
    const colorStyles = style?.color || {};
    const styleProp = getInlineStyles({ color: colorStyles });
    return {
      className: className || void 0,
      style: styleProp
    };
  }
  function useColorProps(attributes) {
    const { backgroundColor, textColor, gradient } = attributes;
    const [
      userPalette,
      themePalette,
      defaultPalette,
      userGradients,
      themeGradients,
      defaultGradients
    ] = useSettings(
      "color.palette.custom",
      "color.palette.theme",
      "color.palette.default",
      "color.gradients.custom",
      "color.gradients.theme",
      "color.gradients.default"
    );
    const colors2 = (0, import_element231.useMemo)(
      () => [
        ...userPalette || [],
        ...themePalette || [],
        ...defaultPalette || []
      ],
      [userPalette, themePalette, defaultPalette]
    );
    const gradients = (0, import_element231.useMemo)(
      () => [
        ...userGradients || [],
        ...themeGradients || [],
        ...defaultGradients || []
      ],
      [userGradients, themeGradients, defaultGradients]
    );
    const colorProps = getColorClassesAndStyles(attributes);
    if (backgroundColor) {
      const backgroundColorObject = getColorObjectByAttributeValues(
        colors2,
        backgroundColor
      );
      colorProps.style.backgroundColor = backgroundColorObject.color;
    }
    if (gradient) {
      colorProps.style.background = getGradientValueBySlug(
        gradients,
        gradient
      );
    }
    if (textColor) {
      const textColorObject = getColorObjectByAttributeValues(
        colors2,
        textColor
      );
      colorProps.style.color = textColorObject.color;
    }
    return colorProps;
  }

  // packages/block-editor/build-module/hooks/use-spacing-props.js
  function getSpacingClassesAndStyles(attributes) {
    const { style } = attributes;
    const spacingStyles = style?.spacing || {};
    const styleProp = getInlineStyles({ spacing: spacingStyles });
    return {
      style: styleProp
    };
  }

  // packages/block-editor/build-module/hooks/use-typography-props.js
  var import_components232 = __toESM(require_components());
  var { kebabCase: kebabCase7 } = unlock(import_components232.privateApis);
  function getTypographyClassesAndStyles(attributes, settings2) {
    let typographyStyles = attributes?.style?.typography || {};
    typographyStyles = {
      ...typographyStyles,
      fontSize: getTypographyFontSizeValue(
        { size: attributes?.style?.typography?.fontSize },
        settings2
      )
    };
    const style = getInlineStyles({ typography: typographyStyles });
    const fontFamilyClassName = !!attributes?.fontFamily ? `has-${kebabCase7(attributes.fontFamily)}-font-family` : "";
    const textAlignClassName = !!attributes?.style?.typography?.textAlign ? `has-text-align-${attributes?.style?.typography?.textAlign}` : "";
    const className = clsx_default(
      fontFamilyClassName,
      textAlignClassName,
      getFontSizeClass(attributes?.fontSize)
    );
    return {
      className,
      style
    };
  }

  // packages/block-editor/build-module/hooks/use-cached-truthy.js
  var import_element232 = __toESM(require_element());
  function useCachedTruthy(value) {
    const [cachedValue, setCachedValue] = (0, import_element232.useState)(value);
    (0, import_element232.useEffect)(() => {
      if (value) {
        setCachedValue(value);
      }
    }, [value]);
    return cachedValue;
  }

  // packages/block-editor/build-module/hooks/index.js
  createBlockEditFilter(
    [
      align_default,
      text_align_default,
      anchor_default,
      custom_class_name_default,
      style_default,
      duotone_default,
      fit_text_default,
      position_default,
      layout_default2,
      content_lock_ui_default,
      block_hooks_default,
      block_bindings_default,
      layout_child_default,
      allowed_blocks_default
    ].filter(Boolean)
  );
  createBlockListBlockFilter([
    align_default,
    text_align_default,
    background_default,
    style_default,
    color_default,
    dimensions_default,
    duotone_default,
    font_family_default,
    font_size_default,
    fit_text_default,
    border_default,
    position_default,
    block_style_variation_default,
    layout_child_default
  ]);
  createBlockSaveFilter([
    align_default,
    text_align_default,
    anchor_default,
    aria_label_default,
    custom_class_name_default,
    border_default,
    fit_text_default,
    color_default,
    style_default,
    font_family_default,
    font_size_default
  ]);

  // packages/block-editor/build-module/elements/index.js
  var ELEMENT_CLASS_NAMES2 = {
    button: "wp-element-button",
    caption: "wp-element-caption"
  };
  var __experimentalGetElementClassName = (element) => {
    return ELEMENT_CLASS_NAMES2[element] ? ELEMENT_CLASS_NAMES2[element] : "";
  };

  // packages/block-editor/build-module/utils/get-px-from-css-unit.js
  var get_px_from_css_unit_default = () => "";

  // packages/block-editor/build-module/components/rich-text/get-rich-text-values.js
  var import_jsx_runtime398 = __toESM(require_jsx_runtime());
  var import_element233 = __toESM(require_element());
  var import_blocks114 = __toESM(require_blocks());
  var import_rich_text18 = __toESM(require_rich_text());
  function addValuesForElement(element, values, innerBlocks) {
    if (null === element || void 0 === element || false === element) {
      return;
    }
    if (Array.isArray(element)) {
      return addValuesForElements(element, values, innerBlocks);
    }
    switch (typeof element) {
      case "string":
      case "number":
        return;
    }
    const { type, props } = element;
    switch (type) {
      case import_element233.StrictMode:
      case import_element233.Fragment:
        return addValuesForElements(props.children, values, innerBlocks);
      case import_element233.RawHTML:
        return;
      case inner_blocks_default.Content:
        return addValuesForBlocks(values, innerBlocks);
      case Content:
        values.push(props.value);
        return;
    }
    switch (typeof type) {
      case "string":
        if (typeof props.children !== "undefined") {
          return addValuesForElements(
            props.children,
            values,
            innerBlocks
          );
        }
        return;
      case "function":
        const el = type.prototype && typeof type.prototype.render === "function" ? new type(props).render() : type(props);
        return addValuesForElement(el, values, innerBlocks);
    }
  }
  function addValuesForElements(children, ...args) {
    children = Array.isArray(children) ? children : [children];
    for (let i2 = 0; i2 < children.length; i2++) {
      addValuesForElement(children[i2], ...args);
    }
  }
  function addValuesForBlocks(values, blocks2) {
    for (let i2 = 0; i2 < blocks2.length; i2++) {
      const { name, attributes, innerBlocks } = blocks2[i2];
      const saveElement = (0, import_blocks114.getSaveElement)(
        name,
        attributes,
        // Instead of letting save elements use `useInnerBlocksProps.save`,
        // force them to use InnerBlocks.Content instead so we can intercept
        // a single component.
        /* @__PURE__ */ (0, import_jsx_runtime398.jsx)(inner_blocks_default.Content, {})
      );
      addValuesForElement(saveElement, values, innerBlocks);
    }
  }
  function getRichTextValues(blocks2 = []) {
    import_blocks114.__unstableGetBlockProps.skipFilters = true;
    const values = [];
    addValuesForBlocks(values, blocks2);
    import_blocks114.__unstableGetBlockProps.skipFilters = false;
    return values.map(
      (value) => value instanceof import_rich_text18.RichTextData ? value : import_rich_text18.RichTextData.fromHTMLString(value)
    );
  }

  // packages/block-editor/build-module/components/resizable-box-popover/index.js
  var import_jsx_runtime399 = __toESM(require_jsx_runtime());
  var import_components233 = __toESM(require_components());
  function ResizableBoxPopover({
    clientId,
    resizableBoxProps,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime399.jsx)(
      cover_default,
      {
        clientId,
        __unstablePopoverSlot: "block-toolbar",
        ...props,
        children: /* @__PURE__ */ (0, import_jsx_runtime399.jsx)(import_components233.ResizableBox, { ...resizableBoxProps })
      }
    );
  }

  // packages/block-editor/build-module/components/block-removal-warning-modal/index.js
  var import_jsx_runtime400 = __toESM(require_jsx_runtime());
  var import_element234 = __toESM(require_element());
  var import_data183 = __toESM(require_data());
  var import_components234 = __toESM(require_components());
  var import_i18n209 = __toESM(require_i18n());
  function BlockRemovalWarningModal({ rules }) {
    const { clientIds, selectPrevious, message } = (0, import_data183.useSelect)(
      (select2) => unlock(select2(store)).getRemovalPromptData()
    );
    const {
      clearBlockRemovalPrompt: clearBlockRemovalPrompt2,
      setBlockRemovalRules: setBlockRemovalRules2,
      privateRemoveBlocks: privateRemoveBlocks2
    } = unlock((0, import_data183.useDispatch)(store));
    (0, import_element234.useEffect)(() => {
      setBlockRemovalRules2(rules);
      return () => {
        setBlockRemovalRules2();
      };
    }, [rules, setBlockRemovalRules2]);
    if (!message) {
      return;
    }
    const onConfirmRemoval = () => {
      privateRemoveBlocks2(
        clientIds,
        selectPrevious,
        /* force */
        true
      );
      clearBlockRemovalPrompt2();
    };
    return /* @__PURE__ */ (0, import_jsx_runtime400.jsxs)(
      import_components234.Modal,
      {
        title: (0, import_i18n209.__)("Be careful!"),
        onRequestClose: clearBlockRemovalPrompt2,
        size: "medium",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime400.jsx)("p", { children: message }),
          /* @__PURE__ */ (0, import_jsx_runtime400.jsxs)(import_components234.__experimentalHStack, { justify: "right", children: [
            /* @__PURE__ */ (0, import_jsx_runtime400.jsx)(
              import_components234.Button,
              {
                variant: "tertiary",
                onClick: clearBlockRemovalPrompt2,
                __next40pxDefaultSize: true,
                children: (0, import_i18n209.__)("Cancel")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime400.jsx)(
              import_components234.Button,
              {
                variant: "primary",
                onClick: onConfirmRemoval,
                __next40pxDefaultSize: true,
                children: (0, import_i18n209.__)("Delete")
              }
            )
          ] })
        ]
      }
    );
  }

  // packages/block-editor/build-module/components/dimensions-tool/index.js
  var import_jsx_runtime403 = __toESM(require_jsx_runtime());
  var import_element236 = __toESM(require_element());

  // packages/block-editor/build-module/components/dimensions-tool/scale-tool.js
  var import_jsx_runtime401 = __toESM(require_jsx_runtime());
  var import_components235 = __toESM(require_components());
  var import_element235 = __toESM(require_element());
  var import_i18n210 = __toESM(require_i18n());
  var DEFAULT_SCALE_OPTIONS = [
    {
      value: "fill",
      label: (0, import_i18n210._x)("Fill", "Scale option for dimensions control"),
      help: (0, import_i18n210.__)("Fill the space by stretching the content.")
    },
    {
      value: "contain",
      label: (0, import_i18n210._x)("Contain", "Scale option for dimensions control"),
      help: (0, import_i18n210.__)("Fit the content to the space without clipping.")
    },
    {
      value: "cover",
      label: (0, import_i18n210._x)("Cover", "Scale option for dimensions control"),
      help: (0, import_i18n210.__)("Fill the space by clipping what doesn't fit.")
    },
    {
      value: "none",
      label: (0, import_i18n210._x)("None", "Scale option for dimensions control"),
      help: (0, import_i18n210.__)(
        "Do not adjust the sizing of the content. Content that is too large will be clipped, and content that is too small will have additional padding."
      )
    },
    {
      value: "scale-down",
      label: (0, import_i18n210._x)("Scale down", "Scale option for dimensions control"),
      help: (0, import_i18n210.__)(
        "Scale down the content to fit the space if it is too big. Content that is too small will have additional padding."
      )
    }
  ];
  function ScaleTool({
    panelId,
    value,
    onChange,
    options = DEFAULT_SCALE_OPTIONS,
    defaultValue = DEFAULT_SCALE_OPTIONS[0].value,
    isShownByDefault = true
  }) {
    const displayValue = value ?? "fill";
    const scaleHelp = (0, import_element235.useMemo)(() => {
      return options.reduce((acc, option) => {
        acc[option.value] = option.help;
        return acc;
      }, {});
    }, [options]);
    return /* @__PURE__ */ (0, import_jsx_runtime401.jsx)(
      import_components235.__experimentalToolsPanelItem,
      {
        label: (0, import_i18n210.__)("Scale"),
        isShownByDefault,
        hasValue: () => displayValue !== defaultValue,
        onDeselect: () => onChange(defaultValue),
        panelId,
        children: /* @__PURE__ */ (0, import_jsx_runtime401.jsx)(
          import_components235.__experimentalToggleGroupControl,
          {
            __nextHasNoMarginBottom: true,
            label: (0, import_i18n210.__)("Scale"),
            isBlock: true,
            help: scaleHelp[displayValue],
            value: displayValue,
            onChange,
            size: "__unstable-large",
            children: options.map((option) => /* @__PURE__ */ (0, import_jsx_runtime401.jsx)(
              import_components235.__experimentalToggleGroupControlOption,
              {
                ...option
              },
              option.value
            ))
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/dimensions-tool/width-height-tool.js
  var import_jsx_runtime402 = __toESM(require_jsx_runtime());

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends4() {
    return _extends4 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var t3 = arguments[e2];
        for (var r3 in t3) ({}).hasOwnProperty.call(t3, r3) && (n2[r3] = t3[r3]);
      }
      return n2;
    }, _extends4.apply(null, arguments);
  }

  // node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js
  var import_react10 = __toESM(require_react());

  // node_modules/@emotion/is-prop-valid/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize(fn) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache[arg] === void 0) cache[arg] = fn(arg);
      return cache[arg];
    };
  }

  // node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid = /* @__PURE__ */ memoize(
    function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
  var import_react8 = __toESM(require_react());

  // node_modules/@emotion/react/dist/emotion-react.browser.esm.js
  var import_react7 = __toESM(require_react());

  // node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      if (document.styleSheets[i2].ownerNode === tag) {
        return document.styleSheets[i2];
      }
    }
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ (function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert7(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (true) {
        var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
        if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
          console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
        }
        this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
      }
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e2) {
          if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear){/.test(rule)) {
            console.error('There was a problem inserting the following rule: "' + rule + '"', e2);
          }
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush2() {
      this.tags.forEach(function(tag) {
        return tag.parentNode && tag.parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
      if (true) {
        this._alreadyInsertedOrderInsensitiveRule = false;
      }
    };
    return StyleSheet2;
  })();

  // node_modules/stylis/src/Enum.js
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";

  // node_modules/stylis/src/Utility.js
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign2 = Object.assign;
  function hash(value, length2) {
    return (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3);
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace2(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }

  // node_modules/stylis/src/Tokenizer.js
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type, props, children, length2) {
    return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root, props) {
    return assign2(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position);
  }

  // node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse4("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse4(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && characters2.charCodeAt(length2 - 1) == 58) {
            if (indexof(characters2 += replace2(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset:
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace2(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset === 0)
                  parse4(characters2, root, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule) {
                    // d m s
                    case 100:
                    case 109:
                    case 115:
                      parse4(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse4(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2) {
    var post = offset - 1;
    var rule = offset === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z = value; x2 < size; ++x2)
        if (z = trim(j2 > 0 ? rule[x2] + " " + y2 : replace2(y2, /&\f/g, rule[x2])))
          props[k2++] = z;
    return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root, parent, length2) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }

  // node_modules/stylis/src/Prefixer.js
  function prefix2(value, length2) {
    switch (hash(value, length2)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      // align-items
      case 5187:
        return WEBKIT + value + replace2(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      // align-self
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace2(value, /flex-|-self/, "") + value;
      // align-content
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace2(value, /align-content|flex-|-self/, "") + value;
      // flex-shrink
      case 5548:
        return WEBKIT + value + MS + replace2(value, "shrink", "negative") + value;
      // flex-basis
      case 5292:
        return WEBKIT + value + MS + replace2(value, "basis", "preferred-size") + value;
      // flex-grow
      case 6060:
        return WEBKIT + "box-" + replace2(value, "-grow", "") + WEBKIT + value + MS + replace2(value, "grow", "positive") + value;
      // transition
      case 4554:
        return WEBKIT + replace2(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      // cursor
      case 6187:
        return replace2(replace2(replace2(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      // background, background-image
      case 5495:
      case 3959:
        return replace2(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      // justify-content
      case 4968:
        return replace2(replace2(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace2(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6)
          switch (charat(value, length2 + 1)) {
            // (m)ax-content, (m)in-content
            case 109:
              if (charat(value, length2 + 4) !== 45)
                break;
            // (f)ill-available, (f)it-content
            case 102:
              return replace2(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
            // (s)tretch
            case 115:
              return ~indexof(value, "stretch") ? prefix2(replace2(value, "stretch", "fill-available"), length2) + value : value;
          }
        break;
      // position: sticky
      case 4949:
        if (charat(value, length2 + 1) !== 115)
          break;
      // display: (flex|inline-flex)
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          // stic(k)y
          case 107:
            return replace2(value, ":", ":" + WEBKIT) + value;
          // (inline-)?fl(e)x
          case 101:
            return replace2(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      // writing-mode
      case 5936:
        switch (charat(value, length2 + 11)) {
          // vertical-l(r)
          case 114:
            return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          // vertical-r(l)
          case 108:
            return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          // horizontal(-)tb
          case 45:
            return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }

  // node_modules/stylis/src/Serializer.js
  function serialize3(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i2 = 0; i2 < length2; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify2(element, index, children, callback) {
    switch (element.type) {
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize3(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize3(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }

  // node_modules/stylis/src/Middleware.js
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i2 = 0; i2 < length2; i2++)
        output += collection[i2](element, index, children, callback) || "";
      return output;
    };
  }
  function prefixer(element, index, children, callback) {
    if (element.length > -1) {
      if (!element.return)
        switch (element.type) {
          case DECLARATION:
            element.return = prefix2(element.value, element.length);
            break;
          case KEYFRAMES:
            return serialize3([copy(element, { value: replace2(element.value, "@", "@" + WEBKIT) })], callback);
          case RULESET:
            if (element.length)
              return combine(element.props, function(value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ":read-only":
                  case ":read-write":
                    return serialize3([copy(element, { props: [replace2(value, /:(read-\w+)/, ":" + MOZ + "$1")] })], callback);
                  // :placeholder
                  case "::placeholder":
                    return serialize3([
                      copy(element, { props: [replace2(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }),
                      copy(element, { props: [replace2(value, /:(plac\w+)/, ":" + MOZ + "$1")] }),
                      copy(element, { props: [replace2(value, /:(plac\w+)/, MS + "input-$1")] })
                    ], callback);
                }
                return "";
              });
        }
    }
  }

  // node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
  var last = function last2(arr) {
    return arr.length ? arr[arr.length - 1] : null;
  };
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
        // fallthrough
        default:
          parsed[index] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
      for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
        element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
  var isIgnoringComment = function isIgnoringComment2(element) {
    return !!element && element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
  };
  var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
    return function(element, index, children) {
      if (element.type !== "rule") return;
      var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
      if (unsafePseudoClasses && cache.compat !== true) {
        var prevElement = index > 0 ? children[index - 1] : null;
        if (prevElement && isIgnoringComment(last(prevElement.children))) {
          return;
        }
        unsafePseudoClasses.forEach(function(unsafePseudoClass) {
          console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
        });
      }
    };
  };
  var isImportRule = function isImportRule2(element) {
    return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
  };
  var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
    for (var i2 = index - 1; i2 >= 0; i2--) {
      if (!isImportRule(children[i2])) {
        return true;
      }
    }
    return false;
  };
  var nullifyElement = function nullifyElement2(element) {
    element.type = "";
    element.value = "";
    element["return"] = "";
    element.children = "";
    element.props = "";
  };
  var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
    if (!isImportRule(element)) {
      return;
    }
    if (element.parent) {
      console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
      nullifyElement(element);
    } else if (isPrependedWithRegularRules(index, children)) {
      console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
      nullifyElement(element);
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (!key) {
      throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
    }
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    if (true) {
      if (/[^a-z-]/.test(key)) {
        throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
      }
    }
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i2 = 1; i2 < attrib.length; i2++) {
            inserted[attrib[i2]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    if (true) {
      omnipresentPlugins.push(createUnsafeSelectorsAlarm({
        get compat() {
          return cache.compat;
        }
      }), incorrectImportAlarm);
    }
    {
      var currentSheet;
      var finalizingPlugins = [stringify2, true ? function(element) {
        if (!element.root) {
          if (element["return"]) {
            currentSheet.insert(element["return"]);
          } else if (element.value && element.type !== COMMENT) {
            currentSheet.insert(element.value + "{}");
          }
        }
      } : rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles) {
        return serialize3(compile(styles), serializer);
      };
      _insert = function insert7(selector3, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        if (serialized.map !== void 0) {
          currentSheet = {
            insert: function insert8(rule) {
              sheet.insert(rule + serialized.map);
            }
          };
        }
        stylis(selector3 ? selector3 + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    }
    var cache = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };
  var emotion_cache_browser_esm_default = createCache;

  // node_modules/@emotion/react/dist/emotion-element-699e6908.browser.esm.js
  var import_react6 = __toESM(require_react());

  // node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
  var isBrowser = true;
  function getRegisteredStyles(registered, registeredStyles, classNames2) {
    var rawClassName = "";
    classNames2.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false) && cache.registered[className] === void 0
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
    registerStyles(cache, serialized, isStringTag);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };

  // node_modules/@emotion/hash/dist/emotion-hash.esm.js
  function murmur2(str) {
    var h2 = 0;
    var k2, i2 = 0, len = str.length;
    for (; len >= 4; ++i2, len -= 4) {
      k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i2) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }

  // node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  // node_modules/@emotion/serialize/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize2(fn) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache[arg] === void 0) cache[arg] = fn(arg);
      return cache[arg];
    };
  }

  // node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
  var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
  var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize2(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  if (true) {
    contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    contentValues = ["normal", "none", "initial", "inherit", "unset"];
    oldProcessStyleValue = processStyleValue;
    msPattern = /^-ms-/;
    hyphenPattern = /-(.)/g;
    hyphenatedCache = {};
    processStyleValue = function processStyleValue3(key, value) {
      if (key === "content") {
        if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
          throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
        }
      }
      var processed = oldProcessStyleValue(key, value);
      if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
        hyphenatedCache[key] = true;
        console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
          return _char.toUpperCase();
        }) + "?");
      }
      return processed;
    };
  }
  var contentValuePattern;
  var contentValues;
  var oldProcessStyleValue;
  var msPattern;
  var hyphenPattern;
  var hyphenatedCache;
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    if (interpolation.__emotion_styles !== void 0) {
      if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
        throw new Error(noComponentSelectorMessage);
      }
      return interpolation;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }
        if (interpolation.styles !== void 0) {
          var next2 = interpolation.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles = interpolation.styles + ";";
          if (interpolation.map !== void 0) {
            styles += interpolation.map;
          }
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (true) {
          console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
        }
        break;
      }
      case "string":
        if (true) {
          var matched = [];
          var replaced = interpolation.replace(animationRegex, function(match2, p1, p2) {
            var fakeVarName = "animation" + matched.length;
            matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
            return "${" + fakeVarName + "}";
          });
          if (matched.length) {
            console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
          }
        }
        break;
    }
    if (registered == null) {
      return interpolation;
    }
    var cached = registered[interpolation];
    return cached !== void 0 ? cached : interpolation;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i2 = 0; i2 < obj.length; i2++) {
        string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
      }
    } else {
      for (var _key in obj) {
        var value = obj[_key];
        if (typeof value !== "object") {
          if (registered != null && registered[value] !== void 0) {
            string += _key + "{" + registered[value] + "}";
          } else if (isProcessableValue(value)) {
            string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
          }
        } else {
          if (_key === "NO_COMPONENT_SELECTOR" && true) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (_key) {
              case "animation":
              case "animationName": {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }
              default: {
                if (_key === "undefined") {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }
                string += _key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
  var sourceMapPattern;
  if (true) {
    sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
  }
  var cursor;
  var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {
      if (strings[0] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += strings[0];
    }
    for (var i2 = 1; i2 < args.length; i2++) {
      styles += handleInterpolation(mergedProps, registered, args[i2]);
      if (stringMode) {
        if (strings[i2] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }
        styles += strings[i2];
      }
    }
    var sourceMap;
    if (true) {
      styles = styles.replace(sourceMapPattern, function(match3) {
        sourceMap = match3;
        return "";
      });
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + // $FlowFixMe we know it's not null
      match2[1];
    }
    var name = murmur2(styles) + identifierName;
    if (true) {
      return {
        name,
        styles,
        map: sourceMap,
        next: cursor,
        toString: function toString() {
          return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
        }
      };
    }
    return {
      name,
      styles,
      next: cursor
    };
  };

  // node_modules/@emotion/react/dist/emotion-element-699e6908.browser.esm.js
  var hasOwnProperty = {}.hasOwnProperty;
  var EmotionCacheContext = /* @__PURE__ */ (0, import_react6.createContext)(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ emotion_cache_browser_esm_default({
      key: "css"
    }) : null
  );
  if (true) {
    EmotionCacheContext.displayName = "EmotionCacheContext";
  }
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ (0, import_react6.forwardRef)(function(props, ref) {
      var cache = (0, import_react6.useContext)(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };
  var ThemeContext = /* @__PURE__ */ (0, import_react6.createContext)({});
  if (true) {
    ThemeContext.displayName = "EmotionThemeContext";
  }
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
  var Noop = function Noop2() {
    return null;
  };
  var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
      cssProp = cache.registered[cssProp];
    }
    var type = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, (0, import_react6.useContext)(ThemeContext));
    if (serialized.name.indexOf("-") === -1) {
      var labelFromStack = props[labelPropName];
      if (labelFromStack) {
        serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
      }
    }
    var rules = insertStyles(cache, serialized, typeof type === "string");
    className += cache.key + "-" + serialized.name;
    var newProps = {};
    for (var key in props) {
      if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
        newProps[key] = props[key];
      }
    }
    newProps.ref = ref;
    newProps.className = className;
    var ele = /* @__PURE__ */ (0, import_react6.createElement)(type, newProps);
    var possiblyStyleElement = /* @__PURE__ */ (0, import_react6.createElement)(Noop, null);
    return /* @__PURE__ */ (0, import_react6.createElement)(import_react6.Fragment, null, possiblyStyleElement, ele);
  });
  if (true) {
    Emotion.displayName = "EmotionCssPropInternal";
  }

  // node_modules/@emotion/react/dist/emotion-react.browser.esm.js
  var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
  var pkg = {
    name: "@emotion/react",
    version: "11.7.1",
    main: "dist/emotion-react.cjs.js",
    module: "dist/emotion-react.esm.js",
    browser: {
      "./dist/emotion-react.cjs.js": "./dist/emotion-react.browser.cjs.js",
      "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
    },
    types: "types/index.d.ts",
    files: [
      "src",
      "dist",
      "jsx-runtime",
      "jsx-dev-runtime",
      "_isolated-hnrs",
      "types/*.d.ts",
      "macro.js",
      "macro.d.ts",
      "macro.js.flow"
    ],
    sideEffects: false,
    author: "mitchellhamilton <mitchell@mitchellhamilton.me>",
    license: "MIT",
    scripts: {
      "test:typescript": "dtslint types"
    },
    dependencies: {
      "@babel/runtime": "^7.13.10",
      "@emotion/cache": "^11.7.1",
      "@emotion/serialize": "^1.0.2",
      "@emotion/sheet": "^1.1.0",
      "@emotion/utils": "^1.0.0",
      "@emotion/weak-memoize": "^0.2.5",
      "hoist-non-react-statics": "^3.3.1"
    },
    peerDependencies: {
      "@babel/core": "^7.0.0",
      react: ">=16.8.0"
    },
    peerDependenciesMeta: {
      "@babel/core": {
        optional: true
      },
      "@types/react": {
        optional: true
      }
    },
    devDependencies: {
      "@babel/core": "^7.13.10",
      "@emotion/css": "11.7.1",
      "@emotion/css-prettifier": "1.0.1",
      "@emotion/server": "11.4.0",
      "@emotion/styled": "11.6.0",
      "@types/react": "^16.9.11",
      dtslint: "^0.3.0",
      "html-tag-names": "^1.1.2",
      react: "16.14.0",
      "svg-tag-names": "^1.1.1"
    },
    repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
    publishConfig: {
      access: "public"
    },
    "umd:main": "dist/emotion-react.umd.min.js",
    preconstruct: {
      entrypoints: [
        "./index.js",
        "./jsx-runtime.js",
        "./jsx-dev-runtime.js",
        "./_isolated-hnrs.js"
      ],
      umdName: "emotionReact"
    }
  };
  var warnedAboutCssPropForGlobal = false;
  var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
    if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
    // probably using the custom createElement which
    // means it will be turned into a className prop
    // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
    (props.className || props.css)) {
      console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
      warnedAboutCssPropForGlobal = true;
    }
    var styles = props.styles;
    var serialized = serializeStyles([styles], void 0, (0, import_react7.useContext)(ThemeContext));
    var sheetRef = (0, import_react7.useRef)();
    (0, import_react7.useLayoutEffect)(function() {
      var key = cache.key + "-global";
      var sheet = new StyleSheet({
        key,
        nonce: cache.sheet.nonce,
        container: cache.sheet.container,
        speedy: cache.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache.sheet.tags.length) {
        sheet.before = cache.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache]);
    (0, import_react7.useLayoutEffect)(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache.insert("", serialized, sheet, false);
    }, [cache, serialized.name]);
    return null;
  });
  if (true) {
    Global.displayName = "EmotionGlobal";
  }
  var classnames = function classnames2(args) {
    var len = args.length;
    var i2 = 0;
    var cls = "";
    for (; i2 < len; i2++) {
      var arg = args[i2];
      if (arg == null) continue;
      var toAdd = void 0;
      switch (typeof arg) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(arg)) {
            toAdd = classnames2(arg);
          } else {
            if (arg.styles !== void 0 && arg.name !== void 0) {
              console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
            }
            toAdd = "";
            for (var k2 in arg) {
              if (arg[k2] && k2) {
                toAdd && (toAdd += " ");
                toAdd += k2;
              }
            }
          }
          break;
        }
        default: {
          toAdd = arg;
        }
      }
      if (toAdd) {
        cls && (cls += " ");
        cls += toAdd;
      }
    }
    return cls;
  };
  function merge(registered, css, className) {
    var registeredStyles = [];
    var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css(registeredStyles);
  }
  var Noop3 = function Noop4() {
    return null;
  };
  var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache) {
    var hasRendered = false;
    var css = function css2() {
      if (hasRendered && true) {
        throw new Error("css can only be used during render");
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var serialized = serializeStyles(args, cache.registered);
      {
        insertStyles(cache, serialized, false);
      }
      return cache.key + "-" + serialized.name;
    };
    var cx = function cx2() {
      if (hasRendered && true) {
        throw new Error("cx can only be used during render");
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return merge(cache.registered, css, classnames(args));
    };
    var content = {
      css,
      cx,
      theme: (0, import_react7.useContext)(ThemeContext)
    };
    var ele = props.children(content);
    hasRendered = true;
    var possiblyStyleElement = /* @__PURE__ */ (0, import_react7.createElement)(Noop3, null);
    return /* @__PURE__ */ (0, import_react7.createElement)(import_react7.Fragment, null, possiblyStyleElement, ele);
  });
  if (true) {
    ClassNames.displayName = "EmotionClassNames";
  }
  if (true) {
    isBrowser2 = true;
    isJest = typeof jest !== "undefined";
    if (isBrowser2 && !isJest) {
      globalContext = // $FlowIgnore
      typeof globalThis !== "undefined" ? globalThis : isBrowser2 ? window : global;
      globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
      if (globalContext[globalKey]) {
        console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
      }
      globalContext[globalKey] = true;
    }
  }
  var isBrowser2;
  var isJest;
  var globalContext;
  var globalKey;

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
  var testOmitPropsOnStringTag = isPropValid;
  var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
  };
  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };
  var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
    var shouldForwardProp;
    if (options) {
      var optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp !== "function" && isReal) {
      shouldForwardProp = tag.__emotion_forwardProp;
    }
    return shouldForwardProp;
  };
  var ILLEGAL_ESCAPE_SEQUENCE_ERROR2 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
  var Noop5 = function Noop6() {
    return null;
  };
  var createStyled = function createStyled2(tag, options) {
    if (true) {
      if (tag === void 0) {
        throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
      }
    }
    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;
    if (options !== void 0) {
      identifierName = options.label;
      targetClassName = options.target;
    }
    var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function() {
      var args = arguments;
      var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
      if (identifierName !== void 0) {
        styles.push("label:" + identifierName + ";");
      }
      if (args[0] == null || args[0].raw === void 0) {
        styles.push.apply(styles, args);
      } else {
        if (args[0][0] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
        }
        styles.push(args[0][0]);
        var len = args.length;
        var i2 = 1;
        for (; i2 < len; i2++) {
          if (args[0][i2] === void 0) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
          }
          styles.push(args[i2], args[0][i2]);
        }
      }
      var Styled = withEmotionCache(function(props, cache, ref) {
        var finalTag = shouldUseAs && props.as || baseTag;
        var className = "";
        var classInterpolations = [];
        var mergedProps = props;
        if (props.theme == null) {
          mergedProps = {};
          for (var key in props) {
            mergedProps[key] = props[key];
          }
          mergedProps.theme = (0, import_react8.useContext)(ThemeContext);
        }
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
        var rules = insertStyles(cache, serialized, typeof finalTag === "string");
        className += cache.key + "-" + serialized.name;
        if (targetClassName !== void 0) {
          className += " " + targetClassName;
        }
        var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(finalTag) : defaultShouldForwardProp;
        var newProps = {};
        for (var _key in props) {
          if (shouldUseAs && _key === "as") continue;
          if (
            // $FlowFixMe
            finalShouldForwardProp(_key)
          ) {
            newProps[_key] = props[_key];
          }
        }
        newProps.className = className;
        newProps.ref = ref;
        var ele = /* @__PURE__ */ (0, import_react8.createElement)(finalTag, newProps);
        var possiblyStyleElement = /* @__PURE__ */ (0, import_react8.createElement)(Noop5, null);
        return /* @__PURE__ */ (0, import_react8.createElement)(import_react8.Fragment, null, possiblyStyleElement, ele);
      });
      Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles;
      Styled.__emotion_forwardProp = shouldForwardProp;
      Object.defineProperty(Styled, "toString", {
        value: function value() {
          if (targetClassName === void 0 && true) {
            return "NO_COMPONENT_SELECTOR";
          }
          return "." + targetClassName;
        }
      });
      Styled.withComponent = function(nextTag, nextOptions) {
        return createStyled2(nextTag, _extends4({}, options, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        })).apply(void 0, styles);
      };
      return Styled;
    };
  };
  var emotion_styled_base_browser_esm_default = createStyled;

  // node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js
  var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  var newStyled = emotion_styled_base_browser_esm_default.bind();
  tags.forEach(function(tagName) {
    newStyled[tagName] = newStyled(tagName);
  });
  var emotion_styled_browser_esm_default = newStyled;

  // packages/block-editor/build-module/components/dimensions-tool/width-height-tool.js
  var import_components236 = __toESM(require_components());
  var import_i18n211 = __toESM(require_i18n());
  var SingleColumnToolsPanelItem = emotion_styled_browser_esm_default(import_components236.__experimentalToolsPanelItem)`
	grid-column: span 1;
`;
  function WidthHeightTool({
    panelId,
    value = {},
    onChange = () => {
    },
    units: units2,
    isShownByDefault = true
  }) {
    const width = value.width === "auto" ? "" : value.width ?? "";
    const height = value.height === "auto" ? "" : value.height ?? "";
    const onDimensionChange = (dimension) => (nextDimension) => {
      const nextValue = { ...value };
      if (!nextDimension) {
        delete nextValue[dimension];
      } else {
        nextValue[dimension] = nextDimension;
      }
      onChange(nextValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime402.jsxs)(import_jsx_runtime402.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime402.jsx)(
        SingleColumnToolsPanelItem,
        {
          label: (0, import_i18n211.__)("Width"),
          isShownByDefault,
          hasValue: () => width !== "",
          onDeselect: onDimensionChange("width"),
          panelId,
          children: /* @__PURE__ */ (0, import_jsx_runtime402.jsx)(
            import_components236.__experimentalUnitControl,
            {
              label: (0, import_i18n211.__)("Width"),
              placeholder: (0, import_i18n211.__)("Auto"),
              labelPosition: "top",
              units: units2,
              min: 0,
              value: width,
              onChange: onDimensionChange("width"),
              size: "__unstable-large"
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime402.jsx)(
        SingleColumnToolsPanelItem,
        {
          label: (0, import_i18n211.__)("Height"),
          isShownByDefault,
          hasValue: () => height !== "",
          onDeselect: onDimensionChange("height"),
          panelId,
          children: /* @__PURE__ */ (0, import_jsx_runtime402.jsx)(
            import_components236.__experimentalUnitControl,
            {
              label: (0, import_i18n211.__)("Height"),
              placeholder: (0, import_i18n211.__)("Auto"),
              labelPosition: "top",
              units: units2,
              min: 0,
              value: height,
              onChange: onDimensionChange("height"),
              size: "__unstable-large"
            }
          )
        }
      )
    ] });
  }

  // packages/block-editor/build-module/components/dimensions-tool/index.js
  function DimensionsTool({
    panelId,
    value = {},
    onChange = () => {
    },
    aspectRatioOptions,
    // Default options handled by AspectRatioTool.
    defaultAspectRatio = "auto",
    // Match CSS default value for aspect-ratio.
    scaleOptions,
    // Default options handled by ScaleTool.
    defaultScale = "fill",
    // Match CSS default value for object-fit.
    unitsOptions,
    // Default options handled by UnitControl.
    tools = ["aspectRatio", "widthHeight", "scale"]
  }) {
    const width = value.width === void 0 || value.width === "auto" ? null : value.width;
    const height = value.height === void 0 || value.height === "auto" ? null : value.height;
    const aspectRatio = value.aspectRatio === void 0 || value.aspectRatio === "auto" ? null : value.aspectRatio;
    const scale = value.scale === void 0 || value.scale === "fill" ? null : value.scale;
    const [lastScale, setLastScale] = (0, import_element236.useState)(scale);
    const [lastAspectRatio, setLastAspectRatio] = (0, import_element236.useState)(aspectRatio);
    const aspectRatioValue = width && height ? "custom" : lastAspectRatio;
    const showScaleControl = aspectRatio || width && height;
    return /* @__PURE__ */ (0, import_jsx_runtime403.jsxs)(import_jsx_runtime403.Fragment, { children: [
      tools.includes("aspectRatio") && /* @__PURE__ */ (0, import_jsx_runtime403.jsx)(
        AspectRatioTool,
        {
          panelId,
          options: aspectRatioOptions,
          defaultValue: defaultAspectRatio,
          value: aspectRatioValue,
          onChange: (nextAspectRatio) => {
            const nextValue = { ...value };
            nextAspectRatio = nextAspectRatio === "auto" ? null : nextAspectRatio;
            setLastAspectRatio(nextAspectRatio);
            if (!nextAspectRatio) {
              delete nextValue.aspectRatio;
            } else {
              nextValue.aspectRatio = nextAspectRatio;
            }
            if (!nextAspectRatio) {
              delete nextValue.scale;
            } else if (lastScale) {
              nextValue.scale = lastScale;
            } else {
              nextValue.scale = defaultScale;
              setLastScale(defaultScale);
            }
            if ("custom" !== nextAspectRatio && width && height) {
              delete nextValue.height;
            }
            onChange(nextValue);
          }
        }
      ),
      tools.includes("widthHeight") && /* @__PURE__ */ (0, import_jsx_runtime403.jsx)(
        WidthHeightTool,
        {
          panelId,
          units: unitsOptions,
          value: { width, height },
          onChange: ({ width: nextWidth, height: nextHeight }) => {
            const nextValue = { ...value };
            nextWidth = nextWidth === "auto" ? null : nextWidth;
            nextHeight = nextHeight === "auto" ? null : nextHeight;
            if (!nextWidth) {
              delete nextValue.width;
            } else {
              nextValue.width = nextWidth;
            }
            if (!nextHeight) {
              delete nextValue.height;
            } else {
              nextValue.height = nextHeight;
            }
            if (nextWidth && nextHeight) {
              delete nextValue.aspectRatio;
            } else if (lastAspectRatio) {
              nextValue.aspectRatio = lastAspectRatio;
            } else {
            }
            if (!lastAspectRatio && !!nextWidth !== !!nextHeight) {
              delete nextValue.scale;
            } else if (lastScale) {
              nextValue.scale = lastScale;
            } else {
              nextValue.scale = defaultScale;
              setLastScale(defaultScale);
            }
            onChange(nextValue);
          }
        }
      ),
      tools.includes("scale") && showScaleControl && /* @__PURE__ */ (0, import_jsx_runtime403.jsx)(
        ScaleTool,
        {
          panelId,
          options: scaleOptions,
          defaultValue: defaultScale,
          value: lastScale,
          onChange: (nextScale) => {
            const nextValue = { ...value };
            nextScale = nextScale === "fill" ? null : nextScale;
            setLastScale(nextScale);
            if (!nextScale) {
              delete nextValue.scale;
            } else {
              nextValue.scale = nextScale;
            }
            onChange(nextValue);
          }
        }
      )
    ] });
  }
  var dimensions_tool_default = DimensionsTool;

  // packages/block-editor/build-module/components/resolution-tool/index.js
  var import_jsx_runtime404 = __toESM(require_jsx_runtime());
  var import_components237 = __toESM(require_components());
  var import_i18n212 = __toESM(require_i18n());
  var DEFAULT_SIZE_OPTIONS = [
    {
      label: (0, import_i18n212._x)("Thumbnail", "Image size option for resolution control"),
      value: "thumbnail"
    },
    {
      label: (0, import_i18n212._x)("Medium", "Image size option for resolution control"),
      value: "medium"
    },
    {
      label: (0, import_i18n212._x)("Large", "Image size option for resolution control"),
      value: "large"
    },
    {
      label: (0, import_i18n212._x)("Full Size", "Image size option for resolution control"),
      value: "full"
    }
  ];
  function ResolutionTool({
    panelId,
    value,
    onChange,
    options = DEFAULT_SIZE_OPTIONS,
    defaultValue = DEFAULT_SIZE_OPTIONS[0].value,
    isShownByDefault = true,
    resetAllFilter
  }) {
    const displayValue = value ?? defaultValue;
    return /* @__PURE__ */ (0, import_jsx_runtime404.jsx)(
      import_components237.__experimentalToolsPanelItem,
      {
        hasValue: () => displayValue !== defaultValue,
        label: (0, import_i18n212.__)("Resolution"),
        onDeselect: () => onChange(defaultValue),
        isShownByDefault,
        panelId,
        resetAllFilter,
        children: /* @__PURE__ */ (0, import_jsx_runtime404.jsx)(
          import_components237.SelectControl,
          {
            __nextHasNoMarginBottom: true,
            label: (0, import_i18n212.__)("Resolution"),
            value: displayValue,
            options,
            onChange,
            help: (0, import_i18n212.__)("Select the size of the source image."),
            size: "__unstable-large"
          }
        )
      }
    );
  }

  // packages/block-editor/build-module/components/html-element-control/index.js
  var import_jsx_runtime405 = __toESM(require_jsx_runtime());
  var import_i18n214 = __toESM(require_i18n());
  var import_components238 = __toESM(require_components());
  var import_data184 = __toESM(require_data());

  // packages/block-editor/build-module/components/html-element-control/messages.js
  var import_i18n213 = __toESM(require_i18n());
  var htmlElementMessages = {
    a: (0, import_i18n213.__)(
      "The <a> element should be used for links that navigate to a different page or to a different section within the same page."
    ),
    article: (0, import_i18n213.__)(
      "The <article> element should represent a self-contained, syndicatable portion of the document."
    ),
    aside: (0, import_i18n213.__)(
      "The <aside> element should represent a portion of a document whose content is only indirectly related to the document's main content."
    ),
    button: (0, import_i18n213.__)(
      "The <button> element should be used for interactive controls that perform an action on the current page, such as opening a modal or toggling content visibility."
    ),
    div: (0, import_i18n213.__)(
      "The <div> element should only be used if the block is a design element with no semantic meaning."
    ),
    footer: (0, import_i18n213.__)(
      "The <footer> element should represent a footer for its nearest sectioning element (e.g.: <section>, <article>, <main> etc.)."
    ),
    header: (0, import_i18n213.__)(
      "The <header> element should represent introductory content, typically a group of introductory or navigational aids."
    ),
    main: (0, import_i18n213.__)(
      "The <main> element should be used for the primary content of your document only."
    ),
    nav: (0, import_i18n213.__)(
      "The <nav> element should be used to identify groups of links that are intended to be used for website or page content navigation."
    ),
    section: (0, import_i18n213.__)(
      "The <section> element should represent a standalone portion of the document that can't be better represented by another element."
    )
  };

  // packages/block-editor/build-module/components/html-element-control/index.js
  function HTMLElementControl({
    tagName,
    onChange,
    clientId,
    options = [
      { label: (0, import_i18n214.__)("Default (<div>)"), value: "div" },
      { label: "<header>", value: "header" },
      { label: "<main>", value: "main" },
      { label: "<section>", value: "section" },
      { label: "<article>", value: "article" },
      { label: "<aside>", value: "aside" },
      { label: "<footer>", value: "footer" }
    ]
  }) {
    const checkForMainTag = !!clientId && options.some((option) => option.value === "main");
    const hasMainElementElsewhere = (0, import_data184.useSelect)(
      (select2) => {
        if (!checkForMainTag) {
          return false;
        }
        const { getClientIdsWithDescendants: getClientIdsWithDescendants2, getBlockAttributes: getBlockAttributes3 } = select2(store);
        return getClientIdsWithDescendants2().some((id) => {
          if (id === clientId) {
            return false;
          }
          return getBlockAttributes3(id)?.tagName === "main";
        });
      },
      [clientId, checkForMainTag]
    );
    const modifiedOptions = options.map((option) => {
      if (option.value === "main" && hasMainElementElsewhere && tagName !== "main") {
        return {
          ...option,
          disabled: true,
          label: (0, import_i18n214.sprintf)(
            /* translators: %s: HTML element name */
            (0, import_i18n214.__)("%s (Already in use)"),
            option.label
          )
        };
      }
      return option;
    });
    return /* @__PURE__ */ (0, import_jsx_runtime405.jsxs)(import_components238.__experimentalVStack, { spacing: 2, className: "block-editor-html-element-control", children: [
      /* @__PURE__ */ (0, import_jsx_runtime405.jsx)(
        import_components238.SelectControl,
        {
          __nextHasNoMarginBottom: true,
          __next40pxDefaultSize: true,
          label: (0, import_i18n214.__)("HTML element"),
          options: modifiedOptions,
          value: tagName,
          onChange,
          help: htmlElementMessages[tagName]
        }
      ),
      tagName === "main" && hasMainElementElsewhere && /* @__PURE__ */ (0, import_jsx_runtime405.jsx)(import_components238.Notice, { status: "warning", isDismissible: false, children: (0, import_i18n214.__)(
        "Multiple <main> elements detected. The duplicate may be in your content or template. This is not valid HTML and may cause accessibility issues. Please change this HTML element."
      ) })
    ] });
  }

  // packages/block-editor/build-module/private-apis.js
  var privateApis2 = {};
  lock(privateApis2, {
    ...global_styles_exports,
    ExperimentalBlockCanvas,
    ExperimentalBlockEditorProvider,
    getDuotoneFilter,
    getRichTextValues,
    PrivateQuickInserter: QuickInserter,
    extractWords,
    getNormalizedSearchTerms,
    normalizeString,
    PrivateListView,
    ResizableBoxPopover,
    useHasBlockToolbar,
    cleanEmptyObject,
    BlockQuickNavigation,
    LayoutStyle,
    BlockManager,
    BlockRemovalWarningModal,
    useLayoutClasses,
    useLayoutStyles,
    DimensionsTool: dimensions_tool_default,
    ResolutionTool,
    TabbedSidebar: tabbed_sidebar_default,
    TextAlignmentControl,
    usesContextKey,
    useFlashEditableBlocks,
    HTMLElementControl,
    useZoomOut,
    globalStylesDataKey,
    globalStylesLinksDataKey,
    selectBlockPatternsKey,
    requiresWrapperOnCopy,
    PrivateRichText,
    PrivateInserterLibrary,
    reusableBlocksSelectKey,
    PrivateBlockPopover,
    PrivatePublishDateTimePicker,
    useSpacingSizes,
    useBlockDisplayTitle,
    __unstableBlockStyleVariationOverridesWithConfig,
    setBackgroundStyleDefaults,
    sectionRootClientIdKey,
    CommentIconSlotFill: block_comment_icon_slot_default,
    CommentIconToolbarSlotFill: block_comment_icon_toolbar_slot_default,
    mediaEditKey,
    essentialFormatKey,
    useBlockElement,
    useBlockElementRef
  });
  return __toCommonJS(index_exports);
})();
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

autosize/dist/autosize.js:
  (*!
  	autosize 4.0.2
  	license: MIT
  	http://www.jacklmoore.com/autosize
  *)

normalize-wheel/src/isEventSupported.js:
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=index.js.map
