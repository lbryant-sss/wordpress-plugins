{
  "version": 3,
  "sources": ["vendor-external:react/jsx-runtime", "wordpress-external:@wordpress/element", "wordpress-external:@wordpress/url", "wordpress-external:@wordpress/compose", "wordpress-external:@wordpress/private-apis", "../../packages/router/src/index.ts", "../../packages/router/src/router.tsx", "../../node_modules/route-recognizer/dist/route-recognizer/util.ts", "../../node_modules/route-recognizer/dist/route-recognizer/dsl.ts", "../../node_modules/route-recognizer/dist/route-recognizer/normalizer.ts", "../../node_modules/route-recognizer/dist/route-recognizer.ts", "../../node_modules/@babel/runtime/helpers/esm/extends.js", "../../node_modules/history/index.js", "../../packages/router/src/link.tsx", "../../packages/router/src/lock-unlock.ts", "../../packages/router/src/private-apis.ts"],
  "sourcesContent": ["module.exports = window.ReactJSXRuntime;", "module.exports = window.wp.element;", "module.exports = window.wp.url;", "module.exports = window.wp.compose;", "module.exports = window.wp.privateApis;", "export { privateApis } from './private-apis';\n", "/**\n * External dependencies\n */\nimport RouteRecognizer from 'route-recognizer';\nimport { createBrowserHistory } from 'history';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tcreateContext,\n\tuseContext,\n\tuseSyncExternalStore,\n\tuseMemo,\n\tuseState,\n\tuseEffect,\n} from '@wordpress/element';\nimport {\n\taddQueryArgs,\n\tgetQueryArgs,\n\tgetPath,\n\tbuildQueryString,\n} from '@wordpress/url';\nimport { useEvent, usePrevious } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport type { ReactNode } from 'react';\n\nconst history = createBrowserHistory();\ninterface Route {\n\tname: string;\n\tpath: string;\n\tareas: Record< string, ReactNode >;\n\twidths: Record< string, number >;\n}\n\ntype LocationWithQuery = Location & {\n\tquery?: Record< string, any >;\n};\n\ninterface Match {\n\tname: string;\n\tpath: string;\n\tareas: Record< string, ReactNode >;\n\twidths: Record< string, number >;\n\tquery?: Record< string, any >;\n\tparams?: Record< string, any >;\n}\n\nexport type BeforeNavigate = ( arg: {\n\tpath: string;\n\tquery: Record< string, any >;\n} ) => {\n\tpath: string;\n\tquery: Record< string, any >;\n};\n\ninterface Config {\n\tpathArg: string;\n\tbeforeNavigate?: BeforeNavigate;\n}\n\nexport interface NavigationOptions {\n\ttransition?: string;\n\tstate?: Record< string, any >;\n}\n\nconst RoutesContext = createContext< Match | null >( null );\nRoutesContext.displayName = 'RoutesContext';\n\nexport const ConfigContext = createContext< Config >( { pathArg: 'p' } );\nConfigContext.displayName = 'ConfigContext';\n\nconst locationMemo = new WeakMap();\nfunction getLocationWithQuery() {\n\tconst location = history.location;\n\tlet locationWithQuery = locationMemo.get( location );\n\tif ( ! locationWithQuery ) {\n\t\tlocationWithQuery = {\n\t\t\t...location,\n\t\t\tquery: Object.fromEntries( new URLSearchParams( location.search ) ),\n\t\t};\n\t\tlocationMemo.set( location, locationWithQuery );\n\t}\n\treturn locationWithQuery;\n}\n\nexport function useLocation() {\n\tconst context = useContext( RoutesContext );\n\tif ( ! context ) {\n\t\tthrow new Error( 'useLocation must be used within a RouterProvider' );\n\t}\n\treturn context;\n}\n\nexport function useHistory() {\n\tconst { pathArg, beforeNavigate } = useContext( ConfigContext );\n\n\tconst navigate = useEvent(\n\t\tasync ( rawPath: string, options: NavigationOptions = {} ) => {\n\t\t\tconst query = getQueryArgs( rawPath );\n\t\t\tconst path = getPath( 'http://domain.com/' + rawPath ) ?? '';\n\t\t\tconst performPush = () => {\n\t\t\t\tconst result = beforeNavigate\n\t\t\t\t\t? beforeNavigate( { path, query } )\n\t\t\t\t\t: { path, query };\n\t\t\t\treturn history.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tsearch: buildQueryString( {\n\t\t\t\t\t\t\t[ pathArg ]: result.path,\n\t\t\t\t\t\t\t...result.query,\n\t\t\t\t\t\t} ),\n\t\t\t\t\t},\n\t\t\t\t\toptions.state\n\t\t\t\t);\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Skip transition in mobile, otherwise it crashes the browser.\n\t\t\t * See: https://github.com/WordPress/gutenberg/pull/63002.\n\t\t\t */\n\t\t\tconst isMediumOrBigger =\n\t\t\t\twindow.matchMedia( '(min-width: 782px)' ).matches;\n\t\t\tif (\n\t\t\t\t! isMediumOrBigger ||\n\t\t\t\t! document.startViewTransition ||\n\t\t\t\t! options.transition\n\t\t\t) {\n\t\t\t\tperformPush();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait new Promise< void >( ( resolve ) => {\n\t\t\t\tconst classname = options.transition ?? '';\n\t\t\t\tdocument.documentElement.classList.add( classname );\n\t\t\t\tconst transition = document.startViewTransition( () =>\n\t\t\t\t\tperformPush()\n\t\t\t\t);\n\t\t\t\ttransition.finished.finally( () => {\n\t\t\t\t\tdocument.documentElement.classList.remove( classname );\n\t\t\t\t\tresolve();\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t);\n\n\treturn useMemo(\n\t\t() => ( {\n\t\t\tnavigate,\n\t\t\tback: history.back,\n\t\t\tinvalidate: () => {\n\t\t\t\thistory.replace( {\n\t\t\t\t\tsearch: history.location.search,\n\t\t\t\t} );\n\t\t\t},\n\t\t} ),\n\t\t[ navigate ]\n\t);\n}\n\nexport default function useMatch(\n\tlocation: LocationWithQuery,\n\tmatcher: RouteRecognizer,\n\tpathArg: string,\n\tmatchResolverArgs: Record< string, any >\n): Match | undefined {\n\tconst { query: rawQuery = {} } = location;\n\tconst [ resolvedMatch, setMatch ] = useState< Match | undefined >();\n\n\tuseEffect( () => {\n\t\tconst { [ pathArg ]: path = '/', ...query } = rawQuery;\n\t\tconst ret = matcher.recognize( path )?.[ 0 ];\n\t\tasync function resolveMatch( result: any ) {\n\t\t\tconst matchedRoute = result.handler as Route;\n\t\t\tconst resolveFunctions = async (\n\t\t\t\trecord: Record< string, any > = {}\n\t\t\t) => {\n\t\t\t\tconst entries = await Promise.all(\n\t\t\t\t\tObject.entries( record ).map( async ( [ key, value ] ) => {\n\t\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tawait value( {\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tparams: result.params,\n\t\t\t\t\t\t\t\t\t...matchResolverArgs,\n\t\t\t\t\t\t\t\t} ),\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [ key, value ];\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\treturn Object.fromEntries( entries );\n\t\t\t};\n\t\t\tconst [ resolvedAreas, resolvedWidths ] = await Promise.all( [\n\t\t\t\tresolveFunctions( matchedRoute.areas ),\n\t\t\t\tresolveFunctions( matchedRoute.widths ),\n\t\t\t] );\n\t\t\tsetMatch( {\n\t\t\t\tname: matchedRoute.name,\n\t\t\t\tareas: resolvedAreas,\n\t\t\t\twidths: resolvedWidths,\n\t\t\t\tparams: result.params,\n\t\t\t\tquery,\n\t\t\t\tpath: addQueryArgs( path, query ),\n\t\t\t} );\n\t\t}\n\n\t\tif ( ! ret ) {\n\t\t\tsetMatch( {\n\t\t\t\tname: '404',\n\t\t\t\tpath: addQueryArgs( path, query ),\n\t\t\t\tareas: {},\n\t\t\t\twidths: {},\n\t\t\t\tquery,\n\t\t\t\tparams: {},\n\t\t\t} );\n\t\t} else {\n\t\t\tresolveMatch( ret );\n\t\t}\n\n\t\treturn () => setMatch( undefined );\n\t}, [ matcher, rawQuery, pathArg, matchResolverArgs ] );\n\n\treturn resolvedMatch;\n}\n\nexport function RouterProvider( {\n\troutes,\n\tpathArg,\n\tbeforeNavigate,\n\tchildren,\n\tmatchResolverArgs,\n}: {\n\troutes: Route[];\n\tpathArg: string;\n\tbeforeNavigate?: BeforeNavigate;\n\tchildren: React.ReactNode;\n\tmatchResolverArgs: Record< string, any >;\n} ) {\n\tconst location = useSyncExternalStore(\n\t\thistory.listen,\n\t\tgetLocationWithQuery,\n\t\tgetLocationWithQuery\n\t);\n\tconst matcher = useMemo( () => {\n\t\tconst ret = new RouteRecognizer();\n\t\t( routes ?? [] ).forEach( ( route ) => {\n\t\t\tret.add( [ { path: route.path, handler: route } ], {\n\t\t\t\tas: route.name,\n\t\t\t} );\n\t\t} );\n\t\treturn ret;\n\t}, [ routes ] );\n\tconst match = useMatch( location, matcher, pathArg, matchResolverArgs );\n\tconst previousMatch = usePrevious( match );\n\tconst config = useMemo(\n\t\t() => ( { beforeNavigate, pathArg } ),\n\t\t[ beforeNavigate, pathArg ]\n\t);\n\tconst renderedMatch = match || previousMatch;\n\n\tif ( ! renderedMatch ) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<ConfigContext.Provider value={ config }>\n\t\t\t<RoutesContext.Provider value={ renderedMatch }>\n\t\t\t\t{ children }\n\t\t\t</RoutesContext.Provider>\n\t\t</ConfigContext.Provider>\n\t);\n}\n", "const createObject = Object.create;\nexport function createMap<T>() {\n  const map: { [key: string]: T | undefined } = createObject(null);\n  map[\"__\"] = undefined;\n  delete map[\"__\"];\n  return map;\n}\n", "import { createMap } from \"./util\";\n\nexport interface Delegate {\n  contextEntered?(context: string, route: MatchDSL): void;\n  willAddRoute?(context: string | undefined, route: string): string;\n}\n\nexport type Opaque = {} | void | null | undefined;\n\nexport interface Route {\n  path: string;\n  handler: Opaque;\n  queryParams?: string[];\n}\n\nexport interface RouteRecognizer {\n  delegate: Delegate | undefined;\n  add(routes: Route[]): void;\n}\n\nexport interface MatchCallback {\n  (match: MatchDSL): void;\n}\n\nexport interface MatchDSL {\n  (path: string): ToDSL;\n  (path: string, callback: MatchCallback): void;\n}\n\nexport interface ToDSL {\n  to(name: string, callback?: MatchCallback): void;\n}\n\nclass Target implements ToDSL {\n  path: string;\n  matcher: Matcher;\n  delegate: Delegate | undefined;\n\n  constructor(path: string, matcher: Matcher, delegate: Delegate | undefined) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n  }\n\n  to(target: string, callback: MatchCallback) {\n    let delegate = this.delegate;\n\n    if (delegate && delegate.willAddRoute) {\n      target = delegate.willAddRoute(this.matcher.target, target);\n    }\n\n    this.matcher.add(this.path, target);\n\n    if (callback) {\n      if (callback.length === 0) { throw new Error(\"You must have an argument in the function passed to `to`\"); }\n      this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n  }\n}\n\nexport class Matcher {\n  routes: {\n    [path: string]: string | undefined;\n  };\n  children: {\n    [path: string]: Matcher | undefined;\n  };\n  target: string | undefined;\n\n  constructor(target?: string) {\n    this.routes = createMap<string>();\n    this.children = createMap<Matcher>();\n    this.target = target;\n  }\n\n  add(path: string, target: string) {\n    this.routes[path] = target;\n  }\n\n  addChild(path: string, target: string, callback: MatchCallback, delegate: Delegate | undefined) {\n    let matcher = new Matcher(target);\n    this.children[path] = matcher;\n\n    let match = generateMatch(path, matcher, delegate);\n\n    if (delegate && delegate.contextEntered) {\n      delegate.contextEntered(target, match);\n    }\n\n    callback(match);\n  }\n}\n\nfunction generateMatch(startingPath: string, matcher: Matcher, delegate: Delegate | undefined): MatchDSL {\n  function match(path: string): ToDSL;\n  function match(path: string, callback: MatchCallback): void;\n  function match(path: string, callback?: MatchCallback): ToDSL | void {\n    let fullPath = startingPath + path;\n    if (callback) {\n      callback(generateMatch(fullPath, matcher, delegate));\n    } else {\n      return new Target(fullPath, matcher, delegate);\n    }\n  };\n  return match;\n}\n\nfunction addRoute(routeArray: Route[], path: string, handler: any) {\n  let len = 0;\n  for (let i = 0; i < routeArray.length; i++) {\n    len += routeArray[i].path.length;\n  }\n\n  path = path.substr(len);\n  let route = { path: path, handler: handler };\n  routeArray.push(route);\n}\n\nfunction eachRoute<T>(baseRoute: Route[], matcher: Matcher, callback: (this: T, routes: Route[]) => void, binding: T) {\n  let routes = matcher.routes;\n  let paths = Object.keys(routes);\n  for (let i = 0; i < paths.length; i++) {\n    let path = paths[i];\n    let routeArray = baseRoute.slice();\n    addRoute(routeArray, path, routes[path]);\n    let nested = matcher.children[path];\n    if (nested) {\n      eachRoute(routeArray, nested, callback, binding);\n    } else {\n      callback.call(binding, routeArray);\n    }\n  }\n}\n\nexport default function <T extends RouteRecognizer>(this: T, callback: MatchCallback, addRouteCallback?: (routeRecognizer: T, routes: Route[]) => void) {\n  let matcher = new Matcher();\n\n  callback(generateMatch(\"\", matcher, this.delegate));\n\n  eachRoute([], matcher, function(routes: Route[]) {\n    if (addRouteCallback) { addRouteCallback(this, routes); }\n    else { this.add(routes); }\n  }, this);\n}\n", "// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\n// values that are not reserved (i.e., unicode characters, emoji, etc). The reserved\n// chars are \"/\" and \"%\".\n// Safe to call multiple times on the same path.\nexport function normalizePath(path: string): string {\n  return path.split(\"/\")\n             .map(normalizeSegment)\n             .join(\"/\");\n}\n\n// We want to ensure the characters \"%\" and \"/\" remain in percent-encoded\n// form when normalizing paths, so replace them with their encoded form after\n// decoding the rest of the path\nconst SEGMENT_RESERVED_CHARS = /%|\\//g;\nexport function normalizeSegment(segment: string) {\n  if (segment.length < 3 || segment.indexOf(\"%\") === -1) return segment;\n  return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);\n}\n\n// We do not want to encode these characters when generating dynamic path segments\n// See https://tools.ietf.org/html/rfc3986#section-3.3\n// sub-delims: \"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"\n// others allowed by RFC 3986: \":\", \"@\"\n//\n// First encode the entire path segment, then decode any of the encoded special chars.\n//\n// The chars \"!\", \"'\", \"(\", \")\", \"*\" do not get changed by `encodeURIComponent`,\n// so the possible encoded chars are:\n// ['%24', '%26', '%2B', '%2C', '%3B', '%3D', '%3A', '%40'].\nconst PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;\n\nexport function encodePathSegment(str: string) {\n  return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);\n}\n", "import { createMap } from \"./route-recognizer/util\";\nimport map, { Delegate, Route, Opaque, MatchCallback } from \"./route-recognizer/dsl\";\nimport { normalizePath, normalizeSegment, encodePathSegment } from \"./route-recognizer/normalizer\";\nexport { Delegate, MatchCallback } from './route-recognizer/dsl';\n\nconst enum CHARS {\n  ANY = -1,\n  STAR = 42,\n  SLASH = 47,\n  COLON = 58\n}\n\nconst escapeRegex = /(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\)/g;\n\nconst isArray = Array.isArray;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getParam(params: Params | null | undefined, key: string): string {\n  if (typeof params !== \"object\" || params === null) {\n    throw new Error(\"You must pass an object as the second argument to `generate`.\");\n  }\n\n  if (!hasOwnProperty.call(params, key)) {\n    throw new Error(\"You must provide param `\" + key + \"` to `generate`.\");\n  }\n\n  let value = params[key];\n  let str = typeof value === \"string\" ? value : \"\" + value;\n  if (str.length === 0) {\n    throw new Error(\"You must provide a param `\" + key + \"`.\");\n  }\n  return str;\n}\n\nconst enum SegmentType {\n  Static  = 0,\n  Dynamic = 1,\n  Star    = 2,\n  Epsilon = 4\n}\n\nconst enum SegmentFlags {\n  Static  = 2 << SegmentType.Static,\n  Dynamic = 2 << SegmentType.Dynamic,\n  Star    = 2 << SegmentType.Star,\n  Epsilon = 2 << SegmentType.Epsilon,\n  Named = Dynamic | Star,\n  Decoded = Dynamic,\n  Counted = Static | Dynamic | Star\n}\n\nconst eachChar: ((segment: Segment, currentState: State) => State)[] = [];\neachChar[SegmentType.Static] = function (segment: Segment, currentState: State) {\n  let state = currentState;\n  let value = segment.value;\n  for (let i = 0; i < value.length; i++) {\n    let ch = value.charCodeAt(i);\n    state = state.put(ch, false, false);\n  }\n  return state;\n};\neachChar[SegmentType.Dynamic] = function (_: Segment, currentState: State) {\n  return currentState.put(CHARS.SLASH, true, true);\n};\neachChar[SegmentType.Star] = function (_: Segment, currentState: State) {\n  return currentState.put(CHARS.ANY, false, true);\n};\neachChar[SegmentType.Epsilon] = function (_: Segment, currentState: State) {\n  return currentState;\n};\n\nconst regex: ((segment: Segment) => string)[] = [];\nregex[SegmentType.Static] = function (segment: Segment) {\n  return segment.value.replace(escapeRegex, \"\\\\$1\");\n};\nregex[SegmentType.Dynamic] = function () {\n  return \"([^/]+)\";\n};\nregex[SegmentType.Star] = function () {\n  return \"(.+)\";\n};\nregex[SegmentType.Epsilon] = function () {\n  return \"\";\n};\n\nconst generate: ((segment: Segment, params?: Params | null) => string)[] = [];\ngenerate[SegmentType.Static] = function (segment: Segment) {\n  return segment.value;\n};\ngenerate[SegmentType.Dynamic] = function (segment: Segment, params?: Params) {\n  let value = getParam(params, segment.value);\n  if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n    return encodePathSegment(value);\n  } else {\n    return value;\n  }\n};\ngenerate[SegmentType.Star] = function (segment: Segment, params?: Params) {\n  return getParam(params, segment.value);\n};\ngenerate[SegmentType.Epsilon] = function () {\n  return \"\";\n};\n\n// A Segment represents a segment in the original route description.\n// Each Segment type provides an `eachChar` and `regex` method.\n//\n// The `eachChar` method invokes the callback with one or more character\n// specifications. A character specification consumes one or more input\n// characters.\n//\n// The `regex` method returns a regex fragment for the segment. If the\n// segment is a dynamic of star segment, the regex fragment also includes\n// a capture.\n//\n// A character specification contains:\n//\n// * `validChars`: a String with a list of all valid characters, or\n// * `invalidChars`: a String with a list of all invalid characters\n// * `repeat`: true if the character specification can repeat\ninterface Segment {\n  type: SegmentType;\n  value: string;\n}\n\nexport interface Params {\n  [key: string]: Opaque;\n  [key: number]: Opaque;\n  queryParams?: QueryParams | null;\n}\n\ninterface PopulatedParsedHandlers {\n  names: string[];\n  shouldDecodes: any[];\n}\n\nconst EmptyObject = Object.freeze({});\ntype EmptyObject = Readonly<{}>\n\nconst EmptyArray = Object.freeze([]) as ReadonlyArray<any>;\ntype EmptyArray = ReadonlyArray<any>;\n\ninterface EmptyParsedHandlers {\n  names: EmptyArray;\n  shouldDecodes: EmptyArray;\n}\n\ntype ParsedHandler = PopulatedParsedHandlers | EmptyParsedHandlers;\n\n// The `names` will be populated with the paramter name for each dynamic/star\n// segment. `shouldDecodes` will be populated with a boolean for each dyanamic/star\n// segment, indicating whether it should be decoded during recognition.\nfunction parse(segments: Segment[], route: string, types: [number, number, number]) {\n  // normalize route as not starting with a \"/\". Recognition will\n  // also normalize.\n  if (route.length > 0 && route.charCodeAt(0) === CHARS.SLASH) { route = route.substr(1); }\n\n  let parts = route.split(\"/\");\n  let names: void | string[] = undefined;\n  let shouldDecodes: void | any[] = undefined;\n\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    let flags: SegmentFlags = 0;\n    let type: SegmentType = 0;\n\n    if (part === \"\") {\n      type = SegmentType.Epsilon;\n    } else if (part.charCodeAt(0) === CHARS.COLON) {\n      type = SegmentType.Dynamic;\n    } else if (part.charCodeAt(0) === CHARS.STAR) {\n      type = SegmentType.Star;\n    }  else {\n      type = SegmentType.Static;\n    }\n\n    flags = 2 << type;\n\n    if (flags & SegmentFlags.Named) {\n      part = part.slice(1);\n      names = names || [];\n      names.push(part);\n\n      shouldDecodes = shouldDecodes || [];\n      shouldDecodes.push((flags & SegmentFlags.Decoded) !== 0);\n    }\n\n    if (flags & SegmentFlags.Counted) {\n      types[type]++;\n    }\n\n    segments.push({\n      type,\n      value: normalizeSegment(part)\n    });\n  }\n\n  return {\n    names: names || EmptyArray,\n    shouldDecodes: shouldDecodes || EmptyArray,\n  } as ParsedHandler;\n}\n\nfunction isEqualCharSpec(spec: CharSpec, char: number, negate: boolean) {\n  return spec.char === char && spec.negate === negate;\n}\n\ninterface EmptyHandler {\n  handler: Opaque;\n  names: EmptyArray;\n  shouldDecodes: EmptyArray;\n}\n\ninterface PopulatedHandler {\n  handler: Opaque;\n  names: string [];\n  shouldDecodes: boolean[];\n}\n\ntype Handler = EmptyHandler | PopulatedHandler;\n\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\nclass State implements CharSpec {\n  states: State[];\n  id: number;\n  negate: boolean;\n  char: number;\n  nextStates: number[] | number | null;\n  pattern: string;\n  _regex: RegExp | undefined;\n  handlers: Handler[] | undefined;\n  types: [number, number, number] | undefined;\n\n  constructor(states: State[], id: number, char: number, negate: boolean, repeat: boolean) {\n    this.states = states;\n    this.id = id;\n    this.char = char;\n    this.negate = negate;\n    this.nextStates = repeat ? id : null;\n    this.pattern = \"\";\n    this._regex = undefined;\n    this.handlers = undefined;\n    this.types = undefined;\n  }\n\n  regex(): RegExp {\n    if (!this._regex) {\n      this._regex = new RegExp(this.pattern);\n    }\n    return this._regex;\n  }\n\n  get(char: number, negate: boolean): State | void {\n    let nextStates = this.nextStates;\n    if (nextStates === null) return;\n    if (isArray(nextStates)) {\n      for (let i = 0; i < nextStates.length; i++) {\n        let child = this.states[nextStates[i]];\n        if (isEqualCharSpec(child, char, negate)) {\n          return child;\n        }\n      }\n    } else {\n      let child = this.states[nextStates];\n      if (isEqualCharSpec(child, char, negate)) {\n        return child;\n      }\n    }\n  }\n\n  put(char: number, negate: boolean, repeat: boolean) {\n    let state: State | void;\n\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(char, negate)) { return state; }\n\n    // Make a new state for the character spec\n    let states = this.states;\n    state = new State(states, states.length, char, negate, repeat);\n    states[states.length] = state;\n\n    // Insert the new state as a child of the current state\n    if (this.nextStates == null) {\n      this.nextStates = state.id;\n    } else if (isArray(this.nextStates)) {\n      this.nextStates.push(state.id);\n    } else {\n      this.nextStates = [this.nextStates, state.id];\n    }\n\n    // Return the new state\n    return state;\n  }\n\n  // Find a list of child states matching the next character\n  match(ch: number): State[] {\n    let nextStates = this.nextStates;\n    if (!nextStates) return [];\n\n    let returned: State[] = [];\n    if (isArray(nextStates)) {\n      for (let i = 0; i < nextStates.length; i++) {\n        let child = this.states[nextStates[i]];\n\n        if (isMatch(child, ch)) {\n          returned.push(child);\n        }\n      }\n    } else {\n      let child = this.states[nextStates];\n      if (isMatch(child, ch)) {\n        returned.push(child);\n      }\n    }\n    return returned;\n  }\n}\n\nfunction isMatch(spec: CharSpec, char: number) {\n  return spec.negate ? spec.char !== char && spec.char !== CHARS.ANY : spec.char === char || spec.char === CHARS.ANY;\n}\n\n// This is a somewhat naive strategy, but should work in a lot of cases\n// A better strategy would properly resolve /posts/:id/new and /posts/edit/:id.\n//\n// This strategy generally prefers more static and less dynamic matching.\n// Specifically, it\n//\n//  * prefers fewer stars to more, then\n//  * prefers using stars for less of the match to more, then\n//  * prefers fewer dynamic segments to more, then\n//  * prefers more static segments to more\nfunction sortSolutions(states: State[]) {\n  return states.sort(function(a, b) {\n    let [ astatics, adynamics, astars ] = a.types || [0, 0, 0];\n    let [ bstatics, bdynamics, bstars ] = b.types || [0, 0, 0];\n    if (astars !== bstars) { return astars - bstars; }\n\n    if (astars) {\n      if (astatics !== bstatics) { return bstatics - astatics; }\n      if (adynamics !== bdynamics) { return bdynamics - adynamics; }\n    }\n\n    if (adynamics !== bdynamics) { return adynamics - bdynamics; }\n    if (astatics !== bstatics) { return bstatics - astatics; }\n\n    return 0;\n  });\n}\n\nfunction recognizeChar(states: State[], ch: number) {\n  let nextStates: State[] = [];\n\n  for (let i = 0, l = states.length; i < l; i++) {\n    let state = states[i];\n\n    nextStates = nextStates.concat(state.match(ch));\n  }\n\n  return nextStates;\n}\n\n\nexport interface QueryParams {\n  [param: string]: any[] | any | null | undefined;\n}\n\nexport interface Result {\n  handler: Opaque;\n  params: Params;\n  isDynamic: boolean;\n}\n\nexport interface Results extends ArrayLike<Result | undefined> {\n  queryParams: QueryParams;\n  slice(start?: number, end?: number): Result[];\n  splice(start: number, deleteCount: number, ...items: Result[]): Result[];\n  push(...results: Result[]): number;\n}\n\nclass RecognizeResults implements Results {\n  queryParams: QueryParams;\n  length = 0;\n  [index: number]: Result | undefined;\n  splice: (start: number, deleteCount: number, ...items: Result[]) => Result[];\n  slice: (start?: number, end?: number) => Result[];\n  push: (...results: Result[]) => number;\n\n  constructor(queryParams?: QueryParams) {\n    this.queryParams = queryParams || {};\n  }\n};\n\nRecognizeResults.prototype.splice = Array.prototype.splice;\nRecognizeResults.prototype.slice =  Array.prototype.slice;\nRecognizeResults.prototype.push = Array.prototype.push;\n\nfunction findHandler(state: State, originalPath: string, queryParams: QueryParams): Results {\n  let handlers = state.handlers;\n  let regex: RegExp = state.regex();\n  if (!regex || !handlers) throw new Error(\"state not initialized\");\n  let captures: RegExpMatchArray | null = originalPath.match(regex);\n  let currentCapture = 1;\n  let result = new RecognizeResults(queryParams);\n\n  result.length = handlers.length;\n\n  for (let i = 0; i < handlers.length; i++) {\n    let handler = handlers[i];\n    let names = handler.names;\n    let shouldDecodes = handler.shouldDecodes;\n    let params: EmptyObject | Params = EmptyObject;\n\n    let isDynamic = false;\n\n    if (names !== EmptyArray && shouldDecodes !== EmptyArray) {\n      for (let j = 0; j < names.length; j++) {\n        isDynamic = true;\n        let name = names[j];\n        let capture = captures && captures[currentCapture++];\n\n        if (params === EmptyObject) {\n          params = {};\n        }\n\n        if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {\n          (<Params>params)[name] = capture && decodeURIComponent(capture);\n        } else {\n          (<Params>params)[name] = capture;\n        }\n      }\n    }\n\n    result[i] = {\n      handler: handler.handler,\n      params,\n      isDynamic\n    };\n  }\n\n  return result;\n}\n\nfunction decodeQueryParamPart(part: string): string {\n  // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n  part = part.replace(/\\+/gm, \"%20\");\n  let result;\n  try {\n    result = decodeURIComponent(part);\n  } catch (error) {result = \"\"; }\n  return result;\n}\n\ninterface NamedRoute {\n  segments: Segment[];\n  handlers: Handler[];\n}\n\nclass RouteRecognizer {\n  private states: State[];\n  private rootState: State;\n  private names: {\n    [name: string]: NamedRoute | undefined;\n  } = createMap<NamedRoute>();\n  map: (context: MatchCallback, addCallback?: (router: this, routes: Route[]) => void) => void;\n  delegate: Delegate | undefined;\n\n  constructor() {\n    let states: State[] = [];\n    let state = new State(states, 0, CHARS.ANY, true, false);\n    states[0] = state;\n    this.states = states;\n    this.rootState = state;\n  }\n\n  static VERSION = \"0.3.4\";\n  // Set to false to opt-out of encoding and decoding path segments.\n  // See https://github.com/tildeio/route-recognizer/pull/55\n  static ENCODE_AND_DECODE_PATH_SEGMENTS = true;\n  static Normalizer = {\n    normalizeSegment, normalizePath, encodePathSegment\n  };\n\n  add(routes: Route[], options?: { as: string }) {\n    let currentState = this.rootState;\n    let pattern = \"^\";\n    let types: [number, number, number] = [0, 0, 0];\n    let handlers: Handler[] = new Array(routes.length);\n    let allSegments: Segment[] = [];\n\n    let isEmpty = true;\n    let j = 0;\n    for (let i = 0; i < routes.length; i++) {\n      let route = routes[i];\n      let { names, shouldDecodes } = parse(allSegments, route.path, types);\n\n      // preserve j so it points to the start of newly added segments\n      for (; j < allSegments.length; j++) {\n        let segment = allSegments[j];\n\n        if (segment.type === SegmentType.Epsilon) { continue; }\n\n        isEmpty = false;\n\n        // Add a \"/\" for the new segment\n        currentState = currentState.put(CHARS.SLASH, false, false);\n        pattern += \"/\";\n\n        // Add a representation of the segment to the NFA and regex\n        currentState = eachChar[segment.type](segment, currentState);\n        pattern += regex[segment.type](segment);\n      }\n      handlers[i] = {\n        handler: route.handler,\n        names,\n        shouldDecodes\n      };\n    }\n\n    if (isEmpty) {\n        currentState = currentState.put(CHARS.SLASH, false, false);\n      pattern += \"/\";\n    }\n\n    currentState.handlers = handlers;\n    currentState.pattern = pattern + \"$\";\n    currentState.types = types;\n\n    let name: string | undefined;\n    if (typeof options === \"object\" && options !== null && options.as) {\n      name = options.as;\n    }\n\n    if (name) {\n      // if (this.names[name]) {\n      //   throw new Error(\"You may not add a duplicate route named `\" + name + \"`.\");\n      // }\n\n      this.names[name] = {\n        segments: allSegments,\n        handlers\n      };\n    }\n  }\n\n  handlersFor(name: string) {\n    let route = this.names[name];\n\n    if (!route) { throw new Error(\"There is no route named \" + name); }\n\n    let result = new Array(route.handlers.length);\n\n    for (let i = 0; i < route.handlers.length; i++) {\n      let handler = route.handlers[i];\n      result[i] = handler;\n    }\n\n    return result;\n  }\n\n  hasRoute(name: string) {\n    return !!this.names[name];\n  }\n\n  generate(name: string, params?: Params | null) {\n    let route = this.names[name];\n    let output = \"\";\n    if (!route) { throw new Error(\"There is no route named \" + name); }\n\n    let segments: Segment[] = route.segments;\n\n    for (let i = 0; i < segments.length; i++) {\n      let segment: Segment = segments[i];\n\n      if (segment.type === SegmentType.Epsilon) {\n        continue;\n      }\n\n      output += \"/\";\n      output += generate[segment.type](segment, params);\n    }\n\n    if (output.charAt(0) !== \"/\") { output = \"/\" + output; }\n\n    if (params && params.queryParams) {\n      output += this.generateQueryString(params.queryParams);\n    }\n\n    return output;\n  }\n\n  generateQueryString(params: QueryParams) {\n    let pairs: string[] = [];\n    let keys: string[] = Object.keys(params);\n    keys.sort();\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let value = params[key];\n      if (value == null) {\n        continue;\n      }\n      let pair = encodeURIComponent(key);\n      if (isArray(value)) {\n        for (let j = 0; j < value.length; j++) {\n          let arrayPair = key + \"[]\" + \"=\" + encodeURIComponent(value[j]);\n          pairs.push(arrayPair);\n        }\n      } else {\n        pair += \"=\" + encodeURIComponent(value);\n        pairs.push(pair);\n      }\n    }\n\n    if (pairs.length === 0) { return \"\"; }\n\n    return \"?\" + pairs.join(\"&\");\n  }\n\n  parseQueryString(queryString: string): QueryParams {\n    let pairs = queryString.split(\"&\");\n    let queryParams: QueryParams = {};\n    for (let i = 0; i < pairs.length; i++) {\n      let pair      = pairs[i].split(\"=\"),\n          key       = decodeQueryParamPart(pair[0]),\n          keyLength = key.length,\n          isArray = false,\n          value;\n      if (pair.length === 1) {\n        value = \"true\";\n      } else {\n        // Handle arrays\n        if (keyLength > 2 && key.slice(keyLength - 2) === \"[]\") {\n          isArray = true;\n          key = key.slice(0, keyLength - 2);\n          if (!queryParams[key]) {\n            queryParams[key] = [];\n          }\n        }\n        value = pair[1] ? decodeQueryParamPart(pair[1]) : \"\";\n      }\n      if (isArray) {\n        (<string[]>queryParams[key]).push(value);\n      } else {\n        queryParams[key] = value;\n      }\n    }\n    return queryParams;\n  }\n\n  recognize(path: string): Results | undefined {\n    let results: Results | undefined;\n    let states: State[] = [ this.rootState ];\n    let queryParams = {};\n    let isSlashDropped = false;\n    let hashStart = path.indexOf(\"#\");\n    if (hashStart !== -1) {\n      path = path.substr(0, hashStart);\n    }\n\n    let queryStart = path.indexOf(\"?\");\n    if (queryStart !== -1) {\n      let queryString = path.substr(queryStart + 1, path.length);\n      path = path.substr(0, queryStart);\n      queryParams = this.parseQueryString(queryString);\n    }\n\n    if (path.charAt(0) !== \"/\") { path = \"/\" + path; }\n    let originalPath = path;\n\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n      path = normalizePath(path);\n    } else {\n      path = decodeURI(path);\n      originalPath = decodeURI(originalPath);\n    }\n\n    let pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n      path = path.substr(0, pathLen - 1);\n      originalPath = originalPath.substr(0, originalPath.length - 1);\n      isSlashDropped = true;\n    }\n\n    for (let i = 0; i < path.length; i++) {\n      states = recognizeChar(states, path.charCodeAt(i));\n      if (!states.length) { break; }\n    }\n\n    let solutions: State[] = [];\n    for (let i = 0; i < states.length; i++) {\n      if (states[i].handlers) { solutions.push(states[i]); }\n    }\n\n    states = sortSolutions(solutions);\n\n    let state = solutions[0];\n\n    if (state && state.handlers) {\n      // if a trailing slash was dropped and a star segment is the last segment\n      // specified, put the trailing slash back\n      if (isSlashDropped && state.pattern && state.pattern.slice(-5) === \"(.+)$\") {\n        originalPath = originalPath + \"/\";\n      }\n      results = findHandler(state, originalPath, queryParams);\n    }\n\n    return results;\n  }\n}\n\nRouteRecognizer.prototype.map = map;\n\nexport default RouteRecognizer;\n\ninterface CharSpec {\n  negate: boolean;\n  char: number;\n}\n", "function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };", "import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n", "/**\n * WordPress dependencies\n */\nimport { useContext, useMemo } from '@wordpress/element';\nimport { getQueryArgs, getPath, buildQueryString } from '@wordpress/url';\n\n/**\n * Internal dependencies\n */\nimport { ConfigContext, type NavigationOptions, useHistory } from './router';\n\nexport function useLink( to: string, options: NavigationOptions = {} ) {\n\tconst history = useHistory();\n\tconst { pathArg, beforeNavigate } = useContext( ConfigContext );\n\tfunction onClick( event: React.SyntheticEvent< HTMLAnchorElement > ) {\n\t\tevent?.preventDefault();\n\t\thistory.navigate( to, options );\n\t}\n\tconst query = getQueryArgs( to );\n\tconst path = getPath( 'http://domain.com/' + to ) ?? '';\n\tconst link = useMemo( () => {\n\t\treturn beforeNavigate\n\t\t\t? beforeNavigate( { path, query } )\n\t\t\t: { path, query };\n\t}, [ path, query, beforeNavigate ] );\n\n\tconst [ before ] = window.location.href.split( '?' );\n\n\treturn {\n\t\thref: `${ before }?${ buildQueryString( {\n\t\t\t[ pathArg ]: link.path,\n\t\t\t...link.query,\n\t\t} ) }`,\n\t\tonClick,\n\t};\n}\n\nexport function Link( {\n\tto,\n\toptions,\n\tchildren,\n\t...props\n}: {\n\tto: string;\n\toptions?: NavigationOptions;\n\tchildren: React.ReactNode;\n} ) {\n\tconst { href, onClick } = useLink( to, options );\n\n\treturn (\n\t\t<a href={ href } onClick={ onClick } { ...props }>\n\t\t\t{ children }\n\t\t</a>\n\t);\n}\n", "/**\n * WordPress dependencies\n */\nimport { __dangerousOptInToUnstableAPIsOnlyForCoreModules } from '@wordpress/private-apis';\n\nexport const { lock, unlock } =\n\t__dangerousOptInToUnstableAPIsOnlyForCoreModules(\n\t\t'I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.',\n\t\t'@wordpress/router'\n\t);\n", "/**\n * Internal dependencies\n */\nimport { useHistory, useLocation, RouterProvider } from './router';\nimport { useLink, Link } from './link';\nimport { lock } from './lock-unlock';\n\nexport const privateApis = {};\nlock( privateApis, {\n\tuseHistory,\n\tuseLocation,\n\tRouterProvider,\n\tuseLink,\n\tLink,\n} );\n"],
  "mappings": "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",
  "names": ["const", "map", "Target", "Matcher", "match", "let", "State", "this", "child", "RecognizeResults", "regex", "RouteRecognizer", "add", "isArray", "i", "Action", "window", "to", "index", "action", "location", "history", "match", "import_jsx_runtime", "import_element", "import_url", "to", "history"]
}
