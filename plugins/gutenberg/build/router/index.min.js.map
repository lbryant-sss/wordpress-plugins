{
  "version": 3,
  "sources": ["vendor-external:react/jsx-runtime", "wordpress-external:@wordpress/element", "wordpress-external:@wordpress/url", "wordpress-external:@wordpress/compose", "wordpress-external:@wordpress/private-apis", "../../packages/router/src/index.ts", "../../packages/router/src/router.tsx", "../../node_modules/route-recognizer/dist/route-recognizer/util.ts", "../../node_modules/route-recognizer/dist/route-recognizer/dsl.ts", "../../node_modules/route-recognizer/dist/route-recognizer/normalizer.ts", "../../node_modules/route-recognizer/dist/route-recognizer.ts", "../../node_modules/@babel/runtime/helpers/esm/extends.js", "../../node_modules/history/index.js", "../../packages/router/src/link.tsx", "../../packages/router/src/lock-unlock.ts", "../../packages/router/src/private-apis.ts"],
  "sourcesContent": ["module.exports = window.ReactJSXRuntime;", "module.exports = window.wp.element;", "module.exports = window.wp.url;", "module.exports = window.wp.compose;", "module.exports = window.wp.privateApis;", "export { privateApis } from './private-apis';\n", "/**\n * External dependencies\n */\nimport RouteRecognizer from 'route-recognizer';\nimport { createBrowserHistory } from 'history';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tcreateContext,\n\tuseContext,\n\tuseSyncExternalStore,\n\tuseMemo,\n\tuseState,\n\tuseEffect,\n} from '@wordpress/element';\nimport {\n\taddQueryArgs,\n\tgetQueryArgs,\n\tgetPath,\n\tbuildQueryString,\n} from '@wordpress/url';\nimport { useEvent, usePrevious } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport type { ReactNode } from 'react';\n\nconst history = createBrowserHistory();\ninterface Route {\n\tname: string;\n\tpath: string;\n\tareas: Record< string, ReactNode >;\n\twidths: Record< string, number >;\n}\n\ntype LocationWithQuery = Location & {\n\tquery?: Record< string, any >;\n};\n\ninterface Match {\n\tname: string;\n\tpath: string;\n\tareas: Record< string, ReactNode >;\n\twidths: Record< string, number >;\n\tquery?: Record< string, any >;\n\tparams?: Record< string, any >;\n}\n\nexport type BeforeNavigate = ( arg: {\n\tpath: string;\n\tquery: Record< string, any >;\n} ) => {\n\tpath: string;\n\tquery: Record< string, any >;\n};\n\ninterface Config {\n\tpathArg: string;\n\tbeforeNavigate?: BeforeNavigate;\n}\n\nexport interface NavigationOptions {\n\ttransition?: string;\n\tstate?: Record< string, any >;\n}\n\nconst RoutesContext = createContext< Match | null >( null );\nRoutesContext.displayName = 'RoutesContext';\n\nexport const ConfigContext = createContext< Config >( { pathArg: 'p' } );\nConfigContext.displayName = 'ConfigContext';\n\nconst locationMemo = new WeakMap();\nfunction getLocationWithQuery() {\n\tconst location = history.location;\n\tlet locationWithQuery = locationMemo.get( location );\n\tif ( ! locationWithQuery ) {\n\t\tlocationWithQuery = {\n\t\t\t...location,\n\t\t\tquery: Object.fromEntries( new URLSearchParams( location.search ) ),\n\t\t};\n\t\tlocationMemo.set( location, locationWithQuery );\n\t}\n\treturn locationWithQuery;\n}\n\nexport function useLocation() {\n\tconst context = useContext( RoutesContext );\n\tif ( ! context ) {\n\t\tthrow new Error( 'useLocation must be used within a RouterProvider' );\n\t}\n\treturn context;\n}\n\nexport function useHistory() {\n\tconst { pathArg, beforeNavigate } = useContext( ConfigContext );\n\n\tconst navigate = useEvent(\n\t\tasync ( rawPath: string, options: NavigationOptions = {} ) => {\n\t\t\tconst query = getQueryArgs( rawPath );\n\t\t\tconst path = getPath( 'http://domain.com/' + rawPath ) ?? '';\n\t\t\tconst performPush = () => {\n\t\t\t\tconst result = beforeNavigate\n\t\t\t\t\t? beforeNavigate( { path, query } )\n\t\t\t\t\t: { path, query };\n\t\t\t\treturn history.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tsearch: buildQueryString( {\n\t\t\t\t\t\t\t[ pathArg ]: result.path,\n\t\t\t\t\t\t\t...result.query,\n\t\t\t\t\t\t} ),\n\t\t\t\t\t},\n\t\t\t\t\toptions.state\n\t\t\t\t);\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Skip transition in mobile, otherwise it crashes the browser.\n\t\t\t * See: https://github.com/WordPress/gutenberg/pull/63002.\n\t\t\t */\n\t\t\tconst isMediumOrBigger =\n\t\t\t\twindow.matchMedia( '(min-width: 782px)' ).matches;\n\t\t\tif (\n\t\t\t\t! isMediumOrBigger ||\n\t\t\t\t! document.startViewTransition ||\n\t\t\t\t! options.transition\n\t\t\t) {\n\t\t\t\tperformPush();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait new Promise< void >( ( resolve ) => {\n\t\t\t\tconst classname = options.transition ?? '';\n\t\t\t\tdocument.documentElement.classList.add( classname );\n\t\t\t\tconst transition = document.startViewTransition( () =>\n\t\t\t\t\tperformPush()\n\t\t\t\t);\n\t\t\t\ttransition.finished.finally( () => {\n\t\t\t\t\tdocument.documentElement.classList.remove( classname );\n\t\t\t\t\tresolve();\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t);\n\n\treturn useMemo(\n\t\t() => ( {\n\t\t\tnavigate,\n\t\t\tback: history.back,\n\t\t\tinvalidate: () => {\n\t\t\t\thistory.replace( {\n\t\t\t\t\tsearch: history.location.search,\n\t\t\t\t} );\n\t\t\t},\n\t\t} ),\n\t\t[ navigate ]\n\t);\n}\n\nexport default function useMatch(\n\tlocation: LocationWithQuery,\n\tmatcher: RouteRecognizer,\n\tpathArg: string,\n\tmatchResolverArgs: Record< string, any >\n): Match | undefined {\n\tconst { query: rawQuery = {} } = location;\n\tconst [ resolvedMatch, setMatch ] = useState< Match | undefined >();\n\n\tuseEffect( () => {\n\t\tconst { [ pathArg ]: path = '/', ...query } = rawQuery;\n\t\tconst ret = matcher.recognize( path )?.[ 0 ];\n\t\tasync function resolveMatch( result: any ) {\n\t\t\tconst matchedRoute = result.handler as Route;\n\t\t\tconst resolveFunctions = async (\n\t\t\t\trecord: Record< string, any > = {}\n\t\t\t) => {\n\t\t\t\tconst entries = await Promise.all(\n\t\t\t\t\tObject.entries( record ).map( async ( [ key, value ] ) => {\n\t\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tawait value( {\n\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\tparams: result.params,\n\t\t\t\t\t\t\t\t\t...matchResolverArgs,\n\t\t\t\t\t\t\t\t} ),\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [ key, value ];\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\treturn Object.fromEntries( entries );\n\t\t\t};\n\t\t\tconst [ resolvedAreas, resolvedWidths ] = await Promise.all( [\n\t\t\t\tresolveFunctions( matchedRoute.areas ),\n\t\t\t\tresolveFunctions( matchedRoute.widths ),\n\t\t\t] );\n\t\t\tsetMatch( {\n\t\t\t\tname: matchedRoute.name,\n\t\t\t\tareas: resolvedAreas,\n\t\t\t\twidths: resolvedWidths,\n\t\t\t\tparams: result.params,\n\t\t\t\tquery,\n\t\t\t\tpath: addQueryArgs( path, query ),\n\t\t\t} );\n\t\t}\n\n\t\tif ( ! ret ) {\n\t\t\tsetMatch( {\n\t\t\t\tname: '404',\n\t\t\t\tpath: addQueryArgs( path, query ),\n\t\t\t\tareas: {},\n\t\t\t\twidths: {},\n\t\t\t\tquery,\n\t\t\t\tparams: {},\n\t\t\t} );\n\t\t} else {\n\t\t\tresolveMatch( ret );\n\t\t}\n\n\t\treturn () => setMatch( undefined );\n\t}, [ matcher, rawQuery, pathArg, matchResolverArgs ] );\n\n\treturn resolvedMatch;\n}\n\nexport function RouterProvider( {\n\troutes,\n\tpathArg,\n\tbeforeNavigate,\n\tchildren,\n\tmatchResolverArgs,\n}: {\n\troutes: Route[];\n\tpathArg: string;\n\tbeforeNavigate?: BeforeNavigate;\n\tchildren: React.ReactNode;\n\tmatchResolverArgs: Record< string, any >;\n} ) {\n\tconst location = useSyncExternalStore(\n\t\thistory.listen,\n\t\tgetLocationWithQuery,\n\t\tgetLocationWithQuery\n\t);\n\tconst matcher = useMemo( () => {\n\t\tconst ret = new RouteRecognizer();\n\t\t( routes ?? [] ).forEach( ( route ) => {\n\t\t\tret.add( [ { path: route.path, handler: route } ], {\n\t\t\t\tas: route.name,\n\t\t\t} );\n\t\t} );\n\t\treturn ret;\n\t}, [ routes ] );\n\tconst match = useMatch( location, matcher, pathArg, matchResolverArgs );\n\tconst previousMatch = usePrevious( match );\n\tconst config = useMemo(\n\t\t() => ( { beforeNavigate, pathArg } ),\n\t\t[ beforeNavigate, pathArg ]\n\t);\n\tconst renderedMatch = match || previousMatch;\n\n\tif ( ! renderedMatch ) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<ConfigContext.Provider value={ config }>\n\t\t\t<RoutesContext.Provider value={ renderedMatch }>\n\t\t\t\t{ children }\n\t\t\t</RoutesContext.Provider>\n\t\t</ConfigContext.Provider>\n\t);\n}\n", "const createObject = Object.create;\nexport function createMap<T>() {\n  const map: { [key: string]: T | undefined } = createObject(null);\n  map[\"__\"] = undefined;\n  delete map[\"__\"];\n  return map;\n}\n", "import { createMap } from \"./util\";\n\nexport interface Delegate {\n  contextEntered?(context: string, route: MatchDSL): void;\n  willAddRoute?(context: string | undefined, route: string): string;\n}\n\nexport type Opaque = {} | void | null | undefined;\n\nexport interface Route {\n  path: string;\n  handler: Opaque;\n  queryParams?: string[];\n}\n\nexport interface RouteRecognizer {\n  delegate: Delegate | undefined;\n  add(routes: Route[]): void;\n}\n\nexport interface MatchCallback {\n  (match: MatchDSL): void;\n}\n\nexport interface MatchDSL {\n  (path: string): ToDSL;\n  (path: string, callback: MatchCallback): void;\n}\n\nexport interface ToDSL {\n  to(name: string, callback?: MatchCallback): void;\n}\n\nclass Target implements ToDSL {\n  path: string;\n  matcher: Matcher;\n  delegate: Delegate | undefined;\n\n  constructor(path: string, matcher: Matcher, delegate: Delegate | undefined) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n  }\n\n  to(target: string, callback: MatchCallback) {\n    let delegate = this.delegate;\n\n    if (delegate && delegate.willAddRoute) {\n      target = delegate.willAddRoute(this.matcher.target, target);\n    }\n\n    this.matcher.add(this.path, target);\n\n    if (callback) {\n      if (callback.length === 0) { throw new Error(\"You must have an argument in the function passed to `to`\"); }\n      this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n  }\n}\n\nexport class Matcher {\n  routes: {\n    [path: string]: string | undefined;\n  };\n  children: {\n    [path: string]: Matcher | undefined;\n  };\n  target: string | undefined;\n\n  constructor(target?: string) {\n    this.routes = createMap<string>();\n    this.children = createMap<Matcher>();\n    this.target = target;\n  }\n\n  add(path: string, target: string) {\n    this.routes[path] = target;\n  }\n\n  addChild(path: string, target: string, callback: MatchCallback, delegate: Delegate | undefined) {\n    let matcher = new Matcher(target);\n    this.children[path] = matcher;\n\n    let match = generateMatch(path, matcher, delegate);\n\n    if (delegate && delegate.contextEntered) {\n      delegate.contextEntered(target, match);\n    }\n\n    callback(match);\n  }\n}\n\nfunction generateMatch(startingPath: string, matcher: Matcher, delegate: Delegate | undefined): MatchDSL {\n  function match(path: string): ToDSL;\n  function match(path: string, callback: MatchCallback): void;\n  function match(path: string, callback?: MatchCallback): ToDSL | void {\n    let fullPath = startingPath + path;\n    if (callback) {\n      callback(generateMatch(fullPath, matcher, delegate));\n    } else {\n      return new Target(fullPath, matcher, delegate);\n    }\n  };\n  return match;\n}\n\nfunction addRoute(routeArray: Route[], path: string, handler: any) {\n  let len = 0;\n  for (let i = 0; i < routeArray.length; i++) {\n    len += routeArray[i].path.length;\n  }\n\n  path = path.substr(len);\n  let route = { path: path, handler: handler };\n  routeArray.push(route);\n}\n\nfunction eachRoute<T>(baseRoute: Route[], matcher: Matcher, callback: (this: T, routes: Route[]) => void, binding: T) {\n  let routes = matcher.routes;\n  let paths = Object.keys(routes);\n  for (let i = 0; i < paths.length; i++) {\n    let path = paths[i];\n    let routeArray = baseRoute.slice();\n    addRoute(routeArray, path, routes[path]);\n    let nested = matcher.children[path];\n    if (nested) {\n      eachRoute(routeArray, nested, callback, binding);\n    } else {\n      callback.call(binding, routeArray);\n    }\n  }\n}\n\nexport default function <T extends RouteRecognizer>(this: T, callback: MatchCallback, addRouteCallback?: (routeRecognizer: T, routes: Route[]) => void) {\n  let matcher = new Matcher();\n\n  callback(generateMatch(\"\", matcher, this.delegate));\n\n  eachRoute([], matcher, function(routes: Route[]) {\n    if (addRouteCallback) { addRouteCallback(this, routes); }\n    else { this.add(routes); }\n  }, this);\n}\n", "// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\n// values that are not reserved (i.e., unicode characters, emoji, etc). The reserved\n// chars are \"/\" and \"%\".\n// Safe to call multiple times on the same path.\nexport function normalizePath(path: string): string {\n  return path.split(\"/\")\n             .map(normalizeSegment)\n             .join(\"/\");\n}\n\n// We want to ensure the characters \"%\" and \"/\" remain in percent-encoded\n// form when normalizing paths, so replace them with their encoded form after\n// decoding the rest of the path\nconst SEGMENT_RESERVED_CHARS = /%|\\//g;\nexport function normalizeSegment(segment: string) {\n  if (segment.length < 3 || segment.indexOf(\"%\") === -1) return segment;\n  return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);\n}\n\n// We do not want to encode these characters when generating dynamic path segments\n// See https://tools.ietf.org/html/rfc3986#section-3.3\n// sub-delims: \"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"\n// others allowed by RFC 3986: \":\", \"@\"\n//\n// First encode the entire path segment, then decode any of the encoded special chars.\n//\n// The chars \"!\", \"'\", \"(\", \")\", \"*\" do not get changed by `encodeURIComponent`,\n// so the possible encoded chars are:\n// ['%24', '%26', '%2B', '%2C', '%3B', '%3D', '%3A', '%40'].\nconst PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;\n\nexport function encodePathSegment(str: string) {\n  return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);\n}\n", "import { createMap } from \"./route-recognizer/util\";\nimport map, { Delegate, Route, Opaque, MatchCallback } from \"./route-recognizer/dsl\";\nimport { normalizePath, normalizeSegment, encodePathSegment } from \"./route-recognizer/normalizer\";\nexport { Delegate, MatchCallback } from './route-recognizer/dsl';\n\nconst enum CHARS {\n  ANY = -1,\n  STAR = 42,\n  SLASH = 47,\n  COLON = 58\n}\n\nconst escapeRegex = /(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\)/g;\n\nconst isArray = Array.isArray;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getParam(params: Params | null | undefined, key: string): string {\n  if (typeof params !== \"object\" || params === null) {\n    throw new Error(\"You must pass an object as the second argument to `generate`.\");\n  }\n\n  if (!hasOwnProperty.call(params, key)) {\n    throw new Error(\"You must provide param `\" + key + \"` to `generate`.\");\n  }\n\n  let value = params[key];\n  let str = typeof value === \"string\" ? value : \"\" + value;\n  if (str.length === 0) {\n    throw new Error(\"You must provide a param `\" + key + \"`.\");\n  }\n  return str;\n}\n\nconst enum SegmentType {\n  Static  = 0,\n  Dynamic = 1,\n  Star    = 2,\n  Epsilon = 4\n}\n\nconst enum SegmentFlags {\n  Static  = 2 << SegmentType.Static,\n  Dynamic = 2 << SegmentType.Dynamic,\n  Star    = 2 << SegmentType.Star,\n  Epsilon = 2 << SegmentType.Epsilon,\n  Named = Dynamic | Star,\n  Decoded = Dynamic,\n  Counted = Static | Dynamic | Star\n}\n\nconst eachChar: ((segment: Segment, currentState: State) => State)[] = [];\neachChar[SegmentType.Static] = function (segment: Segment, currentState: State) {\n  let state = currentState;\n  let value = segment.value;\n  for (let i = 0; i < value.length; i++) {\n    let ch = value.charCodeAt(i);\n    state = state.put(ch, false, false);\n  }\n  return state;\n};\neachChar[SegmentType.Dynamic] = function (_: Segment, currentState: State) {\n  return currentState.put(CHARS.SLASH, true, true);\n};\neachChar[SegmentType.Star] = function (_: Segment, currentState: State) {\n  return currentState.put(CHARS.ANY, false, true);\n};\neachChar[SegmentType.Epsilon] = function (_: Segment, currentState: State) {\n  return currentState;\n};\n\nconst regex: ((segment: Segment) => string)[] = [];\nregex[SegmentType.Static] = function (segment: Segment) {\n  return segment.value.replace(escapeRegex, \"\\\\$1\");\n};\nregex[SegmentType.Dynamic] = function () {\n  return \"([^/]+)\";\n};\nregex[SegmentType.Star] = function () {\n  return \"(.+)\";\n};\nregex[SegmentType.Epsilon] = function () {\n  return \"\";\n};\n\nconst generate: ((segment: Segment, params?: Params | null) => string)[] = [];\ngenerate[SegmentType.Static] = function (segment: Segment) {\n  return segment.value;\n};\ngenerate[SegmentType.Dynamic] = function (segment: Segment, params?: Params) {\n  let value = getParam(params, segment.value);\n  if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n    return encodePathSegment(value);\n  } else {\n    return value;\n  }\n};\ngenerate[SegmentType.Star] = function (segment: Segment, params?: Params) {\n  return getParam(params, segment.value);\n};\ngenerate[SegmentType.Epsilon] = function () {\n  return \"\";\n};\n\n// A Segment represents a segment in the original route description.\n// Each Segment type provides an `eachChar` and `regex` method.\n//\n// The `eachChar` method invokes the callback with one or more character\n// specifications. A character specification consumes one or more input\n// characters.\n//\n// The `regex` method returns a regex fragment for the segment. If the\n// segment is a dynamic of star segment, the regex fragment also includes\n// a capture.\n//\n// A character specification contains:\n//\n// * `validChars`: a String with a list of all valid characters, or\n// * `invalidChars`: a String with a list of all invalid characters\n// * `repeat`: true if the character specification can repeat\ninterface Segment {\n  type: SegmentType;\n  value: string;\n}\n\nexport interface Params {\n  [key: string]: Opaque;\n  [key: number]: Opaque;\n  queryParams?: QueryParams | null;\n}\n\ninterface PopulatedParsedHandlers {\n  names: string[];\n  shouldDecodes: any[];\n}\n\nconst EmptyObject = Object.freeze({});\ntype EmptyObject = Readonly<{}>\n\nconst EmptyArray = Object.freeze([]) as ReadonlyArray<any>;\ntype EmptyArray = ReadonlyArray<any>;\n\ninterface EmptyParsedHandlers {\n  names: EmptyArray;\n  shouldDecodes: EmptyArray;\n}\n\ntype ParsedHandler = PopulatedParsedHandlers | EmptyParsedHandlers;\n\n// The `names` will be populated with the paramter name for each dynamic/star\n// segment. `shouldDecodes` will be populated with a boolean for each dyanamic/star\n// segment, indicating whether it should be decoded during recognition.\nfunction parse(segments: Segment[], route: string, types: [number, number, number]) {\n  // normalize route as not starting with a \"/\". Recognition will\n  // also normalize.\n  if (route.length > 0 && route.charCodeAt(0) === CHARS.SLASH) { route = route.substr(1); }\n\n  let parts = route.split(\"/\");\n  let names: void | string[] = undefined;\n  let shouldDecodes: void | any[] = undefined;\n\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    let flags: SegmentFlags = 0;\n    let type: SegmentType = 0;\n\n    if (part === \"\") {\n      type = SegmentType.Epsilon;\n    } else if (part.charCodeAt(0) === CHARS.COLON) {\n      type = SegmentType.Dynamic;\n    } else if (part.charCodeAt(0) === CHARS.STAR) {\n      type = SegmentType.Star;\n    }  else {\n      type = SegmentType.Static;\n    }\n\n    flags = 2 << type;\n\n    if (flags & SegmentFlags.Named) {\n      part = part.slice(1);\n      names = names || [];\n      names.push(part);\n\n      shouldDecodes = shouldDecodes || [];\n      shouldDecodes.push((flags & SegmentFlags.Decoded) !== 0);\n    }\n\n    if (flags & SegmentFlags.Counted) {\n      types[type]++;\n    }\n\n    segments.push({\n      type,\n      value: normalizeSegment(part)\n    });\n  }\n\n  return {\n    names: names || EmptyArray,\n    shouldDecodes: shouldDecodes || EmptyArray,\n  } as ParsedHandler;\n}\n\nfunction isEqualCharSpec(spec: CharSpec, char: number, negate: boolean) {\n  return spec.char === char && spec.negate === negate;\n}\n\ninterface EmptyHandler {\n  handler: Opaque;\n  names: EmptyArray;\n  shouldDecodes: EmptyArray;\n}\n\ninterface PopulatedHandler {\n  handler: Opaque;\n  names: string [];\n  shouldDecodes: boolean[];\n}\n\ntype Handler = EmptyHandler | PopulatedHandler;\n\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\nclass State implements CharSpec {\n  states: State[];\n  id: number;\n  negate: boolean;\n  char: number;\n  nextStates: number[] | number | null;\n  pattern: string;\n  _regex: RegExp | undefined;\n  handlers: Handler[] | undefined;\n  types: [number, number, number] | undefined;\n\n  constructor(states: State[], id: number, char: number, negate: boolean, repeat: boolean) {\n    this.states = states;\n    this.id = id;\n    this.char = char;\n    this.negate = negate;\n    this.nextStates = repeat ? id : null;\n    this.pattern = \"\";\n    this._regex = undefined;\n    this.handlers = undefined;\n    this.types = undefined;\n  }\n\n  regex(): RegExp {\n    if (!this._regex) {\n      this._regex = new RegExp(this.pattern);\n    }\n    return this._regex;\n  }\n\n  get(char: number, negate: boolean): State | void {\n    let nextStates = this.nextStates;\n    if (nextStates === null) return;\n    if (isArray(nextStates)) {\n      for (let i = 0; i < nextStates.length; i++) {\n        let child = this.states[nextStates[i]];\n        if (isEqualCharSpec(child, char, negate)) {\n          return child;\n        }\n      }\n    } else {\n      let child = this.states[nextStates];\n      if (isEqualCharSpec(child, char, negate)) {\n        return child;\n      }\n    }\n  }\n\n  put(char: number, negate: boolean, repeat: boolean) {\n    let state: State | void;\n\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(char, negate)) { return state; }\n\n    // Make a new state for the character spec\n    let states = this.states;\n    state = new State(states, states.length, char, negate, repeat);\n    states[states.length] = state;\n\n    // Insert the new state as a child of the current state\n    if (this.nextStates == null) {\n      this.nextStates = state.id;\n    } else if (isArray(this.nextStates)) {\n      this.nextStates.push(state.id);\n    } else {\n      this.nextStates = [this.nextStates, state.id];\n    }\n\n    // Return the new state\n    return state;\n  }\n\n  // Find a list of child states matching the next character\n  match(ch: number): State[] {\n    let nextStates = this.nextStates;\n    if (!nextStates) return [];\n\n    let returned: State[] = [];\n    if (isArray(nextStates)) {\n      for (let i = 0; i < nextStates.length; i++) {\n        let child = this.states[nextStates[i]];\n\n        if (isMatch(child, ch)) {\n          returned.push(child);\n        }\n      }\n    } else {\n      let child = this.states[nextStates];\n      if (isMatch(child, ch)) {\n        returned.push(child);\n      }\n    }\n    return returned;\n  }\n}\n\nfunction isMatch(spec: CharSpec, char: number) {\n  return spec.negate ? spec.char !== char && spec.char !== CHARS.ANY : spec.char === char || spec.char === CHARS.ANY;\n}\n\n// This is a somewhat naive strategy, but should work in a lot of cases\n// A better strategy would properly resolve /posts/:id/new and /posts/edit/:id.\n//\n// This strategy generally prefers more static and less dynamic matching.\n// Specifically, it\n//\n//  * prefers fewer stars to more, then\n//  * prefers using stars for less of the match to more, then\n//  * prefers fewer dynamic segments to more, then\n//  * prefers more static segments to more\nfunction sortSolutions(states: State[]) {\n  return states.sort(function(a, b) {\n    let [ astatics, adynamics, astars ] = a.types || [0, 0, 0];\n    let [ bstatics, bdynamics, bstars ] = b.types || [0, 0, 0];\n    if (astars !== bstars) { return astars - bstars; }\n\n    if (astars) {\n      if (astatics !== bstatics) { return bstatics - astatics; }\n      if (adynamics !== bdynamics) { return bdynamics - adynamics; }\n    }\n\n    if (adynamics !== bdynamics) { return adynamics - bdynamics; }\n    if (astatics !== bstatics) { return bstatics - astatics; }\n\n    return 0;\n  });\n}\n\nfunction recognizeChar(states: State[], ch: number) {\n  let nextStates: State[] = [];\n\n  for (let i = 0, l = states.length; i < l; i++) {\n    let state = states[i];\n\n    nextStates = nextStates.concat(state.match(ch));\n  }\n\n  return nextStates;\n}\n\n\nexport interface QueryParams {\n  [param: string]: any[] | any | null | undefined;\n}\n\nexport interface Result {\n  handler: Opaque;\n  params: Params;\n  isDynamic: boolean;\n}\n\nexport interface Results extends ArrayLike<Result | undefined> {\n  queryParams: QueryParams;\n  slice(start?: number, end?: number): Result[];\n  splice(start: number, deleteCount: number, ...items: Result[]): Result[];\n  push(...results: Result[]): number;\n}\n\nclass RecognizeResults implements Results {\n  queryParams: QueryParams;\n  length = 0;\n  [index: number]: Result | undefined;\n  splice: (start: number, deleteCount: number, ...items: Result[]) => Result[];\n  slice: (start?: number, end?: number) => Result[];\n  push: (...results: Result[]) => number;\n\n  constructor(queryParams?: QueryParams) {\n    this.queryParams = queryParams || {};\n  }\n};\n\nRecognizeResults.prototype.splice = Array.prototype.splice;\nRecognizeResults.prototype.slice =  Array.prototype.slice;\nRecognizeResults.prototype.push = Array.prototype.push;\n\nfunction findHandler(state: State, originalPath: string, queryParams: QueryParams): Results {\n  let handlers = state.handlers;\n  let regex: RegExp = state.regex();\n  if (!regex || !handlers) throw new Error(\"state not initialized\");\n  let captures: RegExpMatchArray | null = originalPath.match(regex);\n  let currentCapture = 1;\n  let result = new RecognizeResults(queryParams);\n\n  result.length = handlers.length;\n\n  for (let i = 0; i < handlers.length; i++) {\n    let handler = handlers[i];\n    let names = handler.names;\n    let shouldDecodes = handler.shouldDecodes;\n    let params: EmptyObject | Params = EmptyObject;\n\n    let isDynamic = false;\n\n    if (names !== EmptyArray && shouldDecodes !== EmptyArray) {\n      for (let j = 0; j < names.length; j++) {\n        isDynamic = true;\n        let name = names[j];\n        let capture = captures && captures[currentCapture++];\n\n        if (params === EmptyObject) {\n          params = {};\n        }\n\n        if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {\n          (<Params>params)[name] = capture && decodeURIComponent(capture);\n        } else {\n          (<Params>params)[name] = capture;\n        }\n      }\n    }\n\n    result[i] = {\n      handler: handler.handler,\n      params,\n      isDynamic\n    };\n  }\n\n  return result;\n}\n\nfunction decodeQueryParamPart(part: string): string {\n  // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n  part = part.replace(/\\+/gm, \"%20\");\n  let result;\n  try {\n    result = decodeURIComponent(part);\n  } catch (error) {result = \"\"; }\n  return result;\n}\n\ninterface NamedRoute {\n  segments: Segment[];\n  handlers: Handler[];\n}\n\nclass RouteRecognizer {\n  private states: State[];\n  private rootState: State;\n  private names: {\n    [name: string]: NamedRoute | undefined;\n  } = createMap<NamedRoute>();\n  map: (context: MatchCallback, addCallback?: (router: this, routes: Route[]) => void) => void;\n  delegate: Delegate | undefined;\n\n  constructor() {\n    let states: State[] = [];\n    let state = new State(states, 0, CHARS.ANY, true, false);\n    states[0] = state;\n    this.states = states;\n    this.rootState = state;\n  }\n\n  static VERSION = \"0.3.4\";\n  // Set to false to opt-out of encoding and decoding path segments.\n  // See https://github.com/tildeio/route-recognizer/pull/55\n  static ENCODE_AND_DECODE_PATH_SEGMENTS = true;\n  static Normalizer = {\n    normalizeSegment, normalizePath, encodePathSegment\n  };\n\n  add(routes: Route[], options?: { as: string }) {\n    let currentState = this.rootState;\n    let pattern = \"^\";\n    let types: [number, number, number] = [0, 0, 0];\n    let handlers: Handler[] = new Array(routes.length);\n    let allSegments: Segment[] = [];\n\n    let isEmpty = true;\n    let j = 0;\n    for (let i = 0; i < routes.length; i++) {\n      let route = routes[i];\n      let { names, shouldDecodes } = parse(allSegments, route.path, types);\n\n      // preserve j so it points to the start of newly added segments\n      for (; j < allSegments.length; j++) {\n        let segment = allSegments[j];\n\n        if (segment.type === SegmentType.Epsilon) { continue; }\n\n        isEmpty = false;\n\n        // Add a \"/\" for the new segment\n        currentState = currentState.put(CHARS.SLASH, false, false);\n        pattern += \"/\";\n\n        // Add a representation of the segment to the NFA and regex\n        currentState = eachChar[segment.type](segment, currentState);\n        pattern += regex[segment.type](segment);\n      }\n      handlers[i] = {\n        handler: route.handler,\n        names,\n        shouldDecodes\n      };\n    }\n\n    if (isEmpty) {\n        currentState = currentState.put(CHARS.SLASH, false, false);\n      pattern += \"/\";\n    }\n\n    currentState.handlers = handlers;\n    currentState.pattern = pattern + \"$\";\n    currentState.types = types;\n\n    let name: string | undefined;\n    if (typeof options === \"object\" && options !== null && options.as) {\n      name = options.as;\n    }\n\n    if (name) {\n      // if (this.names[name]) {\n      //   throw new Error(\"You may not add a duplicate route named `\" + name + \"`.\");\n      // }\n\n      this.names[name] = {\n        segments: allSegments,\n        handlers\n      };\n    }\n  }\n\n  handlersFor(name: string) {\n    let route = this.names[name];\n\n    if (!route) { throw new Error(\"There is no route named \" + name); }\n\n    let result = new Array(route.handlers.length);\n\n    for (let i = 0; i < route.handlers.length; i++) {\n      let handler = route.handlers[i];\n      result[i] = handler;\n    }\n\n    return result;\n  }\n\n  hasRoute(name: string) {\n    return !!this.names[name];\n  }\n\n  generate(name: string, params?: Params | null) {\n    let route = this.names[name];\n    let output = \"\";\n    if (!route) { throw new Error(\"There is no route named \" + name); }\n\n    let segments: Segment[] = route.segments;\n\n    for (let i = 0; i < segments.length; i++) {\n      let segment: Segment = segments[i];\n\n      if (segment.type === SegmentType.Epsilon) {\n        continue;\n      }\n\n      output += \"/\";\n      output += generate[segment.type](segment, params);\n    }\n\n    if (output.charAt(0) !== \"/\") { output = \"/\" + output; }\n\n    if (params && params.queryParams) {\n      output += this.generateQueryString(params.queryParams);\n    }\n\n    return output;\n  }\n\n  generateQueryString(params: QueryParams) {\n    let pairs: string[] = [];\n    let keys: string[] = Object.keys(params);\n    keys.sort();\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let value = params[key];\n      if (value == null) {\n        continue;\n      }\n      let pair = encodeURIComponent(key);\n      if (isArray(value)) {\n        for (let j = 0; j < value.length; j++) {\n          let arrayPair = key + \"[]\" + \"=\" + encodeURIComponent(value[j]);\n          pairs.push(arrayPair);\n        }\n      } else {\n        pair += \"=\" + encodeURIComponent(value);\n        pairs.push(pair);\n      }\n    }\n\n    if (pairs.length === 0) { return \"\"; }\n\n    return \"?\" + pairs.join(\"&\");\n  }\n\n  parseQueryString(queryString: string): QueryParams {\n    let pairs = queryString.split(\"&\");\n    let queryParams: QueryParams = {};\n    for (let i = 0; i < pairs.length; i++) {\n      let pair      = pairs[i].split(\"=\"),\n          key       = decodeQueryParamPart(pair[0]),\n          keyLength = key.length,\n          isArray = false,\n          value;\n      if (pair.length === 1) {\n        value = \"true\";\n      } else {\n        // Handle arrays\n        if (keyLength > 2 && key.slice(keyLength - 2) === \"[]\") {\n          isArray = true;\n          key = key.slice(0, keyLength - 2);\n          if (!queryParams[key]) {\n            queryParams[key] = [];\n          }\n        }\n        value = pair[1] ? decodeQueryParamPart(pair[1]) : \"\";\n      }\n      if (isArray) {\n        (<string[]>queryParams[key]).push(value);\n      } else {\n        queryParams[key] = value;\n      }\n    }\n    return queryParams;\n  }\n\n  recognize(path: string): Results | undefined {\n    let results: Results | undefined;\n    let states: State[] = [ this.rootState ];\n    let queryParams = {};\n    let isSlashDropped = false;\n    let hashStart = path.indexOf(\"#\");\n    if (hashStart !== -1) {\n      path = path.substr(0, hashStart);\n    }\n\n    let queryStart = path.indexOf(\"?\");\n    if (queryStart !== -1) {\n      let queryString = path.substr(queryStart + 1, path.length);\n      path = path.substr(0, queryStart);\n      queryParams = this.parseQueryString(queryString);\n    }\n\n    if (path.charAt(0) !== \"/\") { path = \"/\" + path; }\n    let originalPath = path;\n\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n      path = normalizePath(path);\n    } else {\n      path = decodeURI(path);\n      originalPath = decodeURI(originalPath);\n    }\n\n    let pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n      path = path.substr(0, pathLen - 1);\n      originalPath = originalPath.substr(0, originalPath.length - 1);\n      isSlashDropped = true;\n    }\n\n    for (let i = 0; i < path.length; i++) {\n      states = recognizeChar(states, path.charCodeAt(i));\n      if (!states.length) { break; }\n    }\n\n    let solutions: State[] = [];\n    for (let i = 0; i < states.length; i++) {\n      if (states[i].handlers) { solutions.push(states[i]); }\n    }\n\n    states = sortSolutions(solutions);\n\n    let state = solutions[0];\n\n    if (state && state.handlers) {\n      // if a trailing slash was dropped and a star segment is the last segment\n      // specified, put the trailing slash back\n      if (isSlashDropped && state.pattern && state.pattern.slice(-5) === \"(.+)$\") {\n        originalPath = originalPath + \"/\";\n      }\n      results = findHandler(state, originalPath, queryParams);\n    }\n\n    return results;\n  }\n}\n\nRouteRecognizer.prototype.map = map;\n\nexport default RouteRecognizer;\n\ninterface CharSpec {\n  negate: boolean;\n  char: number;\n}\n", "function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };", "import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n", "/**\n * WordPress dependencies\n */\nimport { useContext, useMemo } from '@wordpress/element';\nimport { getQueryArgs, getPath, buildQueryString } from '@wordpress/url';\n\n/**\n * Internal dependencies\n */\nimport { ConfigContext, type NavigationOptions, useHistory } from './router';\n\nexport function useLink( to: string, options: NavigationOptions = {} ) {\n\tconst history = useHistory();\n\tconst { pathArg, beforeNavigate } = useContext( ConfigContext );\n\tfunction onClick( event: React.SyntheticEvent< HTMLAnchorElement > ) {\n\t\tevent?.preventDefault();\n\t\thistory.navigate( to, options );\n\t}\n\tconst query = getQueryArgs( to );\n\tconst path = getPath( 'http://domain.com/' + to ) ?? '';\n\tconst link = useMemo( () => {\n\t\treturn beforeNavigate\n\t\t\t? beforeNavigate( { path, query } )\n\t\t\t: { path, query };\n\t}, [ path, query, beforeNavigate ] );\n\n\tconst [ before ] = window.location.href.split( '?' );\n\n\treturn {\n\t\thref: `${ before }?${ buildQueryString( {\n\t\t\t[ pathArg ]: link.path,\n\t\t\t...link.query,\n\t\t} ) }`,\n\t\tonClick,\n\t};\n}\n\nexport function Link( {\n\tto,\n\toptions,\n\tchildren,\n\t...props\n}: {\n\tto: string;\n\toptions?: NavigationOptions;\n\tchildren: React.ReactNode;\n} ) {\n\tconst { href, onClick } = useLink( to, options );\n\n\treturn (\n\t\t<a href={ href } onClick={ onClick } { ...props }>\n\t\t\t{ children }\n\t\t</a>\n\t);\n}\n", "/**\n * WordPress dependencies\n */\nimport { __dangerousOptInToUnstableAPIsOnlyForCoreModules } from '@wordpress/private-apis';\n\nexport const { lock, unlock } =\n\t__dangerousOptInToUnstableAPIsOnlyForCoreModules(\n\t\t'I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.',\n\t\t'@wordpress/router'\n\t);\n", "/**\n * Internal dependencies\n */\nimport { useHistory, useLocation, RouterProvider } from './router';\nimport { useLink, Link } from './link';\nimport { lock } from './lock-unlock';\n\nexport const privateApis = {};\nlock( privateApis, {\n\tuseHistory,\n\tuseLocation,\n\tRouterProvider,\n\tuseLink,\n\tLink,\n} );\n"],
  "mappings": "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",
  "names": ["require_jsx_runtime", "__commonJSMin", "exports", "module", "require_element", "__commonJSMin", "exports", "module", "require_url", "__commonJSMin", "exports", "module", "require_compose", "__commonJSMin", "exports", "module", "require_private_apis", "__commonJSMin", "exports", "module", "index_exports", "__export", "privateApis", "import_jsx_runtime", "const", "createObject", "createMap", "map", "Target", "path", "matcher", "delegate", "target", "callback", "Matcher", "match", "generateMatch", "startingPath", "let", "fullPath", "addRoute", "routeArray", "handler", "len", "i", "route", "eachRoute", "baseRoute", "binding", "routes", "paths", "nested", "addRouteCallback", "normalizePath", "normalizeSegment", "SEGMENT_RESERVED_CHARS", "segment", "PATH_SEGMENT_ENCODINGS", "encodePathSegment", "str", "escapeRegex", "isArray", "hasOwnProperty", "getParam", "params", "key", "value", "eachChar", "currentState", "state", "ch", "_", "regex", "generate", "RouteRecognizer", "EmptyObject", "EmptyArray", "parse", "segments", "types", "parts", "names", "shouldDecodes", "part", "flags", "type", "isEqualCharSpec", "spec", "char", "negate", "State", "states", "id", "repeat", "nextStates", "child", "this", "returned", "isMatch", "sortSolutions", "a", "b", "ref", "astatics", "adynamics", "astars", "ref$1", "bstatics", "bdynamics", "bstars", "recognizeChar", "l", "RecognizeResults", "queryParams", "findHandler", "originalPath", "handlers", "captures", "currentCapture", "result", "isDynamic", "j", "name", "capture", "decodeQueryParamPart", "options", "pattern", "allSegments", "isEmpty", "output", "pairs", "keys", "pair", "arrayPair", "queryString", "keyLength", "results", "isSlashDropped", "hashStart", "queryStart", "pathLen", "solutions", "_extends", "n", "e", "t", "r", "Action", "readOnly", "obj", "BeforeUnloadEventType", "PopStateEventType", "createBrowserHistory", "options", "_options", "_options$window", "window", "globalHistory", "getIndexAndLocation", "_window$location", "pathname", "search", "hash", "state", "readOnly", "blockedPopTx", "handlePop", "blockers", "nextAction", "Action", "_getIndexAndLocation", "nextIndex", "nextLocation", "delta", "index", "go", "applyTx", "action", "_getIndexAndLocation2", "location", "listeners", "createEvents", "_extends", "createHref", "to", "createPath", "getNextLocation", "parsePath", "createKey", "getHistoryStateAndUrl", "allowTx", "retry", "_getIndexAndLocation3", "push", "_getHistoryStateAndUr", "historyState", "url", "replace", "_getHistoryStateAndUr2", "history", "listener", "blocker", "unblock", "BeforeUnloadEventType", "promptBeforeUnload", "promptBeforeUnload", "event", "createEvents", "handlers", "fn", "handler", "arg", "createKey", "createPath", "_ref", "_ref$pathname", "pathname", "_ref$search", "search", "_ref$hash", "hash", "parsePath", "path", "parsedPath", "hashIndex", "searchIndex", "import_element", "import_url", "import_compose", "history", "createBrowserHistory", "RoutesContext", "ConfigContext", "locationMemo", "getLocationWithQuery", "location", "locationWithQuery", "useLocation", "context", "useHistory", "pathArg", "beforeNavigate", "navigate", "rawPath", "options", "query", "path", "performPush", "result", "resolve", "classname", "useMatch", "matcher", "matchResolverArgs", "rawQuery", "resolvedMatch", "setMatch", "ret", "resolveMatch", "matchedRoute", "resolveFunctions", "record", "entries", "key", "value", "resolvedAreas", "resolvedWidths", "RouterProvider", "routes", "children", "route_recognizer_es_default", "route", "match", "previousMatch", "config", "renderedMatch", "import_jsx_runtime", "import_element", "import_url", "useLink", "to", "options", "history", "useHistory", "pathArg", "beforeNavigate", "ConfigContext", "onClick", "event", "query", "path", "link", "before", "Link", "children", "props", "href", "import_private_apis", "lock", "unlock", "privateApis", "lock", "useHistory", "useLocation", "RouterProvider", "useLink", "Link"]
}
