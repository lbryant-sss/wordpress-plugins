var Ne=Object.defineProperty,Me=Object.defineProperties;var Ue=Object.getOwnPropertyDescriptors;var Se=Object.getOwnPropertySymbols;var Pe=Object.prototype.hasOwnProperty,qe=Object.prototype.propertyIsEnumerable;var Ee=(e,n,t)=>n in e?Ne(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,q=(e,n)=>{for(var t in n||(n={}))Pe.call(n,t)&&Ee(e,t,n[t]);if(Se)for(var t of Se(n))qe.call(n,t)&&Ee(e,t,n[t]);return e},X=(e,n)=>Me(e,Ue(n));var Re=(e,n,t)=>new Promise((r,a)=>{var u=d=>{try{S(t.next(d))}catch(w){a(w)}},l=d=>{try{S(t.throw(d))}catch(w){a(w)}},S=d=>d.done?r(d.value):Promise.resolve(d.value).then(u,l);S((t=t.apply(e,n)).next())});import{r as v,bb as we,cp as ne,cq as $e,cr as pe,cs as De,ct as je,cu as o,cv as He,cw as _e,cx as ze,cy as Ge,cz as Be,cA as Y,cB as Ke,cC as Je,cD as he,cE as Xe,cF as Q,cG as ge,cH as Ye,cI as ve,cJ as Qe,cK as Ze,cL as et,c as tt,cM as nt}from"./main-9.js";var Ce={exports:{}},Te={};/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var y=v;function st(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var rt=typeof Object.is=="function"?Object.is:st,at=y.useState,it=y.useEffect,ct=y.useLayoutEffect,ot=y.useDebugValue;function ut(e,n){var t=n(),r=at({inst:{value:t,getSnapshot:n}}),a=r[0].inst,u=r[1];return ct(function(){a.value=t,a.getSnapshot=n,Z(a)&&u({inst:a})},[e,t,n]),it(function(){return Z(a)&&u({inst:a}),e(function(){Z(a)&&u({inst:a})})},[e]),ot(t),t}function Z(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!rt(e,t)}catch(r){return!0}}function lt(e,n){return n()}var ft=typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"?lt:ut;Te.useSyncExternalStore=y.useSyncExternalStore!==void 0?y.useSyncExternalStore:ft;Ce.exports=Te;var dt=Ce.exports;const St="$inf$",Ie=$e&&window.__SWR_DEVTOOLS_USE__,Et=Ie?window.__SWR_DEVTOOLS_USE__:[],Rt=()=>{Ie&&(window.__SWR_DEVTOOLS_REACT__=we)},Le=e=>ne(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],ht=()=>_e(Ge,v.useContext(ze)),gt=e=>(n,t,r)=>e(n,t&&((...u)=>{const[l]=pe(n),[,,,S]=De.get(je);if(l.startsWith(St))return t(...u);const d=S[l];return o(d)?t(...u):(delete S[l],d)}),r),vt=Et.concat(gt),mt=e=>function(...t){const r=ht(),[a,u,l]=Le(t),S=He(r,l);let d=e;const{use:w}=S,A=(w||[]).concat(vt);for(let b=A.length;b--;)d=A[b](d);return d(a,u||S.fetcher||null,S)},wt=(e,n,t)=>{const r=n[e]||(n[e]=[]);return r.push(t),()=>{const a=r.indexOf(t);a>=0&&(r[a]=r[r.length-1],r.pop())}},pt=(e,n)=>(...t)=>{const[r,a,u]=Le(t),l=(u.use||[]).concat(n);return e(r,a,X(q({},u),{use:l}))};Rt();const ee=we.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e}}),te={dedupe:!0},Dt=(e,n,t)=>{const{cache:r,compare:a,suspense:u,fallbackData:l,revalidateOnMount:S,revalidateIfStale:d,refreshInterval:w,refreshWhenHidden:A,refreshWhenOffline:b,keepPreviousData:Oe}=t,[W,Ve,C,ye]=De.get(r),[s,se]=pe(e),$=v.useRef(!1),k=v.useRef(!1),N=v.useRef(s),j=v.useRef(n),H=v.useRef(t),E=()=>H.current,z=()=>E().isVisible()&&E().isOnline(),[T,G,Ae,be]=Be(r,s),x=v.useRef({}).current,M=o(l)?o(t.fallback)?Y:t.fallback[s]:l,re=(i,c)=>{for(const h in x){const f=h;if(f==="data"){if(!a(i[f],c[f])&&(!o(i[f])||!a(P,c[f])))return!1}else if(c[f]!==i[f])return!1}return!0},ae=v.useMemo(()=>{const i=(()=>!s||!n?!1:o(S)?E().isPaused()||u?!1:d!==!1:S)(),c=g=>{const D=_e(g);return delete D._k,i?q({isValidating:!0,isLoading:!0},D):D},h=T(),f=be(),p=c(h),V=h===f?p:c(f);let R=p;return[()=>{const g=c(T());return re(g,R)?(R.data=g.data,R.isLoading=g.isLoading,R.isValidating=g.isValidating,R.error=g.error,R):(R=g,g)},()=>V]},[r,s]),L=dt.useSyncExternalStore(v.useCallback(i=>Ae(s,(c,h)=>{re(h,c)||i()}),[r,s]),ae[0],ae[1]),ie=!$.current,ke=W[s]&&W[s].length>0,O=L.data,I=o(O)?M&&Ke(M)?ee(M):M:O,U=L.error,B=v.useRef(I),P=Oe?o(O)?o(B.current)?I:B.current:O:I,ce=(()=>ke&&!o(U)?!1:ie&&!o(S)?S:E().isPaused()?!1:u?o(I)?!1:d:o(I)||d)(),oe=!!(s&&n&&ie&&ce),xe=o(L.isValidating)?oe:L.isValidating,Fe=o(L.isLoading)?oe:L.isLoading,F=v.useCallback(i=>Re(void 0,null,function*(){const c=j.current;if(!s||!c||k.current||E().isPaused())return!1;let h,f,p=!0;const V=i||{},R=!C[s]||!V.dedupe,g=()=>ve?!k.current&&s===N.current&&$.current:s===N.current,D={isValidating:!1,isLoading:!1},le=()=>{G(D)},fe=()=>{const m=C[s];m&&m[1]===f&&delete C[s]},de={isValidating:!0};o(T().data)&&(de.isLoading=!0);try{if(R&&(G(de),t.loadingTimeout&&o(T().data)&&setTimeout(()=>{p&&g()&&E().onLoadingSlow(s,t)},t.loadingTimeout),C[s]=[c(se),Je()]),[h,f]=C[s],h=yield h,R&&setTimeout(fe,t.dedupingInterval),!C[s]||C[s][1]!==f)return R&&g()&&E().onDiscarded(s),!1;D.error=Y;const m=Ve[s];if(!o(m)&&(f<=m[0]||f<=m[1]||m[1]===0))return le(),R&&g()&&E().onDiscarded(s),!1;const _=T().data;D.data=a(_,h)?_:h,R&&g()&&E().onSuccess(h,s,t)}catch(m){fe();const _=E(),{shouldRetryOnError:K}=_;_.isPaused()||(D.error=m,R&&g()&&(_.onError(m,s,_),(K===!0||ne(K)&&K(m))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||z())&&_.onErrorRetry(m,s,_,We=>{const J=W[s];J&&J[0]&&J[0](he,We)},{retryCount:(V.retryCount||0)+1,dedupe:!0})))}return p=!1,le(),!0}),[s,r]),ue=v.useCallback((...i)=>Xe(r,N.current,...i),[]);if(Q(()=>{j.current=n,H.current=t,o(O)||(B.current=O)}),Q(()=>{if(!s)return;const i=F.bind(Y,te);let c=0;const f=wt(s,W,(p,V={})=>{if(p==Qe){const R=Date.now();E().revalidateOnFocus&&R>c&&z()&&(c=R+E().focusThrottleInterval,i())}else if(p==Ze)E().revalidateOnReconnect&&z()&&i();else{if(p==et)return F();if(p==he)return F(V)}});return k.current=!1,N.current=s,$.current=!0,G({_k:se}),ce&&(o(I)||ge?i():Ye(i)),()=>{k.current=!0,f()}},[s]),Q(()=>{let i;function c(){const f=ne(w)?w(T().data):w;f&&i!==-1&&(i=setTimeout(h,f))}function h(){!T().error&&(A||E().isVisible())&&(b||E().isOnline())?F(te).then(c):c()}return c(),()=>{i&&(clearTimeout(i),i=-1)}},[w,A,b,s]),v.useDebugValue(P),u&&o(I)&&s){if(!ve&&ge)throw new Error("Fallback data is required when using Suspense in SSR.");j.current=n,H.current=t,k.current=!1;const i=ye[s];if(!o(i)){const c=ue(i);ee(c)}if(o(U)){const c=F(te);o(P)||(c.status="fulfilled",c.value=!0),ee(c)}else throw U}return{mutate:ue,get data(){return x.data=!0,P},get error(){return x.error=!0,U},get isValidating(){return x.isValidating=!0,xe},get isLoading(){return x.isLoading=!0,Fe}}},_t=mt(Dt),Ct=e=>(n,t,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(n,t,r)),Tt=pt(_t,Ct),me=e=>{var n;return(e==null?void 0:e.success)&&!((n=e==null?void 0:e.data)!=null&&n.errors)&&!nt(e.data)},Vt=(e,n,t={})=>{const a=("fetchCondition"in t?t.fetchCondition:!0)?e:null,u=Tt(a,l=>{const S=tt(n,Array.isArray(l)?l[0]:l);return t.onLoading&&u.isLoading&&t.onLoading(),S},X(q({},t),{onSuccess:l=>t.onSuccess&&me(l)&&t.onSuccess(l.data)}));return v.useEffect(()=>{if(!me(u.data))return;const{data:l}=u.data;t.onMount?t.onMount(l):t.onSuccess&&t.onSuccess(l)},[]),u};export{Vt as u};
