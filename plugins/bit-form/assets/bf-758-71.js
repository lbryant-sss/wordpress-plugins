var Ne=Object.defineProperty,Me=Object.defineProperties;var Ue=Object.getOwnPropertyDescriptors;var Ee=Object.getOwnPropertySymbols;var Pe=Object.prototype.hasOwnProperty,qe=Object.prototype.propertyIsEnumerable;var Re=(e,n,t)=>n in e?Ne(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,$=(e,n)=>{for(var t in n||(n={}))Pe.call(n,t)&&Re(e,t,n[t]);if(Ee)for(var t of Ee(n))qe.call(n,t)&&Re(e,t,n[t]);return e},X=(e,n)=>Me(e,Ue(n));var he=(e,n,t)=>new Promise((r,a)=>{var o=d=>{try{S(t.next(d))}catch(D){a(D)}},u=d=>{try{S(t.throw(d))}catch(D){a(D)}},S=d=>d.done?r(d.value):Promise.resolve(d.value).then(o,u);S((t=t.apply(e,n)).next())});import{r as v,bb as De,cp as ne,cq as $e,cr as we,cs as _e,ct as je,cu as l,cv as He,cw as pe,cx as ze,cy as Ge,cz as Be,cA as Y,cB as Je,cC as Ke,cD as W,cE as Xe,cF as Q,cG as ge,cH as Ye,cI as ve,c as Qe,cJ as Ze}from"./main-143.js";var Ce={exports:{}},Te={};/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var y=v;function et(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var tt=typeof Object.is=="function"?Object.is:et,nt=y.useState,st=y.useEffect,rt=y.useLayoutEffect,at=y.useDebugValue;function it(e,n){var t=n(),r=nt({inst:{value:t,getSnapshot:n}}),a=r[0].inst,o=r[1];return rt(function(){a.value=t,a.getSnapshot=n,Z(a)&&o({inst:a})},[e,t,n]),st(function(){return Z(a)&&o({inst:a}),e(function(){Z(a)&&o({inst:a})})},[e]),at(t),t}function Z(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!tt(e,t)}catch(r){return!0}}function ct(e,n){return n()}var ot=typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"?ct:it;Te.useSyncExternalStore=y.useSyncExternalStore!==void 0?y.useSyncExternalStore:ot;Ce.exports=Te;var ut=Ce.exports;const lt="$inf$",Ie=$e&&window.__SWR_DEVTOOLS_USE__,ft=Ie?window.__SWR_DEVTOOLS_USE__:[],dt=()=>{Ie&&(window.__SWR_DEVTOOLS_REACT__=De)},Oe=e=>ne(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],St=()=>pe(Ge,v.useContext(ze)),Et=e=>(n,t,r)=>e(n,t&&((...o)=>{const[u]=we(n),[,,,S]=_e.get(je);if(u.startsWith(lt))return t(...o);const d=S[u];return l(d)?t(...o):(delete S[u],d)}),r),Rt=ft.concat(Et),ht=e=>function(...t){const r=St(),[a,o,u]=Oe(t),S=He(r,u);let d=e;const{use:D}=S,A=(D||[]).concat(Rt);for(let b=A.length;b--;)d=A[b](d);return d(a,o||S.fetcher||null,S)},gt=(e,n,t)=>{const r=n[e]||(n[e]=[]);return r.push(t),()=>{const a=r.indexOf(t);a>=0&&(r[a]=r[r.length-1],r.pop())}},vt=(e,n)=>(...t)=>{const[r,a,o]=Oe(t),u=(o.use||[]).concat(n);return e(r,a,X($({},o),{use:u}))};dt();const ee=De.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e}}),te={dedupe:!0},mt=(e,n,t)=>{const{cache:r,compare:a,suspense:o,fallbackData:u,revalidateOnMount:S,revalidateIfStale:d,refreshInterval:D,refreshWhenHidden:A,refreshWhenOffline:b,keepPreviousData:Ve}=t,[N,Le,C,ye]=_e.get(r),[s,se]=we(e),j=v.useRef(!1),k=v.useRef(!1),M=v.useRef(s),H=v.useRef(n),z=v.useRef(t),E=()=>z.current,G=()=>E().isVisible()&&E().isOnline(),[T,B,Ae,be]=Be(r,s),x=v.useRef({}).current,U=l(u)?l(t.fallback)?Y:t.fallback[s]:u,re=(i,c)=>{for(const h in x){const f=h;if(f==="data"){if(!a(i[f],c[f])&&(!l(i[f])||!a(q,c[f])))return!1}else if(c[f]!==i[f])return!1}return!0},ae=v.useMemo(()=>{const i=(()=>!s||!n?!1:l(S)?E().isPaused()||o?!1:d!==!1:S)(),c=g=>{const _=pe(g);return delete _._k,i?$({isValidating:!0,isLoading:!0},_):_},h=T(),f=be(),w=c(h),L=h===f?w:c(f);let R=w;return[()=>{const g=c(T());return re(g,R)?(R.data=g.data,R.isLoading=g.isLoading,R.isValidating=g.isValidating,R.error=g.error,R):(R=g,g)},()=>L]},[r,s]),I=ut.useSyncExternalStore(v.useCallback(i=>Ae(s,(c,h)=>{re(h,c)||i()}),[r,s]),ae[0],ae[1]),ie=!j.current,ke=N[s]&&N[s].length>0,O=I.data,V=l(O)?U&&Je(U)?ee(U):U:O,P=I.error,ce=v.useRef(V),q=Ve?l(O)?ce.current:O:V,oe=(()=>ke&&!l(P)?!1:ie&&!l(S)?S:E().isPaused()?!1:o?l(V)?!1:d:l(V)||d)(),ue=!!(s&&n&&ie&&oe),xe=l(I.isValidating)?ue:I.isValidating,Fe=l(I.isLoading)?ue:I.isLoading,F=v.useCallback(i=>he(void 0,null,function*(){const c=H.current;if(!s||!c||k.current||E().isPaused())return!1;let h,f,w=!0;const L=i||{},R=!C[s]||!L.dedupe,g=()=>ve?!k.current&&s===M.current&&j.current:s===M.current,_={isValidating:!1,isLoading:!1},fe=()=>{B(_)},de=()=>{const m=C[s];m&&m[1]===f&&delete C[s]},Se={isValidating:!0};l(T().data)&&(Se.isLoading=!0);try{if(R&&(B(Se),t.loadingTimeout&&l(T().data)&&setTimeout(()=>{w&&g()&&E().onLoadingSlow(s,t)},t.loadingTimeout),C[s]=[c(se),Ke()]),[h,f]=C[s],h=yield h,R&&setTimeout(de,t.dedupingInterval),!C[s]||C[s][1]!==f)return R&&g()&&E().onDiscarded(s),!1;_.error=Y;const m=Le[s];if(!l(m)&&(f<=m[0]||f<=m[1]||m[1]===0))return fe(),R&&g()&&E().onDiscarded(s),!1;const p=T().data;_.data=a(p,h)?p:h,R&&g()&&E().onSuccess(h,s,t)}catch(m){de();const p=E(),{shouldRetryOnError:J}=p;p.isPaused()||(_.error=m,R&&g()&&(p.onError(m,s,p),(J===!0||ne(J)&&J(m))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||G())&&p.onErrorRetry(m,s,p,We=>{const K=N[s];K&&K[0]&&K[0](W.ERROR_REVALIDATE_EVENT,We)},{retryCount:(L.retryCount||0)+1,dedupe:!0})))}return w=!1,fe(),!0}),[s,r]),le=v.useCallback((...i)=>Xe(r,M.current,...i),[]);if(Q(()=>{H.current=n,z.current=t,l(O)||(ce.current=O)}),Q(()=>{if(!s)return;const i=F.bind(Y,te);let c=0;const f=gt(s,N,(w,L={})=>{if(w==W.FOCUS_EVENT){const R=Date.now();E().revalidateOnFocus&&R>c&&G()&&(c=R+E().focusThrottleInterval,i())}else if(w==W.RECONNECT_EVENT)E().revalidateOnReconnect&&G()&&i();else{if(w==W.MUTATE_EVENT)return F();if(w==W.ERROR_REVALIDATE_EVENT)return F(L)}});return k.current=!1,M.current=s,j.current=!0,B({_k:se}),oe&&(l(V)||ge?i():Ye(i)),()=>{k.current=!0,f()}},[s]),Q(()=>{let i;function c(){const f=ne(D)?D(T().data):D;f&&i!==-1&&(i=setTimeout(h,f))}function h(){!T().error&&(A||E().isVisible())&&(b||E().isOnline())?F(te).then(c):c()}return c(),()=>{i&&(clearTimeout(i),i=-1)}},[D,A,b,s]),v.useDebugValue(q),o&&l(V)&&s){if(!ve&&ge)throw new Error("Fallback data is required when using Suspense in SSR.");H.current=n,z.current=t,k.current=!1;const i=ye[s];if(!l(i)){const c=le(i);ee(c)}if(l(P)){const c=F(te);l(q)||(c.status="fulfilled",c.value=!0),ee(c)}else throw P}return{mutate:le,get data(){return x.data=!0,q},get error(){return x.error=!0,P},get isValidating(){return x.isValidating=!0,xe},get isLoading(){return x.isLoading=!0,Fe}}},Dt=ht(mt),wt=e=>(n,t,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(n,t,r)),_t=vt(Dt,wt),me=e=>{var n;return(e==null?void 0:e.success)&&!((n=e==null?void 0:e.data)!=null&&n.errors)&&!Ze(e.data)},Tt=(e,n,t={})=>{const a=("fetchCondition"in t?t.fetchCondition:!0)?e:null,o=_t(a,u=>{const S=Qe(n,Array.isArray(u)?u[0]:u);return t.onLoading&&o.isLoading&&t.onLoading(),S},X($({},t),{onSuccess:u=>t.onSuccess&&me(u)&&t.onSuccess(u.data)}));return v.useEffect(()=>{if(!me(o.data))return;const{data:u}=o.data;t.onMount?t.onMount(u):t.onSuccess&&t.onSuccess(u)},[]),o};export{Tt as u};
