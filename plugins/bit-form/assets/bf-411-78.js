var Ne=Object.defineProperty,Me=Object.defineProperties;var Ue=Object.getOwnPropertyDescriptors;var Se=Object.getOwnPropertySymbols;var Pe=Object.prototype.hasOwnProperty,qe=Object.prototype.propertyIsEnumerable;var Ee=(e,n,t)=>n in e?Ne(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,q=(e,n)=>{for(var t in n||(n={}))Pe.call(n,t)&&Ee(e,t,n[t]);if(Se)for(var t of Se(n))qe.call(n,t)&&Ee(e,t,n[t]);return e},B=(e,n)=>Me(e,Ue(n));var Re=(e,n,t)=>new Promise((r,i)=>{var c=S=>{try{E(t.next(S))}catch(b){i(b)}},l=S=>{try{E(t.throw(S))}catch(b){i(b)}},E=S=>S.done?r(S.value):Promise.resolve(S.value).then(c,l);E((t=t.apply(e,n)).next())});import{r as v,bE as we,bI as ne,bJ as $e,bK as be,bL as De,bM as je,bN as u,bO as He,bP as pe,bQ as ze,bR as Ge,bS as Ke,bT as J,bU as Xe,bV as Ye,bW as he,bX as Be,bY as Q,bZ as ge,b_ as Je,b$ as ve,c0 as Qe,c1 as Ze,c2 as et,c as tt,c3 as nt}from"./main-509.js";var _e={exports:{}},Te={};/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var V=v;function st(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var rt=typeof Object.is=="function"?Object.is:st,at=V.useState,it=V.useEffect,ot=V.useLayoutEffect,ut=V.useDebugValue;function ct(e,n){var t=n(),r=at({inst:{value:t,getSnapshot:n}}),i=r[0].inst,c=r[1];return ot(function(){i.value=t,i.getSnapshot=n,Z(i)&&c({inst:i})},[e,t,n]),it(function(){return Z(i)&&c({inst:i}),e(function(){Z(i)&&c({inst:i})})},[e]),ut(t),t}function Z(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!rt(e,t)}catch(r){return!0}}function lt(e,n){return n()}var ft=typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"?lt:ct;Te.useSyncExternalStore=V.useSyncExternalStore!==void 0?V.useSyncExternalStore:ft;_e.exports=Te;var dt=_e.exports;const St="$inf$",Ce=$e&&window.__SWR_DEVTOOLS_USE__,Et=Ce?window.__SWR_DEVTOOLS_USE__:[],Rt=()=>{Ce&&(window.__SWR_DEVTOOLS_REACT__=we)},Oe=e=>ne(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],ht=()=>pe(Ge,v.useContext(ze)),gt=e=>(n,t,r)=>e(n,t&&((...c)=>{const[l]=be(n),[,,,E]=De.get(je);if(l.startsWith(St))return t(...c);const S=E[l];return u(S)?t(...c):(delete E[l],S)}),r),vt=Et.concat(gt),mt=e=>function(...t){const r=ht(),[i,c,l]=Oe(t),E=He(r,l);let S=e;const{use:b}=E,y=(b||[]).concat(vt);for(let A=y.length;A--;)S=y[A](S);return S(i,c||E.fetcher||null,E)},wt=(e,n,t)=>{const r=n[e]||(n[e]=[]);return r.push(t),()=>{const i=r.indexOf(t);i>=0&&(r[i]=r[r.length-1],r.pop())}},bt=(e,n)=>(...t)=>{const[r,i,c]=Oe(t),l=(c.use||[]).concat(n);return e(r,i,B(q({},c),{use:l}))};Rt();const ee=we.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e}}),te={dedupe:!0},Dt=(e,n,t)=>{const{cache:r,compare:i,suspense:c,fallbackData:l,revalidateOnMount:E,revalidateIfStale:S,refreshInterval:b,refreshWhenHidden:y,refreshWhenOffline:A,keepPreviousData:Ie}=t,[F,Le,_,Ve]=De.get(r),[s,se]=be(e),$=v.useRef(!1),k=v.useRef(!1),N=v.useRef(s),j=v.useRef(n),H=v.useRef(t),d=()=>H.current,z=()=>d().isVisible()&&d().isOnline(),[T,G,ye,Ae]=Ke(r,s),W=v.useRef({}).current,M=u(l)?u(t.fallback)?J:t.fallback[s]:l,re=(o,a)=>{for(const h in W){const f=h;if(f==="data"){if(!i(o[f],a[f])&&(!u(o[f])||!i(P,a[f])))return!1}else if(a[f]!==o[f])return!1}return!0},ae=v.useMemo(()=>{const o=(()=>!s||!n?!1:u(E)?d().isPaused()||c?!1:S!==!1:E)(),a=g=>{const D=pe(g);return delete D._k,o?q({isValidating:!0,isLoading:!0},D):D},h=T(),f=Ae(),w=a(h),L=h===f?w:a(f);let R=w;return[()=>{const g=a(T());return re(g,R)?(R.data=g.data,R.isLoading=g.isLoading,R.isValidating=g.isValidating,R.error=g.error,R):(R=g,g)},()=>L]},[r,s]),O=dt.useSyncExternalStore(v.useCallback(o=>ye(s,(a,h)=>{re(h,a)||o()}),[r,s]),ae[0],ae[1]),ie=!$.current,ke=F[s]&&F[s].length>0,I=O.data,C=u(I)?M&&Xe(M)?ee(M):M:I,U=O.error,K=v.useRef(C),P=Ie?u(I)?u(K.current)?C:K.current:I:C,oe=(()=>ke&&!u(U)?!1:ie&&!u(E)?E:d().isPaused()?!1:c?u(C)?!1:S:u(C)||S)(),ue=!!(s&&n&&ie&&oe),We=u(O.isValidating)?ue:O.isValidating,xe=u(O.isLoading)?ue:O.isLoading,x=v.useCallback(o=>Re(void 0,null,function*(){const a=j.current;if(!s||!a||k.current||d().isPaused())return!1;let h,f,w=!0;const L=o||{},R=!_[s]||!L.dedupe,g=()=>ve?!k.current&&s===N.current&&$.current:s===N.current,D={isValidating:!1,isLoading:!1},le=()=>{G(D)},fe=()=>{const m=_[s];m&&m[1]===f&&delete _[s]},de={isValidating:!0};u(T().data)&&(de.isLoading=!0);try{if(R&&(G(de),t.loadingTimeout&&u(T().data)&&setTimeout(()=>{w&&g()&&d().onLoadingSlow(s,t)},t.loadingTimeout),_[s]=[a(se),Ye()]),[h,f]=_[s],h=yield h,R&&setTimeout(fe,t.dedupingInterval),!_[s]||_[s][1]!==f)return R&&g()&&d().onDiscarded(s),!1;D.error=J;const m=Le[s];if(!u(m)&&(f<=m[0]||f<=m[1]||m[1]===0))return le(),R&&g()&&d().onDiscarded(s),!1;const p=T().data;D.data=i(p,h)?p:h,R&&g()&&d().onSuccess(h,s,t)}catch(m){fe();const p=d(),{shouldRetryOnError:X}=p;p.isPaused()||(D.error=m,R&&g()&&(p.onError(m,s,p),(X===!0||ne(X)&&X(m))&&(!d().revalidateOnFocus||!d().revalidateOnReconnect||z())&&p.onErrorRetry(m,s,p,Fe=>{const Y=F[s];Y&&Y[0]&&Y[0](he,Fe)},{retryCount:(L.retryCount||0)+1,dedupe:!0})))}return w=!1,le(),!0}),[s,r]),ce=v.useCallback((...o)=>Be(r,N.current,...o),[]);if(Q(()=>{j.current=n,H.current=t,u(I)||(K.current=I)}),Q(()=>{if(!s)return;const o=x.bind(J,te);let a=0;d().revalidateOnFocus&&(a=Date.now()+d().focusThrottleInterval);const f=wt(s,F,(w,L={})=>{if(w==Qe){const R=Date.now();d().revalidateOnFocus&&R>a&&z()&&(a=R+d().focusThrottleInterval,o())}else if(w==Ze)d().revalidateOnReconnect&&z()&&o();else{if(w==et)return x();if(w==he)return x(L)}});return k.current=!1,N.current=s,$.current=!0,G({_k:se}),oe&&(_[s]||(u(C)||ge?o():Je(o))),()=>{k.current=!0,f()}},[s]),Q(()=>{let o;function a(){const f=ne(b)?b(T().data):b;f&&o!==-1&&(o=setTimeout(h,f))}function h(){!T().error&&(y||d().isVisible())&&(A||d().isOnline())?x(te).then(a):a()}return a(),()=>{o&&(clearTimeout(o),o=-1)}},[b,y,A,s]),v.useDebugValue(P),c&&u(C)&&s){if(!ve&&ge)throw new Error("Fallback data is required when using Suspense in SSR.");j.current=n,H.current=t,k.current=!1;const o=Ve[s];if(!u(o)){const a=ce(o);ee(a)}if(u(U)){const a=x(te);u(P)||(a.status="fulfilled",a.value=!0),ee(a)}else throw U}return{mutate:ce,get data(){return W.data=!0,P},get error(){return W.error=!0,U},get isValidating(){return W.isValidating=!0,We},get isLoading(){return W.isLoading=!0,xe}}},pt=mt(Dt),_t=e=>(n,t,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(n,t,r)),Tt=bt(pt,_t),me=e=>{var n;return(e==null?void 0:e.success)&&!((n=e==null?void 0:e.data)!=null&&n.errors)&&!nt(e.data)},Lt=(e,n,t={})=>{const i=("fetchCondition"in t?t.fetchCondition:!0)?e:null,c=Tt(i,l=>{const E=tt(n,Array.isArray(l)?l[0]:l);return t.onLoading&&c.isLoading&&t.onLoading(),E},B(q({},t),{onSuccess:l=>t.onSuccess&&me(l)&&t.onSuccess(l.data)}));return v.useEffect(()=>{if(!me(c.data))return;const{data:l}=c.data;t.onMount?t.onMount(l):t.onSuccess&&t.onSuccess(l)},[]),c};export{Lt as u};
