var Ne=Object.defineProperty,Me=Object.defineProperties;var Ue=Object.getOwnPropertyDescriptors;var Se=Object.getOwnPropertySymbols;var Pe=Object.prototype.hasOwnProperty,qe=Object.prototype.propertyIsEnumerable;var Re=(e,n,t)=>n in e?Ne(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,q=(e,n)=>{for(var t in n||(n={}))Pe.call(n,t)&&Re(e,t,n[t]);if(Se)for(var t of Se(n))qe.call(n,t)&&Re(e,t,n[t]);return e},B=(e,n)=>Me(e,Ue(n));var Ee=(e,n,t)=>new Promise((r,i)=>{var c=S=>{try{R(t.next(S))}catch(b){i(b)}},l=S=>{try{R(t.throw(S))}catch(b){i(b)}},R=S=>S.done?r(S.value):Promise.resolve(S.value).then(c,l);R((t=t.apply(e,n)).next())});import{r as v,bF as we,bJ as ne,bK as $e,bL as be,bM as De,bN as je,bO as u,bP as He,bQ as pe,bR as ze,bS as Ge,bT as Ke,bU as J,bV as Xe,bW as Ye,bX as he,bY as Be,bZ as Q,b_ as ge,b$ as Je,c0 as ve,c1 as Qe,c2 as Ze,c3 as et,c as tt,c4 as nt}from"./main-216.js";var _e={exports:{}},Te={};/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var V=v;function st(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var rt=typeof Object.is=="function"?Object.is:st,at=V.useState,it=V.useEffect,ot=V.useLayoutEffect,ut=V.useDebugValue;function ct(e,n){var t=n(),r=at({inst:{value:t,getSnapshot:n}}),i=r[0].inst,c=r[1];return ot(function(){i.value=t,i.getSnapshot=n,Z(i)&&c({inst:i})},[e,t,n]),it(function(){return Z(i)&&c({inst:i}),e(function(){Z(i)&&c({inst:i})})},[e]),ut(t),t}function Z(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!rt(e,t)}catch(r){return!0}}function lt(e,n){return n()}var ft=typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"?lt:ct;Te.useSyncExternalStore=V.useSyncExternalStore!==void 0?V.useSyncExternalStore:ft;_e.exports=Te;var dt=_e.exports;const St="$inf$",Ce=$e&&window.__SWR_DEVTOOLS_USE__,Rt=Ce?window.__SWR_DEVTOOLS_USE__:[],Et=()=>{Ce&&(window.__SWR_DEVTOOLS_REACT__=we)},Oe=e=>ne(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],ht=()=>pe(Ge,v.useContext(ze)),gt=e=>(n,t,r)=>e(n,t&&((...c)=>{const[l]=be(n),[,,,R]=De.get(je);if(l.startsWith(St))return t(...c);const S=R[l];return u(S)?t(...c):(delete R[l],S)}),r),vt=Rt.concat(gt),mt=e=>function(...t){const r=ht(),[i,c,l]=Oe(t),R=He(r,l);let S=e;const{use:b}=R,y=(b||[]).concat(vt);for(let A=y.length;A--;)S=y[A](S);return S(i,c||R.fetcher||null,R)},wt=(e,n,t)=>{const r=n[e]||(n[e]=[]);return r.push(t),()=>{const i=r.indexOf(t);i>=0&&(r[i]=r[r.length-1],r.pop())}},bt=(e,n)=>(...t)=>{const[r,i,c]=Oe(t),l=(c.use||[]).concat(n);return e(r,i,B(q({},c),{use:l}))};Et();const ee=we.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e}}),te={dedupe:!0},Dt=(e,n,t)=>{const{cache:r,compare:i,suspense:c,fallbackData:l,revalidateOnMount:R,revalidateIfStale:S,refreshInterval:b,refreshWhenHidden:y,refreshWhenOffline:A,keepPreviousData:Ie}=t,[x,Le,_,Ve]=De.get(r),[s,se]=be(e),$=v.useRef(!1),k=v.useRef(!1),N=v.useRef(s),j=v.useRef(n),H=v.useRef(t),d=()=>H.current,z=()=>d().isVisible()&&d().isOnline(),[T,G,ye,Ae]=Ke(r,s),F=v.useRef({}).current,M=u(l)?u(t.fallback)?J:t.fallback[s]:l,re=(o,a)=>{for(const h in F){const f=h;if(f==="data"){if(!i(o[f],a[f])&&(!u(o[f])||!i(P,a[f])))return!1}else if(a[f]!==o[f])return!1}return!0},ae=v.useMemo(()=>{const o=(()=>!s||!n?!1:u(R)?d().isPaused()||c?!1:S!==!1:R)(),a=g=>{const D=pe(g);return delete D._k,o?q({isValidating:!0,isLoading:!0},D):D},h=T(),f=Ae(),w=a(h),L=h===f?w:a(f);let E=w;return[()=>{const g=a(T());return re(g,E)?(E.data=g.data,E.isLoading=g.isLoading,E.isValidating=g.isValidating,E.error=g.error,E):(E=g,g)},()=>L]},[r,s]),O=dt.useSyncExternalStore(v.useCallback(o=>ye(s,(a,h)=>{re(h,a)||o()}),[r,s]),ae[0],ae[1]),ie=!$.current,ke=x[s]&&x[s].length>0,I=O.data,C=u(I)?M&&Xe(M)?ee(M):M:I,U=O.error,K=v.useRef(C),P=Ie?u(I)?u(K.current)?C:K.current:I:C,oe=(()=>ke&&!u(U)?!1:ie&&!u(R)?R:d().isPaused()?!1:c?u(C)?!1:S:u(C)||S)(),ue=!!(s&&n&&ie&&oe),Fe=u(O.isValidating)?ue:O.isValidating,We=u(O.isLoading)?ue:O.isLoading,W=v.useCallback(o=>Ee(void 0,null,function*(){const a=j.current;if(!s||!a||k.current||d().isPaused())return!1;let h,f,w=!0;const L=o||{},E=!_[s]||!L.dedupe,g=()=>ve?!k.current&&s===N.current&&$.current:s===N.current,D={isValidating:!1,isLoading:!1},le=()=>{G(D)},fe=()=>{const m=_[s];m&&m[1]===f&&delete _[s]},de={isValidating:!0};u(T().data)&&(de.isLoading=!0);try{if(E&&(G(de),t.loadingTimeout&&u(T().data)&&setTimeout(()=>{w&&g()&&d().onLoadingSlow(s,t)},t.loadingTimeout),_[s]=[a(se),Ye()]),[h,f]=_[s],h=yield h,E&&setTimeout(fe,t.dedupingInterval),!_[s]||_[s][1]!==f)return E&&g()&&d().onDiscarded(s),!1;D.error=J;const m=Le[s];if(!u(m)&&(f<=m[0]||f<=m[1]||m[1]===0))return le(),E&&g()&&d().onDiscarded(s),!1;const p=T().data;D.data=i(p,h)?p:h,E&&g()&&d().onSuccess(h,s,t)}catch(m){fe();const p=d(),{shouldRetryOnError:X}=p;p.isPaused()||(D.error=m,E&&g()&&(p.onError(m,s,p),(X===!0||ne(X)&&X(m))&&(!d().revalidateOnFocus||!d().revalidateOnReconnect||z())&&p.onErrorRetry(m,s,p,xe=>{const Y=x[s];Y&&Y[0]&&Y[0](he,xe)},{retryCount:(L.retryCount||0)+1,dedupe:!0})))}return w=!1,le(),!0}),[s,r]),ce=v.useCallback((...o)=>Be(r,N.current,...o),[]);if(Q(()=>{j.current=n,H.current=t,u(I)||(K.current=I)}),Q(()=>{if(!s)return;const o=W.bind(J,te);let a=0;d().revalidateOnFocus&&(a=Date.now()+d().focusThrottleInterval);const f=wt(s,x,(w,L={})=>{if(w==Qe){const E=Date.now();d().revalidateOnFocus&&E>a&&z()&&(a=E+d().focusThrottleInterval,o())}else if(w==Ze)d().revalidateOnReconnect&&z()&&o();else{if(w==et)return W();if(w==he)return W(L)}});return k.current=!1,N.current=s,$.current=!0,G({_k:se}),oe&&(u(C)||ge?o():Je(o)),()=>{k.current=!0,f()}},[s]),Q(()=>{let o;function a(){const f=ne(b)?b(T().data):b;f&&o!==-1&&(o=setTimeout(h,f))}function h(){!T().error&&(y||d().isVisible())&&(A||d().isOnline())?W(te).then(a):a()}return a(),()=>{o&&(clearTimeout(o),o=-1)}},[b,y,A,s]),v.useDebugValue(P),c&&u(C)&&s){if(!ve&&ge)throw new Error("Fallback data is required when using Suspense in SSR.");j.current=n,H.current=t,k.current=!1;const o=Ve[s];if(!u(o)){const a=ce(o);ee(a)}if(u(U)){const a=W(te);u(P)||(a.status="fulfilled",a.value=!0),ee(a)}else throw U}return{mutate:ce,get data(){return F.data=!0,P},get error(){return F.error=!0,U},get isValidating(){return F.isValidating=!0,Fe},get isLoading(){return F.isLoading=!0,We}}},pt=mt(Dt),_t=e=>(n,t,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(n,t,r)),Tt=bt(pt,_t),me=e=>{var n;return(e==null?void 0:e.success)&&!((n=e==null?void 0:e.data)!=null&&n.errors)&&!nt(e.data)},Lt=(e,n,t={})=>{const i=("fetchCondition"in t?t.fetchCondition:!0)?e:null,c=Tt(i,l=>{const R=tt(n,Array.isArray(l)?l[0]:l);return t.onLoading&&c.isLoading&&t.onLoading(),R},B(q({},t),{onSuccess:l=>t.onSuccess&&me(l)&&t.onSuccess(l.data)}));return v.useEffect(()=>{if(!me(c.data))return;const{data:l}=c.data;t.onMount?t.onMount(l):t.onSuccess&&t.onSuccess(l)},[]),c};export{Lt as u};
