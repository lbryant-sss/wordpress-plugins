var Me=Object.defineProperty,Ue=Object.defineProperties;var Pe=Object.getOwnPropertyDescriptors;var Se=Object.getOwnPropertySymbols;var qe=Object.prototype.hasOwnProperty,$e=Object.prototype.propertyIsEnumerable;var Re=(e,n,t)=>n in e?Me(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,q=(e,n)=>{for(var t in n||(n={}))qe.call(n,t)&&Re(e,t,n[t]);if(Se)for(var t of Se(n))$e.call(n,t)&&Re(e,t,n[t]);return e},J=(e,n)=>Ue(e,Pe(n));var Ee=(e,n,t)=>new Promise((r,o)=>{var l=S=>{try{E(t.next(S))}catch(b){o(b)}},f=S=>{try{E(t.throw(S))}catch(b){o(b)}},E=S=>S.done?r(S.value):Promise.resolve(S.value).then(l,f);E((t=t.apply(e,n)).next())});import{r as g,bF as be,bJ as ne,bK as je,bL as De,bM as _e,bN as He,bO as c,bP as ze,bQ as Ge,bR as pe,bS as Ke,bT as $,bU as Be,bV as Xe,bW as Ye,bX as he,bY as Je,bZ as Q,b_ as ge,b$ as Qe,c0 as ve,c1 as Ze,c2 as et,c3 as tt,c as nt,c4 as st}from"./main-353.js";var Ce={exports:{}},Te={};/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var V=g;function rt(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var at=typeof Object.is=="function"?Object.is:rt,ot=V.useState,it=V.useEffect,ut=V.useLayoutEffect,ct=V.useDebugValue;function lt(e,n){var t=n(),r=ot({inst:{value:t,getSnapshot:n}}),o=r[0].inst,l=r[1];return ut(function(){o.value=t,o.getSnapshot=n,Z(o)&&l({inst:o})},[e,t,n]),it(function(){return Z(o)&&l({inst:o}),e(function(){Z(o)&&l({inst:o})})},[e]),ct(t),t}function Z(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!at(e,t)}catch(r){return!0}}function ft(e,n){return n()}var dt=typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"?ft:lt;Te.useSyncExternalStore=V.useSyncExternalStore!==void 0?V.useSyncExternalStore:dt;Ce.exports=Te;var St=Ce.exports;const Rt="$inf$",Oe=je&&window.__SWR_DEVTOOLS_USE__,Et=Oe?window.__SWR_DEVTOOLS_USE__:[],ht=()=>{Oe&&(window.__SWR_DEVTOOLS_REACT__=be)},Ie=e=>ne(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],gt=()=>{const e=g.useContext(Ge);return g.useMemo(()=>pe(Ke,e),[e])},vt=e=>(n,t,r)=>e(n,t&&((...l)=>{const[f]=De(n),[,,,E]=_e.get(He);if(f.startsWith(Rt))return t(...l);const S=E[f];return c(S)?t(...l):(delete E[f],S)}),r),mt=Et.concat(vt),wt=e=>function(...t){const r=gt(),[o,l,f]=Ie(t),E=ze(r,f);let S=e;const{use:b}=E,y=(b||[]).concat(mt);for(let A=y.length;A--;)S=y[A](S);return S(o,l||E.fetcher||null,E)},bt=(e,n,t)=>{const r=n[e]||(n[e]=[]);return r.push(t),()=>{const o=r.indexOf(t);o>=0&&(r[o]=r[r.length-1],r.pop())}},Dt=(e,n)=>(...t)=>{const[r,o,l]=Ie(t),f=(l.use||[]).concat(n);return e(r,o,J(q({},l),{use:f}))};ht();const ee=be.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e}}),te={dedupe:!0},me=Promise.resolve($),_t=(e,n,t)=>{const{cache:r,compare:o,suspense:l,fallbackData:f,revalidateOnMount:E,revalidateIfStale:S,refreshInterval:b,refreshWhenHidden:y,refreshWhenOffline:A,keepPreviousData:Le}=t,[W,Ve,p,ye]=_e.get(r),[s,se]=De(e),j=g.useRef(!1),k=g.useRef(!1),x=g.useRef(s),H=g.useRef(n),z=g.useRef(t),d=()=>z.current,G=()=>d().isVisible()&&d().isOnline(),[C,K,Ae,ke]=Be(r,s),F=g.useRef({}).current,M=c(f)?c(t.fallback)?$:t.fallback[s]:f,re=(a,u)=>{for(const R in F){const i=R;if(i==="data"){if(!o(a[i],u[i])&&(!c(a[i])||!o(P,u[i])))return!1}else if(u[i]!==a[i])return!1}return!0},ae=g.useMemo(()=>{const a=(()=>!s||!n?!1:c(E)?d().isPaused()||l?!1:S!==!1:E)(),u=v=>{const D=pe(v);return delete D._k,a?q({isValidating:!0,isLoading:!0},D):D},R=C(),i=ke(),w=u(R),L=R===i?w:u(i);let h=w;return[()=>{const v=u(C());return re(v,h)?(h.data=v.data,h.isLoading=v.isLoading,h.isValidating=v.isValidating,h.error=v.error,h):(h=v,v)},()=>L]},[r,s]),O=St.useSyncExternalStore(g.useCallback(a=>Ae(s,(u,R)=>{re(R,u)||a()}),[r,s]),ae[0],ae[1]),oe=!j.current,Fe=W[s]&&W[s].length>0,I=O.data,T=c(I)?M&&Xe(M)?ee(M):M:I,U=O.error,B=g.useRef(T),P=Le?c(I)?c(B.current)?T:B.current:I:T,ie=(()=>Fe&&!c(U)?!1:oe&&!c(E)?E:d().isPaused()?!1:l?c(T)?!1:S:c(T)||S)(),ue=!!(s&&n&&oe&&ie),Ne=c(O.isValidating)?ue:O.isValidating,We=c(O.isLoading)?ue:O.isLoading,N=g.useCallback(a=>Ee(void 0,null,function*(){const u=H.current;if(!s||!u||k.current||d().isPaused())return!1;let R,i,w=!0;const L=a||{},h=!p[s]||!L.dedupe,v=()=>ve?!k.current&&s===x.current&&j.current:s===x.current,D={isValidating:!1,isLoading:!1},le=()=>{K(D)},fe=()=>{const m=p[s];m&&m[1]===i&&delete p[s]},de={isValidating:!0};c(C().data)&&(de.isLoading=!0);try{if(h&&(K(de),t.loadingTimeout&&c(C().data)&&setTimeout(()=>{w&&v()&&d().onLoadingSlow(s,t)},t.loadingTimeout),p[s]=[u(se),Ye()]),[R,i]=p[s],R=yield R,h&&setTimeout(fe,t.dedupingInterval),!p[s]||p[s][1]!==i)return h&&v()&&d().onDiscarded(s),!1;D.error=$;const m=Ve[s];if(!c(m)&&(i<=m[0]||i<=m[1]||m[1]===0))return le(),h&&v()&&d().onDiscarded(s),!1;const _=C().data;D.data=o(_,R)?_:R,h&&v()&&d().onSuccess(R,s,t)}catch(m){fe();const _=d(),{shouldRetryOnError:X}=_;_.isPaused()||(D.error=m,h&&v()&&(_.onError(m,s,_),(X===!0||ne(X)&&X(m))&&(!d().revalidateOnFocus||!d().revalidateOnReconnect||G())&&_.onErrorRetry(m,s,_,xe=>{const Y=W[s];Y&&Y[0]&&Y[0](he,xe)},{retryCount:(L.retryCount||0)+1,dedupe:!0})))}return w=!1,le(),!0}),[s,r]),ce=g.useCallback((...a)=>Je(r,x.current,...a),[]);if(Q(()=>{H.current=n,z.current=t,c(I)||(B.current=I)}),Q(()=>{if(!s)return;const a=N.bind($,te);let u=0;d().revalidateOnFocus&&(u=Date.now()+d().focusThrottleInterval);const i=bt(s,W,(w,L={})=>{if(w==Ze){const h=Date.now();d().revalidateOnFocus&&h>u&&G()&&(u=h+d().focusThrottleInterval,a())}else if(w==et)d().revalidateOnReconnect&&G()&&a();else{if(w==tt)return N();if(w==he)return N(L)}});return k.current=!1,x.current=s,j.current=!0,K({_k:se}),ie&&(p[s]||(c(T)||ge?a():Qe(a))),()=>{k.current=!0,i()}},[s]),Q(()=>{let a;function u(){const i=ne(b)?b(C().data):b;i&&a!==-1&&(a=setTimeout(R,i))}function R(){!C().error&&(y||d().isVisible())&&(A||d().isOnline())?N(te).then(u):u()}return u(),()=>{a&&(clearTimeout(a),a=-1)}},[b,y,A,s]),g.useDebugValue(P),l){const a=s&&c(T);if(!ve&&ge&&a)throw new Error("Fallback data is required when using Suspense in SSR.");a&&(H.current=n,z.current=t,k.current=!1);const u=ye[s],R=!c(u)&&a?ce(u):me;if(ee(R),!c(U)&&a)throw U;const i=a?N(te):me;!c(P)&&a&&(i.status="fulfilled",i.value=!0),ee(i)}return{mutate:ce,get data(){return F.data=!0,P},get error(){return F.error=!0,U},get isValidating(){return F.isValidating=!0,Ne},get isLoading(){return F.isLoading=!0,We}}},pt=wt(_t),Ct=e=>(n,t,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(n,t,r)),Tt=Dt(pt,Ct),we=e=>{var n;return(e==null?void 0:e.success)&&!((n=e==null?void 0:e.data)!=null&&n.errors)&&!st(e.data)},Vt=(e,n,t={})=>{const o=("fetchCondition"in t?t.fetchCondition:!0)?e:null,l=Tt(o,f=>{const E=nt(n,Array.isArray(f)?f[0]:f);return t.onLoading&&l.isLoading&&t.onLoading(),E},J(q({},t),{onSuccess:f=>t.onSuccess&&we(f)&&t.onSuccess(f.data)}));return g.useEffect(()=>{if(!we(l.data))return;const{data:f}=l.data;t.onMount?t.onMount(f):t.onSuccess&&t.onSuccess(f)},[]),l};export{Vt as u};
