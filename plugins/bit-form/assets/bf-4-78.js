var Ne=Object.defineProperty,Me=Object.defineProperties;var Ue=Object.getOwnPropertyDescriptors;var Se=Object.getOwnPropertySymbols;var Pe=Object.prototype.hasOwnProperty,qe=Object.prototype.propertyIsEnumerable;var Ee=(e,n,t)=>n in e?Ne(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,q=(e,n)=>{for(var t in n||(n={}))Pe.call(n,t)&&Ee(e,t,n[t]);if(Se)for(var t of Se(n))qe.call(n,t)&&Ee(e,t,n[t]);return e},Y=(e,n)=>Me(e,Ue(n));var Re=(e,n,t)=>new Promise((r,i)=>{var c=S=>{try{E(t.next(S))}catch(w){i(w)}},l=S=>{try{E(t.throw(S))}catch(w){i(w)}},E=S=>S.done?r(S.value):Promise.resolve(S.value).then(c,l);E((t=t.apply(e,n)).next())});import{r as v,bz as me,bB as ne,bC as $e,bD as we,bE as De,bF as je,bG as u,bH as He,bI as pe,bJ as ze,bK as Ge,bL as Be,bM as J,bN as Ke,bO as Xe,bP as he,bQ as Ye,bR as Q,bS as ge,bT as Je,bU as ve,bV as Qe,bW as Ze,bX as et,c as tt,bY as nt}from"./main-381.js";var _e={exports:{}},Ce={};/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/var V=v;function st(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var rt=typeof Object.is=="function"?Object.is:st,at=V.useState,it=V.useEffect,ot=V.useLayoutEffect,ut=V.useDebugValue;function ct(e,n){var t=n(),r=at({inst:{value:t,getSnapshot:n}}),i=r[0].inst,c=r[1];return ot(function(){i.value=t,i.getSnapshot=n,Z(i)&&c({inst:i})},[e,t,n]),it(function(){return Z(i)&&c({inst:i}),e(function(){Z(i)&&c({inst:i})})},[e]),ut(t),t}function Z(e){var n=e.getSnapshot;e=e.value;try{var t=n();return!rt(e,t)}catch(r){return!0}}function lt(e,n){return n()}var ft=typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"?lt:ct;Ce.useSyncExternalStore=V.useSyncExternalStore!==void 0?V.useSyncExternalStore:ft;_e.exports=Ce;var dt=_e.exports;const St="$inf$",Te=$e&&window.__SWR_DEVTOOLS_USE__,Et=Te?window.__SWR_DEVTOOLS_USE__:[],Rt=()=>{Te&&(window.__SWR_DEVTOOLS_REACT__=me)},Oe=e=>ne(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],ht=()=>pe(Ge,v.useContext(ze)),gt=e=>(n,t,r)=>e(n,t&&((...c)=>{const[l]=we(n),[,,,E]=De.get(je);if(l.startsWith(St))return t(...c);const S=E[l];return u(S)?t(...c):(delete E[l],S)}),r),vt=Et.concat(gt),bt=e=>function(...t){const r=ht(),[i,c,l]=Oe(t),E=He(r,l);let S=e;const{use:w}=E,y=(w||[]).concat(vt);for(let A=y.length;A--;)S=y[A](S);return S(i,c||E.fetcher||null,E)},mt=(e,n,t)=>{const r=n[e]||(n[e]=[]);return r.push(t),()=>{const i=r.indexOf(t);i>=0&&(r[i]=r[r.length-1],r.pop())}},wt=(e,n)=>(...t)=>{const[r,i,c]=Oe(t),l=(c.use||[]).concat(n);return e(r,i,Y(q({},c),{use:l}))};Rt();const ee=me.use||(e=>{switch(e.status){case"pending":throw e;case"fulfilled":return e.value;case"rejected":throw e.reason;default:throw e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e}}),te={dedupe:!0},Dt=(e,n,t)=>{const{cache:r,compare:i,suspense:c,fallbackData:l,revalidateOnMount:E,revalidateIfStale:S,refreshInterval:w,refreshWhenHidden:y,refreshWhenOffline:A,keepPreviousData:Ie}=t,[x,Le,_,Ve]=De.get(r),[s,se]=we(e),$=v.useRef(!1),k=v.useRef(!1),N=v.useRef(s),j=v.useRef(n),H=v.useRef(t),d=()=>H.current,z=()=>d().isVisible()&&d().isOnline(),[C,G,ye,Ae]=Be(r,s),F=v.useRef({}).current,M=u(l)?u(t.fallback)?J:t.fallback[s]:l,re=(o,a)=>{for(const h in F){const f=h;if(f==="data"){if(!i(o[f],a[f])&&(!u(o[f])||!i(P,a[f])))return!1}else if(a[f]!==o[f])return!1}return!0},ae=v.useMemo(()=>{const o=(()=>!s||!n?!1:u(E)?d().isPaused()||c?!1:S!==!1:E)(),a=g=>{const D=pe(g);return delete D._k,o?q({isValidating:!0,isLoading:!0},D):D},h=C(),f=Ae(),m=a(h),L=h===f?m:a(f);let R=m;return[()=>{const g=a(C());return re(g,R)?(R.data=g.data,R.isLoading=g.isLoading,R.isValidating=g.isValidating,R.error=g.error,R):(R=g,g)},()=>L]},[r,s]),O=dt.useSyncExternalStore(v.useCallback(o=>ye(s,(a,h)=>{re(h,a)||o()}),[r,s]),ae[0],ae[1]),ie=!$.current,ke=x[s]&&x[s].length>0,I=O.data,T=u(I)?M&&Ke(M)?ee(M):M:I,U=O.error,B=v.useRef(T),P=Ie?u(I)?u(B.current)?T:B.current:I:T,oe=(()=>ke&&!u(U)?!1:ie&&!u(E)?E:d().isPaused()?!1:c?u(T)?!1:S:u(T)||S)(),ue=!!(s&&n&&ie&&oe),Fe=u(O.isValidating)?ue:O.isValidating,We=u(O.isLoading)?ue:O.isLoading,W=v.useCallback(o=>Re(void 0,null,function*(){const a=j.current;if(!s||!a||k.current||d().isPaused())return!1;let h,f,m=!0;const L=o||{},R=!_[s]||!L.dedupe,g=()=>ve?!k.current&&s===N.current&&$.current:s===N.current,D={isValidating:!1,isLoading:!1},le=()=>{G(D)},fe=()=>{const b=_[s];b&&b[1]===f&&delete _[s]},de={isValidating:!0};u(C().data)&&(de.isLoading=!0);try{if(R&&(G(de),t.loadingTimeout&&u(C().data)&&setTimeout(()=>{m&&g()&&d().onLoadingSlow(s,t)},t.loadingTimeout),_[s]=[a(se),Xe()]),[h,f]=_[s],h=yield h,R&&setTimeout(fe,t.dedupingInterval),!_[s]||_[s][1]!==f)return R&&g()&&d().onDiscarded(s),!1;D.error=J;const b=Le[s];if(!u(b)&&(f<=b[0]||f<=b[1]||b[1]===0))return le(),R&&g()&&d().onDiscarded(s),!1;const p=C().data;D.data=i(p,h)?p:h,R&&g()&&d().onSuccess(h,s,t)}catch(b){fe();const p=d(),{shouldRetryOnError:K}=p;p.isPaused()||(D.error=b,R&&g()&&(p.onError(b,s,p),(K===!0||ne(K)&&K(b))&&(!d().revalidateOnFocus||!d().revalidateOnReconnect||z())&&p.onErrorRetry(b,s,p,xe=>{const X=x[s];X&&X[0]&&X[0](he,xe)},{retryCount:(L.retryCount||0)+1,dedupe:!0})))}return m=!1,le(),!0}),[s,r]),ce=v.useCallback((...o)=>Ye(r,N.current,...o),[]);if(Q(()=>{j.current=n,H.current=t,u(I)||(B.current=I)}),Q(()=>{if(!s)return;const o=W.bind(J,te);let a=0;d().revalidateOnFocus&&(a=Date.now()+d().focusThrottleInterval);const f=mt(s,x,(m,L={})=>{if(m==Qe){const R=Date.now();d().revalidateOnFocus&&R>a&&z()&&(a=R+d().focusThrottleInterval,o())}else if(m==Ze)d().revalidateOnReconnect&&z()&&o();else{if(m==et)return W();if(m==he)return W(L)}});return k.current=!1,N.current=s,$.current=!0,G({_k:se}),oe&&(u(T)||ge?o():Je(o)),()=>{k.current=!0,f()}},[s]),Q(()=>{let o;function a(){const f=ne(w)?w(C().data):w;f&&o!==-1&&(o=setTimeout(h,f))}function h(){!C().error&&(y||d().isVisible())&&(A||d().isOnline())?W(te).then(a):a()}return a(),()=>{o&&(clearTimeout(o),o=-1)}},[w,y,A,s]),v.useDebugValue(P),c&&u(T)&&s){if(!ve&&ge)throw new Error("Fallback data is required when using Suspense in SSR.");j.current=n,H.current=t,k.current=!1;const o=Ve[s];if(!u(o)){const a=ce(o);ee(a)}if(u(U)){const a=W(te);u(P)||(a.status="fulfilled",a.value=!0),ee(a)}else throw U}return{mutate:ce,get data(){return F.data=!0,P},get error(){return F.error=!0,U},get isValidating(){return F.isValidating=!0,Fe},get isLoading(){return F.isLoading=!0,We}}},pt=bt(Dt),_t=e=>(n,t,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(n,t,r)),Ct=wt(pt,_t),be=e=>{var n;return(e==null?void 0:e.success)&&!((n=e==null?void 0:e.data)!=null&&n.errors)&&!nt(e.data)},Lt=(e,n,t={})=>{const i=("fetchCondition"in t?t.fetchCondition:!0)?e:null,c=Ct(i,l=>{const E=tt(n,Array.isArray(l)?l[0]:l);return t.onLoading&&c.isLoading&&t.onLoading(),E},Y(q({},t),{onSuccess:l=>t.onSuccess&&be(l)&&t.onSuccess(l.data)}));return v.useEffect(()=>{if(!be(c.data))return;const{data:l}=c.data;t.onMount?t.onMount(l):t.onSuccess&&t.onSuccess(l)},[]),c};export{Lt as u};
